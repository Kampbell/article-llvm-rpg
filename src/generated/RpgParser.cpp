
// Generated from src/antlr/RpgParser.g4 by ANTLR 4.8


#include "RpgParserListener.h"
#include "RpgParserVisitor.h"

#include "RpgParser.h"


using namespace antlrcpp;
using namespace antlrcpprpg;
using namespace antlr4;

RpgParser::RpgParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

RpgParser::~RpgParser() {
  delete _interpreter;
}

std::string RpgParser::getGrammarFileName() const {
  return "RpgParser.g4";
}

const std::vector<std::string>& RpgParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& RpgParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- RContext ------------------------------------------------------------------

RpgParser::RContext::RContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::Dcl_prContext *> RpgParser::RContext::dcl_pr() {
  return getRuleContexts<RpgParser::Dcl_prContext>();
}

RpgParser::Dcl_prContext* RpgParser::RContext::dcl_pr(size_t i) {
  return getRuleContext<RpgParser::Dcl_prContext>(i);
}

std::vector<RpgParser::Dcl_piContext *> RpgParser::RContext::dcl_pi() {
  return getRuleContexts<RpgParser::Dcl_piContext>();
}

RpgParser::Dcl_piContext* RpgParser::RContext::dcl_pi(size_t i) {
  return getRuleContext<RpgParser::Dcl_piContext>(i);
}

std::vector<RpgParser::Ctl_optContext *> RpgParser::RContext::ctl_opt() {
  return getRuleContexts<RpgParser::Ctl_optContext>();
}

RpgParser::Ctl_optContext* RpgParser::RContext::ctl_opt(size_t i) {
  return getRuleContext<RpgParser::Ctl_optContext>(i);
}

std::vector<RpgParser::SubroutineContext *> RpgParser::RContext::subroutine() {
  return getRuleContexts<RpgParser::SubroutineContext>();
}

RpgParser::SubroutineContext* RpgParser::RContext::subroutine(size_t i) {
  return getRuleContext<RpgParser::SubroutineContext>(i);
}

std::vector<RpgParser::StatementContext *> RpgParser::RContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::RContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}

std::vector<RpgParser::ProcedureContext *> RpgParser::RContext::procedure() {
  return getRuleContexts<RpgParser::ProcedureContext>();
}

RpgParser::ProcedureContext* RpgParser::RContext::procedure(size_t i) {
  return getRuleContext<RpgParser::ProcedureContext>(i);
}

RpgParser::EndSourceBlockContext* RpgParser::RContext::endSourceBlock() {
  return getRuleContext<RpgParser::EndSourceBlockContext>(0);
}


size_t RpgParser::RContext::getRuleIndex() const {
  return RpgParser::RuleR;
}

void RpgParser::RContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterR(this);
}

void RpgParser::RContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitR(this);
}


antlrcpp::Any RpgParser::RContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::RContext* RpgParser::r() {
  RContext *_localctx = _tracker.createInstance<RContext>(_ctx, getState());
  enterRule(_localctx, 0, RpgParser::RuleR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1186);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 5) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 5)) & ((1ULL << (RpgParser::COMMENT_SPEC_FIXED - 5))
      | (1ULL << (RpgParser::DS_FIXED - 5))
      | (1ULL << (RpgParser::FS_FIXED - 5))
      | (1ULL << (RpgParser::OS_FIXED - 5))
      | (1ULL << (RpgParser::CS_FIXED - 5))
      | (1ULL << (RpgParser::CS_ExecSQL - 5))
      | (1ULL << (RpgParser::IS_FIXED - 5))
      | (1ULL << (RpgParser::PS_FIXED - 5))
      | (1ULL << (RpgParser::HS_FIXED - 5))
      | (1ULL << (RpgParser::BLANK_LINE - 5))
      | (1ULL << (RpgParser::COMMENTS - 5))
      | (1ULL << (RpgParser::DIRECTIVE - 5))
      | (1ULL << (RpgParser::OPEN_PAREN - 5))
      | (1ULL << (RpgParser::NUMBER - 5))
      | (1ULL << (RpgParser::ID - 5))
      | (1ULL << (RpgParser::OP_ACQ - 5))
      | (1ULL << (RpgParser::OP_BEGSR - 5))
      | (1ULL << (RpgParser::OP_CALLP - 5))
      | (1ULL << (RpgParser::OP_CHAIN - 5))
      | (1ULL << (RpgParser::OP_CLEAR - 5))
      | (1ULL << (RpgParser::OP_CLOSE - 5))
      | (1ULL << (RpgParser::OP_COMMIT - 5))
      | (1ULL << (RpgParser::OP_DEALLOC - 5))
      | (1ULL << (RpgParser::OP_DELETE - 5))
      | (1ULL << (RpgParser::OP_DOU - 5))
      | (1ULL << (RpgParser::OP_DOW - 5))
      | (1ULL << (RpgParser::OP_DSPLY - 5))
      | (1ULL << (RpgParser::OP_DUMP - 5)))) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & ((1ULL << (RpgParser::OP_ENDSR - 73))
      | (1ULL << (RpgParser::OP_EVAL - 73))
      | (1ULL << (RpgParser::OP_EVALR - 73))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 73))
      | (1ULL << (RpgParser::OP_EXCEPT - 73))
      | (1ULL << (RpgParser::OP_EXFMT - 73))
      | (1ULL << (RpgParser::OP_EXSR - 73))
      | (1ULL << (RpgParser::OP_FEOD - 73))
      | (1ULL << (RpgParser::OP_FOR - 73))
      | (1ULL << (RpgParser::OP_FORCE - 73))
      | (1ULL << (RpgParser::OP_IF - 73))
      | (1ULL << (RpgParser::OP_IN - 73))
      | (1ULL << (RpgParser::OP_ITER - 73))
      | (1ULL << (RpgParser::OP_LEAVE - 73))
      | (1ULL << (RpgParser::OP_LEAVESR - 73))
      | (1ULL << (RpgParser::OP_MONITOR - 73))
      | (1ULL << (RpgParser::OP_NEXT - 73))
      | (1ULL << (RpgParser::OP_OPEN - 73))
      | (1ULL << (RpgParser::OP_OTHER - 73))
      | (1ULL << (RpgParser::OP_OUT - 73))
      | (1ULL << (RpgParser::OP_POST - 73))
      | (1ULL << (RpgParser::OP_READ - 73))
      | (1ULL << (RpgParser::OP_READC - 73))
      | (1ULL << (RpgParser::OP_READE - 73))
      | (1ULL << (RpgParser::OP_READP - 73))
      | (1ULL << (RpgParser::OP_READPE - 73))
      | (1ULL << (RpgParser::OP_REL - 73))
      | (1ULL << (RpgParser::OP_RESET - 73))
      | (1ULL << (RpgParser::OP_RETURN - 73))
      | (1ULL << (RpgParser::OP_ROLBK - 73))
      | (1ULL << (RpgParser::OP_SELECT - 73))
      | (1ULL << (RpgParser::OP_SETGT - 73))
      | (1ULL << (RpgParser::OP_SETLL - 73))
      | (1ULL << (RpgParser::OP_SORTA - 73))
      | (1ULL << (RpgParser::OP_TEST - 73))
      | (1ULL << (RpgParser::OP_UNLOCK - 73))
      | (1ULL << (RpgParser::OP_UPDATE - 73))
      | (1ULL << (RpgParser::OP_WHEN - 73))
      | (1ULL << (RpgParser::OP_WRITE - 73))
      | (1ULL << (RpgParser::OP_XML_INTO - 73))
      | (1ULL << (RpgParser::OP_XML_SAX - 73))
      | (1ULL << (RpgParser::DS_Standalone - 73))
      | (1ULL << (RpgParser::DS_DataStructureStart - 73))
      | (1ULL << (RpgParser::DS_PrototypeStart - 73))
      | (1ULL << (RpgParser::DS_ProcedureInterfaceStart - 73))
      | (1ULL << (RpgParser::DS_ProcedureStart - 73))
      | (1ULL << (RpgParser::DS_Constant - 73))
      | (1ULL << (RpgParser::FS_FreeFile - 73))
      | (1ULL << (RpgParser::H_SPEC - 73))
      | (1ULL << (RpgParser::EXEC_SQL - 73))
      | (1ULL << (RpgParser::BIF_ABS - 73))
      | (1ULL << (RpgParser::BIF_ADDR - 73))
      | (1ULL << (RpgParser::BIF_ALLOC - 73))
      | (1ULL << (RpgParser::BIF_BITAND - 73))
      | (1ULL << (RpgParser::BIF_BITNOT - 73)))) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & ((1ULL << (RpgParser::BIF_BITOR - 137))
      | (1ULL << (RpgParser::BIF_BITXOR - 137))
      | (1ULL << (RpgParser::BIF_CHAR - 137))
      | (1ULL << (RpgParser::BIF_CHECK - 137))
      | (1ULL << (RpgParser::BIF_CHECKR - 137))
      | (1ULL << (RpgParser::BIF_DATE - 137))
      | (1ULL << (RpgParser::BIF_DAYS - 137))
      | (1ULL << (RpgParser::BIF_DEC - 137))
      | (1ULL << (RpgParser::BIF_DECH - 137))
      | (1ULL << (RpgParser::BIF_DECPOS - 137))
      | (1ULL << (RpgParser::BIF_DIFF - 137))
      | (1ULL << (RpgParser::BIF_DIV - 137))
      | (1ULL << (RpgParser::BIF_EDITC - 137))
      | (1ULL << (RpgParser::BIF_EDITFLT - 137))
      | (1ULL << (RpgParser::BIF_EDITW - 137))
      | (1ULL << (RpgParser::BIF_ELEM - 137))
      | (1ULL << (RpgParser::BIF_EOF - 137))
      | (1ULL << (RpgParser::BIF_EQUAL - 137))
      | (1ULL << (RpgParser::BIF_ERROR - 137))
      | (1ULL << (RpgParser::BIF_FIELDS - 137))
      | (1ULL << (RpgParser::BIF_FLOAT - 137))
      | (1ULL << (RpgParser::BIF_FOUND - 137))
      | (1ULL << (RpgParser::BIF_GRAPH - 137))
      | (1ULL << (RpgParser::BIF_HANDLER - 137))
      | (1ULL << (RpgParser::BIF_HOURS - 137))
      | (1ULL << (RpgParser::BIF_INT - 137))
      | (1ULL << (RpgParser::BIF_INTH - 137))
      | (1ULL << (RpgParser::BIF_KDS - 137))
      | (1ULL << (RpgParser::BIF_LEN - 137))
      | (1ULL << (RpgParser::BIF_LOOKUP - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 137))
      | (1ULL << (RpgParser::BIF_MINUTES - 137))
      | (1ULL << (RpgParser::BIF_MONTHS - 137))
      | (1ULL << (RpgParser::BIF_MSECONDS - 137))
      | (1ULL << (RpgParser::BIF_NULLIND - 137))
      | (1ULL << (RpgParser::BIF_OCCUR - 137))
      | (1ULL << (RpgParser::BIF_OPEN - 137))
      | (1ULL << (RpgParser::BIF_PADDR - 137))
      | (1ULL << (RpgParser::BIF_PARMS - 137))
      | (1ULL << (RpgParser::BIF_PARMNUM - 137))
      | (1ULL << (RpgParser::BIF_REALLOC - 137))
      | (1ULL << (RpgParser::BIF_REM - 137))
      | (1ULL << (RpgParser::BIF_REPLACE - 137))
      | (1ULL << (RpgParser::BIF_SCAN - 137))
      | (1ULL << (RpgParser::BIF_SCANRPL - 137))
      | (1ULL << (RpgParser::BIF_SECONDS - 137))
      | (1ULL << (RpgParser::BIF_SHTDN - 137))
      | (1ULL << (RpgParser::BIF_SIZE - 137))
      | (1ULL << (RpgParser::BIF_SQRT - 137))
      | (1ULL << (RpgParser::BIF_STATUS - 137))
      | (1ULL << (RpgParser::BIF_STR - 137))
      | (1ULL << (RpgParser::BIF_SUBARR - 137))
      | (1ULL << (RpgParser::BIF_SUBDT - 137))
      | (1ULL << (RpgParser::BIF_SUBST - 137))
      | (1ULL << (RpgParser::BIF_THIS - 137))
      | (1ULL << (RpgParser::BIF_TIME - 137))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 137)))) != 0) || ((((_la - 201) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 201)) & ((1ULL << (RpgParser::BIF_TLOOKUPGE - 201))
      | (1ULL << (RpgParser::BIF_TRIM - 201))
      | (1ULL << (RpgParser::BIF_TRIML - 201))
      | (1ULL << (RpgParser::BIF_TRIMR - 201))
      | (1ULL << (RpgParser::BIF_UCS2 - 201))
      | (1ULL << (RpgParser::BIF_UNS - 201))
      | (1ULL << (RpgParser::BIF_UNSH - 201))
      | (1ULL << (RpgParser::BIF_XFOOT - 201))
      | (1ULL << (RpgParser::BIF_XLATE - 201))
      | (1ULL << (RpgParser::BIF_XML - 201))
      | (1ULL << (RpgParser::BIF_YEARS - 201))
      | (1ULL << (RpgParser::SPLAT_ALL - 201))
      | (1ULL << (RpgParser::SPLAT_NONE - 201))
      | (1ULL << (RpgParser::SPLAT_YES - 201))
      | (1ULL << (RpgParser::SPLAT_NO - 201))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 201))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 201))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 201))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 201))
      | (1ULL << (RpgParser::SPLAT_VRM - 201))
      | (1ULL << (RpgParser::SPLAT_ALLG - 201))
      | (1ULL << (RpgParser::SPLAT_ALLU - 201))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 201))
      | (1ULL << (RpgParser::SPLAT_ALLX - 201))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 201))
      | (1ULL << (RpgParser::SPLAT_CANCL - 201))
      | (1ULL << (RpgParser::SPLAT_CYMD - 201))
      | (1ULL << (RpgParser::SPLAT_CMDY - 201))
      | (1ULL << (RpgParser::SPLAT_CDMY - 201))
      | (1ULL << (RpgParser::SPLAT_MDY - 201))
      | (1ULL << (RpgParser::SPLAT_DMY - 201))
      | (1ULL << (RpgParser::SPLAT_DFT - 201))
      | (1ULL << (RpgParser::SPLAT_YMD - 201))
      | (1ULL << (RpgParser::SPLAT_JUL - 201))
      | (1ULL << (RpgParser::SPLAT_JAVA - 201))
      | (1ULL << (RpgParser::SPLAT_ISO - 201))
      | (1ULL << (RpgParser::SPLAT_USA - 201))
      | (1ULL << (RpgParser::SPLAT_EUR - 201))
      | (1ULL << (RpgParser::SPLAT_JIS - 201))
      | (1ULL << (RpgParser::SPLAT_DATE - 201))
      | (1ULL << (RpgParser::SPLAT_DAY - 201))
      | (1ULL << (RpgParser::SPlAT_DETC - 201))
      | (1ULL << (RpgParser::SPLAT_DETL - 201))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 201))
      | (1ULL << (RpgParser::SPLAT_END - 201))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 201))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 201))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 201))
      | (1ULL << (RpgParser::SPLAT_EXT - 201))
      | (1ULL << (RpgParser::SPLAT_FILE - 201))
      | (1ULL << (RpgParser::SPLAT_GETIN - 201))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 201))
      | (1ULL << (RpgParser::SPLAT_INIT - 201))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 201))
      | (1ULL << (RpgParser::SPLAT_INZSR - 201))
      | (1ULL << (RpgParser::SPLAT_IN - 201))
      | (1ULL << (RpgParser::SPLAT_INPUT - 201))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 201))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 201))
      | (1ULL << (RpgParser::SPLAT_JOB - 201))
      | (1ULL << (RpgParser::SPLAT_LDA - 201))
      | (1ULL << (RpgParser::SPLAT_LIKE - 201))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 201))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 201)))) != 0) || ((((_la - 265) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 265)) & ((1ULL << (RpgParser::SPLAT_KEY - 265))
      | (1ULL << (RpgParser::SPLAT_MONTH - 265))
      | (1ULL << (RpgParser::SPLAT_NEXT - 265))
      | (1ULL << (RpgParser::SPLAT_NOIND - 265))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 265))
      | (1ULL << (RpgParser::SPLAT_NULL - 265))
      | (1ULL << (RpgParser::SPLAT_OFL - 265))
      | (1ULL << (RpgParser::SPLAT_ON - 265))
      | (1ULL << (RpgParser::SPLAT_ONLY - 265))
      | (1ULL << (RpgParser::SPLAT_OFF - 265))
      | (1ULL << (RpgParser::SPLAT_PDA - 265))
      | (1ULL << (RpgParser::SPLAT_PLACE - 265))
      | (1ULL << (RpgParser::SPLAT_PSSR - 265))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 265))
      | (1ULL << (RpgParser::SPLAT_START - 265))
      | (1ULL << (RpgParser::SPLAT_SYS - 265))
      | (1ULL << (RpgParser::SPLAT_TERM - 265))
      | (1ULL << (RpgParser::SPLAT_TOTC - 265))
      | (1ULL << (RpgParser::SPLAT_TOTL - 265))
      | (1ULL << (RpgParser::SPLAT_USER - 265))
      | (1ULL << (RpgParser::SPLAT_VAR - 265))
      | (1ULL << (RpgParser::SPLAT_YEAR - 265))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 265))
      | (1ULL << (RpgParser::SPLAT_HMS - 265))
      | (1ULL << (RpgParser::SPLAT_INLR - 265))
      | (1ULL << (RpgParser::SPLAT_INOF - 265))
      | (1ULL << (RpgParser::SPLAT_DATA - 265))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 265))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 265))
      | (1ULL << (RpgParser::SPLAT_MAX - 265))
      | (1ULL << (RpgParser::SPLAT_LOCK - 265))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 265))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 265))
      | (1ULL << (RpgParser::SPLAT_D - 265))
      | (1ULL << (RpgParser::SPLAT_H - 265))
      | (1ULL << (RpgParser::SPLAT_HOURS - 265))
      | (1ULL << (RpgParser::SPLAT_DAYS - 265))
      | (1ULL << (RpgParser::SPLAT_M - 265))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 265))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 265))
      | (1ULL << (RpgParser::SPLAT_MN - 265))
      | (1ULL << (RpgParser::SPLAT_MS - 265))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 265))
      | (1ULL << (RpgParser::SPLAT_S - 265))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 265))
      | (1ULL << (RpgParser::SPLAT_Y - 265))
      | (1ULL << (RpgParser::SPLAT_YEARS - 265))
      | (1ULL << (RpgParser::UDATE - 265))
      | (1ULL << (RpgParser::UMONTH - 265))
      | (1ULL << (RpgParser::UYEAR - 265))
      | (1ULL << (RpgParser::UDAY - 265))
      | (1ULL << (RpgParser::CHAR - 265))
      | (1ULL << (RpgParser::VARCHAR - 265))
      | (1ULL << (RpgParser::UCS2 - 265))
      | (1ULL << (RpgParser::DATE_ - 265))
      | (1ULL << (RpgParser::VARUCS2 - 265))
      | (1ULL << (RpgParser::GRAPH - 265))
      | (1ULL << (RpgParser::VARGRAPH - 265))
      | (1ULL << (RpgParser::IND - 265)))) != 0) || ((((_la - 329) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 329)) & ((1ULL << (RpgParser::PACKED - 329))
      | (1ULL << (RpgParser::ZONED - 329))
      | (1ULL << (RpgParser::BINDEC - 329))
      | (1ULL << (RpgParser::INT - 329))
      | (1ULL << (RpgParser::UNS - 329))
      | (1ULL << (RpgParser::FLOAT - 329))
      | (1ULL << (RpgParser::TIME - 329))
      | (1ULL << (RpgParser::TIMESTAMP - 329))
      | (1ULL << (RpgParser::POINTER - 329))
      | (1ULL << (RpgParser::OBJECT - 329))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 329))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 329))
      | (1ULL << (RpgParser::KEYWORD_ALT - 329))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 329))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 329))
      | (1ULL << (RpgParser::KEYWORD_BASED - 329))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 329))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 329))
      | (1ULL << (RpgParser::KEYWORD_CONST - 329))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 329))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 329))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 329))
      | (1ULL << (RpgParser::KEYWORD_DIM - 329))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 329))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 329))
      | (1ULL << (RpgParser::KEYWORD_EXT - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 329))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 329))
      | (1ULL << (RpgParser::KEYWORD_INZ - 329))
      | (1ULL << (RpgParser::KEYWORD_LEN - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 329))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 329))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 329))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 329))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 329))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 329))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 329))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 329))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 329))
      | (1ULL << (RpgParser::KEYWORD_POS - 329))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 329))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 329))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 329))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 329))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 329))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 329))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 329))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 329))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 329))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 329))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 329)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 393)) & ((1ULL << (RpgParser::KEYWORD_FORMLEN - 393))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 393))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 393))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 393))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 393))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 393))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 393))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 393))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 393))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 393))
      | (1ULL << (RpgParser::KEYWORD_PASS - 393))
      | (1ULL << (RpgParser::KEYWORD_PGMNAME - 393))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 393))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 393))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 393))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 393))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 393))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 393))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 393))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 393))
      | (1ULL << (RpgParser::KEYWORD_SLN - 393))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 393))
      | (1ULL << (RpgParser::KEYWORD_DISK - 393))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 393))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 393))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 393))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 393))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 393))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 393))
      | (1ULL << (RpgParser::NOT - 393))
      | (1ULL << (RpgParser::PLUS - 393))
      | (1ULL << (RpgParser::MINUS - 393))
      | (1ULL << (RpgParser::MULT_NOSPACE - 393))
      | (1ULL << (RpgParser::FREE_BY - 393))
      | (1ULL << (RpgParser::FREE_TO - 393))
      | (1ULL << (RpgParser::FREE_DOWNTO - 393))
      | (1ULL << (RpgParser::HexLiteralStart - 393))
      | (1ULL << (RpgParser::DateLiteralStart - 393))
      | (1ULL << (RpgParser::TimeLiteralStart - 393))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 393))
      | (1ULL << (RpgParser::GraphicLiteralStart - 393))
      | (1ULL << (RpgParser::UCS2LiteralStart - 393))
      | (1ULL << (RpgParser::StringLiteralStart - 393)))) != 0)) {
      setState(1184);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
      case 1: {
        setState(1178);
        dcl_pr();
        break;
      }

      case 2: {
        setState(1179);
        dcl_pi();
        break;
      }

      case 3: {
        setState(1180);
        ctl_opt();
        break;
      }

      case 4: {
        setState(1181);
        subroutine();
        break;
      }

      case 5: {
        setState(1182);
        statement();
        break;
      }

      case 6: {
        setState(1183);
        procedure();
        break;
      }

      }
      setState(1188);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1190);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::END_SOURCE) {
      setState(1189);
      endSourceBlock();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

RpgParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::DspecContext* RpgParser::StatementContext::dspec() {
  return getRuleContext<RpgParser::DspecContext>(0);
}

RpgParser::Dcl_dsContext* RpgParser::StatementContext::dcl_ds() {
  return getRuleContext<RpgParser::Dcl_dsContext>(0);
}

RpgParser::Dcl_cContext* RpgParser::StatementContext::dcl_c() {
  return getRuleContext<RpgParser::Dcl_cContext>(0);
}

RpgParser::Dspec_fixedContext* RpgParser::StatementContext::dspec_fixed() {
  return getRuleContext<RpgParser::Dspec_fixedContext>(0);
}

RpgParser::Ospec_fixedContext* RpgParser::StatementContext::ospec_fixed() {
  return getRuleContext<RpgParser::Ospec_fixedContext>(0);
}

RpgParser::FspecContext* RpgParser::StatementContext::fspec() {
  return getRuleContext<RpgParser::FspecContext>(0);
}

RpgParser::Fspec_fixedContext* RpgParser::StatementContext::fspec_fixed() {
  return getRuleContext<RpgParser::Fspec_fixedContext>(0);
}

RpgParser::BlockContext* RpgParser::StatementContext::block() {
  return getRuleContext<RpgParser::BlockContext>(0);
}

RpgParser::Cspec_fixedContext* RpgParser::StatementContext::cspec_fixed() {
  return getRuleContext<RpgParser::Cspec_fixedContext>(0);
}

RpgParser::Blank_specContext* RpgParser::StatementContext::blank_spec() {
  return getRuleContext<RpgParser::Blank_specContext>(0);
}

RpgParser::Cspec_fixed_sqlContext* RpgParser::StatementContext::cspec_fixed_sql() {
  return getRuleContext<RpgParser::Cspec_fixed_sqlContext>(0);
}

RpgParser::Ispec_fixedContext* RpgParser::StatementContext::ispec_fixed() {
  return getRuleContext<RpgParser::Ispec_fixedContext>(0);
}

RpgParser::Hspec_fixedContext* RpgParser::StatementContext::hspec_fixed() {
  return getRuleContext<RpgParser::Hspec_fixedContext>(0);
}

RpgParser::Star_commentsContext* RpgParser::StatementContext::star_comments() {
  return getRuleContext<RpgParser::Star_commentsContext>(0);
}

RpgParser::Free_linecommentsContext* RpgParser::StatementContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}

RpgParser::Blank_lineContext* RpgParser::StatementContext::blank_line() {
  return getRuleContext<RpgParser::Blank_lineContext>(0);
}

RpgParser::DirectiveContext* RpgParser::StatementContext::directive() {
  return getRuleContext<RpgParser::DirectiveContext>(0);
}

RpgParser::FreeContext* RpgParser::StatementContext::free() {
  return getRuleContext<RpgParser::FreeContext>(0);
}


size_t RpgParser::StatementContext::getRuleIndex() const {
  return RpgParser::RuleStatement;
}

void RpgParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void RpgParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}


antlrcpp::Any RpgParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::StatementContext* RpgParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 2, RpgParser::RuleStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1210);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1192);
      dspec();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1193);
      dcl_ds();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1194);
      dcl_c();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1195);
      dspec_fixed();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1196);
      ospec_fixed();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1197);
      fspec();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1198);
      fspec_fixed();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1199);
      block();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1200);
      cspec_fixed();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1201);
      blank_spec();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1202);
      cspec_fixed_sql();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1203);
      ispec_fixed();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1204);
      hspec_fixed();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1205);
      star_comments();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1206);
      free_linecomments();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1207);
      blank_line();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1208);
      directive();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1209);
      free();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndSourceBlockContext ------------------------------------------------------------------

RpgParser::EndSourceBlockContext::EndSourceBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::EndSourceContext *> RpgParser::EndSourceBlockContext::endSource() {
  return getRuleContexts<RpgParser::EndSourceContext>();
}

RpgParser::EndSourceContext* RpgParser::EndSourceBlockContext::endSource(size_t i) {
  return getRuleContext<RpgParser::EndSourceContext>(i);
}


size_t RpgParser::EndSourceBlockContext::getRuleIndex() const {
  return RpgParser::RuleEndSourceBlock;
}

void RpgParser::EndSourceBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndSourceBlock(this);
}

void RpgParser::EndSourceBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndSourceBlock(this);
}


antlrcpp::Any RpgParser::EndSourceBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndSourceBlock(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndSourceBlockContext* RpgParser::endSourceBlock() {
  EndSourceBlockContext *_localctx = _tracker.createInstance<EndSourceBlockContext>(_ctx, getState());
  enterRule(_localctx, 4, RpgParser::RuleEndSourceBlock);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1213); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1212);
      endSource();
      setState(1215); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == RpgParser::END_SOURCE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndSourceContext ------------------------------------------------------------------

RpgParser::EndSourceContext::EndSourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::EndSourceHeadContext* RpgParser::EndSourceContext::endSourceHead() {
  return getRuleContext<RpgParser::EndSourceHeadContext>(0);
}

std::vector<RpgParser::EndSourceLineContext *> RpgParser::EndSourceContext::endSourceLine() {
  return getRuleContexts<RpgParser::EndSourceLineContext>();
}

RpgParser::EndSourceLineContext* RpgParser::EndSourceContext::endSourceLine(size_t i) {
  return getRuleContext<RpgParser::EndSourceLineContext>(i);
}


size_t RpgParser::EndSourceContext::getRuleIndex() const {
  return RpgParser::RuleEndSource;
}

void RpgParser::EndSourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndSource(this);
}

void RpgParser::EndSourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndSource(this);
}


antlrcpp::Any RpgParser::EndSourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndSource(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndSourceContext* RpgParser::endSource() {
  EndSourceContext *_localctx = _tracker.createInstance<EndSourceContext>(_ctx, getState());
  enterRule(_localctx, 6, RpgParser::RuleEndSource);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1217);
    endSourceHead();
    setState(1221);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::EOS_Text) {
      setState(1218);
      endSourceLine();
      setState(1223);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndSourceHeadContext ------------------------------------------------------------------

RpgParser::EndSourceHeadContext::EndSourceHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::EndSourceHeadContext::END_SOURCE() {
  return getToken(RpgParser::END_SOURCE, 0);
}


size_t RpgParser::EndSourceHeadContext::getRuleIndex() const {
  return RpgParser::RuleEndSourceHead;
}

void RpgParser::EndSourceHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndSourceHead(this);
}

void RpgParser::EndSourceHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndSourceHead(this);
}


antlrcpp::Any RpgParser::EndSourceHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndSourceHead(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndSourceHeadContext* RpgParser::endSourceHead() {
  EndSourceHeadContext *_localctx = _tracker.createInstance<EndSourceHeadContext>(_ctx, getState());
  enterRule(_localctx, 8, RpgParser::RuleEndSourceHead);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1224);
    match(RpgParser::END_SOURCE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndSourceLineContext ------------------------------------------------------------------

RpgParser::EndSourceLineContext::EndSourceLineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::EndSourceLineTextContext* RpgParser::EndSourceLineContext::endSourceLineText() {
  return getRuleContext<RpgParser::EndSourceLineTextContext>(0);
}

tree::TerminalNode* RpgParser::EndSourceLineContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}


size_t RpgParser::EndSourceLineContext::getRuleIndex() const {
  return RpgParser::RuleEndSourceLine;
}

void RpgParser::EndSourceLineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndSourceLine(this);
}

void RpgParser::EndSourceLineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndSourceLine(this);
}


antlrcpp::Any RpgParser::EndSourceLineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndSourceLine(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndSourceLineContext* RpgParser::endSourceLine() {
  EndSourceLineContext *_localctx = _tracker.createInstance<EndSourceLineContext>(_ctx, getState());
  enterRule(_localctx, 10, RpgParser::RuleEndSourceLine);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1226);
    endSourceLineText();
    setState(1228);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::EOL) {
      setState(1227);
      match(RpgParser::EOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndSourceLineTextContext ------------------------------------------------------------------

RpgParser::EndSourceLineTextContext::EndSourceLineTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::EndSourceLineTextContext::EOS_Text() {
  return getToken(RpgParser::EOS_Text, 0);
}


size_t RpgParser::EndSourceLineTextContext::getRuleIndex() const {
  return RpgParser::RuleEndSourceLineText;
}

void RpgParser::EndSourceLineTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndSourceLineText(this);
}

void RpgParser::EndSourceLineTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndSourceLineText(this);
}


antlrcpp::Any RpgParser::EndSourceLineTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndSourceLineText(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndSourceLineTextContext* RpgParser::endSourceLineText() {
  EndSourceLineTextContext *_localctx = _tracker.createInstance<EndSourceLineTextContext>(_ctx, getState());
  enterRule(_localctx, 12, RpgParser::RuleEndSourceLineText);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1230);
    match(RpgParser::EOS_Text);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_commentsContext ------------------------------------------------------------------

RpgParser::Star_commentsContext::Star_commentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Star_commentsContext::COMMENT_SPEC_FIXED() {
  return getToken(RpgParser::COMMENT_SPEC_FIXED, 0);
}

RpgParser::CommentsContext* RpgParser::Star_commentsContext::comments() {
  return getRuleContext<RpgParser::CommentsContext>(0);
}


size_t RpgParser::Star_commentsContext::getRuleIndex() const {
  return RpgParser::RuleStar_comments;
}

void RpgParser::Star_commentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_comments(this);
}

void RpgParser::Star_commentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_comments(this);
}


antlrcpp::Any RpgParser::Star_commentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitStar_comments(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Star_commentsContext* RpgParser::star_comments() {
  Star_commentsContext *_localctx = _tracker.createInstance<Star_commentsContext>(_ctx, getState());
  enterRule(_localctx, 14, RpgParser::RuleStar_comments);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1232);
    match(RpgParser::COMMENT_SPEC_FIXED);
    setState(1234);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COMMENTS_TEXT) {
      setState(1233);
      comments();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Free_commentsContext ------------------------------------------------------------------

RpgParser::Free_commentsContext::Free_commentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Free_commentsContext::COMMENTS() {
  return getToken(RpgParser::COMMENTS, 0);
}

RpgParser::CommentsContext* RpgParser::Free_commentsContext::comments() {
  return getRuleContext<RpgParser::CommentsContext>(0);
}

tree::TerminalNode* RpgParser::Free_commentsContext::COMMENTS_EOL() {
  return getToken(RpgParser::COMMENTS_EOL, 0);
}


size_t RpgParser::Free_commentsContext::getRuleIndex() const {
  return RpgParser::RuleFree_comments;
}

void RpgParser::Free_commentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFree_comments(this);
}

void RpgParser::Free_commentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFree_comments(this);
}


antlrcpp::Any RpgParser::Free_commentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFree_comments(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Free_commentsContext* RpgParser::free_comments() {
  Free_commentsContext *_localctx = _tracker.createInstance<Free_commentsContext>(_ctx, getState());
  enterRule(_localctx, 16, RpgParser::RuleFree_comments);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1236);
    match(RpgParser::COMMENTS);
    setState(1237);
    comments();
    setState(1238);
    match(RpgParser::COMMENTS_EOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Free_linecommentsContext ------------------------------------------------------------------

RpgParser::Free_linecommentsContext::Free_linecommentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Free_linecommentsContext::COMMENTS() {
  return getToken(RpgParser::COMMENTS, 0);
}

RpgParser::CommentsContext* RpgParser::Free_linecommentsContext::comments() {
  return getRuleContext<RpgParser::CommentsContext>(0);
}


size_t RpgParser::Free_linecommentsContext::getRuleIndex() const {
  return RpgParser::RuleFree_linecomments;
}

void RpgParser::Free_linecommentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFree_linecomments(this);
}

void RpgParser::Free_linecommentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFree_linecomments(this);
}


antlrcpp::Any RpgParser::Free_linecommentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFree_linecomments(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Free_linecommentsContext* RpgParser::free_linecomments() {
  Free_linecommentsContext *_localctx = _tracker.createInstance<Free_linecommentsContext>(_ctx, getState());
  enterRule(_localctx, 18, RpgParser::RuleFree_linecomments);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1240);
    match(RpgParser::COMMENTS);
    setState(1241);
    comments();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentsContext ------------------------------------------------------------------

RpgParser::CommentsContext::CommentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CommentsContext::COMMENTS_TEXT() {
  return getToken(RpgParser::COMMENTS_TEXT, 0);
}


size_t RpgParser::CommentsContext::getRuleIndex() const {
  return RpgParser::RuleComments;
}

void RpgParser::CommentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComments(this);
}

void RpgParser::CommentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComments(this);
}


antlrcpp::Any RpgParser::CommentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitComments(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CommentsContext* RpgParser::comments() {
  CommentsContext *_localctx = _tracker.createInstance<CommentsContext>(_ctx, getState());
  enterRule(_localctx, 20, RpgParser::RuleComments);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1243);
    match(RpgParser::COMMENTS_TEXT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DspecContext ------------------------------------------------------------------

RpgParser::DspecContext::DspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::DspecContext::DS_Standalone() {
  return getToken(RpgParser::DS_Standalone, 0);
}

tree::TerminalNode* RpgParser::DspecContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::IdentifierContext* RpgParser::DspecContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::DatatypeContext* RpgParser::DspecContext::datatype() {
  return getRuleContext<RpgParser::DatatypeContext>(0);
}

RpgParser::Free_linecommentsContext* RpgParser::DspecContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::DspecContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::DspecContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}

RpgParser::DspecConstantContext* RpgParser::DspecContext::dspecConstant() {
  return getRuleContext<RpgParser::DspecConstantContext>(0);
}

tree::TerminalNode* RpgParser::DspecContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::DspecContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::DspecContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::DspecContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::DspecContext::DEF_TYPE_S() {
  return getToken(RpgParser::DEF_TYPE_S, 0);
}

tree::TerminalNode* RpgParser::DspecContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::DspecContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::DspecContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::DspecContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::DspecContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::DspecContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::DspecContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::DspecContext::getRuleIndex() const {
  return RpgParser::RuleDspec;
}

void RpgParser::DspecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDspec(this);
}

void RpgParser::DspecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDspec(this);
}


antlrcpp::Any RpgParser::DspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDspec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DspecContext* RpgParser::dspec() {
  DspecContext *_localctx = _tracker.createInstance<DspecContext>(_ctx, getState());
  enterRule(_localctx, 22, RpgParser::RuleDspec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1280);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1245);
      match(RpgParser::DS_Standalone);
      setState(1246);
      dynamic_cast<DspecContext *>(_localctx)->name = identifier();
      setState(1248);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 321) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 321)) & ((1ULL << (RpgParser::CHAR - 321))
        | (1ULL << (RpgParser::VARCHAR - 321))
        | (1ULL << (RpgParser::UCS2 - 321))
        | (1ULL << (RpgParser::DATE_ - 321))
        | (1ULL << (RpgParser::VARUCS2 - 321))
        | (1ULL << (RpgParser::GRAPH - 321))
        | (1ULL << (RpgParser::VARGRAPH - 321))
        | (1ULL << (RpgParser::IND - 321))
        | (1ULL << (RpgParser::PACKED - 321))
        | (1ULL << (RpgParser::ZONED - 321))
        | (1ULL << (RpgParser::BINDEC - 321))
        | (1ULL << (RpgParser::INT - 321))
        | (1ULL << (RpgParser::UNS - 321))
        | (1ULL << (RpgParser::FLOAT - 321))
        | (1ULL << (RpgParser::TIME - 321))
        | (1ULL << (RpgParser::TIMESTAMP - 321))
        | (1ULL << (RpgParser::POINTER - 321))
        | (1ULL << (RpgParser::OBJECT - 321)))) != 0)) {
        setState(1247);
        datatype();
      }
      setState(1255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
        | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
        | (1ULL << (RpgParser::KEYWORD_ALT - 339))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
        | (1ULL << (RpgParser::KEYWORD_BASED - 339))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
        | (1ULL << (RpgParser::KEYWORD_CONST - 339))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
        | (1ULL << (RpgParser::KEYWORD_DIM - 339))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
        | (1ULL << (RpgParser::KEYWORD_EXT - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
        | (1ULL << (RpgParser::KEYWORD_INZ - 339))
        | (1ULL << (RpgParser::KEYWORD_LEN - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
        | (1ULL << (RpgParser::KEYWORD_POS - 339))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

      || _la == RpgParser::KEYWORD_PSDS) {
        setState(1251); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1250);
          keyword();
          setState(1253); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
          | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
          | (1ULL << (RpgParser::KEYWORD_ALT - 339))
          | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
          | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
          | (1ULL << (RpgParser::KEYWORD_BASED - 339))
          | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
          | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
          | (1ULL << (RpgParser::KEYWORD_CONST - 339))
          | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
          | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
          | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
          | (1ULL << (RpgParser::KEYWORD_DIM - 339))
          | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
          | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
          | (1ULL << (RpgParser::KEYWORD_EXT - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
          | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
          | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
          | (1ULL << (RpgParser::KEYWORD_INZ - 339))
          | (1ULL << (RpgParser::KEYWORD_LEN - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
          | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
          | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
          | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
          | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
          | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
          | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
          | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
          | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
          | (1ULL << (RpgParser::KEYWORD_POS - 339))
          | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
          | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
          | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
          | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
          | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
          | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
          | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
          | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
          | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

        || _la == RpgParser::KEYWORD_PSDS);
      }
      setState(1257);
      match(RpgParser::FREE_SEMI);
      setState(1259);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
      case 1: {
        setState(1258);
        free_linecomments();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1261);
      dspecConstant();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1262);
      match(RpgParser::DS_FIXED);
      setState(1263);
      ds_name();
      setState(1264);
      match(RpgParser::EXTERNAL_DESCRIPTION);
      setState(1265);
      match(RpgParser::DATA_STRUCTURE_TYPE);
      setState(1266);
      match(RpgParser::DEF_TYPE_S);
      setState(1267);
      match(RpgParser::FROM_POSITION);
      setState(1268);
      match(RpgParser::TO_POSITION);
      setState(1269);
      match(RpgParser::DATA_TYPE);
      setState(1270);
      match(RpgParser::DECIMAL_POSITIONS);
      setState(1271);
      match(RpgParser::RESERVED);
      setState(1275);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
        | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
        | (1ULL << (RpgParser::KEYWORD_ALT - 339))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
        | (1ULL << (RpgParser::KEYWORD_BASED - 339))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
        | (1ULL << (RpgParser::KEYWORD_CONST - 339))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
        | (1ULL << (RpgParser::KEYWORD_DIM - 339))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
        | (1ULL << (RpgParser::KEYWORD_EXT - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
        | (1ULL << (RpgParser::KEYWORD_INZ - 339))
        | (1ULL << (RpgParser::KEYWORD_LEN - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
        | (1ULL << (RpgParser::KEYWORD_POS - 339))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

      || _la == RpgParser::KEYWORD_PSDS) {
        setState(1272);
        keyword();
        setState(1277);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1278);
      _la = _input->LA(1);
      if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DspecConstantContext ------------------------------------------------------------------

RpgParser::DspecConstantContext::DspecConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::DspecConstantContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::DspecConstantContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::DEF_TYPE_C() {
  return getToken(RpgParser::DEF_TYPE_C, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

RpgParser::NumberContext* RpgParser::DspecConstantContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::DspecConstantContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::DspecConstantContext::getRuleIndex() const {
  return RpgParser::RuleDspecConstant;
}

void RpgParser::DspecConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDspecConstant(this);
}

void RpgParser::DspecConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDspecConstant(this);
}


antlrcpp::Any RpgParser::DspecConstantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDspecConstant(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DspecConstantContext* RpgParser::dspecConstant() {
  DspecConstantContext *_localctx = _tracker.createInstance<DspecConstantContext>(_ctx, getState());
  enterRule(_localctx, 24, RpgParser::RuleDspecConstant);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1282);
    match(RpgParser::DS_FIXED);
    setState(1283);
    ds_name();
    setState(1284);
    match(RpgParser::EXTERNAL_DESCRIPTION);
    setState(1285);
    match(RpgParser::DATA_STRUCTURE_TYPE);
    setState(1286);
    match(RpgParser::DEF_TYPE_C);
    setState(1287);
    match(RpgParser::FROM_POSITION);
    setState(1288);
    match(RpgParser::TO_POSITION);
    setState(1289);
    match(RpgParser::DATA_TYPE);
    setState(1290);
    match(RpgParser::DECIMAL_POSITIONS);
    setState(1291);
    match(RpgParser::RESERVED);
    setState(1292);
    number();
    setState(1293);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DatatypeContext ------------------------------------------------------------------

RpgParser::DatatypeContext::DatatypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::DatatypeNameContext* RpgParser::DatatypeContext::datatypeName() {
  return getRuleContext<RpgParser::DatatypeNameContext>(0);
}

RpgParser::ArgsContext* RpgParser::DatatypeContext::args() {
  return getRuleContext<RpgParser::ArgsContext>(0);
}


size_t RpgParser::DatatypeContext::getRuleIndex() const {
  return RpgParser::RuleDatatype;
}

void RpgParser::DatatypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatatype(this);
}

void RpgParser::DatatypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatatype(this);
}


antlrcpp::Any RpgParser::DatatypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDatatype(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DatatypeContext* RpgParser::datatype() {
  DatatypeContext *_localctx = _tracker.createInstance<DatatypeContext>(_ctx, getState());
  enterRule(_localctx, 26, RpgParser::RuleDatatype);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1295);
    datatypeName();
    setState(1297);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1296);
      args();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

RpgParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Keyword_aliasContext* RpgParser::KeywordContext::keyword_alias() {
  return getRuleContext<RpgParser::Keyword_aliasContext>(0);
}

RpgParser::Keyword_alignContext* RpgParser::KeywordContext::keyword_align() {
  return getRuleContext<RpgParser::Keyword_alignContext>(0);
}

RpgParser::Keyword_altContext* RpgParser::KeywordContext::keyword_alt() {
  return getRuleContext<RpgParser::Keyword_altContext>(0);
}

RpgParser::Keyword_altseqContext* RpgParser::KeywordContext::keyword_altseq() {
  return getRuleContext<RpgParser::Keyword_altseqContext>(0);
}

RpgParser::Keyword_ascendContext* RpgParser::KeywordContext::keyword_ascend() {
  return getRuleContext<RpgParser::Keyword_ascendContext>(0);
}

RpgParser::Keyword_basedContext* RpgParser::KeywordContext::keyword_based() {
  return getRuleContext<RpgParser::Keyword_basedContext>(0);
}

RpgParser::Keyword_ccsidContext* RpgParser::KeywordContext::keyword_ccsid() {
  return getRuleContext<RpgParser::Keyword_ccsidContext>(0);
}

RpgParser::Keyword_classContext* RpgParser::KeywordContext::keyword_class() {
  return getRuleContext<RpgParser::Keyword_classContext>(0);
}

RpgParser::Keyword_constContext* RpgParser::KeywordContext::keyword_const() {
  return getRuleContext<RpgParser::Keyword_constContext>(0);
}

RpgParser::Keyword_ctdataContext* RpgParser::KeywordContext::keyword_ctdata() {
  return getRuleContext<RpgParser::Keyword_ctdataContext>(0);
}

RpgParser::Keyword_datfmtContext* RpgParser::KeywordContext::keyword_datfmt() {
  return getRuleContext<RpgParser::Keyword_datfmtContext>(0);
}

RpgParser::Keyword_descendContext* RpgParser::KeywordContext::keyword_descend() {
  return getRuleContext<RpgParser::Keyword_descendContext>(0);
}

RpgParser::Keyword_dimContext* RpgParser::KeywordContext::keyword_dim() {
  return getRuleContext<RpgParser::Keyword_dimContext>(0);
}

RpgParser::Keyword_dtaaraContext* RpgParser::KeywordContext::keyword_dtaara() {
  return getRuleContext<RpgParser::Keyword_dtaaraContext>(0);
}

RpgParser::Keyword_exportContext* RpgParser::KeywordContext::keyword_export() {
  return getRuleContext<RpgParser::Keyword_exportContext>(0);
}

RpgParser::Keyword_extContext* RpgParser::KeywordContext::keyword_ext() {
  return getRuleContext<RpgParser::Keyword_extContext>(0);
}

RpgParser::Keyword_extfldContext* RpgParser::KeywordContext::keyword_extfld() {
  return getRuleContext<RpgParser::Keyword_extfldContext>(0);
}

RpgParser::Keyword_extfmtContext* RpgParser::KeywordContext::keyword_extfmt() {
  return getRuleContext<RpgParser::Keyword_extfmtContext>(0);
}

RpgParser::Keyword_extnameContext* RpgParser::KeywordContext::keyword_extname() {
  return getRuleContext<RpgParser::Keyword_extnameContext>(0);
}

RpgParser::Keyword_extpgmContext* RpgParser::KeywordContext::keyword_extpgm() {
  return getRuleContext<RpgParser::Keyword_extpgmContext>(0);
}

RpgParser::Keyword_extprocContext* RpgParser::KeywordContext::keyword_extproc() {
  return getRuleContext<RpgParser::Keyword_extprocContext>(0);
}

RpgParser::Keyword_fromfileContext* RpgParser::KeywordContext::keyword_fromfile() {
  return getRuleContext<RpgParser::Keyword_fromfileContext>(0);
}

RpgParser::Keyword_importContext* RpgParser::KeywordContext::keyword_import() {
  return getRuleContext<RpgParser::Keyword_importContext>(0);
}

RpgParser::Keyword_inzContext* RpgParser::KeywordContext::keyword_inz() {
  return getRuleContext<RpgParser::Keyword_inzContext>(0);
}

RpgParser::Keyword_lenContext* RpgParser::KeywordContext::keyword_len() {
  return getRuleContext<RpgParser::Keyword_lenContext>(0);
}

RpgParser::Keyword_likeContext* RpgParser::KeywordContext::keyword_like() {
  return getRuleContext<RpgParser::Keyword_likeContext>(0);
}

RpgParser::Keyword_likedsContext* RpgParser::KeywordContext::keyword_likeds() {
  return getRuleContext<RpgParser::Keyword_likedsContext>(0);
}

RpgParser::Keyword_likefileContext* RpgParser::KeywordContext::keyword_likefile() {
  return getRuleContext<RpgParser::Keyword_likefileContext>(0);
}

RpgParser::Keyword_likerecContext* RpgParser::KeywordContext::keyword_likerec() {
  return getRuleContext<RpgParser::Keyword_likerecContext>(0);
}

RpgParser::Keyword_nooptContext* RpgParser::KeywordContext::keyword_noopt() {
  return getRuleContext<RpgParser::Keyword_nooptContext>(0);
}

RpgParser::Keyword_occursContext* RpgParser::KeywordContext::keyword_occurs() {
  return getRuleContext<RpgParser::Keyword_occursContext>(0);
}

RpgParser::Keyword_opdescContext* RpgParser::KeywordContext::keyword_opdesc() {
  return getRuleContext<RpgParser::Keyword_opdescContext>(0);
}

RpgParser::Keyword_optionsContext* RpgParser::KeywordContext::keyword_options() {
  return getRuleContext<RpgParser::Keyword_optionsContext>(0);
}

RpgParser::Keyword_overlayContext* RpgParser::KeywordContext::keyword_overlay() {
  return getRuleContext<RpgParser::Keyword_overlayContext>(0);
}

RpgParser::Keyword_packevenContext* RpgParser::KeywordContext::keyword_packeven() {
  return getRuleContext<RpgParser::Keyword_packevenContext>(0);
}

RpgParser::Keyword_perrcdContext* RpgParser::KeywordContext::keyword_perrcd() {
  return getRuleContext<RpgParser::Keyword_perrcdContext>(0);
}

RpgParser::Keyword_prefixContext* RpgParser::KeywordContext::keyword_prefix() {
  return getRuleContext<RpgParser::Keyword_prefixContext>(0);
}

RpgParser::Keyword_posContext* RpgParser::KeywordContext::keyword_pos() {
  return getRuleContext<RpgParser::Keyword_posContext>(0);
}

RpgParser::Keyword_procptrContext* RpgParser::KeywordContext::keyword_procptr() {
  return getRuleContext<RpgParser::Keyword_procptrContext>(0);
}

RpgParser::Keyword_qualifiedContext* RpgParser::KeywordContext::keyword_qualified() {
  return getRuleContext<RpgParser::Keyword_qualifiedContext>(0);
}

RpgParser::Keyword_rtnparmContext* RpgParser::KeywordContext::keyword_rtnparm() {
  return getRuleContext<RpgParser::Keyword_rtnparmContext>(0);
}

RpgParser::Keyword_staticContext* RpgParser::KeywordContext::keyword_static() {
  return getRuleContext<RpgParser::Keyword_staticContext>(0);
}

RpgParser::Keyword_sqltypeContext* RpgParser::KeywordContext::keyword_sqltype() {
  return getRuleContext<RpgParser::Keyword_sqltypeContext>(0);
}

RpgParser::Keyword_templateContext* RpgParser::KeywordContext::keyword_template() {
  return getRuleContext<RpgParser::Keyword_templateContext>(0);
}

RpgParser::Keyword_timfmtContext* RpgParser::KeywordContext::keyword_timfmt() {
  return getRuleContext<RpgParser::Keyword_timfmtContext>(0);
}

RpgParser::Keyword_tofileContext* RpgParser::KeywordContext::keyword_tofile() {
  return getRuleContext<RpgParser::Keyword_tofileContext>(0);
}

RpgParser::Keyword_valueContext* RpgParser::KeywordContext::keyword_value() {
  return getRuleContext<RpgParser::Keyword_valueContext>(0);
}

RpgParser::Keyword_varyingContext* RpgParser::KeywordContext::keyword_varying() {
  return getRuleContext<RpgParser::Keyword_varyingContext>(0);
}

RpgParser::Keyword_psdsContext* RpgParser::KeywordContext::keyword_psds() {
  return getRuleContext<RpgParser::Keyword_psdsContext>(0);
}

RpgParser::Dspec_bifContext* RpgParser::KeywordContext::dspec_bif() {
  return getRuleContext<RpgParser::Dspec_bifContext>(0);
}


size_t RpgParser::KeywordContext::getRuleIndex() const {
  return RpgParser::RuleKeyword;
}

void RpgParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void RpgParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}


antlrcpp::Any RpgParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::KeywordContext* RpgParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 28, RpgParser::RuleKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1349);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::KEYWORD_ALIAS: {
        enterOuterAlt(_localctx, 1);
        setState(1299);
        keyword_alias();
        break;
      }

      case RpgParser::KEYWORD_ALIGN: {
        enterOuterAlt(_localctx, 2);
        setState(1300);
        keyword_align();
        break;
      }

      case RpgParser::KEYWORD_ALT: {
        enterOuterAlt(_localctx, 3);
        setState(1301);
        keyword_alt();
        break;
      }

      case RpgParser::KEYWORD_ALTSEQ: {
        enterOuterAlt(_localctx, 4);
        setState(1302);
        keyword_altseq();
        break;
      }

      case RpgParser::KEYWORD_ASCEND: {
        enterOuterAlt(_localctx, 5);
        setState(1303);
        keyword_ascend();
        break;
      }

      case RpgParser::KEYWORD_BASED: {
        enterOuterAlt(_localctx, 6);
        setState(1304);
        keyword_based();
        break;
      }

      case RpgParser::KEYWORD_CCSID: {
        enterOuterAlt(_localctx, 7);
        setState(1305);
        keyword_ccsid();
        break;
      }

      case RpgParser::KEYWORD_CLASS: {
        enterOuterAlt(_localctx, 8);
        setState(1306);
        keyword_class();
        break;
      }

      case RpgParser::KEYWORD_CONST: {
        enterOuterAlt(_localctx, 9);
        setState(1307);
        keyword_const();
        break;
      }

      case RpgParser::KEYWORD_CTDATA: {
        enterOuterAlt(_localctx, 10);
        setState(1308);
        keyword_ctdata();
        break;
      }

      case RpgParser::KEYWORD_DATFMT: {
        enterOuterAlt(_localctx, 11);
        setState(1309);
        keyword_datfmt();
        break;
      }

      case RpgParser::KEYWORD_DESCEND: {
        enterOuterAlt(_localctx, 12);
        setState(1310);
        keyword_descend();
        break;
      }

      case RpgParser::KEYWORD_DIM: {
        enterOuterAlt(_localctx, 13);
        setState(1311);
        keyword_dim();
        break;
      }

      case RpgParser::KEYWORD_DTAARA: {
        enterOuterAlt(_localctx, 14);
        setState(1312);
        keyword_dtaara();
        break;
      }

      case RpgParser::KEYWORD_EXPORT: {
        enterOuterAlt(_localctx, 15);
        setState(1313);
        keyword_export();
        break;
      }

      case RpgParser::KEYWORD_EXT: {
        enterOuterAlt(_localctx, 16);
        setState(1314);
        keyword_ext();
        break;
      }

      case RpgParser::KEYWORD_EXTFLD: {
        enterOuterAlt(_localctx, 17);
        setState(1315);
        keyword_extfld();
        break;
      }

      case RpgParser::KEYWORD_EXTFMT: {
        enterOuterAlt(_localctx, 18);
        setState(1316);
        keyword_extfmt();
        break;
      }

      case RpgParser::KEYWORD_EXTNAME: {
        enterOuterAlt(_localctx, 19);
        setState(1317);
        keyword_extname();
        break;
      }

      case RpgParser::KEYWORD_EXTPGM: {
        enterOuterAlt(_localctx, 20);
        setState(1318);
        keyword_extpgm();
        break;
      }

      case RpgParser::KEYWORD_EXTPROC: {
        enterOuterAlt(_localctx, 21);
        setState(1319);
        keyword_extproc();
        break;
      }

      case RpgParser::KEYWORD_FROMFILE: {
        enterOuterAlt(_localctx, 22);
        setState(1320);
        keyword_fromfile();
        break;
      }

      case RpgParser::KEYWORD_IMPORT: {
        enterOuterAlt(_localctx, 23);
        setState(1321);
        keyword_import();
        break;
      }

      case RpgParser::KEYWORD_INZ: {
        enterOuterAlt(_localctx, 24);
        setState(1322);
        keyword_inz();
        break;
      }

      case RpgParser::KEYWORD_LEN: {
        enterOuterAlt(_localctx, 25);
        setState(1323);
        keyword_len();
        break;
      }

      case RpgParser::KEYWORD_LIKE: {
        enterOuterAlt(_localctx, 26);
        setState(1324);
        keyword_like();
        break;
      }

      case RpgParser::KEYWORD_LIKEDS: {
        enterOuterAlt(_localctx, 27);
        setState(1325);
        keyword_likeds();
        break;
      }

      case RpgParser::KEYWORD_LIKEFILE: {
        enterOuterAlt(_localctx, 28);
        setState(1326);
        keyword_likefile();
        break;
      }

      case RpgParser::KEYWORD_LIKEREC: {
        enterOuterAlt(_localctx, 29);
        setState(1327);
        keyword_likerec();
        break;
      }

      case RpgParser::KEYWORD_NOOPT: {
        enterOuterAlt(_localctx, 30);
        setState(1328);
        keyword_noopt();
        break;
      }

      case RpgParser::KEYWORD_OCCURS: {
        enterOuterAlt(_localctx, 31);
        setState(1329);
        keyword_occurs();
        break;
      }

      case RpgParser::KEYWORD_OPDESC: {
        enterOuterAlt(_localctx, 32);
        setState(1330);
        keyword_opdesc();
        break;
      }

      case RpgParser::KEYWORD_OPTIONS: {
        enterOuterAlt(_localctx, 33);
        setState(1331);
        keyword_options();
        break;
      }

      case RpgParser::KEYWORD_OVERLAY: {
        enterOuterAlt(_localctx, 34);
        setState(1332);
        keyword_overlay();
        break;
      }

      case RpgParser::KEYWORD_PACKEVEN: {
        enterOuterAlt(_localctx, 35);
        setState(1333);
        keyword_packeven();
        break;
      }

      case RpgParser::KEYWORD_PERRCD: {
        enterOuterAlt(_localctx, 36);
        setState(1334);
        keyword_perrcd();
        break;
      }

      case RpgParser::KEYWORD_PREFIX: {
        enterOuterAlt(_localctx, 37);
        setState(1335);
        keyword_prefix();
        break;
      }

      case RpgParser::KEYWORD_POS: {
        enterOuterAlt(_localctx, 38);
        setState(1336);
        keyword_pos();
        break;
      }

      case RpgParser::KEYWORD_PROCPTR: {
        enterOuterAlt(_localctx, 39);
        setState(1337);
        keyword_procptr();
        break;
      }

      case RpgParser::KEYWORD_QUALIFIED: {
        enterOuterAlt(_localctx, 40);
        setState(1338);
        keyword_qualified();
        break;
      }

      case RpgParser::KEYWORD_RTNPARM: {
        enterOuterAlt(_localctx, 41);
        setState(1339);
        keyword_rtnparm();
        break;
      }

      case RpgParser::KEYWORD_STATIC: {
        enterOuterAlt(_localctx, 42);
        setState(1340);
        keyword_static();
        break;
      }

      case RpgParser::KEYWORD_SQLTYPE: {
        enterOuterAlt(_localctx, 43);
        setState(1341);
        keyword_sqltype();
        break;
      }

      case RpgParser::KEYWORD_TEMPLATE: {
        enterOuterAlt(_localctx, 44);
        setState(1342);
        keyword_template();
        break;
      }

      case RpgParser::KEYWORD_TIMFMT: {
        enterOuterAlt(_localctx, 45);
        setState(1343);
        keyword_timfmt();
        break;
      }

      case RpgParser::KEYWORD_TOFILE: {
        enterOuterAlt(_localctx, 46);
        setState(1344);
        keyword_tofile();
        break;
      }

      case RpgParser::KEYWORD_VALUE: {
        enterOuterAlt(_localctx, 47);
        setState(1345);
        keyword_value();
        break;
      }

      case RpgParser::KEYWORD_VARYING: {
        enterOuterAlt(_localctx, 48);
        setState(1346);
        keyword_varying();
        break;
      }

      case RpgParser::KEYWORD_PSDS: {
        enterOuterAlt(_localctx, 49);
        setState(1347);
        keyword_psds();
        break;
      }

      case RpgParser::BIF_ELEM: {
        enterOuterAlt(_localctx, 50);
        setState(1348);
        dspec_bif();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dspec_bifContext ------------------------------------------------------------------

RpgParser::Dspec_bifContext::Dspec_bifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Bif_elemContext* RpgParser::Dspec_bifContext::bif_elem() {
  return getRuleContext<RpgParser::Bif_elemContext>(0);
}


size_t RpgParser::Dspec_bifContext::getRuleIndex() const {
  return RpgParser::RuleDspec_bif;
}

void RpgParser::Dspec_bifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDspec_bif(this);
}

void RpgParser::Dspec_bifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDspec_bif(this);
}


antlrcpp::Any RpgParser::Dspec_bifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDspec_bif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dspec_bifContext* RpgParser::dspec_bif() {
  Dspec_bifContext *_localctx = _tracker.createInstance<Dspec_bifContext>(_ctx, getState());
  enterRule(_localctx, 30, RpgParser::RuleDspec_bif);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1351);
    bif_elem();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_aliasContext ------------------------------------------------------------------

RpgParser::Keyword_aliasContext::Keyword_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_aliasContext::KEYWORD_ALIAS() {
  return getToken(RpgParser::KEYWORD_ALIAS, 0);
}


size_t RpgParser::Keyword_aliasContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_alias;
}

void RpgParser::Keyword_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_alias(this);
}

void RpgParser::Keyword_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_alias(this);
}


antlrcpp::Any RpgParser::Keyword_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_alias(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_aliasContext* RpgParser::keyword_alias() {
  Keyword_aliasContext *_localctx = _tracker.createInstance<Keyword_aliasContext>(_ctx, getState());
  enterRule(_localctx, 32, RpgParser::RuleKeyword_alias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1353);
    match(RpgParser::KEYWORD_ALIAS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_alignContext ------------------------------------------------------------------

RpgParser::Keyword_alignContext::Keyword_alignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_alignContext::KEYWORD_ALIGN() {
  return getToken(RpgParser::KEYWORD_ALIGN, 0);
}


size_t RpgParser::Keyword_alignContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_align;
}

void RpgParser::Keyword_alignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_align(this);
}

void RpgParser::Keyword_alignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_align(this);
}


antlrcpp::Any RpgParser::Keyword_alignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_align(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_alignContext* RpgParser::keyword_align() {
  Keyword_alignContext *_localctx = _tracker.createInstance<Keyword_alignContext>(_ctx, getState());
  enterRule(_localctx, 34, RpgParser::RuleKeyword_align);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1355);
    match(RpgParser::KEYWORD_ALIGN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_altContext ------------------------------------------------------------------

RpgParser::Keyword_altContext::Keyword_altContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_altContext::KEYWORD_ALT() {
  return getToken(RpgParser::KEYWORD_ALT, 0);
}

tree::TerminalNode* RpgParser::Keyword_altContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_altContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_altContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_altContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_alt;
}

void RpgParser::Keyword_altContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_alt(this);
}

void RpgParser::Keyword_altContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_alt(this);
}


antlrcpp::Any RpgParser::Keyword_altContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_alt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_altContext* RpgParser::keyword_alt() {
  Keyword_altContext *_localctx = _tracker.createInstance<Keyword_altContext>(_ctx, getState());
  enterRule(_localctx, 36, RpgParser::RuleKeyword_alt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1357);
    match(RpgParser::KEYWORD_ALT);
    setState(1358);
    match(RpgParser::OPEN_PAREN);
    setState(1359);
    dynamic_cast<Keyword_altContext *>(_localctx)->array_name = simpleExpression();
    setState(1360);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_altseqContext ------------------------------------------------------------------

RpgParser::Keyword_altseqContext::Keyword_altseqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_altseqContext::KEYWORD_ALTSEQ() {
  return getToken(RpgParser::KEYWORD_ALTSEQ, 0);
}

tree::TerminalNode* RpgParser::Keyword_altseqContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_altseqContext::SPLAT_NONE() {
  return getToken(RpgParser::SPLAT_NONE, 0);
}

tree::TerminalNode* RpgParser::Keyword_altseqContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_altseqContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_altseq;
}

void RpgParser::Keyword_altseqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_altseq(this);
}

void RpgParser::Keyword_altseqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_altseq(this);
}


antlrcpp::Any RpgParser::Keyword_altseqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_altseq(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_altseqContext* RpgParser::keyword_altseq() {
  Keyword_altseqContext *_localctx = _tracker.createInstance<Keyword_altseqContext>(_ctx, getState());
  enterRule(_localctx, 38, RpgParser::RuleKeyword_altseq);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1362);
    match(RpgParser::KEYWORD_ALTSEQ);
    setState(1363);
    match(RpgParser::OPEN_PAREN);
    setState(1364);
    match(RpgParser::SPLAT_NONE);
    setState(1365);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_ascendContext ------------------------------------------------------------------

RpgParser::Keyword_ascendContext::Keyword_ascendContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_ascendContext::KEYWORD_ASCEND() {
  return getToken(RpgParser::KEYWORD_ASCEND, 0);
}


size_t RpgParser::Keyword_ascendContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_ascend;
}

void RpgParser::Keyword_ascendContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_ascend(this);
}

void RpgParser::Keyword_ascendContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_ascend(this);
}


antlrcpp::Any RpgParser::Keyword_ascendContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_ascend(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_ascendContext* RpgParser::keyword_ascend() {
  Keyword_ascendContext *_localctx = _tracker.createInstance<Keyword_ascendContext>(_ctx, getState());
  enterRule(_localctx, 40, RpgParser::RuleKeyword_ascend);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1367);
    match(RpgParser::KEYWORD_ASCEND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_basedContext ------------------------------------------------------------------

RpgParser::Keyword_basedContext::Keyword_basedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_basedContext::KEYWORD_BASED() {
  return getToken(RpgParser::KEYWORD_BASED, 0);
}

tree::TerminalNode* RpgParser::Keyword_basedContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_basedContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_basedContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_basedContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_based;
}

void RpgParser::Keyword_basedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_based(this);
}

void RpgParser::Keyword_basedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_based(this);
}


antlrcpp::Any RpgParser::Keyword_basedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_based(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_basedContext* RpgParser::keyword_based() {
  Keyword_basedContext *_localctx = _tracker.createInstance<Keyword_basedContext>(_ctx, getState());
  enterRule(_localctx, 42, RpgParser::RuleKeyword_based);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1369);
    match(RpgParser::KEYWORD_BASED);
    setState(1370);
    match(RpgParser::OPEN_PAREN);
    setState(1371);
    dynamic_cast<Keyword_basedContext *>(_localctx)->basing_pointer_name = simpleExpression();
    setState(1372);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_ccsidContext ------------------------------------------------------------------

RpgParser::Keyword_ccsidContext::Keyword_ccsidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_ccsidContext::KEYWORD_CCSID() {
  return getToken(RpgParser::KEYWORD_CCSID, 0);
}

tree::TerminalNode* RpgParser::Keyword_ccsidContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_ccsidContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_ccsidContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_ccsidContext::SPLAT_DFT() {
  return getToken(RpgParser::SPLAT_DFT, 0);
}


size_t RpgParser::Keyword_ccsidContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_ccsid;
}

void RpgParser::Keyword_ccsidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_ccsid(this);
}

void RpgParser::Keyword_ccsidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_ccsid(this);
}


antlrcpp::Any RpgParser::Keyword_ccsidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_ccsid(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_ccsidContext* RpgParser::keyword_ccsid() {
  Keyword_ccsidContext *_localctx = _tracker.createInstance<Keyword_ccsidContext>(_ctx, getState());
  enterRule(_localctx, 44, RpgParser::RuleKeyword_ccsid);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1374);
    match(RpgParser::KEYWORD_CCSID);
    setState(1375);
    match(RpgParser::OPEN_PAREN);
    setState(1378);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::NUMBER:
      case RpgParser::MINUS: {
        setState(1376);
        number();
        break;
      }

      case RpgParser::SPLAT_DFT: {
        setState(1377);
        match(RpgParser::SPLAT_DFT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1380);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_classContext ------------------------------------------------------------------

RpgParser::Keyword_classContext::Keyword_classContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_classContext::KEYWORD_CLASS() {
  return getToken(RpgParser::KEYWORD_CLASS, 0);
}

tree::TerminalNode* RpgParser::Keyword_classContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_classContext::SPLAT_JAVA() {
  return getToken(RpgParser::SPLAT_JAVA, 0);
}

tree::TerminalNode* RpgParser::Keyword_classContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Keyword_classContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_classContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_classContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_class;
}

void RpgParser::Keyword_classContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_class(this);
}

void RpgParser::Keyword_classContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_class(this);
}


antlrcpp::Any RpgParser::Keyword_classContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_class(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_classContext* RpgParser::keyword_class() {
  Keyword_classContext *_localctx = _tracker.createInstance<Keyword_classContext>(_ctx, getState());
  enterRule(_localctx, 46, RpgParser::RuleKeyword_class);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1382);
    match(RpgParser::KEYWORD_CLASS);
    setState(1383);
    match(RpgParser::OPEN_PAREN);
    setState(1384);
    match(RpgParser::SPLAT_JAVA);
    setState(1385);
    match(RpgParser::COLON);
    setState(1386);
    dynamic_cast<Keyword_classContext *>(_localctx)->class_name = simpleExpression();
    setState(1387);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_constContext ------------------------------------------------------------------

RpgParser::Keyword_constContext::Keyword_constContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_constContext::KEYWORD_CONST() {
  return getToken(RpgParser::KEYWORD_CONST, 0);
}

tree::TerminalNode* RpgParser::Keyword_constContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_constContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_constContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_constContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_const;
}

void RpgParser::Keyword_constContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_const(this);
}

void RpgParser::Keyword_constContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_const(this);
}


antlrcpp::Any RpgParser::Keyword_constContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_const(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_constContext* RpgParser::keyword_const() {
  Keyword_constContext *_localctx = _tracker.createInstance<Keyword_constContext>(_ctx, getState());
  enterRule(_localctx, 48, RpgParser::RuleKeyword_const);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1389);
    match(RpgParser::KEYWORD_CONST);
    setState(1394);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1390);
      match(RpgParser::OPEN_PAREN);
      setState(1391);
      dynamic_cast<Keyword_constContext *>(_localctx)->constant = simpleExpression();
      setState(1392);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_ctdataContext ------------------------------------------------------------------

RpgParser::Keyword_ctdataContext::Keyword_ctdataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_ctdataContext::KEYWORD_CTDATA() {
  return getToken(RpgParser::KEYWORD_CTDATA, 0);
}


size_t RpgParser::Keyword_ctdataContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_ctdata;
}

void RpgParser::Keyword_ctdataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_ctdata(this);
}

void RpgParser::Keyword_ctdataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_ctdata(this);
}


antlrcpp::Any RpgParser::Keyword_ctdataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_ctdata(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_ctdataContext* RpgParser::keyword_ctdata() {
  Keyword_ctdataContext *_localctx = _tracker.createInstance<Keyword_ctdataContext>(_ctx, getState());
  enterRule(_localctx, 50, RpgParser::RuleKeyword_ctdata);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1396);
    match(RpgParser::KEYWORD_CTDATA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_datfmtContext ------------------------------------------------------------------

RpgParser::Keyword_datfmtContext::Keyword_datfmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_datfmtContext::KEYWORD_DATFMT() {
  return getToken(RpgParser::KEYWORD_DATFMT, 0);
}

tree::TerminalNode* RpgParser::Keyword_datfmtContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_datfmtContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_datfmtContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_datfmtContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

RpgParser::DateSeparatorContext* RpgParser::Keyword_datfmtContext::dateSeparator() {
  return getRuleContext<RpgParser::DateSeparatorContext>(0);
}


size_t RpgParser::Keyword_datfmtContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_datfmt;
}

void RpgParser::Keyword_datfmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_datfmt(this);
}

void RpgParser::Keyword_datfmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_datfmt(this);
}


antlrcpp::Any RpgParser::Keyword_datfmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_datfmt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_datfmtContext* RpgParser::keyword_datfmt() {
  Keyword_datfmtContext *_localctx = _tracker.createInstance<Keyword_datfmtContext>(_ctx, getState());
  enterRule(_localctx, 52, RpgParser::RuleKeyword_datfmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1398);
    match(RpgParser::KEYWORD_DATFMT);
    setState(1399);
    match(RpgParser::OPEN_PAREN);
    setState(1402);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(1400);
      simpleExpression();
      break;
    }

    case 2: {
      setState(1401);
      symbolicConstants();
      break;
    }

    }
    setState(1405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 423) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 423)) & ((1ULL << (RpgParser::AMPERSAND - 423))
      | (1ULL << (RpgParser::MINUS - 423))
      | (1ULL << (RpgParser::DIV - 423))
      | (1ULL << (RpgParser::FREE_DOT - 423)))) != 0)) {
      setState(1404);
      dateSeparator();
    }
    setState(1407);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DateSeparatorContext ------------------------------------------------------------------

RpgParser::DateSeparatorContext::DateSeparatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::DateSeparatorContext::AMPERSAND() {
  return getToken(RpgParser::AMPERSAND, 0);
}

tree::TerminalNode* RpgParser::DateSeparatorContext::MINUS() {
  return getToken(RpgParser::MINUS, 0);
}

tree::TerminalNode* RpgParser::DateSeparatorContext::DIV() {
  return getToken(RpgParser::DIV, 0);
}

tree::TerminalNode* RpgParser::DateSeparatorContext::FREE_DOT() {
  return getToken(RpgParser::FREE_DOT, 0);
}


size_t RpgParser::DateSeparatorContext::getRuleIndex() const {
  return RpgParser::RuleDateSeparator;
}

void RpgParser::DateSeparatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDateSeparator(this);
}

void RpgParser::DateSeparatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDateSeparator(this);
}


antlrcpp::Any RpgParser::DateSeparatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDateSeparator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DateSeparatorContext* RpgParser::dateSeparator() {
  DateSeparatorContext *_localctx = _tracker.createInstance<DateSeparatorContext>(_ctx, getState());
  enterRule(_localctx, 54, RpgParser::RuleDateSeparator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1409);
    _la = _input->LA(1);
    if (!(((((_la - 423) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 423)) & ((1ULL << (RpgParser::AMPERSAND - 423))
      | (1ULL << (RpgParser::MINUS - 423))
      | (1ULL << (RpgParser::DIV - 423))
      | (1ULL << (RpgParser::FREE_DOT - 423)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_descendContext ------------------------------------------------------------------

RpgParser::Keyword_descendContext::Keyword_descendContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_descendContext::KEYWORD_DESCEND() {
  return getToken(RpgParser::KEYWORD_DESCEND, 0);
}


size_t RpgParser::Keyword_descendContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_descend;
}

void RpgParser::Keyword_descendContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_descend(this);
}

void RpgParser::Keyword_descendContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_descend(this);
}


antlrcpp::Any RpgParser::Keyword_descendContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_descend(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_descendContext* RpgParser::keyword_descend() {
  Keyword_descendContext *_localctx = _tracker.createInstance<Keyword_descendContext>(_ctx, getState());
  enterRule(_localctx, 56, RpgParser::RuleKeyword_descend);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1411);
    match(RpgParser::KEYWORD_DESCEND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_dimContext ------------------------------------------------------------------

RpgParser::Keyword_dimContext::Keyword_dimContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_dimContext::KEYWORD_DIM() {
  return getToken(RpgParser::KEYWORD_DIM, 0);
}

tree::TerminalNode* RpgParser::Keyword_dimContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_dimContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_dimContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_dimContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_dim;
}

void RpgParser::Keyword_dimContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_dim(this);
}

void RpgParser::Keyword_dimContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_dim(this);
}


antlrcpp::Any RpgParser::Keyword_dimContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_dim(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_dimContext* RpgParser::keyword_dim() {
  Keyword_dimContext *_localctx = _tracker.createInstance<Keyword_dimContext>(_ctx, getState());
  enterRule(_localctx, 58, RpgParser::RuleKeyword_dim);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1413);
    match(RpgParser::KEYWORD_DIM);
    setState(1414);
    match(RpgParser::OPEN_PAREN);

    setState(1415);
    dynamic_cast<Keyword_dimContext *>(_localctx)->numeric_constant = simpleExpression();
    setState(1416);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_dtaaraContext ------------------------------------------------------------------

RpgParser::Keyword_dtaaraContext::Keyword_dtaaraContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_dtaaraContext::KEYWORD_DTAARA() {
  return getToken(RpgParser::KEYWORD_DTAARA, 0);
}

tree::TerminalNode* RpgParser::Keyword_dtaaraContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_dtaaraContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_dtaaraContext::SPLAT_VAR() {
  return getToken(RpgParser::SPLAT_VAR, 0);
}

tree::TerminalNode* RpgParser::Keyword_dtaaraContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::LiteralContext* RpgParser::Keyword_dtaaraContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_dtaaraContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_dtaaraContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_dtaara;
}

void RpgParser::Keyword_dtaaraContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_dtaara(this);
}

void RpgParser::Keyword_dtaaraContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_dtaara(this);
}


antlrcpp::Any RpgParser::Keyword_dtaaraContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_dtaara(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_dtaaraContext* RpgParser::keyword_dtaara() {
  Keyword_dtaaraContext *_localctx = _tracker.createInstance<Keyword_dtaaraContext>(_ctx, getState());
  enterRule(_localctx, 60, RpgParser::RuleKeyword_dtaara);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1418);
    match(RpgParser::KEYWORD_DTAARA);
    setState(1430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1419);
      match(RpgParser::OPEN_PAREN);
      setState(1422);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
      case 1: {
        setState(1420);
        match(RpgParser::SPLAT_VAR);
        setState(1421);
        match(RpgParser::COLON);
        break;
      }

      }
      setState(1426);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
      case 1: {
        setState(1424);
        dynamic_cast<Keyword_dtaaraContext *>(_localctx)->name = literal();
        break;
      }

      case 2: {
        setState(1425);
        dynamic_cast<Keyword_dtaaraContext *>(_localctx)->nameVariable = simpleExpression();
        break;
      }

      }
      setState(1428);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_exportContext ------------------------------------------------------------------

RpgParser::Keyword_exportContext::Keyword_exportContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_exportContext::KEYWORD_EXPORT() {
  return getToken(RpgParser::KEYWORD_EXPORT, 0);
}

tree::TerminalNode* RpgParser::Keyword_exportContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_exportContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_exportContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_exportContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_export;
}

void RpgParser::Keyword_exportContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_export(this);
}

void RpgParser::Keyword_exportContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_export(this);
}


antlrcpp::Any RpgParser::Keyword_exportContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_export(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_exportContext* RpgParser::keyword_export() {
  Keyword_exportContext *_localctx = _tracker.createInstance<Keyword_exportContext>(_ctx, getState());
  enterRule(_localctx, 62, RpgParser::RuleKeyword_export);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1432);
    match(RpgParser::KEYWORD_EXPORT);
    setState(1437);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1433);
      match(RpgParser::OPEN_PAREN);
      setState(1434);
      dynamic_cast<Keyword_exportContext *>(_localctx)->external_name = simpleExpression();
      setState(1435);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extContext ------------------------------------------------------------------

RpgParser::Keyword_extContext::Keyword_extContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extContext::KEYWORD_EXT() {
  return getToken(RpgParser::KEYWORD_EXT, 0);
}


size_t RpgParser::Keyword_extContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_ext;
}

void RpgParser::Keyword_extContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_ext(this);
}

void RpgParser::Keyword_extContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_ext(this);
}


antlrcpp::Any RpgParser::Keyword_extContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_ext(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extContext* RpgParser::keyword_ext() {
  Keyword_extContext *_localctx = _tracker.createInstance<Keyword_extContext>(_ctx, getState());
  enterRule(_localctx, 64, RpgParser::RuleKeyword_ext);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1439);
    match(RpgParser::KEYWORD_EXT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extfldContext ------------------------------------------------------------------

RpgParser::Keyword_extfldContext::Keyword_extfldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extfldContext::KEYWORD_EXTFLD() {
  return getToken(RpgParser::KEYWORD_EXTFLD, 0);
}

tree::TerminalNode* RpgParser::Keyword_extfldContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_extfldContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extfldContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_extfldContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extfld;
}

void RpgParser::Keyword_extfldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extfld(this);
}

void RpgParser::Keyword_extfldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extfld(this);
}


antlrcpp::Any RpgParser::Keyword_extfldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extfld(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extfldContext* RpgParser::keyword_extfld() {
  Keyword_extfldContext *_localctx = _tracker.createInstance<Keyword_extfldContext>(_ctx, getState());
  enterRule(_localctx, 66, RpgParser::RuleKeyword_extfld);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1441);
    match(RpgParser::KEYWORD_EXTFLD);
    setState(1442);
    match(RpgParser::OPEN_PAREN);
    setState(1443);
    dynamic_cast<Keyword_extfldContext *>(_localctx)->field_name = simpleExpression();
    setState(1444);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extfmtContext ------------------------------------------------------------------

RpgParser::Keyword_extfmtContext::Keyword_extfmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extfmtContext::KEYWORD_EXTFMT() {
  return getToken(RpgParser::KEYWORD_EXTFMT, 0);
}

tree::TerminalNode* RpgParser::Keyword_extfmtContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_extfmtContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extfmtContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_extfmtContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extfmt;
}

void RpgParser::Keyword_extfmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extfmt(this);
}

void RpgParser::Keyword_extfmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extfmt(this);
}


antlrcpp::Any RpgParser::Keyword_extfmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extfmt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extfmtContext* RpgParser::keyword_extfmt() {
  Keyword_extfmtContext *_localctx = _tracker.createInstance<Keyword_extfmtContext>(_ctx, getState());
  enterRule(_localctx, 68, RpgParser::RuleKeyword_extfmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1446);
    match(RpgParser::KEYWORD_EXTFMT);
    setState(1447);
    match(RpgParser::OPEN_PAREN);
    setState(1448);
    dynamic_cast<Keyword_extfmtContext *>(_localctx)->code = simpleExpression();
    setState(1449);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extnameContext ------------------------------------------------------------------

RpgParser::Keyword_extnameContext::Keyword_extnameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::KEYWORD_EXTNAME() {
  return getToken(RpgParser::KEYWORD_EXTNAME, 0);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_extnameContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extnameContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_extnameContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::SPLAT_ALL() {
  return getToken(RpgParser::SPLAT_ALL, 0);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::SPLAT_INPUT() {
  return getToken(RpgParser::SPLAT_INPUT, 0);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::SPLAT_OUTPUT() {
  return getToken(RpgParser::SPLAT_OUTPUT, 0);
}

tree::TerminalNode* RpgParser::Keyword_extnameContext::SPLAT_KEY() {
  return getToken(RpgParser::SPLAT_KEY, 0);
}


size_t RpgParser::Keyword_extnameContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extname;
}

void RpgParser::Keyword_extnameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extname(this);
}

void RpgParser::Keyword_extnameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extname(this);
}


antlrcpp::Any RpgParser::Keyword_extnameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extname(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extnameContext* RpgParser::keyword_extname() {
  Keyword_extnameContext *_localctx = _tracker.createInstance<Keyword_extnameContext>(_ctx, getState());
  enterRule(_localctx, 70, RpgParser::RuleKeyword_extname);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1451);
    match(RpgParser::KEYWORD_EXTNAME);
    setState(1452);
    match(RpgParser::OPEN_PAREN);
    setState(1453);
    dynamic_cast<Keyword_extnameContext *>(_localctx)->file_name = simpleExpression();
    setState(1456);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(1454);
      match(RpgParser::COLON);
      setState(1455);
      dynamic_cast<Keyword_extnameContext *>(_localctx)->format_name = simpleExpression();
      break;
    }

    }
    setState(1460);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1458);
      match(RpgParser::COLON);
      setState(1459);
      _la = _input->LA(1);
      if (!(((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1462);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extpgmContext ------------------------------------------------------------------

RpgParser::Keyword_extpgmContext::Keyword_extpgmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extpgmContext::KEYWORD_EXTPGM() {
  return getToken(RpgParser::KEYWORD_EXTPGM, 0);
}

tree::TerminalNode* RpgParser::Keyword_extpgmContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_extpgmContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extpgmContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_extpgmContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extpgm;
}

void RpgParser::Keyword_extpgmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extpgm(this);
}

void RpgParser::Keyword_extpgmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extpgm(this);
}


antlrcpp::Any RpgParser::Keyword_extpgmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extpgm(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extpgmContext* RpgParser::keyword_extpgm() {
  Keyword_extpgmContext *_localctx = _tracker.createInstance<Keyword_extpgmContext>(_ctx, getState());
  enterRule(_localctx, 72, RpgParser::RuleKeyword_extpgm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1464);
    match(RpgParser::KEYWORD_EXTPGM);
    setState(1469);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1465);
      match(RpgParser::OPEN_PAREN);
      setState(1466);
      dynamic_cast<Keyword_extpgmContext *>(_localctx)->name = simpleExpression();
      setState(1467);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extprocContext ------------------------------------------------------------------

RpgParser::Keyword_extprocContext::Keyword_extprocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extprocContext::KEYWORD_EXTPROC() {
  return getToken(RpgParser::KEYWORD_EXTPROC, 0);
}

tree::TerminalNode* RpgParser::Keyword_extprocContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_extprocContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_extprocContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extprocContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Keyword_extprocContext::SPLAT_JAVA() {
  return getToken(RpgParser::SPLAT_JAVA, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_extprocContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Keyword_extprocContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

RpgParser::IdentifierContext* RpgParser::Keyword_extprocContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Keyword_extprocContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extproc;
}

void RpgParser::Keyword_extprocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extproc(this);
}

void RpgParser::Keyword_extprocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extproc(this);
}


antlrcpp::Any RpgParser::Keyword_extprocContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extproc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extprocContext* RpgParser::keyword_extproc() {
  Keyword_extprocContext *_localctx = _tracker.createInstance<Keyword_extprocContext>(_ctx, getState());
  enterRule(_localctx, 74, RpgParser::RuleKeyword_extproc);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1471);
    match(RpgParser::KEYWORD_EXTPROC);
    setState(1472);
    match(RpgParser::OPEN_PAREN);
    setState(1481);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(1473);
      match(RpgParser::SPLAT_JAVA);
      setState(1474);
      match(RpgParser::COLON);
      setState(1475);
      dynamic_cast<Keyword_extprocContext *>(_localctx)->class_name = simpleExpression();
      setState(1476);
      match(RpgParser::COLON);
      break;
    }

    case 2: {
      setState(1478);
      identifier();
      setState(1479);
      match(RpgParser::COLON);
      break;
    }

    }
    setState(1483);
    dynamic_cast<Keyword_extprocContext *>(_localctx)->name = simpleExpression();
    setState(1484);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_fromfileContext ------------------------------------------------------------------

RpgParser::Keyword_fromfileContext::Keyword_fromfileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_fromfileContext::KEYWORD_FROMFILE() {
  return getToken(RpgParser::KEYWORD_FROMFILE, 0);
}

tree::TerminalNode* RpgParser::Keyword_fromfileContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_fromfileContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_fromfileContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_fromfileContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_fromfile;
}

void RpgParser::Keyword_fromfileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_fromfile(this);
}

void RpgParser::Keyword_fromfileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_fromfile(this);
}


antlrcpp::Any RpgParser::Keyword_fromfileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_fromfile(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_fromfileContext* RpgParser::keyword_fromfile() {
  Keyword_fromfileContext *_localctx = _tracker.createInstance<Keyword_fromfileContext>(_ctx, getState());
  enterRule(_localctx, 76, RpgParser::RuleKeyword_fromfile);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1486);
    match(RpgParser::KEYWORD_FROMFILE);
    setState(1487);
    match(RpgParser::OPEN_PAREN);
    setState(1488);
    dynamic_cast<Keyword_fromfileContext *>(_localctx)->file_name = simpleExpression();
    setState(1489);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_importContext ------------------------------------------------------------------

RpgParser::Keyword_importContext::Keyword_importContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_importContext::KEYWORD_IMPORT() {
  return getToken(RpgParser::KEYWORD_IMPORT, 0);
}

tree::TerminalNode* RpgParser::Keyword_importContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_importContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_importContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_importContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_import;
}

void RpgParser::Keyword_importContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_import(this);
}

void RpgParser::Keyword_importContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_import(this);
}


antlrcpp::Any RpgParser::Keyword_importContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_import(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_importContext* RpgParser::keyword_import() {
  Keyword_importContext *_localctx = _tracker.createInstance<Keyword_importContext>(_ctx, getState());
  enterRule(_localctx, 78, RpgParser::RuleKeyword_import);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1491);
    match(RpgParser::KEYWORD_IMPORT);
    setState(1496);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1492);
      match(RpgParser::OPEN_PAREN);
      setState(1493);
      dynamic_cast<Keyword_importContext *>(_localctx)->external_name = simpleExpression();
      setState(1494);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_inzContext ------------------------------------------------------------------

RpgParser::Keyword_inzContext::Keyword_inzContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_inzContext::KEYWORD_INZ() {
  return getToken(RpgParser::KEYWORD_INZ, 0);
}

tree::TerminalNode* RpgParser::Keyword_inzContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_inzContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_inzContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_inzContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_inz;
}

void RpgParser::Keyword_inzContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_inz(this);
}

void RpgParser::Keyword_inzContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_inz(this);
}


antlrcpp::Any RpgParser::Keyword_inzContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_inz(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_inzContext* RpgParser::keyword_inz() {
  Keyword_inzContext *_localctx = _tracker.createInstance<Keyword_inzContext>(_ctx, getState());
  enterRule(_localctx, 80, RpgParser::RuleKeyword_inz);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1498);
    match(RpgParser::KEYWORD_INZ);
    setState(1503);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1499);
      match(RpgParser::OPEN_PAREN);
      setState(1500);
      simpleExpression();
      setState(1501);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_lenContext ------------------------------------------------------------------

RpgParser::Keyword_lenContext::Keyword_lenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_lenContext::KEYWORD_LEN() {
  return getToken(RpgParser::KEYWORD_LEN, 0);
}

tree::TerminalNode* RpgParser::Keyword_lenContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_lenContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_lenContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_lenContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_len;
}

void RpgParser::Keyword_lenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_len(this);
}

void RpgParser::Keyword_lenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_len(this);
}


antlrcpp::Any RpgParser::Keyword_lenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_len(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_lenContext* RpgParser::keyword_len() {
  Keyword_lenContext *_localctx = _tracker.createInstance<Keyword_lenContext>(_ctx, getState());
  enterRule(_localctx, 82, RpgParser::RuleKeyword_len);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1505);
    match(RpgParser::KEYWORD_LEN);
    setState(1506);
    match(RpgParser::OPEN_PAREN);
    setState(1507);
    dynamic_cast<Keyword_lenContext *>(_localctx)->length = simpleExpression();
    setState(1508);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_likeContext ------------------------------------------------------------------

RpgParser::Keyword_likeContext::Keyword_likeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_likeContext::KEYWORD_LIKE() {
  return getToken(RpgParser::KEYWORD_LIKE, 0);
}

tree::TerminalNode* RpgParser::Keyword_likeContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_likeContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_likeContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_likeContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::Like_lengthAdjustmentContext* RpgParser::Keyword_likeContext::like_lengthAdjustment() {
  return getRuleContext<RpgParser::Like_lengthAdjustmentContext>(0);
}


size_t RpgParser::Keyword_likeContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_like;
}

void RpgParser::Keyword_likeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_like(this);
}

void RpgParser::Keyword_likeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_like(this);
}


antlrcpp::Any RpgParser::Keyword_likeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_like(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_likeContext* RpgParser::keyword_like() {
  Keyword_likeContext *_localctx = _tracker.createInstance<Keyword_likeContext>(_ctx, getState());
  enterRule(_localctx, 84, RpgParser::RuleKeyword_like);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1510);
    match(RpgParser::KEYWORD_LIKE);
    setState(1511);
    match(RpgParser::OPEN_PAREN);
    setState(1512);
    dynamic_cast<Keyword_likeContext *>(_localctx)->name = simpleExpression();
    setState(1515);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1513);
      match(RpgParser::COLON);
      setState(1514);
      like_lengthAdjustment();
    }
    setState(1517);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_likedsContext ------------------------------------------------------------------

RpgParser::Keyword_likedsContext::Keyword_likedsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_likedsContext::KEYWORD_LIKEDS() {
  return getToken(RpgParser::KEYWORD_LIKEDS, 0);
}

tree::TerminalNode* RpgParser::Keyword_likedsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_likedsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_likedsContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_likedsContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_likeds;
}

void RpgParser::Keyword_likedsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_likeds(this);
}

void RpgParser::Keyword_likedsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_likeds(this);
}


antlrcpp::Any RpgParser::Keyword_likedsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_likeds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_likedsContext* RpgParser::keyword_likeds() {
  Keyword_likedsContext *_localctx = _tracker.createInstance<Keyword_likedsContext>(_ctx, getState());
  enterRule(_localctx, 86, RpgParser::RuleKeyword_likeds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1519);
    match(RpgParser::KEYWORD_LIKEDS);
    setState(1520);
    match(RpgParser::OPEN_PAREN);
    setState(1521);
    dynamic_cast<Keyword_likedsContext *>(_localctx)->data_structure_name = simpleExpression();
    setState(1522);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_likefileContext ------------------------------------------------------------------

RpgParser::Keyword_likefileContext::Keyword_likefileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_likefileContext::KEYWORD_LIKEFILE() {
  return getToken(RpgParser::KEYWORD_LIKEFILE, 0);
}

tree::TerminalNode* RpgParser::Keyword_likefileContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_likefileContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_likefileContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_likefileContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_likefile;
}

void RpgParser::Keyword_likefileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_likefile(this);
}

void RpgParser::Keyword_likefileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_likefile(this);
}


antlrcpp::Any RpgParser::Keyword_likefileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_likefile(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_likefileContext* RpgParser::keyword_likefile() {
  Keyword_likefileContext *_localctx = _tracker.createInstance<Keyword_likefileContext>(_ctx, getState());
  enterRule(_localctx, 88, RpgParser::RuleKeyword_likefile);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1524);
    match(RpgParser::KEYWORD_LIKEFILE);
    setState(1525);
    match(RpgParser::OPEN_PAREN);
    setState(1526);
    dynamic_cast<Keyword_likefileContext *>(_localctx)->file_name = simpleExpression();
    setState(1527);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_likerecContext ------------------------------------------------------------------

RpgParser::Keyword_likerecContext::Keyword_likerecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::KEYWORD_LIKEREC() {
  return getToken(RpgParser::KEYWORD_LIKEREC, 0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_likerecContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::SPLAT_ALL() {
  return getToken(RpgParser::SPLAT_ALL, 0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::SPLAT_INPUT() {
  return getToken(RpgParser::SPLAT_INPUT, 0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::SPLAT_OUTPUT() {
  return getToken(RpgParser::SPLAT_OUTPUT, 0);
}

tree::TerminalNode* RpgParser::Keyword_likerecContext::SPLAT_KEY() {
  return getToken(RpgParser::SPLAT_KEY, 0);
}


size_t RpgParser::Keyword_likerecContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_likerec;
}

void RpgParser::Keyword_likerecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_likerec(this);
}

void RpgParser::Keyword_likerecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_likerec(this);
}


antlrcpp::Any RpgParser::Keyword_likerecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_likerec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_likerecContext* RpgParser::keyword_likerec() {
  Keyword_likerecContext *_localctx = _tracker.createInstance<Keyword_likerecContext>(_ctx, getState());
  enterRule(_localctx, 90, RpgParser::RuleKeyword_likerec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1529);
    match(RpgParser::KEYWORD_LIKEREC);
    setState(1530);
    match(RpgParser::OPEN_PAREN);
    setState(1531);
    dynamic_cast<Keyword_likerecContext *>(_localctx)->intrecname = simpleExpression();
    setState(1534);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1532);
      match(RpgParser::COLON);
      setState(1533);
      _la = _input->LA(1);
      if (!(((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1536);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_nooptContext ------------------------------------------------------------------

RpgParser::Keyword_nooptContext::Keyword_nooptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_nooptContext::KEYWORD_NOOPT() {
  return getToken(RpgParser::KEYWORD_NOOPT, 0);
}


size_t RpgParser::Keyword_nooptContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_noopt;
}

void RpgParser::Keyword_nooptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_noopt(this);
}

void RpgParser::Keyword_nooptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_noopt(this);
}


antlrcpp::Any RpgParser::Keyword_nooptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_noopt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_nooptContext* RpgParser::keyword_noopt() {
  Keyword_nooptContext *_localctx = _tracker.createInstance<Keyword_nooptContext>(_ctx, getState());
  enterRule(_localctx, 92, RpgParser::RuleKeyword_noopt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1538);
    match(RpgParser::KEYWORD_NOOPT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_occursContext ------------------------------------------------------------------

RpgParser::Keyword_occursContext::Keyword_occursContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_occursContext::KEYWORD_OCCURS() {
  return getToken(RpgParser::KEYWORD_OCCURS, 0);
}

tree::TerminalNode* RpgParser::Keyword_occursContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_occursContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::FunctionContext* RpgParser::Keyword_occursContext::function() {
  return getRuleContext<RpgParser::FunctionContext>(0);
}

RpgParser::IdentifierContext* RpgParser::Keyword_occursContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::NumberContext* RpgParser::Keyword_occursContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}


size_t RpgParser::Keyword_occursContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_occurs;
}

void RpgParser::Keyword_occursContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_occurs(this);
}

void RpgParser::Keyword_occursContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_occurs(this);
}


antlrcpp::Any RpgParser::Keyword_occursContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_occurs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_occursContext* RpgParser::keyword_occurs() {
  Keyword_occursContext *_localctx = _tracker.createInstance<Keyword_occursContext>(_ctx, getState());
  enterRule(_localctx, 94, RpgParser::RuleKeyword_occurs);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1540);
    match(RpgParser::KEYWORD_OCCURS);
    setState(1541);
    match(RpgParser::OPEN_PAREN);
    setState(1545);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(1542);
      dynamic_cast<Keyword_occursContext *>(_localctx)->numeric_constant = number();
      break;
    }

    case 2: {
      setState(1543);
      function();
      break;
    }

    case 3: {
      setState(1544);
      identifier();
      break;
    }

    }
    setState(1547);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_opdescContext ------------------------------------------------------------------

RpgParser::Keyword_opdescContext::Keyword_opdescContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_opdescContext::KEYWORD_OPDESC() {
  return getToken(RpgParser::KEYWORD_OPDESC, 0);
}


size_t RpgParser::Keyword_opdescContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_opdesc;
}

void RpgParser::Keyword_opdescContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_opdesc(this);
}

void RpgParser::Keyword_opdescContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_opdesc(this);
}


antlrcpp::Any RpgParser::Keyword_opdescContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_opdesc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_opdescContext* RpgParser::keyword_opdesc() {
  Keyword_opdescContext *_localctx = _tracker.createInstance<Keyword_opdescContext>(_ctx, getState());
  enterRule(_localctx, 96, RpgParser::RuleKeyword_opdesc);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1549);
    match(RpgParser::KEYWORD_OPDESC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_optionsContext ------------------------------------------------------------------

RpgParser::Keyword_optionsContext::Keyword_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_optionsContext::KEYWORD_OPTIONS() {
  return getToken(RpgParser::KEYWORD_OPTIONS, 0);
}

tree::TerminalNode* RpgParser::Keyword_optionsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Keyword_optionsContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Keyword_optionsContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

tree::TerminalNode* RpgParser::Keyword_optionsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_optionsContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Keyword_optionsContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Keyword_optionsContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_options;
}

void RpgParser::Keyword_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_options(this);
}

void RpgParser::Keyword_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_options(this);
}


antlrcpp::Any RpgParser::Keyword_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_options(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_optionsContext* RpgParser::keyword_options() {
  Keyword_optionsContext *_localctx = _tracker.createInstance<Keyword_optionsContext>(_ctx, getState());
  enterRule(_localctx, 98, RpgParser::RuleKeyword_options);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1551);
    match(RpgParser::KEYWORD_OPTIONS);
    setState(1552);
    match(RpgParser::OPEN_PAREN);
    setState(1553);
    identifier();
    setState(1558);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(1554);
      match(RpgParser::COLON);
      setState(1555);
      identifier();
      setState(1560);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1561);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_overlayContext ------------------------------------------------------------------

RpgParser::Keyword_overlayContext::Keyword_overlayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_overlayContext::KEYWORD_OVERLAY() {
  return getToken(RpgParser::KEYWORD_OVERLAY, 0);
}

tree::TerminalNode* RpgParser::Keyword_overlayContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_overlayContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_overlayContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_overlayContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Keyword_overlayContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Keyword_overlayContext::SPLAT_NEXT() {
  return getToken(RpgParser::SPLAT_NEXT, 0);
}


size_t RpgParser::Keyword_overlayContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_overlay;
}

void RpgParser::Keyword_overlayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_overlay(this);
}

void RpgParser::Keyword_overlayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_overlay(this);
}


antlrcpp::Any RpgParser::Keyword_overlayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_overlay(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_overlayContext* RpgParser::keyword_overlay() {
  Keyword_overlayContext *_localctx = _tracker.createInstance<Keyword_overlayContext>(_ctx, getState());
  enterRule(_localctx, 100, RpgParser::RuleKeyword_overlay);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1563);
    match(RpgParser::KEYWORD_OVERLAY);
    setState(1564);
    match(RpgParser::OPEN_PAREN);
    setState(1565);
    dynamic_cast<Keyword_overlayContext *>(_localctx)->name = simpleExpression();
    setState(1571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1566);
      match(RpgParser::COLON);
      setState(1569);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
      case 1: {
        setState(1567);
        match(RpgParser::SPLAT_NEXT);
        break;
      }

      case 2: {
        setState(1568);
        dynamic_cast<Keyword_overlayContext *>(_localctx)->pos = simpleExpression();
        break;
      }

      }
    }
    setState(1573);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_packevenContext ------------------------------------------------------------------

RpgParser::Keyword_packevenContext::Keyword_packevenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_packevenContext::KEYWORD_PACKEVEN() {
  return getToken(RpgParser::KEYWORD_PACKEVEN, 0);
}


size_t RpgParser::Keyword_packevenContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_packeven;
}

void RpgParser::Keyword_packevenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_packeven(this);
}

void RpgParser::Keyword_packevenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_packeven(this);
}


antlrcpp::Any RpgParser::Keyword_packevenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_packeven(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_packevenContext* RpgParser::keyword_packeven() {
  Keyword_packevenContext *_localctx = _tracker.createInstance<Keyword_packevenContext>(_ctx, getState());
  enterRule(_localctx, 102, RpgParser::RuleKeyword_packeven);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1575);
    match(RpgParser::KEYWORD_PACKEVEN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_perrcdContext ------------------------------------------------------------------

RpgParser::Keyword_perrcdContext::Keyword_perrcdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_perrcdContext::KEYWORD_PERRCD() {
  return getToken(RpgParser::KEYWORD_PERRCD, 0);
}

tree::TerminalNode* RpgParser::Keyword_perrcdContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_perrcdContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_perrcdContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_perrcdContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_perrcd;
}

void RpgParser::Keyword_perrcdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_perrcd(this);
}

void RpgParser::Keyword_perrcdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_perrcd(this);
}


antlrcpp::Any RpgParser::Keyword_perrcdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_perrcd(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_perrcdContext* RpgParser::keyword_perrcd() {
  Keyword_perrcdContext *_localctx = _tracker.createInstance<Keyword_perrcdContext>(_ctx, getState());
  enterRule(_localctx, 104, RpgParser::RuleKeyword_perrcd);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1577);
    match(RpgParser::KEYWORD_PERRCD);
    setState(1578);
    match(RpgParser::OPEN_PAREN);
    setState(1579);
    dynamic_cast<Keyword_perrcdContext *>(_localctx)->numeric_constant = simpleExpression();
    setState(1580);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_prefixContext ------------------------------------------------------------------

RpgParser::Keyword_prefixContext::Keyword_prefixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_prefixContext::KEYWORD_PREFIX() {
  return getToken(RpgParser::KEYWORD_PREFIX, 0);
}

tree::TerminalNode* RpgParser::Keyword_prefixContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_prefixContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_prefixContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_prefixContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Keyword_prefixContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Keyword_prefixContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_prefix;
}

void RpgParser::Keyword_prefixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_prefix(this);
}

void RpgParser::Keyword_prefixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_prefix(this);
}


antlrcpp::Any RpgParser::Keyword_prefixContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_prefix(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_prefixContext* RpgParser::keyword_prefix() {
  Keyword_prefixContext *_localctx = _tracker.createInstance<Keyword_prefixContext>(_ctx, getState());
  enterRule(_localctx, 106, RpgParser::RuleKeyword_prefix);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1582);
    match(RpgParser::KEYWORD_PREFIX);
    setState(1583);
    match(RpgParser::OPEN_PAREN);
    setState(1584);
    dynamic_cast<Keyword_prefixContext *>(_localctx)->prefix = simpleExpression();
    setState(1587);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1585);
      match(RpgParser::COLON);
      setState(1586);
      dynamic_cast<Keyword_prefixContext *>(_localctx)->nbr_of_char_replaced = simpleExpression();
    }
    setState(1589);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_posContext ------------------------------------------------------------------

RpgParser::Keyword_posContext::Keyword_posContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_posContext::KEYWORD_POS() {
  return getToken(RpgParser::KEYWORD_POS, 0);
}

tree::TerminalNode* RpgParser::Keyword_posContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_posContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_posContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_posContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_pos;
}

void RpgParser::Keyword_posContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_pos(this);
}

void RpgParser::Keyword_posContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_pos(this);
}


antlrcpp::Any RpgParser::Keyword_posContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_pos(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_posContext* RpgParser::keyword_pos() {
  Keyword_posContext *_localctx = _tracker.createInstance<Keyword_posContext>(_ctx, getState());
  enterRule(_localctx, 108, RpgParser::RuleKeyword_pos);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1591);
    match(RpgParser::KEYWORD_POS);
    setState(1592);
    match(RpgParser::OPEN_PAREN);
    setState(1593);
    dynamic_cast<Keyword_posContext *>(_localctx)->numeric_constant = simpleExpression();
    setState(1594);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_procptrContext ------------------------------------------------------------------

RpgParser::Keyword_procptrContext::Keyword_procptrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_procptrContext::KEYWORD_PROCPTR() {
  return getToken(RpgParser::KEYWORD_PROCPTR, 0);
}


size_t RpgParser::Keyword_procptrContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_procptr;
}

void RpgParser::Keyword_procptrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_procptr(this);
}

void RpgParser::Keyword_procptrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_procptr(this);
}


antlrcpp::Any RpgParser::Keyword_procptrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_procptr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_procptrContext* RpgParser::keyword_procptr() {
  Keyword_procptrContext *_localctx = _tracker.createInstance<Keyword_procptrContext>(_ctx, getState());
  enterRule(_localctx, 110, RpgParser::RuleKeyword_procptr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1596);
    match(RpgParser::KEYWORD_PROCPTR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_qualifiedContext ------------------------------------------------------------------

RpgParser::Keyword_qualifiedContext::Keyword_qualifiedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_qualifiedContext::KEYWORD_QUALIFIED() {
  return getToken(RpgParser::KEYWORD_QUALIFIED, 0);
}


size_t RpgParser::Keyword_qualifiedContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_qualified;
}

void RpgParser::Keyword_qualifiedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_qualified(this);
}

void RpgParser::Keyword_qualifiedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_qualified(this);
}


antlrcpp::Any RpgParser::Keyword_qualifiedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_qualified(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_qualifiedContext* RpgParser::keyword_qualified() {
  Keyword_qualifiedContext *_localctx = _tracker.createInstance<Keyword_qualifiedContext>(_ctx, getState());
  enterRule(_localctx, 112, RpgParser::RuleKeyword_qualified);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1598);
    match(RpgParser::KEYWORD_QUALIFIED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_rtnparmContext ------------------------------------------------------------------

RpgParser::Keyword_rtnparmContext::Keyword_rtnparmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_rtnparmContext::KEYWORD_RTNPARM() {
  return getToken(RpgParser::KEYWORD_RTNPARM, 0);
}


size_t RpgParser::Keyword_rtnparmContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_rtnparm;
}

void RpgParser::Keyword_rtnparmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_rtnparm(this);
}

void RpgParser::Keyword_rtnparmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_rtnparm(this);
}


antlrcpp::Any RpgParser::Keyword_rtnparmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_rtnparm(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_rtnparmContext* RpgParser::keyword_rtnparm() {
  Keyword_rtnparmContext *_localctx = _tracker.createInstance<Keyword_rtnparmContext>(_ctx, getState());
  enterRule(_localctx, 114, RpgParser::RuleKeyword_rtnparm);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1600);
    match(RpgParser::KEYWORD_RTNPARM);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_staticContext ------------------------------------------------------------------

RpgParser::Keyword_staticContext::Keyword_staticContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_staticContext::KEYWORD_STATIC() {
  return getToken(RpgParser::KEYWORD_STATIC, 0);
}

tree::TerminalNode* RpgParser::Keyword_staticContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_staticContext::SPLAT_ALLTHREAD() {
  return getToken(RpgParser::SPLAT_ALLTHREAD, 0);
}

tree::TerminalNode* RpgParser::Keyword_staticContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_staticContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_static;
}

void RpgParser::Keyword_staticContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_static(this);
}

void RpgParser::Keyword_staticContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_static(this);
}


antlrcpp::Any RpgParser::Keyword_staticContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_static(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_staticContext* RpgParser::keyword_static() {
  Keyword_staticContext *_localctx = _tracker.createInstance<Keyword_staticContext>(_ctx, getState());
  enterRule(_localctx, 116, RpgParser::RuleKeyword_static);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1602);
    match(RpgParser::KEYWORD_STATIC);
    setState(1606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1603);
      match(RpgParser::OPEN_PAREN);
      setState(1604);
      match(RpgParser::SPLAT_ALLTHREAD);
      setState(1605);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_sqltypeContext ------------------------------------------------------------------

RpgParser::Keyword_sqltypeContext::Keyword_sqltypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_sqltypeContext::KEYWORD_SQLTYPE() {
  return getToken(RpgParser::KEYWORD_SQLTYPE, 0);
}

tree::TerminalNode* RpgParser::Keyword_sqltypeContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_sqltypeContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_sqltypeContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_sqltypeContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_sqltypeContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}


size_t RpgParser::Keyword_sqltypeContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_sqltype;
}

void RpgParser::Keyword_sqltypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_sqltype(this);
}

void RpgParser::Keyword_sqltypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_sqltype(this);
}


antlrcpp::Any RpgParser::Keyword_sqltypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_sqltype(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_sqltypeContext* RpgParser::keyword_sqltype() {
  Keyword_sqltypeContext *_localctx = _tracker.createInstance<Keyword_sqltypeContext>(_ctx, getState());
  enterRule(_localctx, 118, RpgParser::RuleKeyword_sqltype);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1608);
    match(RpgParser::KEYWORD_SQLTYPE);
    setState(1617);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1609);
      match(RpgParser::OPEN_PAREN);
      setState(1610);
      dynamic_cast<Keyword_sqltypeContext *>(_localctx)->id = simpleExpression();
      setState(1613);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::COLON) {
        setState(1611);
        match(RpgParser::COLON);
        setState(1612);
        number();
      }
      setState(1615);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_templateContext ------------------------------------------------------------------

RpgParser::Keyword_templateContext::Keyword_templateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_templateContext::KEYWORD_TEMPLATE() {
  return getToken(RpgParser::KEYWORD_TEMPLATE, 0);
}


size_t RpgParser::Keyword_templateContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_template;
}

void RpgParser::Keyword_templateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_template(this);
}

void RpgParser::Keyword_templateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_template(this);
}


antlrcpp::Any RpgParser::Keyword_templateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_template(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_templateContext* RpgParser::keyword_template() {
  Keyword_templateContext *_localctx = _tracker.createInstance<Keyword_templateContext>(_ctx, getState());
  enterRule(_localctx, 120, RpgParser::RuleKeyword_template);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1619);
    match(RpgParser::KEYWORD_TEMPLATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_timfmtContext ------------------------------------------------------------------

RpgParser::Keyword_timfmtContext::Keyword_timfmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_timfmtContext::KEYWORD_TIMFMT() {
  return getToken(RpgParser::KEYWORD_TIMFMT, 0);
}

tree::TerminalNode* RpgParser::Keyword_timfmtContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_timfmtContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_timfmtContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_timfmtContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Keyword_timfmtContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_timfmt;
}

void RpgParser::Keyword_timfmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_timfmt(this);
}

void RpgParser::Keyword_timfmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_timfmt(this);
}


antlrcpp::Any RpgParser::Keyword_timfmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_timfmt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_timfmtContext* RpgParser::keyword_timfmt() {
  Keyword_timfmtContext *_localctx = _tracker.createInstance<Keyword_timfmtContext>(_ctx, getState());
  enterRule(_localctx, 122, RpgParser::RuleKeyword_timfmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1621);
    match(RpgParser::KEYWORD_TIMFMT);
    setState(1622);
    match(RpgParser::OPEN_PAREN);
    setState(1623);
    dynamic_cast<Keyword_timfmtContext *>(_localctx)->format = simpleExpression();
    setState(1625);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1624);
      match(RpgParser::COLON);
    }
    setState(1627);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_tofileContext ------------------------------------------------------------------

RpgParser::Keyword_tofileContext::Keyword_tofileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_tofileContext::KEYWORD_TOFILE() {
  return getToken(RpgParser::KEYWORD_TOFILE, 0);
}

tree::TerminalNode* RpgParser::Keyword_tofileContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_tofileContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_tofileContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_tofileContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}


size_t RpgParser::Keyword_tofileContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_tofile;
}

void RpgParser::Keyword_tofileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_tofile(this);
}

void RpgParser::Keyword_tofileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_tofile(this);
}


antlrcpp::Any RpgParser::Keyword_tofileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_tofile(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_tofileContext* RpgParser::keyword_tofile() {
  Keyword_tofileContext *_localctx = _tracker.createInstance<Keyword_tofileContext>(_ctx, getState());
  enterRule(_localctx, 124, RpgParser::RuleKeyword_tofile);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1629);
    match(RpgParser::KEYWORD_TOFILE);
    setState(1630);
    match(RpgParser::OPEN_PAREN);
    setState(1631);
    dynamic_cast<Keyword_tofileContext *>(_localctx)->file_name = simpleExpression();
    setState(1633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(1632);
      dynamic_cast<Keyword_tofileContext *>(_localctx)->separator = simpleExpression();
    }
    setState(1635);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_valueContext ------------------------------------------------------------------

RpgParser::Keyword_valueContext::Keyword_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_valueContext::KEYWORD_VALUE() {
  return getToken(RpgParser::KEYWORD_VALUE, 0);
}


size_t RpgParser::Keyword_valueContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_value;
}

void RpgParser::Keyword_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_value(this);
}

void RpgParser::Keyword_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_value(this);
}


antlrcpp::Any RpgParser::Keyword_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_value(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_valueContext* RpgParser::keyword_value() {
  Keyword_valueContext *_localctx = _tracker.createInstance<Keyword_valueContext>(_ctx, getState());
  enterRule(_localctx, 126, RpgParser::RuleKeyword_value);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1637);
    match(RpgParser::KEYWORD_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_varyingContext ------------------------------------------------------------------

RpgParser::Keyword_varyingContext::Keyword_varyingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_varyingContext::KEYWORD_VARYING() {
  return getToken(RpgParser::KEYWORD_VARYING, 0);
}

tree::TerminalNode* RpgParser::Keyword_varyingContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_varyingContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_varyingContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_varyingContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_varying;
}

void RpgParser::Keyword_varyingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_varying(this);
}

void RpgParser::Keyword_varyingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_varying(this);
}


antlrcpp::Any RpgParser::Keyword_varyingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_varying(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_varyingContext* RpgParser::keyword_varying() {
  Keyword_varyingContext *_localctx = _tracker.createInstance<Keyword_varyingContext>(_ctx, getState());
  enterRule(_localctx, 128, RpgParser::RuleKeyword_varying);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1639);
    match(RpgParser::KEYWORD_VARYING);
    setState(1644);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1640);
      match(RpgParser::OPEN_PAREN);
      setState(1641);
      dynamic_cast<Keyword_varyingContext *>(_localctx)->size = simpleExpression();
      setState(1642);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_psdsContext ------------------------------------------------------------------

RpgParser::Keyword_psdsContext::Keyword_psdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_psdsContext::KEYWORD_PSDS() {
  return getToken(RpgParser::KEYWORD_PSDS, 0);
}


size_t RpgParser::Keyword_psdsContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_psds;
}

void RpgParser::Keyword_psdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_psds(this);
}

void RpgParser::Keyword_psdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_psds(this);
}


antlrcpp::Any RpgParser::Keyword_psdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_psds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_psdsContext* RpgParser::keyword_psds() {
  Keyword_psdsContext *_localctx = _tracker.createInstance<Keyword_psdsContext>(_ctx, getState());
  enterRule(_localctx, 130, RpgParser::RuleKeyword_psds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1646);
    match(RpgParser::KEYWORD_PSDS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_blockContext ------------------------------------------------------------------

RpgParser::Keyword_blockContext::Keyword_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_blockContext::KEYWORD_BLOCK() {
  return getToken(RpgParser::KEYWORD_BLOCK, 0);
}

tree::TerminalNode* RpgParser::Keyword_blockContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_blockContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_blockContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_blockContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_block;
}

void RpgParser::Keyword_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_block(this);
}

void RpgParser::Keyword_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_block(this);
}


antlrcpp::Any RpgParser::Keyword_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_block(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_blockContext* RpgParser::keyword_block() {
  Keyword_blockContext *_localctx = _tracker.createInstance<Keyword_blockContext>(_ctx, getState());
  enterRule(_localctx, 132, RpgParser::RuleKeyword_block);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1648);
    match(RpgParser::KEYWORD_BLOCK);
    setState(1649);
    match(RpgParser::OPEN_PAREN);
    setState(1650);
    symbolicConstants();
    setState(1651);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_commitContext ------------------------------------------------------------------

RpgParser::Keyword_commitContext::Keyword_commitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_commitContext::KEYWORD_COMMIT() {
  return getToken(RpgParser::KEYWORD_COMMIT, 0);
}

tree::TerminalNode* RpgParser::Keyword_commitContext::OP_COMMIT() {
  return getToken(RpgParser::OP_COMMIT, 0);
}

tree::TerminalNode* RpgParser::Keyword_commitContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_commitContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_commitContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_commitContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_commit;
}

void RpgParser::Keyword_commitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_commit(this);
}

void RpgParser::Keyword_commitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_commit(this);
}


antlrcpp::Any RpgParser::Keyword_commitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_commit(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_commitContext* RpgParser::keyword_commit() {
  Keyword_commitContext *_localctx = _tracker.createInstance<Keyword_commitContext>(_ctx, getState());
  enterRule(_localctx, 134, RpgParser::RuleKeyword_commit);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1653);
    _la = _input->LA(1);
    if (!(_la == RpgParser::OP_COMMIT || _la == RpgParser::KEYWORD_COMMIT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1654);
      match(RpgParser::OPEN_PAREN);
      setState(1655);
      simpleExpression();
      setState(1656);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_devidContext ------------------------------------------------------------------

RpgParser::Keyword_devidContext::Keyword_devidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_devidContext::KEYWORD_DEVID() {
  return getToken(RpgParser::KEYWORD_DEVID, 0);
}

tree::TerminalNode* RpgParser::Keyword_devidContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_devidContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_devidContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_devidContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_devid;
}

void RpgParser::Keyword_devidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_devid(this);
}

void RpgParser::Keyword_devidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_devid(this);
}


antlrcpp::Any RpgParser::Keyword_devidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_devid(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_devidContext* RpgParser::keyword_devid() {
  Keyword_devidContext *_localctx = _tracker.createInstance<Keyword_devidContext>(_ctx, getState());
  enterRule(_localctx, 136, RpgParser::RuleKeyword_devid);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1660);
    match(RpgParser::KEYWORD_DEVID);

    setState(1661);
    match(RpgParser::OPEN_PAREN);
    setState(1662);
    simpleExpression();
    setState(1663);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extdescContext ------------------------------------------------------------------

RpgParser::Keyword_extdescContext::Keyword_extdescContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extdescContext::KEYWORD_EXTDESC() {
  return getToken(RpgParser::KEYWORD_EXTDESC, 0);
}

tree::TerminalNode* RpgParser::Keyword_extdescContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extdescContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_extdescContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_extdescContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extdesc;
}

void RpgParser::Keyword_extdescContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extdesc(this);
}

void RpgParser::Keyword_extdescContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extdesc(this);
}


antlrcpp::Any RpgParser::Keyword_extdescContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extdesc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extdescContext* RpgParser::keyword_extdesc() {
  Keyword_extdescContext *_localctx = _tracker.createInstance<Keyword_extdescContext>(_ctx, getState());
  enterRule(_localctx, 138, RpgParser::RuleKeyword_extdesc);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1665);
    match(RpgParser::KEYWORD_EXTDESC);

    setState(1666);
    match(RpgParser::OPEN_PAREN);
    setState(1667);
    simpleExpression();
    setState(1668);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extfileContext ------------------------------------------------------------------

RpgParser::Keyword_extfileContext::Keyword_extfileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extfileContext::KEYWORD_EXTFILE() {
  return getToken(RpgParser::KEYWORD_EXTFILE, 0);
}

tree::TerminalNode* RpgParser::Keyword_extfileContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_extfileContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extfileContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_extfileContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}


size_t RpgParser::Keyword_extfileContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extfile;
}

void RpgParser::Keyword_extfileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extfile(this);
}

void RpgParser::Keyword_extfileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extfile(this);
}


antlrcpp::Any RpgParser::Keyword_extfileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extfile(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extfileContext* RpgParser::keyword_extfile() {
  Keyword_extfileContext *_localctx = _tracker.createInstance<Keyword_extfileContext>(_ctx, getState());
  enterRule(_localctx, 140, RpgParser::RuleKeyword_extfile);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1670);
    match(RpgParser::KEYWORD_EXTFILE);

    setState(1671);
    match(RpgParser::OPEN_PAREN);
    setState(1674);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(1672);
      simpleExpression();
      break;
    }

    case 2: {
      setState(1673);
      symbolicConstants();
      break;
    }

    }
    setState(1676);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extindContext ------------------------------------------------------------------

RpgParser::Keyword_extindContext::Keyword_extindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extindContext::KEYWORD_EXTIND() {
  return getToken(RpgParser::KEYWORD_EXTIND, 0);
}

tree::TerminalNode* RpgParser::Keyword_extindContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extindContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_extindContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_extindContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extind;
}

void RpgParser::Keyword_extindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extind(this);
}

void RpgParser::Keyword_extindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extind(this);
}


antlrcpp::Any RpgParser::Keyword_extindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extind(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extindContext* RpgParser::keyword_extind() {
  Keyword_extindContext *_localctx = _tracker.createInstance<Keyword_extindContext>(_ctx, getState());
  enterRule(_localctx, 142, RpgParser::RuleKeyword_extind);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1678);
    match(RpgParser::KEYWORD_EXTIND);
    setState(1679);
    match(RpgParser::OPEN_PAREN);
    setState(1680);
    simpleExpression();
    setState(1681);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_extmbrContext ------------------------------------------------------------------

RpgParser::Keyword_extmbrContext::Keyword_extmbrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_extmbrContext::KEYWORD_EXTMBR() {
  return getToken(RpgParser::KEYWORD_EXTMBR, 0);
}

tree::TerminalNode* RpgParser::Keyword_extmbrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_extmbrContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_extmbrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_extmbrContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_extmbr;
}

void RpgParser::Keyword_extmbrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_extmbr(this);
}

void RpgParser::Keyword_extmbrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_extmbr(this);
}


antlrcpp::Any RpgParser::Keyword_extmbrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_extmbr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_extmbrContext* RpgParser::keyword_extmbr() {
  Keyword_extmbrContext *_localctx = _tracker.createInstance<Keyword_extmbrContext>(_ctx, getState());
  enterRule(_localctx, 144, RpgParser::RuleKeyword_extmbr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1683);
    match(RpgParser::KEYWORD_EXTMBR);
    setState(1684);
    match(RpgParser::OPEN_PAREN);
    setState(1685);
    simpleExpression();
    setState(1686);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_formlenContext ------------------------------------------------------------------

RpgParser::Keyword_formlenContext::Keyword_formlenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_formlenContext::KEYWORD_FORMLEN() {
  return getToken(RpgParser::KEYWORD_FORMLEN, 0);
}

tree::TerminalNode* RpgParser::Keyword_formlenContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_formlenContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_formlenContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_formlenContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_formlen;
}

void RpgParser::Keyword_formlenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_formlen(this);
}

void RpgParser::Keyword_formlenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_formlen(this);
}


antlrcpp::Any RpgParser::Keyword_formlenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_formlen(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_formlenContext* RpgParser::keyword_formlen() {
  Keyword_formlenContext *_localctx = _tracker.createInstance<Keyword_formlenContext>(_ctx, getState());
  enterRule(_localctx, 146, RpgParser::RuleKeyword_formlen);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1688);
    match(RpgParser::KEYWORD_FORMLEN);
    setState(1689);
    match(RpgParser::OPEN_PAREN);
    setState(1690);
    number();
    setState(1691);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_formoflContext ------------------------------------------------------------------

RpgParser::Keyword_formoflContext::Keyword_formoflContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_formoflContext::KEYWORD_FORMOFL() {
  return getToken(RpgParser::KEYWORD_FORMOFL, 0);
}

tree::TerminalNode* RpgParser::Keyword_formoflContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_formoflContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_formoflContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_formoflContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_formofl;
}

void RpgParser::Keyword_formoflContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_formofl(this);
}

void RpgParser::Keyword_formoflContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_formofl(this);
}


antlrcpp::Any RpgParser::Keyword_formoflContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_formofl(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_formoflContext* RpgParser::keyword_formofl() {
  Keyword_formoflContext *_localctx = _tracker.createInstance<Keyword_formoflContext>(_ctx, getState());
  enterRule(_localctx, 148, RpgParser::RuleKeyword_formofl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1693);
    match(RpgParser::KEYWORD_FORMOFL);
    setState(1694);
    match(RpgParser::OPEN_PAREN);
    setState(1695);
    number();
    setState(1696);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_ignoreContext ------------------------------------------------------------------

RpgParser::Keyword_ignoreContext::Keyword_ignoreContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_ignoreContext::KEYWORD_IGNORE() {
  return getToken(RpgParser::KEYWORD_IGNORE, 0);
}

tree::TerminalNode* RpgParser::Keyword_ignoreContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_ignoreContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_ignoreContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Keyword_ignoreContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_ignoreContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Keyword_ignoreContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Keyword_ignoreContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_ignore;
}

void RpgParser::Keyword_ignoreContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_ignore(this);
}

void RpgParser::Keyword_ignoreContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_ignore(this);
}


antlrcpp::Any RpgParser::Keyword_ignoreContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_ignore(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_ignoreContext* RpgParser::keyword_ignore() {
  Keyword_ignoreContext *_localctx = _tracker.createInstance<Keyword_ignoreContext>(_ctx, getState());
  enterRule(_localctx, 150, RpgParser::RuleKeyword_ignore);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1698);
    match(RpgParser::KEYWORD_IGNORE);
    setState(1699);
    match(RpgParser::OPEN_PAREN);
    setState(1700);
    simpleExpression();
    setState(1705);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(1701);
      match(RpgParser::COLON);
      setState(1702);
      simpleExpression();
      setState(1707);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1708);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_includeContext ------------------------------------------------------------------

RpgParser::Keyword_includeContext::Keyword_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_includeContext::KEYWORD_INCLUDE() {
  return getToken(RpgParser::KEYWORD_INCLUDE, 0);
}

tree::TerminalNode* RpgParser::Keyword_includeContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_includeContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_includeContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Keyword_includeContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_includeContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Keyword_includeContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Keyword_includeContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_include;
}

void RpgParser::Keyword_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_include(this);
}

void RpgParser::Keyword_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_include(this);
}


antlrcpp::Any RpgParser::Keyword_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_include(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_includeContext* RpgParser::keyword_include() {
  Keyword_includeContext *_localctx = _tracker.createInstance<Keyword_includeContext>(_ctx, getState());
  enterRule(_localctx, 152, RpgParser::RuleKeyword_include);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1710);
    match(RpgParser::KEYWORD_INCLUDE);
    setState(1711);
    match(RpgParser::OPEN_PAREN);
    setState(1712);
    simpleExpression();
    setState(1717);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(1713);
      match(RpgParser::COLON);
      setState(1714);
      simpleExpression();
      setState(1719);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1720);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_inddsContext ------------------------------------------------------------------

RpgParser::Keyword_inddsContext::Keyword_inddsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_inddsContext::KEYWORD_INDDS() {
  return getToken(RpgParser::KEYWORD_INDDS, 0);
}

tree::TerminalNode* RpgParser::Keyword_inddsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_inddsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_inddsContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_inddsContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_indds;
}

void RpgParser::Keyword_inddsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_indds(this);
}

void RpgParser::Keyword_inddsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_indds(this);
}


antlrcpp::Any RpgParser::Keyword_inddsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_indds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_inddsContext* RpgParser::keyword_indds() {
  Keyword_inddsContext *_localctx = _tracker.createInstance<Keyword_inddsContext>(_ctx, getState());
  enterRule(_localctx, 154, RpgParser::RuleKeyword_indds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1722);
    match(RpgParser::KEYWORD_INDDS);
    setState(1723);
    match(RpgParser::OPEN_PAREN);
    setState(1724);
    dynamic_cast<Keyword_inddsContext *>(_localctx)->data_structure_name = simpleExpression();
    setState(1725);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_infdsContext ------------------------------------------------------------------

RpgParser::Keyword_infdsContext::Keyword_infdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_infdsContext::KEYWORD_INFDS() {
  return getToken(RpgParser::KEYWORD_INFDS, 0);
}

tree::TerminalNode* RpgParser::Keyword_infdsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_infdsContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_infdsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_infdsContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_infds;
}

void RpgParser::Keyword_infdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_infds(this);
}

void RpgParser::Keyword_infdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_infds(this);
}


antlrcpp::Any RpgParser::Keyword_infdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_infds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_infdsContext* RpgParser::keyword_infds() {
  Keyword_infdsContext *_localctx = _tracker.createInstance<Keyword_infdsContext>(_ctx, getState());
  enterRule(_localctx, 156, RpgParser::RuleKeyword_infds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1727);
    match(RpgParser::KEYWORD_INFDS);
    setState(1728);
    match(RpgParser::OPEN_PAREN);
    setState(1729);
    simpleExpression();
    setState(1730);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_infsrContext ------------------------------------------------------------------

RpgParser::Keyword_infsrContext::Keyword_infsrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_infsrContext::KEYWORD_INFSR() {
  return getToken(RpgParser::KEYWORD_INFSR, 0);
}

tree::TerminalNode* RpgParser::Keyword_infsrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_infsrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_infsrContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_infsrContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_infsr;
}

void RpgParser::Keyword_infsrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_infsr(this);
}

void RpgParser::Keyword_infsrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_infsr(this);
}


antlrcpp::Any RpgParser::Keyword_infsrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_infsr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_infsrContext* RpgParser::keyword_infsr() {
  Keyword_infsrContext *_localctx = _tracker.createInstance<Keyword_infsrContext>(_ctx, getState());
  enterRule(_localctx, 158, RpgParser::RuleKeyword_infsr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1732);
    match(RpgParser::KEYWORD_INFSR);
    setState(1733);
    match(RpgParser::OPEN_PAREN);
    setState(1734);
    dynamic_cast<Keyword_infsrContext *>(_localctx)->subr_name = simpleExpression();
    setState(1735);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_keylocContext ------------------------------------------------------------------

RpgParser::Keyword_keylocContext::Keyword_keylocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_keylocContext::KEYWORD_KEYLOC() {
  return getToken(RpgParser::KEYWORD_KEYLOC, 0);
}

tree::TerminalNode* RpgParser::Keyword_keylocContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_keylocContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_keylocContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_keylocContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_keyloc;
}

void RpgParser::Keyword_keylocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_keyloc(this);
}

void RpgParser::Keyword_keylocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_keyloc(this);
}


antlrcpp::Any RpgParser::Keyword_keylocContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_keyloc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_keylocContext* RpgParser::keyword_keyloc() {
  Keyword_keylocContext *_localctx = _tracker.createInstance<Keyword_keylocContext>(_ctx, getState());
  enterRule(_localctx, 160, RpgParser::RuleKeyword_keyloc);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1737);
    match(RpgParser::KEYWORD_KEYLOC);
    setState(1738);
    match(RpgParser::OPEN_PAREN);
    setState(1739);
    number();
    setState(1740);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_maxdevContext ------------------------------------------------------------------

RpgParser::Keyword_maxdevContext::Keyword_maxdevContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_maxdevContext::KEYWORD_MAXDEV() {
  return getToken(RpgParser::KEYWORD_MAXDEV, 0);
}

tree::TerminalNode* RpgParser::Keyword_maxdevContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_maxdevContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_maxdevContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_maxdevContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_maxdev;
}

void RpgParser::Keyword_maxdevContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_maxdev(this);
}

void RpgParser::Keyword_maxdevContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_maxdev(this);
}


antlrcpp::Any RpgParser::Keyword_maxdevContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_maxdev(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_maxdevContext* RpgParser::keyword_maxdev() {
  Keyword_maxdevContext *_localctx = _tracker.createInstance<Keyword_maxdevContext>(_ctx, getState());
  enterRule(_localctx, 162, RpgParser::RuleKeyword_maxdev);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1742);
    match(RpgParser::KEYWORD_MAXDEV);
    setState(1743);
    match(RpgParser::OPEN_PAREN);
    setState(1744);
    symbolicConstants();
    setState(1745);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_oflindContext ------------------------------------------------------------------

RpgParser::Keyword_oflindContext::Keyword_oflindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_oflindContext::KEYWORD_OFLIND() {
  return getToken(RpgParser::KEYWORD_OFLIND, 0);
}

tree::TerminalNode* RpgParser::Keyword_oflindContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_oflindContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_oflindContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_oflindContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_oflind;
}

void RpgParser::Keyword_oflindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_oflind(this);
}

void RpgParser::Keyword_oflindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_oflind(this);
}


antlrcpp::Any RpgParser::Keyword_oflindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_oflind(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_oflindContext* RpgParser::keyword_oflind() {
  Keyword_oflindContext *_localctx = _tracker.createInstance<Keyword_oflindContext>(_ctx, getState());
  enterRule(_localctx, 164, RpgParser::RuleKeyword_oflind);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1747);
    match(RpgParser::KEYWORD_OFLIND);
    setState(1748);
    match(RpgParser::OPEN_PAREN);
    setState(1749);
    simpleExpression();
    setState(1750);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_passContext ------------------------------------------------------------------

RpgParser::Keyword_passContext::Keyword_passContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_passContext::KEYWORD_PASS() {
  return getToken(RpgParser::KEYWORD_PASS, 0);
}

tree::TerminalNode* RpgParser::Keyword_passContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_passContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_passContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_passContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_pass;
}

void RpgParser::Keyword_passContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_pass(this);
}

void RpgParser::Keyword_passContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_pass(this);
}


antlrcpp::Any RpgParser::Keyword_passContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_pass(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_passContext* RpgParser::keyword_pass() {
  Keyword_passContext *_localctx = _tracker.createInstance<Keyword_passContext>(_ctx, getState());
  enterRule(_localctx, 166, RpgParser::RuleKeyword_pass);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1752);
    match(RpgParser::KEYWORD_PASS);
    setState(1753);
    match(RpgParser::OPEN_PAREN);
    setState(1754);
    symbolicConstants();
    setState(1755);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_pgmnameContext ------------------------------------------------------------------

RpgParser::Keyword_pgmnameContext::Keyword_pgmnameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_pgmnameContext::KEYWORD_PGMNAME() {
  return getToken(RpgParser::KEYWORD_PGMNAME, 0);
}

tree::TerminalNode* RpgParser::Keyword_pgmnameContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_pgmnameContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_pgmnameContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_pgmnameContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_pgmname;
}

void RpgParser::Keyword_pgmnameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_pgmname(this);
}

void RpgParser::Keyword_pgmnameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_pgmname(this);
}


antlrcpp::Any RpgParser::Keyword_pgmnameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_pgmname(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_pgmnameContext* RpgParser::keyword_pgmname() {
  Keyword_pgmnameContext *_localctx = _tracker.createInstance<Keyword_pgmnameContext>(_ctx, getState());
  enterRule(_localctx, 168, RpgParser::RuleKeyword_pgmname);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1757);
    match(RpgParser::KEYWORD_PGMNAME);
    setState(1758);
    match(RpgParser::OPEN_PAREN);
    setState(1759);
    dynamic_cast<Keyword_pgmnameContext *>(_localctx)->program_name = simpleExpression();
    setState(1760);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_plistContext ------------------------------------------------------------------

RpgParser::Keyword_plistContext::Keyword_plistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_plistContext::KEYWORD_PLIST() {
  return getToken(RpgParser::KEYWORD_PLIST, 0);
}

tree::TerminalNode* RpgParser::Keyword_plistContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_plistContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_plistContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_plistContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_plist;
}

void RpgParser::Keyword_plistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_plist(this);
}

void RpgParser::Keyword_plistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_plist(this);
}


antlrcpp::Any RpgParser::Keyword_plistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_plist(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_plistContext* RpgParser::keyword_plist() {
  Keyword_plistContext *_localctx = _tracker.createInstance<Keyword_plistContext>(_ctx, getState());
  enterRule(_localctx, 170, RpgParser::RuleKeyword_plist);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1762);
    match(RpgParser::KEYWORD_PLIST);
    setState(1763);
    match(RpgParser::OPEN_PAREN);
    setState(1764);
    dynamic_cast<Keyword_plistContext *>(_localctx)->plist_name = simpleExpression();
    setState(1765);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_prtctlContext ------------------------------------------------------------------

RpgParser::Keyword_prtctlContext::Keyword_prtctlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_prtctlContext::KEYWORD_PRTCTL() {
  return getToken(RpgParser::KEYWORD_PRTCTL, 0);
}

tree::TerminalNode* RpgParser::Keyword_prtctlContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_prtctlContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_prtctlContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_prtctlContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_prtctlContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}


size_t RpgParser::Keyword_prtctlContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_prtctl;
}

void RpgParser::Keyword_prtctlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_prtctl(this);
}

void RpgParser::Keyword_prtctlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_prtctl(this);
}


antlrcpp::Any RpgParser::Keyword_prtctlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_prtctl(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_prtctlContext* RpgParser::keyword_prtctl() {
  Keyword_prtctlContext *_localctx = _tracker.createInstance<Keyword_prtctlContext>(_ctx, getState());
  enterRule(_localctx, 172, RpgParser::RuleKeyword_prtctl);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1767);
    match(RpgParser::KEYWORD_PRTCTL);
    setState(1768);
    match(RpgParser::OPEN_PAREN);
    setState(1769);
    dynamic_cast<Keyword_prtctlContext *>(_localctx)->data_struct = simpleExpression();
    setState(1772);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(1770);
      match(RpgParser::COLON);
      setState(1771);
      symbolicConstants();
    }
    setState(1774);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_rafdataContext ------------------------------------------------------------------

RpgParser::Keyword_rafdataContext::Keyword_rafdataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_rafdataContext::KEYWORD_RAFDATA() {
  return getToken(RpgParser::KEYWORD_RAFDATA, 0);
}

tree::TerminalNode* RpgParser::Keyword_rafdataContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_rafdataContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_rafdataContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_rafdataContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_rafdata;
}

void RpgParser::Keyword_rafdataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_rafdata(this);
}

void RpgParser::Keyword_rafdataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_rafdata(this);
}


antlrcpp::Any RpgParser::Keyword_rafdataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_rafdata(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_rafdataContext* RpgParser::keyword_rafdata() {
  Keyword_rafdataContext *_localctx = _tracker.createInstance<Keyword_rafdataContext>(_ctx, getState());
  enterRule(_localctx, 174, RpgParser::RuleKeyword_rafdata);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1776);
    match(RpgParser::KEYWORD_RAFDATA);
    setState(1777);
    match(RpgParser::OPEN_PAREN);
    setState(1778);
    dynamic_cast<Keyword_rafdataContext *>(_localctx)->file_name = simpleExpression();
    setState(1779);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_recnoContext ------------------------------------------------------------------

RpgParser::Keyword_recnoContext::Keyword_recnoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_recnoContext::KEYWORD_RECNO() {
  return getToken(RpgParser::KEYWORD_RECNO, 0);
}

tree::TerminalNode* RpgParser::Keyword_recnoContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_recnoContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_recnoContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}


size_t RpgParser::Keyword_recnoContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_recno;
}

void RpgParser::Keyword_recnoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_recno(this);
}

void RpgParser::Keyword_recnoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_recno(this);
}


antlrcpp::Any RpgParser::Keyword_recnoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_recno(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_recnoContext* RpgParser::keyword_recno() {
  Keyword_recnoContext *_localctx = _tracker.createInstance<Keyword_recnoContext>(_ctx, getState());
  enterRule(_localctx, 176, RpgParser::RuleKeyword_recno);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1781);
    match(RpgParser::KEYWORD_RECNO);
    setState(1782);
    match(RpgParser::OPEN_PAREN);
    setState(1783);
    dynamic_cast<Keyword_recnoContext *>(_localctx)->field_name = simpleExpression();
    setState(1784);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_renameContext ------------------------------------------------------------------

RpgParser::Keyword_renameContext::Keyword_renameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_renameContext::KEYWORD_RENAME() {
  return getToken(RpgParser::KEYWORD_RENAME, 0);
}

tree::TerminalNode* RpgParser::Keyword_renameContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_renameContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Keyword_renameContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_renameContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_renameContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}


size_t RpgParser::Keyword_renameContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_rename;
}

void RpgParser::Keyword_renameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_rename(this);
}

void RpgParser::Keyword_renameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_rename(this);
}


antlrcpp::Any RpgParser::Keyword_renameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_rename(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_renameContext* RpgParser::keyword_rename() {
  Keyword_renameContext *_localctx = _tracker.createInstance<Keyword_renameContext>(_ctx, getState());
  enterRule(_localctx, 178, RpgParser::RuleKeyword_rename);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1786);
    match(RpgParser::KEYWORD_RENAME);
    setState(1787);
    match(RpgParser::OPEN_PAREN);
    setState(1788);
    dynamic_cast<Keyword_renameContext *>(_localctx)->ext_format = simpleExpression();
    setState(1789);
    match(RpgParser::COLON);
    setState(1790);
    dynamic_cast<Keyword_renameContext *>(_localctx)->int_format = simpleExpression();
    setState(1791);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_savedsContext ------------------------------------------------------------------

RpgParser::Keyword_savedsContext::Keyword_savedsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_savedsContext::KEYWORD_SAVEDS() {
  return getToken(RpgParser::KEYWORD_SAVEDS, 0);
}

tree::TerminalNode* RpgParser::Keyword_savedsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_savedsContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_savedsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_savedsContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_saveds;
}

void RpgParser::Keyword_savedsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_saveds(this);
}

void RpgParser::Keyword_savedsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_saveds(this);
}


antlrcpp::Any RpgParser::Keyword_savedsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_saveds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_savedsContext* RpgParser::keyword_saveds() {
  Keyword_savedsContext *_localctx = _tracker.createInstance<Keyword_savedsContext>(_ctx, getState());
  enterRule(_localctx, 180, RpgParser::RuleKeyword_saveds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1793);
    match(RpgParser::KEYWORD_SAVEDS);
    setState(1794);
    match(RpgParser::OPEN_PAREN);
    setState(1795);
    simpleExpression();
    setState(1796);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_saveindContext ------------------------------------------------------------------

RpgParser::Keyword_saveindContext::Keyword_saveindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_saveindContext::KEYWORD_SAVEIND() {
  return getToken(RpgParser::KEYWORD_SAVEIND, 0);
}

tree::TerminalNode* RpgParser::Keyword_saveindContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_saveindContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_saveindContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_saveindContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_saveind;
}

void RpgParser::Keyword_saveindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_saveind(this);
}

void RpgParser::Keyword_saveindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_saveind(this);
}


antlrcpp::Any RpgParser::Keyword_saveindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_saveind(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_saveindContext* RpgParser::keyword_saveind() {
  Keyword_saveindContext *_localctx = _tracker.createInstance<Keyword_saveindContext>(_ctx, getState());
  enterRule(_localctx, 182, RpgParser::RuleKeyword_saveind);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1798);
    match(RpgParser::KEYWORD_SAVEIND);
    setState(1799);
    match(RpgParser::OPEN_PAREN);
    setState(1800);
    number();
    setState(1801);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_sfileContext ------------------------------------------------------------------

RpgParser::Keyword_sfileContext::Keyword_sfileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_sfileContext::KEYWORD_SFILE() {
  return getToken(RpgParser::KEYWORD_SFILE, 0);
}

tree::TerminalNode* RpgParser::Keyword_sfileContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_sfileContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Keyword_sfileContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SimpleExpressionContext *> RpgParser::Keyword_sfileContext::simpleExpression() {
  return getRuleContexts<RpgParser::SimpleExpressionContext>();
}

RpgParser::SimpleExpressionContext* RpgParser::Keyword_sfileContext::simpleExpression(size_t i) {
  return getRuleContext<RpgParser::SimpleExpressionContext>(i);
}


size_t RpgParser::Keyword_sfileContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_sfile;
}

void RpgParser::Keyword_sfileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_sfile(this);
}

void RpgParser::Keyword_sfileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_sfile(this);
}


antlrcpp::Any RpgParser::Keyword_sfileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_sfile(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_sfileContext* RpgParser::keyword_sfile() {
  Keyword_sfileContext *_localctx = _tracker.createInstance<Keyword_sfileContext>(_ctx, getState());
  enterRule(_localctx, 184, RpgParser::RuleKeyword_sfile);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1803);
    match(RpgParser::KEYWORD_SFILE);
    setState(1804);
    match(RpgParser::OPEN_PAREN);
    setState(1805);
    dynamic_cast<Keyword_sfileContext *>(_localctx)->recformat = simpleExpression();
    setState(1806);
    match(RpgParser::COLON);
    setState(1807);
    dynamic_cast<Keyword_sfileContext *>(_localctx)->rrnfield = simpleExpression();
    setState(1808);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_slnContext ------------------------------------------------------------------

RpgParser::Keyword_slnContext::Keyword_slnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_slnContext::KEYWORD_SLN() {
  return getToken(RpgParser::KEYWORD_SLN, 0);
}

tree::TerminalNode* RpgParser::Keyword_slnContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::NumberContext* RpgParser::Keyword_slnContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_slnContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_slnContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_sln;
}

void RpgParser::Keyword_slnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_sln(this);
}

void RpgParser::Keyword_slnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_sln(this);
}


antlrcpp::Any RpgParser::Keyword_slnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_sln(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_slnContext* RpgParser::keyword_sln() {
  Keyword_slnContext *_localctx = _tracker.createInstance<Keyword_slnContext>(_ctx, getState());
  enterRule(_localctx, 186, RpgParser::RuleKeyword_sln);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1810);
    match(RpgParser::KEYWORD_SLN);
    setState(1811);
    match(RpgParser::OPEN_PAREN);
    setState(1812);
    number();
    setState(1813);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_usropnContext ------------------------------------------------------------------

RpgParser::Keyword_usropnContext::Keyword_usropnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_usropnContext::KEYWORD_USROPN() {
  return getToken(RpgParser::KEYWORD_USROPN, 0);
}


size_t RpgParser::Keyword_usropnContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_usropn;
}

void RpgParser::Keyword_usropnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_usropn(this);
}

void RpgParser::Keyword_usropnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_usropn(this);
}


antlrcpp::Any RpgParser::Keyword_usropnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_usropn(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_usropnContext* RpgParser::keyword_usropn() {
  Keyword_usropnContext *_localctx = _tracker.createInstance<Keyword_usropnContext>(_ctx, getState());
  enterRule(_localctx, 188, RpgParser::RuleKeyword_usropn);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1815);
    match(RpgParser::KEYWORD_USROPN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_diskContext ------------------------------------------------------------------

RpgParser::Keyword_diskContext::Keyword_diskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_diskContext::KEYWORD_DISK() {
  return getToken(RpgParser::KEYWORD_DISK, 0);
}

tree::TerminalNode* RpgParser::Keyword_diskContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_diskContext::SPLAT_EXT() {
  return getToken(RpgParser::SPLAT_EXT, 0);
}

tree::TerminalNode* RpgParser::Keyword_diskContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_diskContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_disk;
}

void RpgParser::Keyword_diskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_disk(this);
}

void RpgParser::Keyword_diskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_disk(this);
}


antlrcpp::Any RpgParser::Keyword_diskContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_disk(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_diskContext* RpgParser::keyword_disk() {
  Keyword_diskContext *_localctx = _tracker.createInstance<Keyword_diskContext>(_ctx, getState());
  enterRule(_localctx, 190, RpgParser::RuleKeyword_disk);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1817);
    match(RpgParser::KEYWORD_DISK);
    setState(1821);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(1818);
      match(RpgParser::OPEN_PAREN);
      setState(1819);
      match(RpgParser::SPLAT_EXT);
      setState(1820);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_workstnContext ------------------------------------------------------------------

RpgParser::Keyword_workstnContext::Keyword_workstnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_workstnContext::KEYWORD_WORKSTN() {
  return getToken(RpgParser::KEYWORD_WORKSTN, 0);
}


size_t RpgParser::Keyword_workstnContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_workstn;
}

void RpgParser::Keyword_workstnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_workstn(this);
}

void RpgParser::Keyword_workstnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_workstn(this);
}


antlrcpp::Any RpgParser::Keyword_workstnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_workstn(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_workstnContext* RpgParser::keyword_workstn() {
  Keyword_workstnContext *_localctx = _tracker.createInstance<Keyword_workstnContext>(_ctx, getState());
  enterRule(_localctx, 192, RpgParser::RuleKeyword_workstn);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1823);
    match(RpgParser::KEYWORD_WORKSTN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_printerContext ------------------------------------------------------------------

RpgParser::Keyword_printerContext::Keyword_printerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_printerContext::KEYWORD_PRINTER() {
  return getToken(RpgParser::KEYWORD_PRINTER, 0);
}

tree::TerminalNode* RpgParser::Keyword_printerContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_printerContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

tree::TerminalNode* RpgParser::Keyword_printerContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Keyword_printerContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_printer;
}

void RpgParser::Keyword_printerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_printer(this);
}

void RpgParser::Keyword_printerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_printer(this);
}


antlrcpp::Any RpgParser::Keyword_printerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_printer(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_printerContext* RpgParser::keyword_printer() {
  Keyword_printerContext *_localctx = _tracker.createInstance<Keyword_printerContext>(_ctx, getState());
  enterRule(_localctx, 194, RpgParser::RuleKeyword_printer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1825);
    match(RpgParser::KEYWORD_PRINTER);
    setState(1826);
    match(RpgParser::OPEN_PAREN);
    setState(1827);
    symbolicConstants();
    setState(1828);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_specialContext ------------------------------------------------------------------

RpgParser::Keyword_specialContext::Keyword_specialContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_specialContext::KEYWORD_SPECIAL() {
  return getToken(RpgParser::KEYWORD_SPECIAL, 0);
}


size_t RpgParser::Keyword_specialContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_special;
}

void RpgParser::Keyword_specialContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_special(this);
}

void RpgParser::Keyword_specialContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_special(this);
}


antlrcpp::Any RpgParser::Keyword_specialContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_special(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_specialContext* RpgParser::keyword_special() {
  Keyword_specialContext *_localctx = _tracker.createInstance<Keyword_specialContext>(_ctx, getState());
  enterRule(_localctx, 196, RpgParser::RuleKeyword_special);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1830);
    match(RpgParser::KEYWORD_SPECIAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_keyedContext ------------------------------------------------------------------

RpgParser::Keyword_keyedContext::Keyword_keyedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_keyedContext::KEYWORD_KEYED() {
  return getToken(RpgParser::KEYWORD_KEYED, 0);
}


size_t RpgParser::Keyword_keyedContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_keyed;
}

void RpgParser::Keyword_keyedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_keyed(this);
}

void RpgParser::Keyword_keyedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_keyed(this);
}


antlrcpp::Any RpgParser::Keyword_keyedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_keyed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_keyedContext* RpgParser::keyword_keyed() {
  Keyword_keyedContext *_localctx = _tracker.createInstance<Keyword_keyedContext>(_ctx, getState());
  enterRule(_localctx, 198, RpgParser::RuleKeyword_keyed);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1832);
    match(RpgParser::KEYWORD_KEYED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_usageContext ------------------------------------------------------------------

RpgParser::Keyword_usageContext::Keyword_usageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Keyword_usageContext::KEYWORD_USAGE() {
  return getToken(RpgParser::KEYWORD_USAGE, 0);
}

tree::TerminalNode* RpgParser::Keyword_usageContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Keyword_usageContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::SymbolicConstantsContext *> RpgParser::Keyword_usageContext::symbolicConstants() {
  return getRuleContexts<RpgParser::SymbolicConstantsContext>();
}

RpgParser::SymbolicConstantsContext* RpgParser::Keyword_usageContext::symbolicConstants(size_t i) {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_usageContext::ID() {
  return getTokens(RpgParser::ID);
}

tree::TerminalNode* RpgParser::Keyword_usageContext::ID(size_t i) {
  return getToken(RpgParser::ID, i);
}

std::vector<tree::TerminalNode *> RpgParser::Keyword_usageContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Keyword_usageContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Keyword_usageContext::getRuleIndex() const {
  return RpgParser::RuleKeyword_usage;
}

void RpgParser::Keyword_usageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_usage(this);
}

void RpgParser::Keyword_usageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_usage(this);
}


antlrcpp::Any RpgParser::Keyword_usageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_usage(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Keyword_usageContext* RpgParser::keyword_usage() {
  Keyword_usageContext *_localctx = _tracker.createInstance<Keyword_usageContext>(_ctx, getState());
  enterRule(_localctx, 200, RpgParser::RuleKeyword_usage);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1834);
    match(RpgParser::KEYWORD_USAGE);
    setState(1835);
    match(RpgParser::OPEN_PAREN);
    setState(1838);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS: {
        setState(1836);
        symbolicConstants();
        break;
      }

      case RpgParser::ID: {
        setState(1837);
        match(RpgParser::ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1847);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(1840);
      match(RpgParser::COLON);
      setState(1843);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case RpgParser::SPLAT_ALL:
        case RpgParser::SPLAT_NONE:
        case RpgParser::SPLAT_YES:
        case RpgParser::SPLAT_NO:
        case RpgParser::SPLAT_ILERPG:
        case RpgParser::SPLAT_COMPAT:
        case RpgParser::SPLAT_CRTBNDRPG:
        case RpgParser::SPLAT_CRTRPGMOD:
        case RpgParser::SPLAT_VRM:
        case RpgParser::SPLAT_ALLG:
        case RpgParser::SPLAT_ALLU:
        case RpgParser::SPLAT_ALLTHREAD:
        case RpgParser::SPLAT_ALLX:
        case RpgParser::SPLAT_BLANKS:
        case RpgParser::SPLAT_CANCL:
        case RpgParser::SPLAT_CYMD:
        case RpgParser::SPLAT_CMDY:
        case RpgParser::SPLAT_CDMY:
        case RpgParser::SPLAT_MDY:
        case RpgParser::SPLAT_DMY:
        case RpgParser::SPLAT_DFT:
        case RpgParser::SPLAT_YMD:
        case RpgParser::SPLAT_JUL:
        case RpgParser::SPLAT_JAVA:
        case RpgParser::SPLAT_ISO:
        case RpgParser::SPLAT_USA:
        case RpgParser::SPLAT_EUR:
        case RpgParser::SPLAT_JIS:
        case RpgParser::SPLAT_DATE:
        case RpgParser::SPLAT_DAY:
        case RpgParser::SPlAT_DETC:
        case RpgParser::SPLAT_DETL:
        case RpgParser::SPLAT_DTAARA:
        case RpgParser::SPLAT_END:
        case RpgParser::SPLAT_ENTRY:
        case RpgParser::SPLAT_EQUATE:
        case RpgParser::SPLAT_EXTDFT:
        case RpgParser::SPLAT_EXT:
        case RpgParser::SPLAT_FILE:
        case RpgParser::SPLAT_GETIN:
        case RpgParser::SPLAT_HIVAL:
        case RpgParser::SPLAT_INIT:
        case RpgParser::SPLAT_INDICATOR:
        case RpgParser::SPLAT_INZSR:
        case RpgParser::SPLAT_IN:
        case RpgParser::SPLAT_INPUT:
        case RpgParser::SPLAT_OUTPUT:
        case RpgParser::SPLAT_JOBRUN:
        case RpgParser::SPLAT_JOB:
        case RpgParser::SPLAT_LDA:
        case RpgParser::SPLAT_LIKE:
        case RpgParser::SPLAT_LONGJUL:
        case RpgParser::SPLAT_LOVAL:
        case RpgParser::SPLAT_KEY:
        case RpgParser::SPLAT_MONTH:
        case RpgParser::SPLAT_NEXT:
        case RpgParser::SPLAT_NOIND:
        case RpgParser::SPLAT_NOKEY:
        case RpgParser::SPLAT_NULL:
        case RpgParser::SPLAT_OFL:
        case RpgParser::SPLAT_ON:
        case RpgParser::SPLAT_ONLY:
        case RpgParser::SPLAT_OFF:
        case RpgParser::SPLAT_PDA:
        case RpgParser::SPLAT_PLACE:
        case RpgParser::SPLAT_PSSR:
        case RpgParser::SPLAT_ROUTINE:
        case RpgParser::SPLAT_START:
        case RpgParser::SPLAT_SYS:
        case RpgParser::SPLAT_TERM:
        case RpgParser::SPLAT_TOTC:
        case RpgParser::SPLAT_TOTL:
        case RpgParser::SPLAT_USER:
        case RpgParser::SPLAT_VAR:
        case RpgParser::SPLAT_YEAR:
        case RpgParser::SPLAT_ZEROS:
        case RpgParser::SPLAT_HMS:
        case RpgParser::SPLAT_INLR:
        case RpgParser::SPLAT_INOF:
        case RpgParser::SPLAT_DATA:
        case RpgParser::SPLAT_ASTFILL:
        case RpgParser::SPLAT_CURSYM:
        case RpgParser::SPLAT_MAX:
        case RpgParser::SPLAT_LOCK:
        case RpgParser::SPLAT_PROGRAM:
        case RpgParser::SPLAT_EXTDESC:
        case RpgParser::SPLAT_D:
        case RpgParser::SPLAT_H:
        case RpgParser::SPLAT_HOURS:
        case RpgParser::SPLAT_DAYS:
        case RpgParser::SPLAT_M:
        case RpgParser::SPLAT_MINUTES:
        case RpgParser::SPLAT_MONTHS:
        case RpgParser::SPLAT_MN:
        case RpgParser::SPLAT_MS:
        case RpgParser::SPLAT_MSECONDS:
        case RpgParser::SPLAT_S:
        case RpgParser::SPLAT_SECONDS:
        case RpgParser::SPLAT_Y:
        case RpgParser::SPLAT_YEARS: {
          setState(1841);
          symbolicConstants();
          break;
        }

        case RpgParser::ID: {
          setState(1842);
          match(RpgParser::ID);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1849);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1850);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Like_lengthAdjustmentContext ------------------------------------------------------------------

RpgParser::Like_lengthAdjustmentContext::Like_lengthAdjustmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SignContext* RpgParser::Like_lengthAdjustmentContext::sign() {
  return getRuleContext<RpgParser::SignContext>(0);
}

RpgParser::NumberContext* RpgParser::Like_lengthAdjustmentContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}


size_t RpgParser::Like_lengthAdjustmentContext::getRuleIndex() const {
  return RpgParser::RuleLike_lengthAdjustment;
}

void RpgParser::Like_lengthAdjustmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLike_lengthAdjustment(this);
}

void RpgParser::Like_lengthAdjustmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLike_lengthAdjustment(this);
}


antlrcpp::Any RpgParser::Like_lengthAdjustmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitLike_lengthAdjustment(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Like_lengthAdjustmentContext* RpgParser::like_lengthAdjustment() {
  Like_lengthAdjustmentContext *_localctx = _tracker.createInstance<Like_lengthAdjustmentContext>(_ctx, getState());
  enterRule(_localctx, 202, RpgParser::RuleLike_lengthAdjustment);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1852);
    sign();
    setState(1853);
    number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignContext ------------------------------------------------------------------

RpgParser::SignContext::SignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::SignContext::PLUS() {
  return getToken(RpgParser::PLUS, 0);
}

tree::TerminalNode* RpgParser::SignContext::MINUS() {
  return getToken(RpgParser::MINUS, 0);
}


size_t RpgParser::SignContext::getRuleIndex() const {
  return RpgParser::RuleSign;
}

void RpgParser::SignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSign(this);
}

void RpgParser::SignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSign(this);
}


antlrcpp::Any RpgParser::SignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSign(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::SignContext* RpgParser::sign() {
  SignContext *_localctx = _tracker.createInstance<SignContext>(_ctx, getState());
  enterRule(_localctx, 204, RpgParser::RuleSign);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1855);
    _la = _input->LA(1);
    if (!(_la == RpgParser::PLUS

    || _la == RpgParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_dsContext ------------------------------------------------------------------

RpgParser::Dcl_dsContext::Dcl_dsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dcl_dsContext::DS_DataStructureStart() {
  return getToken(RpgParser::DS_DataStructureStart, 0);
}

RpgParser::IdentifierContext* RpgParser::Dcl_dsContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

std::vector<tree::TerminalNode *> RpgParser::Dcl_dsContext::FREE_SEMI() {
  return getTokens(RpgParser::FREE_SEMI);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::FREE_SEMI(size_t i) {
  return getToken(RpgParser::FREE_SEMI, i);
}

RpgParser::Keyword_likerecContext* RpgParser::Dcl_dsContext::keyword_likerec() {
  return getRuleContext<RpgParser::Keyword_likerecContext>(0);
}

RpgParser::Keyword_likedsContext* RpgParser::Dcl_dsContext::keyword_likeds() {
  return getRuleContext<RpgParser::Keyword_likedsContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dcl_dsContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dcl_dsContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}

RpgParser::End_dcl_dsContext* RpgParser::Dcl_dsContext::end_dcl_ds() {
  return getRuleContext<RpgParser::End_dcl_dsContext>(0);
}

std::vector<RpgParser::Star_commentsContext *> RpgParser::Dcl_dsContext::star_comments() {
  return getRuleContexts<RpgParser::Star_commentsContext>();
}

RpgParser::Star_commentsContext* RpgParser::Dcl_dsContext::star_comments(size_t i) {
  return getRuleContext<RpgParser::Star_commentsContext>(i);
}

std::vector<RpgParser::DirectiveContext *> RpgParser::Dcl_dsContext::directive() {
  return getRuleContexts<RpgParser::DirectiveContext>();
}

RpgParser::DirectiveContext* RpgParser::Dcl_dsContext::directive(size_t i) {
  return getRuleContext<RpgParser::DirectiveContext>(i);
}

std::vector<RpgParser::Dcl_ds_fieldContext *> RpgParser::Dcl_dsContext::dcl_ds_field() {
  return getRuleContexts<RpgParser::Dcl_ds_fieldContext>();
}

RpgParser::Dcl_ds_fieldContext* RpgParser::Dcl_dsContext::dcl_ds_field(size_t i) {
  return getRuleContext<RpgParser::Dcl_ds_fieldContext>(i);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::Dcl_dsContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::DEF_TYPE_DS() {
  return getToken(RpgParser::DEF_TYPE_DS, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Dcl_dsContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::Parm_fixedContext *> RpgParser::Dcl_dsContext::parm_fixed() {
  return getRuleContexts<RpgParser::Parm_fixedContext>();
}

RpgParser::Parm_fixedContext* RpgParser::Dcl_dsContext::parm_fixed(size_t i) {
  return getRuleContext<RpgParser::Parm_fixedContext>(i);
}


size_t RpgParser::Dcl_dsContext::getRuleIndex() const {
  return RpgParser::RuleDcl_ds;
}

void RpgParser::Dcl_dsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_ds(this);
}

void RpgParser::Dcl_dsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_ds(this);
}


antlrcpp::Any RpgParser::Dcl_dsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_ds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_dsContext* RpgParser::dcl_ds() {
  Dcl_dsContext *_localctx = _tracker.createInstance<Dcl_dsContext>(_ctx, getState());
  enterRule(_localctx, 206, RpgParser::RuleDcl_ds);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(1911);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::DS_DataStructureStart: {
        enterOuterAlt(_localctx, 1);
        setState(1857);
        match(RpgParser::DS_DataStructureStart);
        setState(1858);
        identifier();
        setState(1862);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1859);
            keyword(); 
          }
          setState(1864);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
        }
        setState(1879);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::DS_DataStructureEnd:
          case RpgParser::FREE_SEMI: {
            setState(1874);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == RpgParser::FREE_SEMI) {
              setState(1865);
              match(RpgParser::FREE_SEMI);
              setState(1871);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while ((((_la & ~ 0x3fULL) == 0) &&
                ((1ULL << _la) & ((1ULL << RpgParser::COMMENT_SPEC_FIXED)
                | (1ULL << RpgParser::DIRECTIVE)
                | (1ULL << RpgParser::ID)
                | (1ULL << RpgParser::OP_ACQ)
                | (1ULL << RpgParser::OP_BEGSR)
                | (1ULL << RpgParser::OP_CALLP)
                | (1ULL << RpgParser::OP_CHAIN)
                | (1ULL << RpgParser::OP_CLEAR)
                | (1ULL << RpgParser::OP_CLOSE)
                | (1ULL << RpgParser::OP_COMMIT)
                | (1ULL << RpgParser::OP_DEALLOC)
                | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
                | (1ULL << (RpgParser::OP_DUMP - 64))
                | (1ULL << (RpgParser::OP_ENDSR - 64))
                | (1ULL << (RpgParser::OP_EVAL - 64))
                | (1ULL << (RpgParser::OP_EVALR - 64))
                | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
                | (1ULL << (RpgParser::OP_EXCEPT - 64))
                | (1ULL << (RpgParser::OP_EXFMT - 64))
                | (1ULL << (RpgParser::OP_EXSR - 64))
                | (1ULL << (RpgParser::OP_FEOD - 64))
                | (1ULL << (RpgParser::OP_FORCE - 64))
                | (1ULL << (RpgParser::OP_IN - 64))
                | (1ULL << (RpgParser::OP_ITER - 64))
                | (1ULL << (RpgParser::OP_LEAVE - 64))
                | (1ULL << (RpgParser::OP_LEAVESR - 64))
                | (1ULL << (RpgParser::OP_NEXT - 64))
                | (1ULL << (RpgParser::OP_OPEN - 64))
                | (1ULL << (RpgParser::OP_OTHER - 64))
                | (1ULL << (RpgParser::OP_OUT - 64))
                | (1ULL << (RpgParser::OP_POST - 64))
                | (1ULL << (RpgParser::OP_READ - 64))
                | (1ULL << (RpgParser::OP_READC - 64))
                | (1ULL << (RpgParser::OP_READE - 64))
                | (1ULL << (RpgParser::OP_READP - 64))
                | (1ULL << (RpgParser::OP_READPE - 64))
                | (1ULL << (RpgParser::OP_REL - 64))
                | (1ULL << (RpgParser::OP_RESET - 64))
                | (1ULL << (RpgParser::OP_RETURN - 64))
                | (1ULL << (RpgParser::OP_ROLBK - 64))
                | (1ULL << (RpgParser::OP_SELECT - 64))
                | (1ULL << (RpgParser::OP_SETGT - 64))
                | (1ULL << (RpgParser::OP_SETLL - 64))
                | (1ULL << (RpgParser::OP_SORTA - 64))
                | (1ULL << (RpgParser::OP_TEST - 64))
                | (1ULL << (RpgParser::OP_UNLOCK - 64))
                | (1ULL << (RpgParser::OP_UPDATE - 64))
                | (1ULL << (RpgParser::OP_WHEN - 64))
                | (1ULL << (RpgParser::OP_WRITE - 64))
                | (1ULL << (RpgParser::OP_XML_INTO - 64))
                | (1ULL << (RpgParser::OP_XML_SAX - 64))
                | (1ULL << (RpgParser::DS_SubField - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
                | (1ULL << (RpgParser::SPLAT_NONE - 212))
                | (1ULL << (RpgParser::SPLAT_YES - 212))
                | (1ULL << (RpgParser::SPLAT_NO - 212))
                | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
                | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
                | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
                | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
                | (1ULL << (RpgParser::SPLAT_VRM - 212))
                | (1ULL << (RpgParser::SPLAT_ALLG - 212))
                | (1ULL << (RpgParser::SPLAT_ALLU - 212))
                | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
                | (1ULL << (RpgParser::SPLAT_ALLX - 212))
                | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
                | (1ULL << (RpgParser::SPLAT_CANCL - 212))
                | (1ULL << (RpgParser::SPLAT_CYMD - 212))
                | (1ULL << (RpgParser::SPLAT_CMDY - 212))
                | (1ULL << (RpgParser::SPLAT_CDMY - 212))
                | (1ULL << (RpgParser::SPLAT_MDY - 212))
                | (1ULL << (RpgParser::SPLAT_DMY - 212))
                | (1ULL << (RpgParser::SPLAT_DFT - 212))
                | (1ULL << (RpgParser::SPLAT_YMD - 212))
                | (1ULL << (RpgParser::SPLAT_JUL - 212))
                | (1ULL << (RpgParser::SPLAT_JAVA - 212))
                | (1ULL << (RpgParser::SPLAT_ISO - 212))
                | (1ULL << (RpgParser::SPLAT_USA - 212))
                | (1ULL << (RpgParser::SPLAT_EUR - 212))
                | (1ULL << (RpgParser::SPLAT_JIS - 212))
                | (1ULL << (RpgParser::SPLAT_DATE - 212))
                | (1ULL << (RpgParser::SPLAT_DAY - 212))
                | (1ULL << (RpgParser::SPlAT_DETC - 212))
                | (1ULL << (RpgParser::SPLAT_DETL - 212))
                | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
                | (1ULL << (RpgParser::SPLAT_END - 212))
                | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
                | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
                | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
                | (1ULL << (RpgParser::SPLAT_EXT - 212))
                | (1ULL << (RpgParser::SPLAT_FILE - 212))
                | (1ULL << (RpgParser::SPLAT_GETIN - 212))
                | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
                | (1ULL << (RpgParser::SPLAT_INIT - 212))
                | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
                | (1ULL << (RpgParser::SPLAT_INZSR - 212))
                | (1ULL << (RpgParser::SPLAT_IN - 212))
                | (1ULL << (RpgParser::SPLAT_INPUT - 212))
                | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
                | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
                | (1ULL << (RpgParser::SPLAT_JOB - 212))
                | (1ULL << (RpgParser::SPLAT_LDA - 212))
                | (1ULL << (RpgParser::SPLAT_LIKE - 212))
                | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
                | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
                | (1ULL << (RpgParser::SPLAT_KEY - 212))
                | (1ULL << (RpgParser::SPLAT_MONTH - 212))
                | (1ULL << (RpgParser::SPLAT_NEXT - 212))
                | (1ULL << (RpgParser::SPLAT_NOIND - 212))
                | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
                | (1ULL << (RpgParser::SPLAT_NULL - 212))
                | (1ULL << (RpgParser::SPLAT_OFL - 212))
                | (1ULL << (RpgParser::SPLAT_ON - 212))
                | (1ULL << (RpgParser::SPLAT_ONLY - 212))
                | (1ULL << (RpgParser::SPLAT_OFF - 212))
                | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
                | (1ULL << (RpgParser::SPLAT_PSSR - 276))
                | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
                | (1ULL << (RpgParser::SPLAT_START - 276))
                | (1ULL << (RpgParser::SPLAT_SYS - 276))
                | (1ULL << (RpgParser::SPLAT_TERM - 276))
                | (1ULL << (RpgParser::SPLAT_TOTC - 276))
                | (1ULL << (RpgParser::SPLAT_TOTL - 276))
                | (1ULL << (RpgParser::SPLAT_USER - 276))
                | (1ULL << (RpgParser::SPLAT_VAR - 276))
                | (1ULL << (RpgParser::SPLAT_YEAR - 276))
                | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
                | (1ULL << (RpgParser::SPLAT_HMS - 276))
                | (1ULL << (RpgParser::SPLAT_INLR - 276))
                | (1ULL << (RpgParser::SPLAT_INOF - 276))
                | (1ULL << (RpgParser::SPLAT_DATA - 276))
                | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
                | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
                | (1ULL << (RpgParser::SPLAT_MAX - 276))
                | (1ULL << (RpgParser::SPLAT_LOCK - 276))
                | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
                | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
                | (1ULL << (RpgParser::SPLAT_D - 276))
                | (1ULL << (RpgParser::SPLAT_H - 276))
                | (1ULL << (RpgParser::SPLAT_HOURS - 276))
                | (1ULL << (RpgParser::SPLAT_DAYS - 276))
                | (1ULL << (RpgParser::SPLAT_M - 276))
                | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
                | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
                | (1ULL << (RpgParser::SPLAT_MN - 276))
                | (1ULL << (RpgParser::SPLAT_MS - 276))
                | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
                | (1ULL << (RpgParser::SPLAT_S - 276))
                | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
                | (1ULL << (RpgParser::SPLAT_Y - 276))
                | (1ULL << (RpgParser::SPLAT_YEARS - 276))
                | (1ULL << (RpgParser::UDATE - 276))
                | (1ULL << (RpgParser::UMONTH - 276))
                | (1ULL << (RpgParser::UYEAR - 276))
                | (1ULL << (RpgParser::UDAY - 276))
                | (1ULL << (RpgParser::CHAR - 276))
                | (1ULL << (RpgParser::VARCHAR - 276))
                | (1ULL << (RpgParser::UCS2 - 276))
                | (1ULL << (RpgParser::DATE_ - 276))
                | (1ULL << (RpgParser::VARUCS2 - 276))
                | (1ULL << (RpgParser::GRAPH - 276))
                | (1ULL << (RpgParser::VARGRAPH - 276))
                | (1ULL << (RpgParser::IND - 276))
                | (1ULL << (RpgParser::PACKED - 276))
                | (1ULL << (RpgParser::ZONED - 276))
                | (1ULL << (RpgParser::BINDEC - 276))
                | (1ULL << (RpgParser::INT - 276))
                | (1ULL << (RpgParser::UNS - 276))
                | (1ULL << (RpgParser::FLOAT - 276))
                | (1ULL << (RpgParser::TIME - 276))
                | (1ULL << (RpgParser::TIMESTAMP - 276))
                | (1ULL << (RpgParser::POINTER - 276))
                | (1ULL << (RpgParser::OBJECT - 276))
                | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
                | (1ULL << (RpgParser::KEYWORD_ALT - 340))
                | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
                | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
                | (1ULL << (RpgParser::KEYWORD_BASED - 340))
                | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
                | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
                | (1ULL << (RpgParser::KEYWORD_CONST - 340))
                | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
                | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
                | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
                | (1ULL << (RpgParser::KEYWORD_DIM - 340))
                | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
                | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
                | (1ULL << (RpgParser::KEYWORD_EXT - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
                | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
                | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
                | (1ULL << (RpgParser::KEYWORD_INZ - 340))
                | (1ULL << (RpgParser::KEYWORD_LEN - 340))
                | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
                | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
                | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
                | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
                | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
                | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
                | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
                | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
                | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
                | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
                | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
                | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
                | (1ULL << (RpgParser::KEYWORD_POS - 340))
                | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
                | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
                | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
                | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
                | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
                | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
                | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
                | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
                | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
                | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
                | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
                | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
                | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
                | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
                | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
                | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
                | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
                | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
                | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
                | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
                | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
                | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
                | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
                | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
                | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
                | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
                | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
                | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
                | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
                | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
                | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
                | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
                | (1ULL << (RpgParser::KEYWORD_SLN - 404))
                | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
                | (1ULL << (RpgParser::KEYWORD_DISK - 404))
                | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
                | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
                | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
                | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
                | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
                | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
                | (1ULL << (RpgParser::NOT - 404))
                | (1ULL << (RpgParser::MULT_NOSPACE - 404))
                | (1ULL << (RpgParser::FREE_BY - 404))
                | (1ULL << (RpgParser::FREE_TO - 404))
                | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
                setState(1869);
                _errHandler->sync(this);
                switch (_input->LA(1)) {
                  case RpgParser::COMMENT_SPEC_FIXED: {
                    setState(1866);
                    star_comments();
                    break;
                  }

                  case RpgParser::DIRECTIVE: {
                    setState(1867);
                    directive();
                    break;
                  }

                  case RpgParser::ID:
                  case RpgParser::OP_ACQ:
                  case RpgParser::OP_BEGSR:
                  case RpgParser::OP_CALLP:
                  case RpgParser::OP_CHAIN:
                  case RpgParser::OP_CLEAR:
                  case RpgParser::OP_CLOSE:
                  case RpgParser::OP_COMMIT:
                  case RpgParser::OP_DEALLOC:
                  case RpgParser::OP_DELETE:
                  case RpgParser::OP_DSPLY:
                  case RpgParser::OP_DUMP:
                  case RpgParser::OP_ENDSR:
                  case RpgParser::OP_EVAL:
                  case RpgParser::OP_EVALR:
                  case RpgParser::OP_EVAL_CORR:
                  case RpgParser::OP_EXCEPT:
                  case RpgParser::OP_EXFMT:
                  case RpgParser::OP_EXSR:
                  case RpgParser::OP_FEOD:
                  case RpgParser::OP_FORCE:
                  case RpgParser::OP_IN:
                  case RpgParser::OP_ITER:
                  case RpgParser::OP_LEAVE:
                  case RpgParser::OP_LEAVESR:
                  case RpgParser::OP_NEXT:
                  case RpgParser::OP_OPEN:
                  case RpgParser::OP_OTHER:
                  case RpgParser::OP_OUT:
                  case RpgParser::OP_POST:
                  case RpgParser::OP_READ:
                  case RpgParser::OP_READC:
                  case RpgParser::OP_READE:
                  case RpgParser::OP_READP:
                  case RpgParser::OP_READPE:
                  case RpgParser::OP_REL:
                  case RpgParser::OP_RESET:
                  case RpgParser::OP_RETURN:
                  case RpgParser::OP_ROLBK:
                  case RpgParser::OP_SELECT:
                  case RpgParser::OP_SETGT:
                  case RpgParser::OP_SETLL:
                  case RpgParser::OP_SORTA:
                  case RpgParser::OP_TEST:
                  case RpgParser::OP_UNLOCK:
                  case RpgParser::OP_UPDATE:
                  case RpgParser::OP_WHEN:
                  case RpgParser::OP_WRITE:
                  case RpgParser::OP_XML_INTO:
                  case RpgParser::OP_XML_SAX:
                  case RpgParser::DS_SubField:
                  case RpgParser::SPLAT_ALL:
                  case RpgParser::SPLAT_NONE:
                  case RpgParser::SPLAT_YES:
                  case RpgParser::SPLAT_NO:
                  case RpgParser::SPLAT_ILERPG:
                  case RpgParser::SPLAT_COMPAT:
                  case RpgParser::SPLAT_CRTBNDRPG:
                  case RpgParser::SPLAT_CRTRPGMOD:
                  case RpgParser::SPLAT_VRM:
                  case RpgParser::SPLAT_ALLG:
                  case RpgParser::SPLAT_ALLU:
                  case RpgParser::SPLAT_ALLTHREAD:
                  case RpgParser::SPLAT_ALLX:
                  case RpgParser::SPLAT_BLANKS:
                  case RpgParser::SPLAT_CANCL:
                  case RpgParser::SPLAT_CYMD:
                  case RpgParser::SPLAT_CMDY:
                  case RpgParser::SPLAT_CDMY:
                  case RpgParser::SPLAT_MDY:
                  case RpgParser::SPLAT_DMY:
                  case RpgParser::SPLAT_DFT:
                  case RpgParser::SPLAT_YMD:
                  case RpgParser::SPLAT_JUL:
                  case RpgParser::SPLAT_JAVA:
                  case RpgParser::SPLAT_ISO:
                  case RpgParser::SPLAT_USA:
                  case RpgParser::SPLAT_EUR:
                  case RpgParser::SPLAT_JIS:
                  case RpgParser::SPLAT_DATE:
                  case RpgParser::SPLAT_DAY:
                  case RpgParser::SPlAT_DETC:
                  case RpgParser::SPLAT_DETL:
                  case RpgParser::SPLAT_DTAARA:
                  case RpgParser::SPLAT_END:
                  case RpgParser::SPLAT_ENTRY:
                  case RpgParser::SPLAT_EQUATE:
                  case RpgParser::SPLAT_EXTDFT:
                  case RpgParser::SPLAT_EXT:
                  case RpgParser::SPLAT_FILE:
                  case RpgParser::SPLAT_GETIN:
                  case RpgParser::SPLAT_HIVAL:
                  case RpgParser::SPLAT_INIT:
                  case RpgParser::SPLAT_INDICATOR:
                  case RpgParser::SPLAT_INZSR:
                  case RpgParser::SPLAT_IN:
                  case RpgParser::SPLAT_INPUT:
                  case RpgParser::SPLAT_OUTPUT:
                  case RpgParser::SPLAT_JOBRUN:
                  case RpgParser::SPLAT_JOB:
                  case RpgParser::SPLAT_LDA:
                  case RpgParser::SPLAT_LIKE:
                  case RpgParser::SPLAT_LONGJUL:
                  case RpgParser::SPLAT_LOVAL:
                  case RpgParser::SPLAT_KEY:
                  case RpgParser::SPLAT_MONTH:
                  case RpgParser::SPLAT_NEXT:
                  case RpgParser::SPLAT_NOIND:
                  case RpgParser::SPLAT_NOKEY:
                  case RpgParser::SPLAT_NULL:
                  case RpgParser::SPLAT_OFL:
                  case RpgParser::SPLAT_ON:
                  case RpgParser::SPLAT_ONLY:
                  case RpgParser::SPLAT_OFF:
                  case RpgParser::SPLAT_PDA:
                  case RpgParser::SPLAT_PLACE:
                  case RpgParser::SPLAT_PSSR:
                  case RpgParser::SPLAT_ROUTINE:
                  case RpgParser::SPLAT_START:
                  case RpgParser::SPLAT_SYS:
                  case RpgParser::SPLAT_TERM:
                  case RpgParser::SPLAT_TOTC:
                  case RpgParser::SPLAT_TOTL:
                  case RpgParser::SPLAT_USER:
                  case RpgParser::SPLAT_VAR:
                  case RpgParser::SPLAT_YEAR:
                  case RpgParser::SPLAT_ZEROS:
                  case RpgParser::SPLAT_HMS:
                  case RpgParser::SPLAT_INLR:
                  case RpgParser::SPLAT_INOF:
                  case RpgParser::SPLAT_DATA:
                  case RpgParser::SPLAT_ASTFILL:
                  case RpgParser::SPLAT_CURSYM:
                  case RpgParser::SPLAT_MAX:
                  case RpgParser::SPLAT_LOCK:
                  case RpgParser::SPLAT_PROGRAM:
                  case RpgParser::SPLAT_EXTDESC:
                  case RpgParser::SPLAT_D:
                  case RpgParser::SPLAT_H:
                  case RpgParser::SPLAT_HOURS:
                  case RpgParser::SPLAT_DAYS:
                  case RpgParser::SPLAT_M:
                  case RpgParser::SPLAT_MINUTES:
                  case RpgParser::SPLAT_MONTHS:
                  case RpgParser::SPLAT_MN:
                  case RpgParser::SPLAT_MS:
                  case RpgParser::SPLAT_MSECONDS:
                  case RpgParser::SPLAT_S:
                  case RpgParser::SPLAT_SECONDS:
                  case RpgParser::SPLAT_Y:
                  case RpgParser::SPLAT_YEARS:
                  case RpgParser::UDATE:
                  case RpgParser::UMONTH:
                  case RpgParser::UYEAR:
                  case RpgParser::UDAY:
                  case RpgParser::CHAR:
                  case RpgParser::VARCHAR:
                  case RpgParser::UCS2:
                  case RpgParser::DATE_:
                  case RpgParser::VARUCS2:
                  case RpgParser::GRAPH:
                  case RpgParser::VARGRAPH:
                  case RpgParser::IND:
                  case RpgParser::PACKED:
                  case RpgParser::ZONED:
                  case RpgParser::BINDEC:
                  case RpgParser::INT:
                  case RpgParser::UNS:
                  case RpgParser::FLOAT:
                  case RpgParser::TIME:
                  case RpgParser::TIMESTAMP:
                  case RpgParser::POINTER:
                  case RpgParser::OBJECT:
                  case RpgParser::KEYWORD_ALIAS:
                  case RpgParser::KEYWORD_ALIGN:
                  case RpgParser::KEYWORD_ALT:
                  case RpgParser::KEYWORD_ALTSEQ:
                  case RpgParser::KEYWORD_ASCEND:
                  case RpgParser::KEYWORD_BASED:
                  case RpgParser::KEYWORD_CCSID:
                  case RpgParser::KEYWORD_CLASS:
                  case RpgParser::KEYWORD_CONST:
                  case RpgParser::KEYWORD_CTDATA:
                  case RpgParser::KEYWORD_DATFMT:
                  case RpgParser::KEYWORD_DESCEND:
                  case RpgParser::KEYWORD_DIM:
                  case RpgParser::KEYWORD_DTAARA:
                  case RpgParser::KEYWORD_EXPORT:
                  case RpgParser::KEYWORD_EXT:
                  case RpgParser::KEYWORD_EXTFLD:
                  case RpgParser::KEYWORD_EXTFMT:
                  case RpgParser::KEYWORD_EXTNAME:
                  case RpgParser::KEYWORD_EXTPGM:
                  case RpgParser::KEYWORD_EXTPROC:
                  case RpgParser::KEYWORD_FROMFILE:
                  case RpgParser::KEYWORD_IMPORT:
                  case RpgParser::KEYWORD_INZ:
                  case RpgParser::KEYWORD_LEN:
                  case RpgParser::KEYWORD_LIKE:
                  case RpgParser::KEYWORD_LIKEDS:
                  case RpgParser::KEYWORD_LIKEFILE:
                  case RpgParser::KEYWORD_LIKEREC:
                  case RpgParser::KEYWORD_NOOPT:
                  case RpgParser::KEYWORD_OCCURS:
                  case RpgParser::KEYWORD_OPDESC:
                  case RpgParser::KEYWORD_OPTIONS:
                  case RpgParser::KEYWORD_OVERLAY:
                  case RpgParser::KEYWORD_PACKEVEN:
                  case RpgParser::KEYWORD_PERRCD:
                  case RpgParser::KEYWORD_PREFIX:
                  case RpgParser::KEYWORD_POS:
                  case RpgParser::KEYWORD_PROCPTR:
                  case RpgParser::KEYWORD_QUALIFIED:
                  case RpgParser::KEYWORD_RTNPARM:
                  case RpgParser::KEYWORD_STATIC:
                  case RpgParser::KEYWORD_TEMPLATE:
                  case RpgParser::KEYWORD_TIMFMT:
                  case RpgParser::KEYWORD_TOFILE:
                  case RpgParser::KEYWORD_VALUE:
                  case RpgParser::KEYWORD_VARYING:
                  case RpgParser::KEYWORD_BLOCK:
                  case RpgParser::KEYWORD_COMMIT:
                  case RpgParser::KEYWORD_DEVID:
                  case RpgParser::KEYWORD_EXTDESC:
                  case RpgParser::KEYWORD_EXTFILE:
                  case RpgParser::KEYWORD_EXTIND:
                  case RpgParser::KEYWORD_EXTMBR:
                  case RpgParser::KEYWORD_FORMLEN:
                  case RpgParser::KEYWORD_FORMOFL:
                  case RpgParser::KEYWORD_IGNORE:
                  case RpgParser::KEYWORD_INCLUDE:
                  case RpgParser::KEYWORD_INDDS:
                  case RpgParser::KEYWORD_INFDS:
                  case RpgParser::KEYWORD_INFSR:
                  case RpgParser::KEYWORD_KEYLOC:
                  case RpgParser::KEYWORD_MAXDEV:
                  case RpgParser::KEYWORD_OFLIND:
                  case RpgParser::KEYWORD_PASS:
                  case RpgParser::KEYWORD_PGMNAME:
                  case RpgParser::KEYWORD_PLIST:
                  case RpgParser::KEYWORD_PRTCTL:
                  case RpgParser::KEYWORD_RAFDATA:
                  case RpgParser::KEYWORD_RECNO:
                  case RpgParser::KEYWORD_RENAME:
                  case RpgParser::KEYWORD_SAVEDS:
                  case RpgParser::KEYWORD_SAVEIND:
                  case RpgParser::KEYWORD_SFILE:
                  case RpgParser::KEYWORD_SLN:
                  case RpgParser::KEYWORD_USROPN:
                  case RpgParser::KEYWORD_DISK:
                  case RpgParser::KEYWORD_WORKSTN:
                  case RpgParser::KEYWORD_PRINTER:
                  case RpgParser::KEYWORD_SPECIAL:
                  case RpgParser::KEYWORD_KEYED:
                  case RpgParser::KEYWORD_USAGE:
                  case RpgParser::KEYWORD_PSDS:
                  case RpgParser::NOT:
                  case RpgParser::MULT_NOSPACE:
                  case RpgParser::FREE_BY:
                  case RpgParser::FREE_TO:
                  case RpgParser::FREE_DOWNTO: {
                    setState(1868);
                    dcl_ds_field();
                    break;
                  }

                default:
                  throw NoViableAltException(this);
                }
                setState(1873);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
            }
            setState(1876);
            end_dcl_ds();
            break;
          }

          case RpgParser::KEYWORD_LIKEREC: {
            setState(1877);
            keyword_likerec();
            break;
          }

          case RpgParser::KEYWORD_LIKEDS: {
            setState(1878);
            keyword_likeds();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1881);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::DS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(1883);
        match(RpgParser::DS_FIXED);
        setState(1884);
        ds_name();
        setState(1885);
        match(RpgParser::EXTERNAL_DESCRIPTION);
        setState(1886);
        match(RpgParser::DATA_STRUCTURE_TYPE);
        setState(1887);
        match(RpgParser::DEF_TYPE_DS);
        setState(1888);
        match(RpgParser::FROM_POSITION);
        setState(1889);
        match(RpgParser::TO_POSITION);
        setState(1890);
        match(RpgParser::DATA_TYPE);
        setState(1891);
        match(RpgParser::DECIMAL_POSITIONS);
        setState(1892);
        match(RpgParser::RESERVED);
        setState(1896);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
          | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
          | (1ULL << (RpgParser::KEYWORD_ALT - 339))
          | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
          | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
          | (1ULL << (RpgParser::KEYWORD_BASED - 339))
          | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
          | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
          | (1ULL << (RpgParser::KEYWORD_CONST - 339))
          | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
          | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
          | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
          | (1ULL << (RpgParser::KEYWORD_DIM - 339))
          | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
          | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
          | (1ULL << (RpgParser::KEYWORD_EXT - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
          | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
          | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
          | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
          | (1ULL << (RpgParser::KEYWORD_INZ - 339))
          | (1ULL << (RpgParser::KEYWORD_LEN - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
          | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
          | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
          | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
          | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
          | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
          | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
          | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
          | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
          | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
          | (1ULL << (RpgParser::KEYWORD_POS - 339))
          | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
          | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
          | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
          | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
          | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
          | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
          | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
          | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
          | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

        || _la == RpgParser::KEYWORD_PSDS) {
          setState(1893);
          keyword();
          setState(1898);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1899);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1909);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(1905);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(1903);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case RpgParser::COMMENT_SPEC_FIXED: {
                  setState(1900);
                  star_comments();
                  break;
                }

                case RpgParser::DIRECTIVE: {
                  setState(1901);
                  directive();
                  break;
                }

                case RpgParser::DS_FIXED: {
                  setState(1902);
                  parm_fixed();
                  break;
                }

              default:
                throw NoViableAltException(this);
              } 
            }
            setState(1907);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
          }
          setState(1908);
          parm_fixed();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_ds_fieldContext ------------------------------------------------------------------

RpgParser::Dcl_ds_fieldContext::Dcl_ds_fieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Dcl_ds_fieldContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Dcl_ds_fieldContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

tree::TerminalNode* RpgParser::Dcl_ds_fieldContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

tree::TerminalNode* RpgParser::Dcl_ds_fieldContext::DS_SubField() {
  return getToken(RpgParser::DS_SubField, 0);
}

RpgParser::DatatypeContext* RpgParser::Dcl_ds_fieldContext::datatype() {
  return getRuleContext<RpgParser::DatatypeContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dcl_ds_fieldContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dcl_ds_fieldContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::Dcl_ds_fieldContext::getRuleIndex() const {
  return RpgParser::RuleDcl_ds_field;
}

void RpgParser::Dcl_ds_fieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_ds_field(this);
}

void RpgParser::Dcl_ds_fieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_ds_field(this);
}


antlrcpp::Any RpgParser::Dcl_ds_fieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_ds_field(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_ds_fieldContext* RpgParser::dcl_ds_field() {
  Dcl_ds_fieldContext *_localctx = _tracker.createInstance<Dcl_ds_fieldContext>(_ctx, getState());
  enterRule(_localctx, 208, RpgParser::RuleDcl_ds_field);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1914);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::DS_SubField) {
      setState(1913);
      match(RpgParser::DS_SubField);
    }
    setState(1916);
    identifier();
    setState(1919);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(1917);
      datatype();
      break;
    }

    case 2: {
      setState(1918);
      identifier();
      break;
    }

    }
    setState(1924);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(1921);
      keyword();
      setState(1926);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1927);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_dcl_dsContext ------------------------------------------------------------------

RpgParser::End_dcl_dsContext::End_dcl_dsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::End_dcl_dsContext::DS_DataStructureEnd() {
  return getToken(RpgParser::DS_DataStructureEnd, 0);
}

RpgParser::IdentifierContext* RpgParser::End_dcl_dsContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::End_dcl_dsContext::getRuleIndex() const {
  return RpgParser::RuleEnd_dcl_ds;
}

void RpgParser::End_dcl_dsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_dcl_ds(this);
}

void RpgParser::End_dcl_dsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_dcl_ds(this);
}


antlrcpp::Any RpgParser::End_dcl_dsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEnd_dcl_ds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::End_dcl_dsContext* RpgParser::end_dcl_ds() {
  End_dcl_dsContext *_localctx = _tracker.createInstance<End_dcl_dsContext>(_ctx, getState());
  enterRule(_localctx, 210, RpgParser::RuleEnd_dcl_ds);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1929);
    match(RpgParser::DS_DataStructureEnd);
    setState(1931);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(1930);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_prContext ------------------------------------------------------------------

RpgParser::Dcl_prContext::Dcl_prContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dcl_prContext::DS_PrototypeStart() {
  return getToken(RpgParser::DS_PrototypeStart, 0);
}

RpgParser::IdentifierContext* RpgParser::Dcl_prContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::End_dcl_prContext* RpgParser::Dcl_prContext::end_dcl_pr() {
  return getRuleContext<RpgParser::End_dcl_prContext>(0);
}

std::vector<tree::TerminalNode *> RpgParser::Dcl_prContext::FREE_SEMI() {
  return getTokens(RpgParser::FREE_SEMI);
}

tree::TerminalNode* RpgParser::Dcl_prContext::FREE_SEMI(size_t i) {
  return getToken(RpgParser::FREE_SEMI, i);
}

RpgParser::DatatypeContext* RpgParser::Dcl_prContext::datatype() {
  return getRuleContext<RpgParser::DatatypeContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dcl_prContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dcl_prContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}

std::vector<RpgParser::Dcl_pr_fieldContext *> RpgParser::Dcl_prContext::dcl_pr_field() {
  return getRuleContexts<RpgParser::Dcl_pr_fieldContext>();
}

RpgParser::Dcl_pr_fieldContext* RpgParser::Dcl_prContext::dcl_pr_field(size_t i) {
  return getRuleContext<RpgParser::Dcl_pr_fieldContext>(i);
}

RpgParser::Dcl_piContext* RpgParser::Dcl_prContext::dcl_pi() {
  return getRuleContext<RpgParser::Dcl_piContext>(0);
}

RpgParser::PrBeginContext* RpgParser::Dcl_prContext::prBegin() {
  return getRuleContext<RpgParser::PrBeginContext>(0);
}

std::vector<RpgParser::Parm_fixedContext *> RpgParser::Dcl_prContext::parm_fixed() {
  return getRuleContexts<RpgParser::Parm_fixedContext>();
}

RpgParser::Parm_fixedContext* RpgParser::Dcl_prContext::parm_fixed(size_t i) {
  return getRuleContext<RpgParser::Parm_fixedContext>(i);
}


size_t RpgParser::Dcl_prContext::getRuleIndex() const {
  return RpgParser::RuleDcl_pr;
}

void RpgParser::Dcl_prContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_pr(this);
}

void RpgParser::Dcl_prContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_pr(this);
}


antlrcpp::Any RpgParser::Dcl_prContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_pr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_prContext* RpgParser::dcl_pr() {
  Dcl_prContext *_localctx = _tracker.createInstance<Dcl_prContext>(_ctx, getState());
  enterRule(_localctx, 212, RpgParser::RuleDcl_pr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(1966);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::DS_PrototypeStart: {
        enterOuterAlt(_localctx, 1);
        setState(1933);
        match(RpgParser::DS_PrototypeStart);
        setState(1934);
        identifier();
        setState(1936);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
        case 1: {
          setState(1935);
          datatype();
          break;
        }

        }
        setState(1941);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1938);
            keyword(); 
          }
          setState(1943);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
        }
        setState(1945);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::FREE_SEMI) {
          setState(1944);
          match(RpgParser::FREE_SEMI);
        }
        setState(1950);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << RpgParser::ID)
          | (1ULL << RpgParser::OP_ACQ)
          | (1ULL << RpgParser::OP_BEGSR)
          | (1ULL << RpgParser::OP_CALLP)
          | (1ULL << RpgParser::OP_CHAIN)
          | (1ULL << RpgParser::OP_CLEAR)
          | (1ULL << RpgParser::OP_CLOSE)
          | (1ULL << RpgParser::OP_COMMIT)
          | (1ULL << RpgParser::OP_DEALLOC)
          | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
          | (1ULL << (RpgParser::OP_DUMP - 64))
          | (1ULL << (RpgParser::OP_ENDSR - 64))
          | (1ULL << (RpgParser::OP_EVAL - 64))
          | (1ULL << (RpgParser::OP_EVALR - 64))
          | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
          | (1ULL << (RpgParser::OP_EXCEPT - 64))
          | (1ULL << (RpgParser::OP_EXFMT - 64))
          | (1ULL << (RpgParser::OP_EXSR - 64))
          | (1ULL << (RpgParser::OP_FEOD - 64))
          | (1ULL << (RpgParser::OP_FORCE - 64))
          | (1ULL << (RpgParser::OP_IN - 64))
          | (1ULL << (RpgParser::OP_ITER - 64))
          | (1ULL << (RpgParser::OP_LEAVE - 64))
          | (1ULL << (RpgParser::OP_LEAVESR - 64))
          | (1ULL << (RpgParser::OP_NEXT - 64))
          | (1ULL << (RpgParser::OP_OPEN - 64))
          | (1ULL << (RpgParser::OP_OTHER - 64))
          | (1ULL << (RpgParser::OP_OUT - 64))
          | (1ULL << (RpgParser::OP_POST - 64))
          | (1ULL << (RpgParser::OP_READ - 64))
          | (1ULL << (RpgParser::OP_READC - 64))
          | (1ULL << (RpgParser::OP_READE - 64))
          | (1ULL << (RpgParser::OP_READP - 64))
          | (1ULL << (RpgParser::OP_READPE - 64))
          | (1ULL << (RpgParser::OP_REL - 64))
          | (1ULL << (RpgParser::OP_RESET - 64))
          | (1ULL << (RpgParser::OP_RETURN - 64))
          | (1ULL << (RpgParser::OP_ROLBK - 64))
          | (1ULL << (RpgParser::OP_SELECT - 64))
          | (1ULL << (RpgParser::OP_SETGT - 64))
          | (1ULL << (RpgParser::OP_SETLL - 64))
          | (1ULL << (RpgParser::OP_SORTA - 64))
          | (1ULL << (RpgParser::OP_TEST - 64))
          | (1ULL << (RpgParser::OP_UNLOCK - 64))
          | (1ULL << (RpgParser::OP_UPDATE - 64))
          | (1ULL << (RpgParser::OP_WHEN - 64))
          | (1ULL << (RpgParser::OP_WRITE - 64))
          | (1ULL << (RpgParser::OP_XML_INTO - 64))
          | (1ULL << (RpgParser::OP_XML_SAX - 64))
          | (1ULL << (RpgParser::DS_Parm - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
          | (1ULL << (RpgParser::SPLAT_NONE - 212))
          | (1ULL << (RpgParser::SPLAT_YES - 212))
          | (1ULL << (RpgParser::SPLAT_NO - 212))
          | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
          | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
          | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
          | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
          | (1ULL << (RpgParser::SPLAT_VRM - 212))
          | (1ULL << (RpgParser::SPLAT_ALLG - 212))
          | (1ULL << (RpgParser::SPLAT_ALLU - 212))
          | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
          | (1ULL << (RpgParser::SPLAT_ALLX - 212))
          | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
          | (1ULL << (RpgParser::SPLAT_CANCL - 212))
          | (1ULL << (RpgParser::SPLAT_CYMD - 212))
          | (1ULL << (RpgParser::SPLAT_CMDY - 212))
          | (1ULL << (RpgParser::SPLAT_CDMY - 212))
          | (1ULL << (RpgParser::SPLAT_MDY - 212))
          | (1ULL << (RpgParser::SPLAT_DMY - 212))
          | (1ULL << (RpgParser::SPLAT_DFT - 212))
          | (1ULL << (RpgParser::SPLAT_YMD - 212))
          | (1ULL << (RpgParser::SPLAT_JUL - 212))
          | (1ULL << (RpgParser::SPLAT_JAVA - 212))
          | (1ULL << (RpgParser::SPLAT_ISO - 212))
          | (1ULL << (RpgParser::SPLAT_USA - 212))
          | (1ULL << (RpgParser::SPLAT_EUR - 212))
          | (1ULL << (RpgParser::SPLAT_JIS - 212))
          | (1ULL << (RpgParser::SPLAT_DATE - 212))
          | (1ULL << (RpgParser::SPLAT_DAY - 212))
          | (1ULL << (RpgParser::SPlAT_DETC - 212))
          | (1ULL << (RpgParser::SPLAT_DETL - 212))
          | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
          | (1ULL << (RpgParser::SPLAT_END - 212))
          | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
          | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
          | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
          | (1ULL << (RpgParser::SPLAT_EXT - 212))
          | (1ULL << (RpgParser::SPLAT_FILE - 212))
          | (1ULL << (RpgParser::SPLAT_GETIN - 212))
          | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
          | (1ULL << (RpgParser::SPLAT_INIT - 212))
          | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
          | (1ULL << (RpgParser::SPLAT_INZSR - 212))
          | (1ULL << (RpgParser::SPLAT_IN - 212))
          | (1ULL << (RpgParser::SPLAT_INPUT - 212))
          | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
          | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
          | (1ULL << (RpgParser::SPLAT_JOB - 212))
          | (1ULL << (RpgParser::SPLAT_LDA - 212))
          | (1ULL << (RpgParser::SPLAT_LIKE - 212))
          | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
          | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
          | (1ULL << (RpgParser::SPLAT_KEY - 212))
          | (1ULL << (RpgParser::SPLAT_MONTH - 212))
          | (1ULL << (RpgParser::SPLAT_NEXT - 212))
          | (1ULL << (RpgParser::SPLAT_NOIND - 212))
          | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
          | (1ULL << (RpgParser::SPLAT_NULL - 212))
          | (1ULL << (RpgParser::SPLAT_OFL - 212))
          | (1ULL << (RpgParser::SPLAT_ON - 212))
          | (1ULL << (RpgParser::SPLAT_ONLY - 212))
          | (1ULL << (RpgParser::SPLAT_OFF - 212))
          | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
          | (1ULL << (RpgParser::SPLAT_PSSR - 276))
          | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
          | (1ULL << (RpgParser::SPLAT_START - 276))
          | (1ULL << (RpgParser::SPLAT_SYS - 276))
          | (1ULL << (RpgParser::SPLAT_TERM - 276))
          | (1ULL << (RpgParser::SPLAT_TOTC - 276))
          | (1ULL << (RpgParser::SPLAT_TOTL - 276))
          | (1ULL << (RpgParser::SPLAT_USER - 276))
          | (1ULL << (RpgParser::SPLAT_VAR - 276))
          | (1ULL << (RpgParser::SPLAT_YEAR - 276))
          | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
          | (1ULL << (RpgParser::SPLAT_HMS - 276))
          | (1ULL << (RpgParser::SPLAT_INLR - 276))
          | (1ULL << (RpgParser::SPLAT_INOF - 276))
          | (1ULL << (RpgParser::SPLAT_DATA - 276))
          | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
          | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
          | (1ULL << (RpgParser::SPLAT_MAX - 276))
          | (1ULL << (RpgParser::SPLAT_LOCK - 276))
          | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
          | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
          | (1ULL << (RpgParser::SPLAT_D - 276))
          | (1ULL << (RpgParser::SPLAT_H - 276))
          | (1ULL << (RpgParser::SPLAT_HOURS - 276))
          | (1ULL << (RpgParser::SPLAT_DAYS - 276))
          | (1ULL << (RpgParser::SPLAT_M - 276))
          | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
          | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
          | (1ULL << (RpgParser::SPLAT_MN - 276))
          | (1ULL << (RpgParser::SPLAT_MS - 276))
          | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
          | (1ULL << (RpgParser::SPLAT_S - 276))
          | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
          | (1ULL << (RpgParser::SPLAT_Y - 276))
          | (1ULL << (RpgParser::SPLAT_YEARS - 276))
          | (1ULL << (RpgParser::UDATE - 276))
          | (1ULL << (RpgParser::UMONTH - 276))
          | (1ULL << (RpgParser::UYEAR - 276))
          | (1ULL << (RpgParser::UDAY - 276))
          | (1ULL << (RpgParser::CHAR - 276))
          | (1ULL << (RpgParser::VARCHAR - 276))
          | (1ULL << (RpgParser::UCS2 - 276))
          | (1ULL << (RpgParser::DATE_ - 276))
          | (1ULL << (RpgParser::VARUCS2 - 276))
          | (1ULL << (RpgParser::GRAPH - 276))
          | (1ULL << (RpgParser::VARGRAPH - 276))
          | (1ULL << (RpgParser::IND - 276))
          | (1ULL << (RpgParser::PACKED - 276))
          | (1ULL << (RpgParser::ZONED - 276))
          | (1ULL << (RpgParser::BINDEC - 276))
          | (1ULL << (RpgParser::INT - 276))
          | (1ULL << (RpgParser::UNS - 276))
          | (1ULL << (RpgParser::FLOAT - 276))
          | (1ULL << (RpgParser::TIME - 276))
          | (1ULL << (RpgParser::TIMESTAMP - 276))
          | (1ULL << (RpgParser::POINTER - 276))
          | (1ULL << (RpgParser::OBJECT - 276))
          | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
          | (1ULL << (RpgParser::KEYWORD_ALT - 340))
          | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
          | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
          | (1ULL << (RpgParser::KEYWORD_BASED - 340))
          | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
          | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
          | (1ULL << (RpgParser::KEYWORD_CONST - 340))
          | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
          | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
          | (1ULL << (RpgParser::KEYWORD_DIM - 340))
          | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
          | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
          | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
          | (1ULL << (RpgParser::KEYWORD_INZ - 340))
          | (1ULL << (RpgParser::KEYWORD_LEN - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
          | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
          | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
          | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
          | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
          | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
          | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
          | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
          | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
          | (1ULL << (RpgParser::KEYWORD_POS - 340))
          | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
          | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
          | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
          | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
          | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
          | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
          | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
          | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
          | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
          | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
          | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
          | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
          | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
          | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
          | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
          | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
          | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
          | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
          | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
          | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
          | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
          | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
          | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
          | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
          | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
          | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
          | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
          | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
          | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
          | (1ULL << (RpgParser::KEYWORD_SLN - 404))
          | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
          | (1ULL << (RpgParser::KEYWORD_DISK - 404))
          | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
          | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
          | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
          | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
          | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
          | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
          | (1ULL << (RpgParser::NOT - 404))
          | (1ULL << (RpgParser::MULT_NOSPACE - 404))
          | (1ULL << (RpgParser::FREE_BY - 404))
          | (1ULL << (RpgParser::FREE_TO - 404))
          | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
          setState(1947);
          dcl_pr_field();
          setState(1952);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1954);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::DS_FIXED || _la == RpgParser::DS_ProcedureInterfaceStart) {
          setState(1953);
          dcl_pi();
        }
        setState(1956);
        end_dcl_pr();
        setState(1957);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::DS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(1959);
        prBegin();
        setState(1963);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1960);
            parm_fixed(); 
          }
          setState(1965);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_pr_fieldContext ------------------------------------------------------------------

RpgParser::Dcl_pr_fieldContext::Dcl_pr_fieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::IdentifierContext* RpgParser::Dcl_pr_fieldContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::Dcl_pr_fieldContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

tree::TerminalNode* RpgParser::Dcl_pr_fieldContext::DS_Parm() {
  return getToken(RpgParser::DS_Parm, 0);
}

RpgParser::DatatypeContext* RpgParser::Dcl_pr_fieldContext::datatype() {
  return getRuleContext<RpgParser::DatatypeContext>(0);
}

RpgParser::Keyword_likeContext* RpgParser::Dcl_pr_fieldContext::keyword_like() {
  return getRuleContext<RpgParser::Keyword_likeContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dcl_pr_fieldContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dcl_pr_fieldContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::Dcl_pr_fieldContext::getRuleIndex() const {
  return RpgParser::RuleDcl_pr_field;
}

void RpgParser::Dcl_pr_fieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_pr_field(this);
}

void RpgParser::Dcl_pr_fieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_pr_field(this);
}


antlrcpp::Any RpgParser::Dcl_pr_fieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_pr_field(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_pr_fieldContext* RpgParser::dcl_pr_field() {
  Dcl_pr_fieldContext *_localctx = _tracker.createInstance<Dcl_pr_fieldContext>(_ctx, getState());
  enterRule(_localctx, 214, RpgParser::RuleDcl_pr_field);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1969);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::DS_Parm) {
      setState(1968);
      match(RpgParser::DS_Parm);
    }

    setState(1971);
    identifier();
    setState(1974);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT: {
        setState(1972);
        datatype();
        break;
      }

      case RpgParser::KEYWORD_LIKE: {
        setState(1973);
        dynamic_cast<Dcl_pr_fieldContext *>(_localctx)->like = keyword_like();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1979);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(1976);
      keyword();
      setState(1981);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1982);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_dcl_prContext ------------------------------------------------------------------

RpgParser::End_dcl_prContext::End_dcl_prContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::End_dcl_prContext::DS_PrototypeEnd() {
  return getToken(RpgParser::DS_PrototypeEnd, 0);
}


size_t RpgParser::End_dcl_prContext::getRuleIndex() const {
  return RpgParser::RuleEnd_dcl_pr;
}

void RpgParser::End_dcl_prContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_dcl_pr(this);
}

void RpgParser::End_dcl_prContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_dcl_pr(this);
}


antlrcpp::Any RpgParser::End_dcl_prContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEnd_dcl_pr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::End_dcl_prContext* RpgParser::end_dcl_pr() {
  End_dcl_prContext *_localctx = _tracker.createInstance<End_dcl_prContext>(_ctx, getState());
  enterRule(_localctx, 216, RpgParser::RuleEnd_dcl_pr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1984);
    match(RpgParser::DS_PrototypeEnd);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_piContext ------------------------------------------------------------------

RpgParser::Dcl_piContext::Dcl_piContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dcl_piContext::DS_ProcedureInterfaceStart() {
  return getToken(RpgParser::DS_ProcedureInterfaceStart, 0);
}

RpgParser::IdentifierContext* RpgParser::Dcl_piContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::End_dcl_piContext* RpgParser::Dcl_piContext::end_dcl_pi() {
  return getRuleContext<RpgParser::End_dcl_piContext>(0);
}

std::vector<tree::TerminalNode *> RpgParser::Dcl_piContext::FREE_SEMI() {
  return getTokens(RpgParser::FREE_SEMI);
}

tree::TerminalNode* RpgParser::Dcl_piContext::FREE_SEMI(size_t i) {
  return getToken(RpgParser::FREE_SEMI, i);
}

RpgParser::DatatypeContext* RpgParser::Dcl_piContext::datatype() {
  return getRuleContext<RpgParser::DatatypeContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dcl_piContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dcl_piContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}

std::vector<RpgParser::Dcl_pi_fieldContext *> RpgParser::Dcl_piContext::dcl_pi_field() {
  return getRuleContexts<RpgParser::Dcl_pi_fieldContext>();
}

RpgParser::Dcl_pi_fieldContext* RpgParser::Dcl_piContext::dcl_pi_field(size_t i) {
  return getRuleContext<RpgParser::Dcl_pi_fieldContext>(i);
}

RpgParser::PiBeginContext* RpgParser::Dcl_piContext::piBegin() {
  return getRuleContext<RpgParser::PiBeginContext>(0);
}

std::vector<RpgParser::Pi_parm_fixedContext *> RpgParser::Dcl_piContext::pi_parm_fixed() {
  return getRuleContexts<RpgParser::Pi_parm_fixedContext>();
}

RpgParser::Pi_parm_fixedContext* RpgParser::Dcl_piContext::pi_parm_fixed(size_t i) {
  return getRuleContext<RpgParser::Pi_parm_fixedContext>(i);
}


size_t RpgParser::Dcl_piContext::getRuleIndex() const {
  return RpgParser::RuleDcl_pi;
}

void RpgParser::Dcl_piContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_pi(this);
}

void RpgParser::Dcl_piContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_pi(this);
}


antlrcpp::Any RpgParser::Dcl_piContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_pi(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_piContext* RpgParser::dcl_pi() {
  Dcl_piContext *_localctx = _tracker.createInstance<Dcl_piContext>(_ctx, getState());
  enterRule(_localctx, 218, RpgParser::RuleDcl_pi);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2016);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::DS_ProcedureInterfaceStart: {
        enterOuterAlt(_localctx, 1);
        setState(1986);
        match(RpgParser::DS_ProcedureInterfaceStart);
        setState(1987);
        identifier();
        setState(1989);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
        case 1: {
          setState(1988);
          datatype();
          break;
        }

        }
        setState(1994);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1991);
            keyword(); 
          }
          setState(1996);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
        }
        setState(1998);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::FREE_SEMI) {
          setState(1997);
          match(RpgParser::FREE_SEMI);
        }
        setState(2003);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << RpgParser::ID)
          | (1ULL << RpgParser::OP_ACQ)
          | (1ULL << RpgParser::OP_BEGSR)
          | (1ULL << RpgParser::OP_CALLP)
          | (1ULL << RpgParser::OP_CHAIN)
          | (1ULL << RpgParser::OP_CLEAR)
          | (1ULL << RpgParser::OP_CLOSE)
          | (1ULL << RpgParser::OP_COMMIT)
          | (1ULL << RpgParser::OP_DEALLOC)
          | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
          | (1ULL << (RpgParser::OP_DUMP - 64))
          | (1ULL << (RpgParser::OP_ENDSR - 64))
          | (1ULL << (RpgParser::OP_EVAL - 64))
          | (1ULL << (RpgParser::OP_EVALR - 64))
          | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
          | (1ULL << (RpgParser::OP_EXCEPT - 64))
          | (1ULL << (RpgParser::OP_EXFMT - 64))
          | (1ULL << (RpgParser::OP_EXSR - 64))
          | (1ULL << (RpgParser::OP_FEOD - 64))
          | (1ULL << (RpgParser::OP_FORCE - 64))
          | (1ULL << (RpgParser::OP_IN - 64))
          | (1ULL << (RpgParser::OP_ITER - 64))
          | (1ULL << (RpgParser::OP_LEAVE - 64))
          | (1ULL << (RpgParser::OP_LEAVESR - 64))
          | (1ULL << (RpgParser::OP_NEXT - 64))
          | (1ULL << (RpgParser::OP_OPEN - 64))
          | (1ULL << (RpgParser::OP_OTHER - 64))
          | (1ULL << (RpgParser::OP_OUT - 64))
          | (1ULL << (RpgParser::OP_POST - 64))
          | (1ULL << (RpgParser::OP_READ - 64))
          | (1ULL << (RpgParser::OP_READC - 64))
          | (1ULL << (RpgParser::OP_READE - 64))
          | (1ULL << (RpgParser::OP_READP - 64))
          | (1ULL << (RpgParser::OP_READPE - 64))
          | (1ULL << (RpgParser::OP_REL - 64))
          | (1ULL << (RpgParser::OP_RESET - 64))
          | (1ULL << (RpgParser::OP_RETURN - 64))
          | (1ULL << (RpgParser::OP_ROLBK - 64))
          | (1ULL << (RpgParser::OP_SELECT - 64))
          | (1ULL << (RpgParser::OP_SETGT - 64))
          | (1ULL << (RpgParser::OP_SETLL - 64))
          | (1ULL << (RpgParser::OP_SORTA - 64))
          | (1ULL << (RpgParser::OP_TEST - 64))
          | (1ULL << (RpgParser::OP_UNLOCK - 64))
          | (1ULL << (RpgParser::OP_UPDATE - 64))
          | (1ULL << (RpgParser::OP_WHEN - 64))
          | (1ULL << (RpgParser::OP_WRITE - 64))
          | (1ULL << (RpgParser::OP_XML_INTO - 64))
          | (1ULL << (RpgParser::OP_XML_SAX - 64))
          | (1ULL << (RpgParser::DS_Parm - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
          | (1ULL << (RpgParser::SPLAT_NONE - 212))
          | (1ULL << (RpgParser::SPLAT_YES - 212))
          | (1ULL << (RpgParser::SPLAT_NO - 212))
          | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
          | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
          | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
          | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
          | (1ULL << (RpgParser::SPLAT_VRM - 212))
          | (1ULL << (RpgParser::SPLAT_ALLG - 212))
          | (1ULL << (RpgParser::SPLAT_ALLU - 212))
          | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
          | (1ULL << (RpgParser::SPLAT_ALLX - 212))
          | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
          | (1ULL << (RpgParser::SPLAT_CANCL - 212))
          | (1ULL << (RpgParser::SPLAT_CYMD - 212))
          | (1ULL << (RpgParser::SPLAT_CMDY - 212))
          | (1ULL << (RpgParser::SPLAT_CDMY - 212))
          | (1ULL << (RpgParser::SPLAT_MDY - 212))
          | (1ULL << (RpgParser::SPLAT_DMY - 212))
          | (1ULL << (RpgParser::SPLAT_DFT - 212))
          | (1ULL << (RpgParser::SPLAT_YMD - 212))
          | (1ULL << (RpgParser::SPLAT_JUL - 212))
          | (1ULL << (RpgParser::SPLAT_JAVA - 212))
          | (1ULL << (RpgParser::SPLAT_ISO - 212))
          | (1ULL << (RpgParser::SPLAT_USA - 212))
          | (1ULL << (RpgParser::SPLAT_EUR - 212))
          | (1ULL << (RpgParser::SPLAT_JIS - 212))
          | (1ULL << (RpgParser::SPLAT_DATE - 212))
          | (1ULL << (RpgParser::SPLAT_DAY - 212))
          | (1ULL << (RpgParser::SPlAT_DETC - 212))
          | (1ULL << (RpgParser::SPLAT_DETL - 212))
          | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
          | (1ULL << (RpgParser::SPLAT_END - 212))
          | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
          | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
          | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
          | (1ULL << (RpgParser::SPLAT_EXT - 212))
          | (1ULL << (RpgParser::SPLAT_FILE - 212))
          | (1ULL << (RpgParser::SPLAT_GETIN - 212))
          | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
          | (1ULL << (RpgParser::SPLAT_INIT - 212))
          | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
          | (1ULL << (RpgParser::SPLAT_INZSR - 212))
          | (1ULL << (RpgParser::SPLAT_IN - 212))
          | (1ULL << (RpgParser::SPLAT_INPUT - 212))
          | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
          | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
          | (1ULL << (RpgParser::SPLAT_JOB - 212))
          | (1ULL << (RpgParser::SPLAT_LDA - 212))
          | (1ULL << (RpgParser::SPLAT_LIKE - 212))
          | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
          | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
          | (1ULL << (RpgParser::SPLAT_KEY - 212))
          | (1ULL << (RpgParser::SPLAT_MONTH - 212))
          | (1ULL << (RpgParser::SPLAT_NEXT - 212))
          | (1ULL << (RpgParser::SPLAT_NOIND - 212))
          | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
          | (1ULL << (RpgParser::SPLAT_NULL - 212))
          | (1ULL << (RpgParser::SPLAT_OFL - 212))
          | (1ULL << (RpgParser::SPLAT_ON - 212))
          | (1ULL << (RpgParser::SPLAT_ONLY - 212))
          | (1ULL << (RpgParser::SPLAT_OFF - 212))
          | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
          | (1ULL << (RpgParser::SPLAT_PSSR - 276))
          | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
          | (1ULL << (RpgParser::SPLAT_START - 276))
          | (1ULL << (RpgParser::SPLAT_SYS - 276))
          | (1ULL << (RpgParser::SPLAT_TERM - 276))
          | (1ULL << (RpgParser::SPLAT_TOTC - 276))
          | (1ULL << (RpgParser::SPLAT_TOTL - 276))
          | (1ULL << (RpgParser::SPLAT_USER - 276))
          | (1ULL << (RpgParser::SPLAT_VAR - 276))
          | (1ULL << (RpgParser::SPLAT_YEAR - 276))
          | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
          | (1ULL << (RpgParser::SPLAT_HMS - 276))
          | (1ULL << (RpgParser::SPLAT_INLR - 276))
          | (1ULL << (RpgParser::SPLAT_INOF - 276))
          | (1ULL << (RpgParser::SPLAT_DATA - 276))
          | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
          | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
          | (1ULL << (RpgParser::SPLAT_MAX - 276))
          | (1ULL << (RpgParser::SPLAT_LOCK - 276))
          | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
          | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
          | (1ULL << (RpgParser::SPLAT_D - 276))
          | (1ULL << (RpgParser::SPLAT_H - 276))
          | (1ULL << (RpgParser::SPLAT_HOURS - 276))
          | (1ULL << (RpgParser::SPLAT_DAYS - 276))
          | (1ULL << (RpgParser::SPLAT_M - 276))
          | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
          | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
          | (1ULL << (RpgParser::SPLAT_MN - 276))
          | (1ULL << (RpgParser::SPLAT_MS - 276))
          | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
          | (1ULL << (RpgParser::SPLAT_S - 276))
          | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
          | (1ULL << (RpgParser::SPLAT_Y - 276))
          | (1ULL << (RpgParser::SPLAT_YEARS - 276))
          | (1ULL << (RpgParser::UDATE - 276))
          | (1ULL << (RpgParser::UMONTH - 276))
          | (1ULL << (RpgParser::UYEAR - 276))
          | (1ULL << (RpgParser::UDAY - 276))
          | (1ULL << (RpgParser::CHAR - 276))
          | (1ULL << (RpgParser::VARCHAR - 276))
          | (1ULL << (RpgParser::UCS2 - 276))
          | (1ULL << (RpgParser::DATE_ - 276))
          | (1ULL << (RpgParser::VARUCS2 - 276))
          | (1ULL << (RpgParser::GRAPH - 276))
          | (1ULL << (RpgParser::VARGRAPH - 276))
          | (1ULL << (RpgParser::IND - 276))
          | (1ULL << (RpgParser::PACKED - 276))
          | (1ULL << (RpgParser::ZONED - 276))
          | (1ULL << (RpgParser::BINDEC - 276))
          | (1ULL << (RpgParser::INT - 276))
          | (1ULL << (RpgParser::UNS - 276))
          | (1ULL << (RpgParser::FLOAT - 276))
          | (1ULL << (RpgParser::TIME - 276))
          | (1ULL << (RpgParser::TIMESTAMP - 276))
          | (1ULL << (RpgParser::POINTER - 276))
          | (1ULL << (RpgParser::OBJECT - 276))
          | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
          | (1ULL << (RpgParser::KEYWORD_ALT - 340))
          | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
          | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
          | (1ULL << (RpgParser::KEYWORD_BASED - 340))
          | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
          | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
          | (1ULL << (RpgParser::KEYWORD_CONST - 340))
          | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
          | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
          | (1ULL << (RpgParser::KEYWORD_DIM - 340))
          | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
          | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
          | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
          | (1ULL << (RpgParser::KEYWORD_INZ - 340))
          | (1ULL << (RpgParser::KEYWORD_LEN - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
          | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
          | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
          | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
          | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
          | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
          | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
          | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
          | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
          | (1ULL << (RpgParser::KEYWORD_POS - 340))
          | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
          | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
          | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
          | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
          | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
          | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
          | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
          | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
          | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
          | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
          | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
          | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
          | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
          | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
          | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
          | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
          | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
          | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
          | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
          | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
          | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
          | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
          | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
          | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
          | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
          | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
          | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
          | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
          | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
          | (1ULL << (RpgParser::KEYWORD_SLN - 404))
          | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
          | (1ULL << (RpgParser::KEYWORD_DISK - 404))
          | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
          | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
          | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
          | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
          | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
          | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
          | (1ULL << (RpgParser::NOT - 404))
          | (1ULL << (RpgParser::MULT_NOSPACE - 404))
          | (1ULL << (RpgParser::FREE_BY - 404))
          | (1ULL << (RpgParser::FREE_TO - 404))
          | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
          setState(2000);
          dcl_pi_field();
          setState(2005);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2006);
        end_dcl_pi();
        setState(2007);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::DS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(2009);
        piBegin();
        setState(2013);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2010);
            pi_parm_fixed(); 
          }
          setState(2015);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_pi_fieldContext ------------------------------------------------------------------

RpgParser::Dcl_pi_fieldContext::Dcl_pi_fieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::IdentifierContext* RpgParser::Dcl_pi_fieldContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::Dcl_pi_fieldContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::DatatypeContext* RpgParser::Dcl_pi_fieldContext::datatype() {
  return getRuleContext<RpgParser::DatatypeContext>(0);
}

tree::TerminalNode* RpgParser::Dcl_pi_fieldContext::DS_Parm() {
  return getToken(RpgParser::DS_Parm, 0);
}

RpgParser::Keyword_likeContext* RpgParser::Dcl_pi_fieldContext::keyword_like() {
  return getRuleContext<RpgParser::Keyword_likeContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dcl_pi_fieldContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dcl_pi_fieldContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::Dcl_pi_fieldContext::getRuleIndex() const {
  return RpgParser::RuleDcl_pi_field;
}

void RpgParser::Dcl_pi_fieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_pi_field(this);
}

void RpgParser::Dcl_pi_fieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_pi_field(this);
}


antlrcpp::Any RpgParser::Dcl_pi_fieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_pi_field(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_pi_fieldContext* RpgParser::dcl_pi_field() {
  Dcl_pi_fieldContext *_localctx = _tracker.createInstance<Dcl_pi_fieldContext>(_ctx, getState());
  enterRule(_localctx, 220, RpgParser::RuleDcl_pi_field);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2019);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::DS_Parm) {
      setState(2018);
      match(RpgParser::DS_Parm);
    }
    setState(2021);
    identifier();
    setState(2024);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT: {
        setState(2022);
        datatype();
        break;
      }

      case RpgParser::KEYWORD_LIKE: {
        setState(2023);
        dynamic_cast<Dcl_pi_fieldContext *>(_localctx)->like = keyword_like();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2029);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(2026);
      keyword();
      setState(2031);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2032);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_dcl_piContext ------------------------------------------------------------------

RpgParser::End_dcl_piContext::End_dcl_piContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::End_dcl_piContext::DS_ProcedureInterfaceEnd() {
  return getToken(RpgParser::DS_ProcedureInterfaceEnd, 0);
}


size_t RpgParser::End_dcl_piContext::getRuleIndex() const {
  return RpgParser::RuleEnd_dcl_pi;
}

void RpgParser::End_dcl_piContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_dcl_pi(this);
}

void RpgParser::End_dcl_piContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_dcl_pi(this);
}


antlrcpp::Any RpgParser::End_dcl_piContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEnd_dcl_pi(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::End_dcl_piContext* RpgParser::end_dcl_pi() {
  End_dcl_piContext *_localctx = _tracker.createInstance<End_dcl_piContext>(_ctx, getState());
  enterRule(_localctx, 222, RpgParser::RuleEnd_dcl_pi);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2034);
    match(RpgParser::DS_ProcedureInterfaceEnd);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dcl_cContext ------------------------------------------------------------------

RpgParser::Dcl_cContext::Dcl_cContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dcl_cContext::DS_Constant() {
  return getToken(RpgParser::DS_Constant, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::IdentifierContext* RpgParser::Dcl_cContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Keyword_constContext* RpgParser::Dcl_cContext::keyword_const() {
  return getRuleContext<RpgParser::Keyword_constContext>(0);
}

RpgParser::LiteralContext* RpgParser::Dcl_cContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::SPLAT_ON() {
  return getToken(RpgParser::SPLAT_ON, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::SPLAT_OFF() {
  return getToken(RpgParser::SPLAT_OFF, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::SPLAT_ZEROS() {
  return getToken(RpgParser::SPLAT_ZEROS, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::SPLAT_BLANKS() {
  return getToken(RpgParser::SPLAT_BLANKS, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::Dcl_cContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::DEF_TYPE_C() {
  return getToken(RpgParser::DEF_TYPE_C, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Dcl_cContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Dspec_bifContext* RpgParser::Dcl_cContext::dspec_bif() {
  return getRuleContext<RpgParser::Dspec_bifContext>(0);
}


size_t RpgParser::Dcl_cContext::getRuleIndex() const {
  return RpgParser::RuleDcl_c;
}

void RpgParser::Dcl_cContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDcl_c(this);
}

void RpgParser::Dcl_cContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDcl_c(this);
}


antlrcpp::Any RpgParser::Dcl_cContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDcl_c(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dcl_cContext* RpgParser::dcl_c() {
  Dcl_cContext *_localctx = _tracker.createInstance<Dcl_cContext>(_ctx, getState());
  enterRule(_localctx, 224, RpgParser::RuleDcl_c);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2069);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::DS_Constant: {
        enterOuterAlt(_localctx, 1);
        setState(2036);
        match(RpgParser::DS_Constant);
        setState(2037);
        dynamic_cast<Dcl_cContext *>(_localctx)->name = identifier();
        setState(2044);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::KEYWORD_CONST: {
            setState(2038);
            keyword_const();
            break;
          }

          case RpgParser::HexLiteralStart:
          case RpgParser::DateLiteralStart:
          case RpgParser::TimeLiteralStart:
          case RpgParser::TimeStampLiteralStart:
          case RpgParser::GraphicLiteralStart:
          case RpgParser::UCS2LiteralStart:
          case RpgParser::StringLiteralStart: {
            setState(2039);
            literal();
            break;
          }

          case RpgParser::SPLAT_ON: {
            setState(2040);
            match(RpgParser::SPLAT_ON);
            break;
          }

          case RpgParser::SPLAT_OFF: {
            setState(2041);
            match(RpgParser::SPLAT_OFF);
            break;
          }

          case RpgParser::SPLAT_ZEROS: {
            setState(2042);
            match(RpgParser::SPLAT_ZEROS);
            break;
          }

          case RpgParser::SPLAT_BLANKS: {
            setState(2043);
            match(RpgParser::SPLAT_BLANKS);
            break;
          }

          case RpgParser::FREE_SEMI: {
            break;
          }

        default:
          break;
        }
        setState(2046);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::DS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(2048);
        match(RpgParser::DS_FIXED);
        setState(2049);
        ds_name();
        setState(2050);
        match(RpgParser::EXTERNAL_DESCRIPTION);
        setState(2051);
        match(RpgParser::DATA_STRUCTURE_TYPE);
        setState(2052);
        match(RpgParser::DEF_TYPE_C);
        setState(2053);
        match(RpgParser::FROM_POSITION);
        setState(2054);
        match(RpgParser::TO_POSITION);
        setState(2055);
        match(RpgParser::DATA_TYPE);
        setState(2056);
        match(RpgParser::DECIMAL_POSITIONS);
        setState(2057);
        match(RpgParser::RESERVED);
        setState(2065);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::KEYWORD_CONST: {
            setState(2058);
            keyword_const();
            break;
          }

          case RpgParser::HexLiteralStart:
          case RpgParser::DateLiteralStart:
          case RpgParser::TimeLiteralStart:
          case RpgParser::TimeStampLiteralStart:
          case RpgParser::GraphicLiteralStart:
          case RpgParser::UCS2LiteralStart:
          case RpgParser::StringLiteralStart: {
            setState(2059);
            literal();
            break;
          }

          case RpgParser::BIF_ELEM: {
            setState(2060);
            dspec_bif();
            break;
          }

          case RpgParser::SPLAT_ON: {
            setState(2061);
            match(RpgParser::SPLAT_ON);
            break;
          }

          case RpgParser::SPLAT_OFF: {
            setState(2062);
            match(RpgParser::SPLAT_OFF);
            break;
          }

          case RpgParser::SPLAT_ZEROS: {
            setState(2063);
            match(RpgParser::SPLAT_ZEROS);
            break;
          }

          case RpgParser::SPLAT_BLANKS: {
            setState(2064);
            match(RpgParser::SPLAT_BLANKS);
            break;
          }

          case RpgParser::EOF:
          case RpgParser::EOL: {
            break;
          }

        default:
          break;
        }
        setState(2067);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ctl_optContext ------------------------------------------------------------------

RpgParser::Ctl_optContext::Ctl_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Ctl_optContext::H_SPEC() {
  return getToken(RpgParser::H_SPEC, 0);
}

tree::TerminalNode* RpgParser::Ctl_optContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Ctl_optContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Ctl_optContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Ctl_optContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Ctl_optContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Ctl_optContext::getRuleIndex() const {
  return RpgParser::RuleCtl_opt;
}

void RpgParser::Ctl_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCtl_opt(this);
}

void RpgParser::Ctl_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCtl_opt(this);
}


antlrcpp::Any RpgParser::Ctl_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCtl_opt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Ctl_optContext* RpgParser::ctl_opt() {
  Ctl_optContext *_localctx = _tracker.createInstance<Ctl_optContext>(_ctx, getState());
  enterRule(_localctx, 226, RpgParser::RuleCtl_opt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2071);
    match(RpgParser::H_SPEC);
    setState(2076);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::PLUS - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(2074);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
      case 1: {
        setState(2072);
        identifier();
        break;
      }

      case 2: {
        setState(2073);
        expression(0);
        break;
      }

      }
      setState(2078);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2079);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DatatypeNameContext ------------------------------------------------------------------

RpgParser::DatatypeNameContext::DatatypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::DatatypeNameContext::CHAR() {
  return getToken(RpgParser::CHAR, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::DATE_() {
  return getToken(RpgParser::DATE_, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::VARCHAR() {
  return getToken(RpgParser::VARCHAR, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::UCS2() {
  return getToken(RpgParser::UCS2, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::VARUCS2() {
  return getToken(RpgParser::VARUCS2, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::GRAPH() {
  return getToken(RpgParser::GRAPH, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::VARGRAPH() {
  return getToken(RpgParser::VARGRAPH, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::IND() {
  return getToken(RpgParser::IND, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::PACKED() {
  return getToken(RpgParser::PACKED, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::ZONED() {
  return getToken(RpgParser::ZONED, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::BINDEC() {
  return getToken(RpgParser::BINDEC, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::INT() {
  return getToken(RpgParser::INT, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::UNS() {
  return getToken(RpgParser::UNS, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::FLOAT() {
  return getToken(RpgParser::FLOAT, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::TIME() {
  return getToken(RpgParser::TIME, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::TIMESTAMP() {
  return getToken(RpgParser::TIMESTAMP, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::POINTER() {
  return getToken(RpgParser::POINTER, 0);
}

tree::TerminalNode* RpgParser::DatatypeNameContext::OBJECT() {
  return getToken(RpgParser::OBJECT, 0);
}


size_t RpgParser::DatatypeNameContext::getRuleIndex() const {
  return RpgParser::RuleDatatypeName;
}

void RpgParser::DatatypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatatypeName(this);
}

void RpgParser::DatatypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatatypeName(this);
}


antlrcpp::Any RpgParser::DatatypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDatatypeName(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DatatypeNameContext* RpgParser::datatypeName() {
  DatatypeNameContext *_localctx = _tracker.createInstance<DatatypeNameContext>(_ctx, getState());
  enterRule(_localctx, 228, RpgParser::RuleDatatypeName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2081);
    _la = _input->LA(1);
    if (!(((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & ((1ULL << (RpgParser::CHAR - 321))
      | (1ULL << (RpgParser::VARCHAR - 321))
      | (1ULL << (RpgParser::UCS2 - 321))
      | (1ULL << (RpgParser::DATE_ - 321))
      | (1ULL << (RpgParser::VARUCS2 - 321))
      | (1ULL << (RpgParser::GRAPH - 321))
      | (1ULL << (RpgParser::VARGRAPH - 321))
      | (1ULL << (RpgParser::IND - 321))
      | (1ULL << (RpgParser::PACKED - 321))
      | (1ULL << (RpgParser::ZONED - 321))
      | (1ULL << (RpgParser::BINDEC - 321))
      | (1ULL << (RpgParser::INT - 321))
      | (1ULL << (RpgParser::UNS - 321))
      | (1ULL << (RpgParser::FLOAT - 321))
      | (1ULL << (RpgParser::TIME - 321))
      | (1ULL << (RpgParser::TIMESTAMP - 321))
      | (1ULL << (RpgParser::POINTER - 321))
      | (1ULL << (RpgParser::OBJECT - 321)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

RpgParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::EnddoContext* RpgParser::BlockContext::enddo() {
  return getRuleContext<RpgParser::EnddoContext>(0);
}

RpgParser::CsDOUxxContext* RpgParser::BlockContext::csDOUxx() {
  return getRuleContext<RpgParser::CsDOUxxContext>(0);
}

RpgParser::CsDOWxxContext* RpgParser::BlockContext::csDOWxx() {
  return getRuleContext<RpgParser::CsDOWxxContext>(0);
}

RpgParser::BegindouContext* RpgParser::BlockContext::begindou() {
  return getRuleContext<RpgParser::BegindouContext>(0);
}

RpgParser::BegindowContext* RpgParser::BlockContext::begindow() {
  return getRuleContext<RpgParser::BegindowContext>(0);
}

RpgParser::BegindoContext* RpgParser::BlockContext::begindo() {
  return getRuleContext<RpgParser::BegindoContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::BlockContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::BlockContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}

RpgParser::IfstatementContext* RpgParser::BlockContext::ifstatement() {
  return getRuleContext<RpgParser::IfstatementContext>(0);
}

RpgParser::SelectstatementContext* RpgParser::BlockContext::selectstatement() {
  return getRuleContext<RpgParser::SelectstatementContext>(0);
}

RpgParser::ForstatementContext* RpgParser::BlockContext::forstatement() {
  return getRuleContext<RpgParser::ForstatementContext>(0);
}

RpgParser::MonitorstatementContext* RpgParser::BlockContext::monitorstatement() {
  return getRuleContext<RpgParser::MonitorstatementContext>(0);
}

RpgParser::CasestatementContext* RpgParser::BlockContext::casestatement() {
  return getRuleContext<RpgParser::CasestatementContext>(0);
}


size_t RpgParser::BlockContext::getRuleIndex() const {
  return RpgParser::RuleBlock;
}

void RpgParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void RpgParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}


antlrcpp::Any RpgParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BlockContext* RpgParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 230, RpgParser::RuleBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2103);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2088);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
      case 1: {
        setState(2083);
        csDOUxx();
        break;
      }

      case 2: {
        setState(2084);
        csDOWxx();
        break;
      }

      case 3: {
        setState(2085);
        begindou();
        break;
      }

      case 4: {
        setState(2086);
        begindow();
        break;
      }

      case 5: {
        setState(2087);
        begindo();
        break;
      }

      }
      setState(2093);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2090);
          statement(); 
        }
        setState(2095);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      }
      setState(2096);
      enddo();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2098);
      ifstatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2099);
      selectstatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2100);
      forstatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2101);
      monitorstatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2102);
      casestatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfstatementContext ------------------------------------------------------------------

RpgParser::IfstatementContext::IfstatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::BeginifContext* RpgParser::IfstatementContext::beginif() {
  return getRuleContext<RpgParser::BeginifContext>(0);
}

RpgParser::EndifContext* RpgParser::IfstatementContext::endif() {
  return getRuleContext<RpgParser::EndifContext>(0);
}

std::vector<RpgParser::ElseIfClauseContext *> RpgParser::IfstatementContext::elseIfClause() {
  return getRuleContexts<RpgParser::ElseIfClauseContext>();
}

RpgParser::ElseIfClauseContext* RpgParser::IfstatementContext::elseIfClause(size_t i) {
  return getRuleContext<RpgParser::ElseIfClauseContext>(i);
}

RpgParser::ElseClauseContext* RpgParser::IfstatementContext::elseClause() {
  return getRuleContext<RpgParser::ElseClauseContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::IfstatementContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::IfstatementContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}


size_t RpgParser::IfstatementContext::getRuleIndex() const {
  return RpgParser::RuleIfstatement;
}

void RpgParser::IfstatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfstatement(this);
}

void RpgParser::IfstatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfstatement(this);
}


antlrcpp::Any RpgParser::IfstatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIfstatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::IfstatementContext* RpgParser::ifstatement() {
  IfstatementContext *_localctx = _tracker.createInstance<IfstatementContext>(_ctx, getState());
  enterRule(_localctx, 232, RpgParser::RuleIfstatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2105);
    beginif();
    setState(2109);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2106);
        dynamic_cast<IfstatementContext *>(_localctx)->statementContext = statement();
        dynamic_cast<IfstatementContext *>(_localctx)->thenBody.push_back(dynamic_cast<IfstatementContext *>(_localctx)->statementContext); 
      }
      setState(2111);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
    }
    setState(2115);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2112);
        elseIfClause(); 
      }
      setState(2117);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx);
    }
    setState(2119);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      setState(2118);
      elseClause();
      break;
    }

    }
    setState(2121);
    endif();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseIfClauseContext ------------------------------------------------------------------

RpgParser::ElseIfClauseContext::ElseIfClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ElseifstmtContext* RpgParser::ElseIfClauseContext::elseifstmt() {
  return getRuleContext<RpgParser::ElseifstmtContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::ElseIfClauseContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::ElseIfClauseContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}


size_t RpgParser::ElseIfClauseContext::getRuleIndex() const {
  return RpgParser::RuleElseIfClause;
}

void RpgParser::ElseIfClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseIfClause(this);
}

void RpgParser::ElseIfClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseIfClause(this);
}


antlrcpp::Any RpgParser::ElseIfClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitElseIfClause(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ElseIfClauseContext* RpgParser::elseIfClause() {
  ElseIfClauseContext *_localctx = _tracker.createInstance<ElseIfClauseContext>(_ctx, getState());
  enterRule(_localctx, 234, RpgParser::RuleElseIfClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2123);
    elseifstmt();
    setState(2127);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2124);
        statement(); 
      }
      setState(2129);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseClauseContext ------------------------------------------------------------------

RpgParser::ElseClauseContext::ElseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ElsestmtContext* RpgParser::ElseClauseContext::elsestmt() {
  return getRuleContext<RpgParser::ElsestmtContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::ElseClauseContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::ElseClauseContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}


size_t RpgParser::ElseClauseContext::getRuleIndex() const {
  return RpgParser::RuleElseClause;
}

void RpgParser::ElseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseClause(this);
}

void RpgParser::ElseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseClause(this);
}


antlrcpp::Any RpgParser::ElseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitElseClause(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ElseClauseContext* RpgParser::elseClause() {
  ElseClauseContext *_localctx = _tracker.createInstance<ElseClauseContext>(_ctx, getState());
  enterRule(_localctx, 236, RpgParser::RuleElseClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2130);
    elsestmt();
    setState(2134);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2131);
        statement(); 
      }
      setState(2136);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CasestatementContext ------------------------------------------------------------------

RpgParser::CasestatementContext::CasestatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CasestatementendContext* RpgParser::CasestatementContext::casestatementend() {
  return getRuleContext<RpgParser::CasestatementendContext>(0);
}

std::vector<tree::TerminalNode *> RpgParser::CasestatementContext::CS_FIXED() {
  return getTokens(RpgParser::CS_FIXED);
}

tree::TerminalNode* RpgParser::CasestatementContext::CS_FIXED(size_t i) {
  return getToken(RpgParser::CS_FIXED, i);
}

std::vector<RpgParser::Cs_controlLevelContext *> RpgParser::CasestatementContext::cs_controlLevel() {
  return getRuleContexts<RpgParser::Cs_controlLevelContext>();
}

RpgParser::Cs_controlLevelContext* RpgParser::CasestatementContext::cs_controlLevel(size_t i) {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(i);
}

std::vector<RpgParser::CsCASEQContext *> RpgParser::CasestatementContext::csCASEQ() {
  return getRuleContexts<RpgParser::CsCASEQContext>();
}

RpgParser::CsCASEQContext* RpgParser::CasestatementContext::csCASEQ(size_t i) {
  return getRuleContext<RpgParser::CsCASEQContext>(i);
}

std::vector<RpgParser::CsCASNEContext *> RpgParser::CasestatementContext::csCASNE() {
  return getRuleContexts<RpgParser::CsCASNEContext>();
}

RpgParser::CsCASNEContext* RpgParser::CasestatementContext::csCASNE(size_t i) {
  return getRuleContext<RpgParser::CsCASNEContext>(i);
}

std::vector<RpgParser::CsCASLEContext *> RpgParser::CasestatementContext::csCASLE() {
  return getRuleContexts<RpgParser::CsCASLEContext>();
}

RpgParser::CsCASLEContext* RpgParser::CasestatementContext::csCASLE(size_t i) {
  return getRuleContext<RpgParser::CsCASLEContext>(i);
}

std::vector<RpgParser::CsCASLTContext *> RpgParser::CasestatementContext::csCASLT() {
  return getRuleContexts<RpgParser::CsCASLTContext>();
}

RpgParser::CsCASLTContext* RpgParser::CasestatementContext::csCASLT(size_t i) {
  return getRuleContext<RpgParser::CsCASLTContext>(i);
}

std::vector<RpgParser::CsCASGEContext *> RpgParser::CasestatementContext::csCASGE() {
  return getRuleContexts<RpgParser::CsCASGEContext>();
}

RpgParser::CsCASGEContext* RpgParser::CasestatementContext::csCASGE(size_t i) {
  return getRuleContext<RpgParser::CsCASGEContext>(i);
}

std::vector<RpgParser::CsCASGTContext *> RpgParser::CasestatementContext::csCASGT() {
  return getRuleContexts<RpgParser::CsCASGTContext>();
}

RpgParser::CsCASGTContext* RpgParser::CasestatementContext::csCASGT(size_t i) {
  return getRuleContext<RpgParser::CsCASGTContext>(i);
}

std::vector<RpgParser::CsCASContext *> RpgParser::CasestatementContext::csCAS() {
  return getRuleContexts<RpgParser::CsCASContext>();
}

RpgParser::CsCASContext* RpgParser::CasestatementContext::csCAS(size_t i) {
  return getRuleContext<RpgParser::CsCASContext>(i);
}

std::vector<RpgParser::OnOffIndicatorsFlagContext *> RpgParser::CasestatementContext::onOffIndicatorsFlag() {
  return getRuleContexts<RpgParser::OnOffIndicatorsFlagContext>();
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CasestatementContext::onOffIndicatorsFlag(size_t i) {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(i);
}

std::vector<RpgParser::Cs_indicatorsContext *> RpgParser::CasestatementContext::cs_indicators() {
  return getRuleContexts<RpgParser::Cs_indicatorsContext>();
}

RpgParser::Cs_indicatorsContext* RpgParser::CasestatementContext::cs_indicators(size_t i) {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(i);
}

std::vector<RpgParser::FactorContext *> RpgParser::CasestatementContext::factor() {
  return getRuleContexts<RpgParser::FactorContext>();
}

RpgParser::FactorContext* RpgParser::CasestatementContext::factor(size_t i) {
  return getRuleContext<RpgParser::FactorContext>(i);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CasestatementContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CasestatementContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::CasestatementContext::getRuleIndex() const {
  return RpgParser::RuleCasestatement;
}

void RpgParser::CasestatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCasestatement(this);
}

void RpgParser::CasestatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCasestatement(this);
}


antlrcpp::Any RpgParser::CasestatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCasestatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CasestatementContext* RpgParser::casestatement() {
  CasestatementContext *_localctx = _tracker.createInstance<CasestatementContext>(_ctx, getState());
  enterRule(_localctx, 238, RpgParser::RuleCasestatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2158); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2137);
              match(RpgParser::CS_FIXED);
              setState(2141);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
              while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                if (alt == 1) {
                  setState(2138);
                  cspec_continuedIndicators(); 
                }
                setState(2143);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
              }
              setState(2144);
              cs_controlLevel();
              setState(2145);
              dynamic_cast<CasestatementContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
              setState(2146);
              dynamic_cast<CasestatementContext *>(_localctx)->indicators = cs_indicators();
              setState(2147);
              dynamic_cast<CasestatementContext *>(_localctx)->factor1 = factor();
              setState(2156);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case RpgParser::OP_CASEQ: {
                  setState(2149);
                  csCASEQ();
                  break;
                }

                case RpgParser::OP_CASNE: {
                  setState(2150);
                  csCASNE();
                  break;
                }

                case RpgParser::OP_CASLE: {
                  setState(2151);
                  csCASLE();
                  break;
                }

                case RpgParser::OP_CASLT: {
                  setState(2152);
                  csCASLT();
                  break;
                }

                case RpgParser::OP_CASGE: {
                  setState(2153);
                  csCASGE();
                  break;
                }

                case RpgParser::OP_CASGT: {
                  setState(2154);
                  csCASGT();
                  break;
                }

                case RpgParser::OP_CAS: {
                  setState(2155);
                  csCAS();
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2160); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(2162);
    casestatementend();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CasestatementendContext ------------------------------------------------------------------

RpgParser::CasestatementendContext::CasestatementendContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CasestatementendContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CasestatementendContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CasestatementendContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CasestatementendContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CasestatementendContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsENDContext* RpgParser::CasestatementendContext::csEND() {
  return getRuleContext<RpgParser::CsENDContext>(0);
}

RpgParser::CsENDCSContext* RpgParser::CasestatementendContext::csENDCS() {
  return getRuleContext<RpgParser::CsENDCSContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CasestatementendContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CasestatementendContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::CasestatementendContext::getRuleIndex() const {
  return RpgParser::RuleCasestatementend;
}

void RpgParser::CasestatementendContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCasestatementend(this);
}

void RpgParser::CasestatementendContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCasestatementend(this);
}


antlrcpp::Any RpgParser::CasestatementendContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCasestatementend(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CasestatementendContext* RpgParser::casestatementend() {
  CasestatementendContext *_localctx = _tracker.createInstance<CasestatementendContext>(_ctx, getState());
  enterRule(_localctx, 240, RpgParser::RuleCasestatementend);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2164);
    match(RpgParser::CS_FIXED);
    setState(2168);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2165);
        cspec_continuedIndicators(); 
      }
      setState(2170);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    }
    setState(2171);
    cs_controlLevel();
    setState(2172);
    dynamic_cast<CasestatementendContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2173);
    dynamic_cast<CasestatementendContext *>(_localctx)->indicators = cs_indicators();
    setState(2174);
    dynamic_cast<CasestatementendContext *>(_localctx)->factor1 = factor();
    setState(2177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_END: {
        setState(2175);
        csEND();
        break;
      }

      case RpgParser::OP_ENDCS: {
        setState(2176);
        csENDCS();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MonitorstatementContext ------------------------------------------------------------------

RpgParser::MonitorstatementContext::MonitorstatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::BeginmonitorContext* RpgParser::MonitorstatementContext::beginmonitor() {
  return getRuleContext<RpgParser::BeginmonitorContext>(0);
}

RpgParser::EndmonitorContext* RpgParser::MonitorstatementContext::endmonitor() {
  return getRuleContext<RpgParser::EndmonitorContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::MonitorstatementContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::MonitorstatementContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}

std::vector<RpgParser::OnErrorContext *> RpgParser::MonitorstatementContext::onError() {
  return getRuleContexts<RpgParser::OnErrorContext>();
}

RpgParser::OnErrorContext* RpgParser::MonitorstatementContext::onError(size_t i) {
  return getRuleContext<RpgParser::OnErrorContext>(i);
}


size_t RpgParser::MonitorstatementContext::getRuleIndex() const {
  return RpgParser::RuleMonitorstatement;
}

void RpgParser::MonitorstatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMonitorstatement(this);
}

void RpgParser::MonitorstatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMonitorstatement(this);
}


antlrcpp::Any RpgParser::MonitorstatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitMonitorstatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::MonitorstatementContext* RpgParser::monitorstatement() {
  MonitorstatementContext *_localctx = _tracker.createInstance<MonitorstatementContext>(_ctx, getState());
  enterRule(_localctx, 242, RpgParser::RuleMonitorstatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2179);
    beginmonitor();
    setState(2183);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2180);
        statement(); 
      }
      setState(2185);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
    }
    setState(2189);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2186);
        onError(); 
      }
      setState(2191);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx);
    }
    setState(2192);
    endmonitor();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginmonitorContext ------------------------------------------------------------------

RpgParser::BeginmonitorContext::BeginmonitorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Op_monitorContext* RpgParser::BeginmonitorContext::op_monitor() {
  return getRuleContext<RpgParser::Op_monitorContext>(0);
}

tree::TerminalNode* RpgParser::BeginmonitorContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

tree::TerminalNode* RpgParser::BeginmonitorContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BeginmonitorContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsMONITORContext* RpgParser::BeginmonitorContext::csMONITOR() {
  return getRuleContext<RpgParser::CsMONITORContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BeginmonitorContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BeginmonitorContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BeginmonitorContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BeginmonitorContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BeginmonitorContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::BeginmonitorContext::getRuleIndex() const {
  return RpgParser::RuleBeginmonitor;
}

void RpgParser::BeginmonitorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginmonitor(this);
}

void RpgParser::BeginmonitorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginmonitor(this);
}


antlrcpp::Any RpgParser::BeginmonitorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBeginmonitor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BeginmonitorContext* RpgParser::beginmonitor() {
  BeginmonitorContext *_localctx = _tracker.createInstance<BeginmonitorContext>(_ctx, getState());
  enterRule(_localctx, 244, RpgParser::RuleBeginmonitor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2210);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_MONITOR: {
        enterOuterAlt(_localctx, 1);
        setState(2194);
        op_monitor();
        setState(2195);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(2197);
        match(RpgParser::CS_FIXED);
        setState(2201);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2198);
            cspec_continuedIndicators(); 
          }
          setState(2203);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
        }
        setState(2204);
        cs_controlLevel();
        setState(2205);
        dynamic_cast<BeginmonitorContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2206);
        dynamic_cast<BeginmonitorContext *>(_localctx)->indicators = cs_indicators();
        setState(2207);
        dynamic_cast<BeginmonitorContext *>(_localctx)->factor1 = factor();
        setState(2208);
        csMONITOR();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndmonitorContext ------------------------------------------------------------------

RpgParser::EndmonitorContext::EndmonitorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Op_endmonContext* RpgParser::EndmonitorContext::op_endmon() {
  return getRuleContext<RpgParser::Op_endmonContext>(0);
}

tree::TerminalNode* RpgParser::EndmonitorContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

tree::TerminalNode* RpgParser::EndmonitorContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::EndmonitorContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsENDMONContext* RpgParser::EndmonitorContext::csENDMON() {
  return getRuleContext<RpgParser::CsENDMONContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::EndmonitorContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::EndmonitorContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::EndmonitorContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::EndmonitorContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::EndmonitorContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::EndmonitorContext::getRuleIndex() const {
  return RpgParser::RuleEndmonitor;
}

void RpgParser::EndmonitorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndmonitor(this);
}

void RpgParser::EndmonitorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndmonitor(this);
}


antlrcpp::Any RpgParser::EndmonitorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndmonitor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndmonitorContext* RpgParser::endmonitor() {
  EndmonitorContext *_localctx = _tracker.createInstance<EndmonitorContext>(_ctx, getState());
  enterRule(_localctx, 246, RpgParser::RuleEndmonitor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2228);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_ENDMON: {
        enterOuterAlt(_localctx, 1);
        setState(2212);
        op_endmon();
        setState(2213);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(2215);
        match(RpgParser::CS_FIXED);
        setState(2219);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2216);
            cspec_continuedIndicators(); 
          }
          setState(2221);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
        }
        setState(2222);
        cs_controlLevel();
        setState(2223);
        dynamic_cast<EndmonitorContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2224);
        dynamic_cast<EndmonitorContext *>(_localctx)->indicators = cs_indicators();
        setState(2225);
        dynamic_cast<EndmonitorContext *>(_localctx)->factor1 = factor();
        setState(2226);
        csENDMON();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnErrorContext ------------------------------------------------------------------

RpgParser::OnErrorContext::OnErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::OnErrorContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::OnErrorContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsON_ERRORContext* RpgParser::OnErrorContext::csON_ERROR() {
  return getRuleContext<RpgParser::CsON_ERRORContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::OnErrorContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::OnErrorContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::OnErrorContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::OnErrorContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::OnErrorContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}

RpgParser::Op_on_errorContext* RpgParser::OnErrorContext::op_on_error() {
  return getRuleContext<RpgParser::Op_on_errorContext>(0);
}

tree::TerminalNode* RpgParser::OnErrorContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::OnErrorContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::OnErrorContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::OnErrorContext::getRuleIndex() const {
  return RpgParser::RuleOnError;
}

void RpgParser::OnErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnError(this);
}

void RpgParser::OnErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnError(this);
}


antlrcpp::Any RpgParser::OnErrorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOnError(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OnErrorContext* RpgParser::onError() {
  OnErrorContext *_localctx = _tracker.createInstance<OnErrorContext>(_ctx, getState());
  enterRule(_localctx, 248, RpgParser::RuleOnError);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2246);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_ON_ERROR: {
        setState(2230);
        op_on_error();
        setState(2231);
        match(RpgParser::FREE_SEMI);
        break;
      }

      case RpgParser::CS_FIXED: {
        setState(2233);
        match(RpgParser::CS_FIXED);
        setState(2237);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2234);
            cspec_continuedIndicators(); 
          }
          setState(2239);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
        }
        setState(2240);
        cs_controlLevel();
        setState(2241);
        dynamic_cast<OnErrorContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2242);
        dynamic_cast<OnErrorContext *>(_localctx)->indicators = cs_indicators();
        setState(2243);
        dynamic_cast<OnErrorContext *>(_localctx)->factor1 = factor();
        setState(2244);
        csON_ERROR();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2251);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2248);
        statement(); 
      }
      setState(2253);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectstatementContext ------------------------------------------------------------------

RpgParser::SelectstatementContext::SelectstatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::BeginselectContext* RpgParser::SelectstatementContext::beginselect() {
  return getRuleContext<RpgParser::BeginselectContext>(0);
}

RpgParser::EndselectContext* RpgParser::SelectstatementContext::endselect() {
  return getRuleContext<RpgParser::EndselectContext>(0);
}

std::vector<RpgParser::WhenstatementContext *> RpgParser::SelectstatementContext::whenstatement() {
  return getRuleContexts<RpgParser::WhenstatementContext>();
}

RpgParser::WhenstatementContext* RpgParser::SelectstatementContext::whenstatement(size_t i) {
  return getRuleContext<RpgParser::WhenstatementContext>(i);
}

RpgParser::OtherContext* RpgParser::SelectstatementContext::other() {
  return getRuleContext<RpgParser::OtherContext>(0);
}


size_t RpgParser::SelectstatementContext::getRuleIndex() const {
  return RpgParser::RuleSelectstatement;
}

void RpgParser::SelectstatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectstatement(this);
}

void RpgParser::SelectstatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectstatement(this);
}


antlrcpp::Any RpgParser::SelectstatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSelectstatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::SelectstatementContext* RpgParser::selectstatement() {
  SelectstatementContext *_localctx = _tracker.createInstance<SelectstatementContext>(_ctx, getState());
  enterRule(_localctx, 250, RpgParser::RuleSelectstatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2254);
    beginselect();
    setState(2258);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2255);
        whenstatement(); 
      }
      setState(2260);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx);
    }
    setState(2262);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(2261);
      other();
      break;
    }

    }
    setState(2264);
    endselect();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherContext ------------------------------------------------------------------

RpgParser::OtherContext::OtherContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::OtherContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::OtherContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsOTHERContext* RpgParser::OtherContext::csOTHER() {
  return getRuleContext<RpgParser::CsOTHERContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::OtherContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::OtherContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::OtherContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::OtherContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::OtherContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_otherContext* RpgParser::OtherContext::op_other() {
  return getRuleContext<RpgParser::Op_otherContext>(0);
}

tree::TerminalNode* RpgParser::OtherContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::OtherContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::OtherContext::getRuleIndex() const {
  return RpgParser::RuleOther;
}

void RpgParser::OtherContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOther(this);
}

void RpgParser::OtherContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOther(this);
}


antlrcpp::Any RpgParser::OtherContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOther(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OtherContext* RpgParser::other() {
  OtherContext *_localctx = _tracker.createInstance<OtherContext>(_ctx, getState());
  enterRule(_localctx, 252, RpgParser::RuleOther);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2284);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2266);
        match(RpgParser::CS_FIXED);
        setState(2270);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2267);
            cspec_continuedIndicators(); 
          }
          setState(2272);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx);
        }
        setState(2273);
        cs_controlLevel();
        setState(2274);
        dynamic_cast<OtherContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2275);
        dynamic_cast<OtherContext *>(_localctx)->indicators = cs_indicators();
        setState(2276);
        dynamic_cast<OtherContext *>(_localctx)->factor1 = factor();
        setState(2277);
        csOTHER();
        break;
      }

      case RpgParser::OP_OTHER: {
        enterOuterAlt(_localctx, 2);
        setState(2279);
        op_other();
        setState(2280);
        match(RpgParser::FREE_SEMI);
        setState(2282);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::COMMENTS) {
          setState(2281);
          free_linecomments();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginselectContext ------------------------------------------------------------------

RpgParser::BeginselectContext::BeginselectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::BeginselectContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BeginselectContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsSELECTContext* RpgParser::BeginselectContext::csSELECT() {
  return getRuleContext<RpgParser::CsSELECTContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BeginselectContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BeginselectContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BeginselectContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BeginselectContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BeginselectContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_selectContext* RpgParser::BeginselectContext::op_select() {
  return getRuleContext<RpgParser::Op_selectContext>(0);
}

tree::TerminalNode* RpgParser::BeginselectContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::BeginselectContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::BeginselectContext::getRuleIndex() const {
  return RpgParser::RuleBeginselect;
}

void RpgParser::BeginselectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginselect(this);
}

void RpgParser::BeginselectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginselect(this);
}


antlrcpp::Any RpgParser::BeginselectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBeginselect(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BeginselectContext* RpgParser::beginselect() {
  BeginselectContext *_localctx = _tracker.createInstance<BeginselectContext>(_ctx, getState());
  enterRule(_localctx, 254, RpgParser::RuleBeginselect);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2304);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2286);
        match(RpgParser::CS_FIXED);
        setState(2290);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2287);
            cspec_continuedIndicators(); 
          }
          setState(2292);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
        }
        setState(2293);
        cs_controlLevel();
        setState(2294);
        dynamic_cast<BeginselectContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2295);
        dynamic_cast<BeginselectContext *>(_localctx)->indicators = cs_indicators();
        setState(2296);
        dynamic_cast<BeginselectContext *>(_localctx)->factor1 = factor();
        setState(2297);
        csSELECT();
        break;
      }

      case RpgParser::OP_SELECT: {
        enterOuterAlt(_localctx, 2);
        setState(2299);
        op_select();
        setState(2300);
        match(RpgParser::FREE_SEMI);
        setState(2302);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::COMMENTS) {
          setState(2301);
          free_linecomments();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenstatementContext ------------------------------------------------------------------

RpgParser::WhenstatementContext::WhenstatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsWHENxxContext* RpgParser::WhenstatementContext::csWHENxx() {
  return getRuleContext<RpgParser::CsWHENxxContext>(0);
}

RpgParser::WhenContext* RpgParser::WhenstatementContext::when() {
  return getRuleContext<RpgParser::WhenContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::WhenstatementContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::WhenstatementContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}


size_t RpgParser::WhenstatementContext::getRuleIndex() const {
  return RpgParser::RuleWhenstatement;
}

void RpgParser::WhenstatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenstatement(this);
}

void RpgParser::WhenstatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenstatement(this);
}


antlrcpp::Any RpgParser::WhenstatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitWhenstatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::WhenstatementContext* RpgParser::whenstatement() {
  WhenstatementContext *_localctx = _tracker.createInstance<WhenstatementContext>(_ctx, getState());
  enterRule(_localctx, 256, RpgParser::RuleWhenstatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2308);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      setState(2306);
      csWHENxx();
      break;
    }

    case 2: {
      setState(2307);
      when();
      break;
    }

    }
    setState(2313);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2310);
        statement(); 
      }
      setState(2315);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenContext ------------------------------------------------------------------

RpgParser::WhenContext::WhenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::WhenContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::WhenContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsWHENContext* RpgParser::WhenContext::csWHEN() {
  return getRuleContext<RpgParser::CsWHENContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::WhenContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::WhenContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::WhenContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::WhenContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::WhenContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_whenContext* RpgParser::WhenContext::op_when() {
  return getRuleContext<RpgParser::Op_whenContext>(0);
}

tree::TerminalNode* RpgParser::WhenContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

std::vector<RpgParser::StatementContext *> RpgParser::WhenContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::WhenContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}

RpgParser::Free_linecommentsContext* RpgParser::WhenContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::WhenContext::getRuleIndex() const {
  return RpgParser::RuleWhen;
}

void RpgParser::WhenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen(this);
}

void RpgParser::WhenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen(this);
}


antlrcpp::Any RpgParser::WhenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitWhen(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::WhenContext* RpgParser::when() {
  WhenContext *_localctx = _tracker.createInstance<WhenContext>(_ctx, getState());
  enterRule(_localctx, 258, RpgParser::RuleWhen);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2316);
        match(RpgParser::CS_FIXED);
        setState(2320);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2317);
            cspec_continuedIndicators(); 
          }
          setState(2322);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx);
        }
        setState(2323);
        cs_controlLevel();
        setState(2324);
        dynamic_cast<WhenContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2325);
        dynamic_cast<WhenContext *>(_localctx)->indicators = cs_indicators();
        setState(2326);
        dynamic_cast<WhenContext *>(_localctx)->factor1 = factor();
        setState(2327);
        csWHEN();
        break;
      }

      case RpgParser::OP_WHEN: {
        enterOuterAlt(_localctx, 2);
        setState(2329);
        op_when();
        setState(2330);
        match(RpgParser::FREE_SEMI);
        setState(2332);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
        case 1: {
          setState(2331);
          free_linecomments();
          break;
        }

        }
        setState(2337);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2334);
            statement(); 
          }
          setState(2339);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENxxContext ------------------------------------------------------------------

RpgParser::CsWHENxxContext::CsWHENxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsWHENxxContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsWHENxxContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsWHENxxContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsWHENxxContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsWHENxxContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsWHENEQContext* RpgParser::CsWHENxxContext::csWHENEQ() {
  return getRuleContext<RpgParser::CsWHENEQContext>(0);
}

RpgParser::CsWHENNEContext* RpgParser::CsWHENxxContext::csWHENNE() {
  return getRuleContext<RpgParser::CsWHENNEContext>(0);
}

RpgParser::CsWHENLEContext* RpgParser::CsWHENxxContext::csWHENLE() {
  return getRuleContext<RpgParser::CsWHENLEContext>(0);
}

RpgParser::CsWHENLTContext* RpgParser::CsWHENxxContext::csWHENLT() {
  return getRuleContext<RpgParser::CsWHENLTContext>(0);
}

RpgParser::CsWHENGEContext* RpgParser::CsWHENxxContext::csWHENGE() {
  return getRuleContext<RpgParser::CsWHENGEContext>(0);
}

RpgParser::CsWHENGTContext* RpgParser::CsWHENxxContext::csWHENGT() {
  return getRuleContext<RpgParser::CsWHENGTContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsWHENxxContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsWHENxxContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

std::vector<RpgParser::CsANDxxContext *> RpgParser::CsWHENxxContext::csANDxx() {
  return getRuleContexts<RpgParser::CsANDxxContext>();
}

RpgParser::CsANDxxContext* RpgParser::CsWHENxxContext::csANDxx(size_t i) {
  return getRuleContext<RpgParser::CsANDxxContext>(i);
}

std::vector<RpgParser::CsORxxContext *> RpgParser::CsWHENxxContext::csORxx() {
  return getRuleContexts<RpgParser::CsORxxContext>();
}

RpgParser::CsORxxContext* RpgParser::CsWHENxxContext::csORxx(size_t i) {
  return getRuleContext<RpgParser::CsORxxContext>(i);
}


size_t RpgParser::CsWHENxxContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENxx;
}

void RpgParser::CsWHENxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENxx(this);
}

void RpgParser::CsWHENxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENxx(this);
}


antlrcpp::Any RpgParser::CsWHENxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENxxContext* RpgParser::csWHENxx() {
  CsWHENxxContext *_localctx = _tracker.createInstance<CsWHENxxContext>(_ctx, getState());
  enterRule(_localctx, 260, RpgParser::RuleCsWHENxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2342);
    match(RpgParser::CS_FIXED);
    setState(2346);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2343);
        cspec_continuedIndicators(); 
      }
      setState(2348);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx);
    }
    setState(2349);
    cs_controlLevel();
    setState(2350);
    dynamic_cast<CsWHENxxContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2351);
    dynamic_cast<CsWHENxxContext *>(_localctx)->indicators = cs_indicators();
    setState(2352);
    dynamic_cast<CsWHENxxContext *>(_localctx)->factor1 = factor();
    setState(2359);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_WHENEQ: {
        setState(2353);
        csWHENEQ();
        break;
      }

      case RpgParser::OP_WHENNE: {
        setState(2354);
        csWHENNE();
        break;
      }

      case RpgParser::OP_WHENLE: {
        setState(2355);
        csWHENLE();
        break;
      }

      case RpgParser::OP_WHENLT: {
        setState(2356);
        csWHENLT();
        break;
      }

      case RpgParser::OP_WHENGE: {
        setState(2357);
        csWHENGE();
        break;
      }

      case RpgParser::OP_WHENGT: {
        setState(2358);
        csWHENGT();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2364);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2361);
        dynamic_cast<CsWHENxxContext *>(_localctx)->andConds = csANDxx(); 
      }
      setState(2366);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx);
    }
    setState(2370);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2367);
        dynamic_cast<CsWHENxxContext *>(_localctx)->orConds = csORxx(); 
      }
      setState(2372);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndselectContext ------------------------------------------------------------------

RpgParser::EndselectContext::EndselectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::EndselectContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::EndselectContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::EndselectContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::EndselectContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::EndselectContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsENDContext* RpgParser::EndselectContext::csEND() {
  return getRuleContext<RpgParser::CsENDContext>(0);
}

RpgParser::CsENDSLContext* RpgParser::EndselectContext::csENDSL() {
  return getRuleContext<RpgParser::CsENDSLContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::EndselectContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::EndselectContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_endslContext* RpgParser::EndselectContext::op_endsl() {
  return getRuleContext<RpgParser::Op_endslContext>(0);
}

tree::TerminalNode* RpgParser::EndselectContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::EndselectContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::EndselectContext::getRuleIndex() const {
  return RpgParser::RuleEndselect;
}

void RpgParser::EndselectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndselect(this);
}

void RpgParser::EndselectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndselect(this);
}


antlrcpp::Any RpgParser::EndselectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndselect(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndselectContext* RpgParser::endselect() {
  EndselectContext *_localctx = _tracker.createInstance<EndselectContext>(_ctx, getState());
  enterRule(_localctx, 262, RpgParser::RuleEndselect);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2393);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2373);
        match(RpgParser::CS_FIXED);
        setState(2377);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2374);
            cspec_continuedIndicators(); 
          }
          setState(2379);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx);
        }
        setState(2380);
        cs_controlLevel();
        setState(2381);
        dynamic_cast<EndselectContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2382);
        dynamic_cast<EndselectContext *>(_localctx)->indicators = cs_indicators();
        setState(2383);
        dynamic_cast<EndselectContext *>(_localctx)->factor1 = factor();
        setState(2386);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::OP_END: {
            setState(2384);
            csEND();
            break;
          }

          case RpgParser::OP_ENDSL: {
            setState(2385);
            csENDSL();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case RpgParser::OP_ENDSL: {
        enterOuterAlt(_localctx, 2);
        setState(2388);
        op_endsl();
        setState(2389);
        match(RpgParser::FREE_SEMI);
        setState(2391);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
        case 1: {
          setState(2390);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginifContext ------------------------------------------------------------------

RpgParser::BeginifContext::BeginifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsIFxxContext* RpgParser::BeginifContext::csIFxx() {
  return getRuleContext<RpgParser::CsIFxxContext>(0);
}

tree::TerminalNode* RpgParser::BeginifContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BeginifContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

tree::TerminalNode* RpgParser::BeginifContext::OP_IF() {
  return getToken(RpgParser::OP_IF, 0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BeginifContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BeginifContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BeginifContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::C_freeContext* RpgParser::BeginifContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::BeginifContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::BeginifContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BeginifContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BeginifContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::BeginifContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::Op_ifContext* RpgParser::BeginifContext::op_if() {
  return getRuleContext<RpgParser::Op_ifContext>(0);
}

tree::TerminalNode* RpgParser::BeginifContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::BeginifContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::BeginifContext::getRuleIndex() const {
  return RpgParser::RuleBeginif;
}

void RpgParser::BeginifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginif(this);
}

void RpgParser::BeginifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginif(this);
}


antlrcpp::Any RpgParser::BeginifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBeginif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BeginifContext* RpgParser::beginif() {
  BeginifContext *_localctx = _tracker.createInstance<BeginifContext>(_ctx, getState());
  enterRule(_localctx, 264, RpgParser::RuleBeginif);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2419);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2395);
      csIFxx();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2396);
      match(RpgParser::CS_FIXED);
      setState(2400);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2397);
          cspec_continuedIndicators(); 
        }
        setState(2402);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx);
      }
      setState(2403);
      cs_controlLevel();
      setState(2404);
      dynamic_cast<BeginifContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
      setState(2405);
      dynamic_cast<BeginifContext *>(_localctx)->indicators = cs_indicators();
      setState(2406);
      dynamic_cast<BeginifContext *>(_localctx)->factor1 = factor();
      setState(2407);
      match(RpgParser::OP_IF);
      setState(2409);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
      case 1: {
        setState(2408);
        cs_operationExtender();
        break;
      }

      }
      setState(2411);
      dynamic_cast<BeginifContext *>(_localctx)->fixedexpression = c_free();
      setState(2412);
      _la = _input->LA(1);
      if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2414);
      op_if();
      setState(2415);
      match(RpgParser::FREE_SEMI);
      setState(2417);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
      case 1: {
        setState(2416);
        free_linecomments();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BegindouContext ------------------------------------------------------------------

RpgParser::BegindouContext::BegindouContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::BegindouContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BegindouContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsDOUContext* RpgParser::BegindouContext::csDOU() {
  return getRuleContext<RpgParser::CsDOUContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BegindouContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BegindouContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BegindouContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BegindouContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BegindouContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_douContext* RpgParser::BegindouContext::op_dou() {
  return getRuleContext<RpgParser::Op_douContext>(0);
}

tree::TerminalNode* RpgParser::BegindouContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::BegindouContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::BegindouContext::getRuleIndex() const {
  return RpgParser::RuleBegindou;
}

void RpgParser::BegindouContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegindou(this);
}

void RpgParser::BegindouContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegindou(this);
}


antlrcpp::Any RpgParser::BegindouContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBegindou(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BegindouContext* RpgParser::begindou() {
  BegindouContext *_localctx = _tracker.createInstance<BegindouContext>(_ctx, getState());
  enterRule(_localctx, 266, RpgParser::RuleBegindou);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2439);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2421);
        match(RpgParser::CS_FIXED);
        setState(2425);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2422);
            cspec_continuedIndicators(); 
          }
          setState(2427);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
        }
        setState(2428);
        cs_controlLevel();
        setState(2429);
        dynamic_cast<BegindouContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2430);
        dynamic_cast<BegindouContext *>(_localctx)->indicators = cs_indicators();
        setState(2431);
        dynamic_cast<BegindouContext *>(_localctx)->factor1 = factor();
        setState(2432);
        csDOU();
        break;
      }

      case RpgParser::OP_DOU: {
        enterOuterAlt(_localctx, 2);
        setState(2434);
        op_dou();
        setState(2435);
        match(RpgParser::FREE_SEMI);
        setState(2437);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
        case 1: {
          setState(2436);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BegindowContext ------------------------------------------------------------------

RpgParser::BegindowContext::BegindowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::BegindowContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BegindowContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsDOWContext* RpgParser::BegindowContext::csDOW() {
  return getRuleContext<RpgParser::CsDOWContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BegindowContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BegindowContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BegindowContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BegindowContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BegindowContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_dowContext* RpgParser::BegindowContext::op_dow() {
  return getRuleContext<RpgParser::Op_dowContext>(0);
}

tree::TerminalNode* RpgParser::BegindowContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::BegindowContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::BegindowContext::getRuleIndex() const {
  return RpgParser::RuleBegindow;
}

void RpgParser::BegindowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegindow(this);
}

void RpgParser::BegindowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegindow(this);
}


antlrcpp::Any RpgParser::BegindowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBegindow(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BegindowContext* RpgParser::begindow() {
  BegindowContext *_localctx = _tracker.createInstance<BegindowContext>(_ctx, getState());
  enterRule(_localctx, 268, RpgParser::RuleBegindow);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2459);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2441);
        match(RpgParser::CS_FIXED);
        setState(2445);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2442);
            cspec_continuedIndicators(); 
          }
          setState(2447);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
        }
        setState(2448);
        cs_controlLevel();
        setState(2449);
        dynamic_cast<BegindowContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2450);
        dynamic_cast<BegindowContext *>(_localctx)->indicators = cs_indicators();
        setState(2451);
        dynamic_cast<BegindowContext *>(_localctx)->factor1 = factor();
        setState(2452);
        csDOW();
        break;
      }

      case RpgParser::OP_DOW: {
        enterOuterAlt(_localctx, 2);
        setState(2454);
        op_dow();
        setState(2455);
        match(RpgParser::FREE_SEMI);
        setState(2457);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
        case 1: {
          setState(2456);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BegindoContext ------------------------------------------------------------------

RpgParser::BegindoContext::BegindoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::BegindoContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BegindoContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsDOContext* RpgParser::BegindoContext::csDO() {
  return getRuleContext<RpgParser::CsDOContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BegindoContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BegindoContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BegindoContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BegindoContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BegindoContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_dowContext* RpgParser::BegindoContext::op_dow() {
  return getRuleContext<RpgParser::Op_dowContext>(0);
}

tree::TerminalNode* RpgParser::BegindoContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::BegindoContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::BegindoContext::getRuleIndex() const {
  return RpgParser::RuleBegindo;
}

void RpgParser::BegindoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegindo(this);
}

void RpgParser::BegindoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegindo(this);
}


antlrcpp::Any RpgParser::BegindoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBegindo(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BegindoContext* RpgParser::begindo() {
  BegindoContext *_localctx = _tracker.createInstance<BegindoContext>(_ctx, getState());
  enterRule(_localctx, 270, RpgParser::RuleBegindo);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2479);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2461);
        match(RpgParser::CS_FIXED);
        setState(2465);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2462);
            cspec_continuedIndicators(); 
          }
          setState(2467);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
        }
        setState(2468);
        cs_controlLevel();
        setState(2469);
        dynamic_cast<BegindoContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2470);
        dynamic_cast<BegindoContext *>(_localctx)->indicators = cs_indicators();
        setState(2471);
        dynamic_cast<BegindoContext *>(_localctx)->factor1 = factor();
        setState(2472);
        csDO();
        break;
      }

      case RpgParser::OP_DOW: {
        enterOuterAlt(_localctx, 2);
        setState(2474);
        op_dow();
        setState(2475);
        match(RpgParser::FREE_SEMI);
        setState(2477);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
        case 1: {
          setState(2476);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseifstmtContext ------------------------------------------------------------------

RpgParser::ElseifstmtContext::ElseifstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ElseifstmtContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::ElseifstmtContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

tree::TerminalNode* RpgParser::ElseifstmtContext::OP_ELSEIF() {
  return getToken(RpgParser::OP_ELSEIF, 0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::ElseifstmtContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::ElseifstmtContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::ElseifstmtContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::C_freeContext* RpgParser::ElseifstmtContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::ElseifstmtContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::ElseifstmtContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::ElseifstmtContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::ElseifstmtContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::ElseifstmtContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::Op_elseifContext* RpgParser::ElseifstmtContext::op_elseif() {
  return getRuleContext<RpgParser::Op_elseifContext>(0);
}

tree::TerminalNode* RpgParser::ElseifstmtContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::ElseifstmtContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::ElseifstmtContext::getRuleIndex() const {
  return RpgParser::RuleElseifstmt;
}

void RpgParser::ElseifstmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseifstmt(this);
}

void RpgParser::ElseifstmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseifstmt(this);
}


antlrcpp::Any RpgParser::ElseifstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitElseifstmt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ElseifstmtContext* RpgParser::elseifstmt() {
  ElseifstmtContext *_localctx = _tracker.createInstance<ElseifstmtContext>(_ctx, getState());
  enterRule(_localctx, 272, RpgParser::RuleElseifstmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2504);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2481);
        match(RpgParser::CS_FIXED);
        setState(2485);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2482);
            cspec_continuedIndicators(); 
          }
          setState(2487);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx);
        }
        setState(2488);
        cs_controlLevel();
        setState(2489);
        dynamic_cast<ElseifstmtContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2490);
        dynamic_cast<ElseifstmtContext *>(_localctx)->indicators = cs_indicators();
        setState(2491);
        dynamic_cast<ElseifstmtContext *>(_localctx)->factor1 = factor();
        setState(2492);
        match(RpgParser::OP_ELSEIF);
        setState(2494);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
        case 1: {
          setState(2493);
          cs_operationExtender();
          break;
        }

        }
        setState(2496);
        dynamic_cast<ElseifstmtContext *>(_localctx)->fixedexpression = c_free();
        setState(2497);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case RpgParser::OP_ELSEIF: {
        enterOuterAlt(_localctx, 2);
        setState(2499);
        op_elseif();
        setState(2500);
        match(RpgParser::FREE_SEMI);
        setState(2502);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
        case 1: {
          setState(2501);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElsestmtContext ------------------------------------------------------------------

RpgParser::ElsestmtContext::ElsestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ElsestmtContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::ElsestmtContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

tree::TerminalNode* RpgParser::ElsestmtContext::OP_ELSE() {
  return getToken(RpgParser::OP_ELSE, 0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::ElsestmtContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::ElsestmtContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::ElsestmtContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::ElsestmtContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::ElsestmtContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::ElsestmtContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_elseContext* RpgParser::ElsestmtContext::op_else() {
  return getRuleContext<RpgParser::Op_elseContext>(0);
}

tree::TerminalNode* RpgParser::ElsestmtContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::ElsestmtContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::ElsestmtContext::getRuleIndex() const {
  return RpgParser::RuleElsestmt;
}

void RpgParser::ElsestmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElsestmt(this);
}

void RpgParser::ElsestmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElsestmt(this);
}


antlrcpp::Any RpgParser::ElsestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitElsestmt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ElsestmtContext* RpgParser::elsestmt() {
  ElsestmtContext *_localctx = _tracker.createInstance<ElsestmtContext>(_ctx, getState());
  enterRule(_localctx, 274, RpgParser::RuleElsestmt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2525);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2506);
        match(RpgParser::CS_FIXED);
        setState(2510);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2507);
            cspec_continuedIndicators(); 
          }
          setState(2512);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
        }
        setState(2513);
        cs_controlLevel();
        setState(2514);
        dynamic_cast<ElsestmtContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2515);
        dynamic_cast<ElsestmtContext *>(_localctx)->indicators = cs_indicators();
        setState(2516);
        dynamic_cast<ElsestmtContext *>(_localctx)->factor1 = factor();
        setState(2517);
        match(RpgParser::OP_ELSE);
        setState(2518);
        cspec_fixed_standard_parts();
        break;
      }

      case RpgParser::OP_ELSE: {
        enterOuterAlt(_localctx, 2);
        setState(2520);
        op_else();
        setState(2521);
        match(RpgParser::FREE_SEMI);
        setState(2523);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
        case 1: {
          setState(2522);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFxxContext ------------------------------------------------------------------

RpgParser::CsIFxxContext::CsIFxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsIFxxContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsIFxxContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsIFxxContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsIFxxContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsIFxxContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsIFEQContext* RpgParser::CsIFxxContext::csIFEQ() {
  return getRuleContext<RpgParser::CsIFEQContext>(0);
}

RpgParser::CsIFNEContext* RpgParser::CsIFxxContext::csIFNE() {
  return getRuleContext<RpgParser::CsIFNEContext>(0);
}

RpgParser::CsIFLEContext* RpgParser::CsIFxxContext::csIFLE() {
  return getRuleContext<RpgParser::CsIFLEContext>(0);
}

RpgParser::CsIFLTContext* RpgParser::CsIFxxContext::csIFLT() {
  return getRuleContext<RpgParser::CsIFLTContext>(0);
}

RpgParser::CsIFGEContext* RpgParser::CsIFxxContext::csIFGE() {
  return getRuleContext<RpgParser::CsIFGEContext>(0);
}

RpgParser::CsIFGTContext* RpgParser::CsIFxxContext::csIFGT() {
  return getRuleContext<RpgParser::CsIFGTContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsIFxxContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsIFxxContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

std::vector<RpgParser::CsANDxxContext *> RpgParser::CsIFxxContext::csANDxx() {
  return getRuleContexts<RpgParser::CsANDxxContext>();
}

RpgParser::CsANDxxContext* RpgParser::CsIFxxContext::csANDxx(size_t i) {
  return getRuleContext<RpgParser::CsANDxxContext>(i);
}

std::vector<RpgParser::CsORxxContext *> RpgParser::CsIFxxContext::csORxx() {
  return getRuleContexts<RpgParser::CsORxxContext>();
}

RpgParser::CsORxxContext* RpgParser::CsIFxxContext::csORxx(size_t i) {
  return getRuleContext<RpgParser::CsORxxContext>(i);
}


size_t RpgParser::CsIFxxContext::getRuleIndex() const {
  return RpgParser::RuleCsIFxx;
}

void RpgParser::CsIFxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFxx(this);
}

void RpgParser::CsIFxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFxx(this);
}


antlrcpp::Any RpgParser::CsIFxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFxxContext* RpgParser::csIFxx() {
  CsIFxxContext *_localctx = _tracker.createInstance<CsIFxxContext>(_ctx, getState());
  enterRule(_localctx, 276, RpgParser::RuleCsIFxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2527);
    match(RpgParser::CS_FIXED);
    setState(2531);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2528);
        cspec_continuedIndicators(); 
      }
      setState(2533);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx);
    }
    setState(2534);
    cs_controlLevel();
    setState(2535);
    dynamic_cast<CsIFxxContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2536);
    dynamic_cast<CsIFxxContext *>(_localctx)->indicators = cs_indicators();
    setState(2537);
    dynamic_cast<CsIFxxContext *>(_localctx)->factor1 = factor();
    setState(2544);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_IFEQ: {
        setState(2538);
        csIFEQ();
        break;
      }

      case RpgParser::OP_IFNE: {
        setState(2539);
        csIFNE();
        break;
      }

      case RpgParser::OP_IFLE: {
        setState(2540);
        csIFLE();
        break;
      }

      case RpgParser::OP_IFLT: {
        setState(2541);
        csIFLT();
        break;
      }

      case RpgParser::OP_IFGE: {
        setState(2542);
        csIFGE();
        break;
      }

      case RpgParser::OP_IFGT: {
        setState(2543);
        csIFGT();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2549);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2546);
        dynamic_cast<CsIFxxContext *>(_localctx)->andConds = csANDxx(); 
      }
      setState(2551);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
    }
    setState(2555);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2552);
        dynamic_cast<CsIFxxContext *>(_localctx)->orConds = csORxx(); 
      }
      setState(2557);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOUxxContext ------------------------------------------------------------------

RpgParser::CsDOUxxContext::CsDOUxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsDOUxxContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsDOUxxContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsDOUxxContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsDOUxxContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsDOUxxContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsDOUEQContext* RpgParser::CsDOUxxContext::csDOUEQ() {
  return getRuleContext<RpgParser::CsDOUEQContext>(0);
}

RpgParser::CsDOUNEContext* RpgParser::CsDOUxxContext::csDOUNE() {
  return getRuleContext<RpgParser::CsDOUNEContext>(0);
}

RpgParser::CsDOULEContext* RpgParser::CsDOUxxContext::csDOULE() {
  return getRuleContext<RpgParser::CsDOULEContext>(0);
}

RpgParser::CsDOULTContext* RpgParser::CsDOUxxContext::csDOULT() {
  return getRuleContext<RpgParser::CsDOULTContext>(0);
}

RpgParser::CsDOUGEContext* RpgParser::CsDOUxxContext::csDOUGE() {
  return getRuleContext<RpgParser::CsDOUGEContext>(0);
}

RpgParser::CsDOUGTContext* RpgParser::CsDOUxxContext::csDOUGT() {
  return getRuleContext<RpgParser::CsDOUGTContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsDOUxxContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsDOUxxContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

std::vector<RpgParser::CsANDxxContext *> RpgParser::CsDOUxxContext::csANDxx() {
  return getRuleContexts<RpgParser::CsANDxxContext>();
}

RpgParser::CsANDxxContext* RpgParser::CsDOUxxContext::csANDxx(size_t i) {
  return getRuleContext<RpgParser::CsANDxxContext>(i);
}

std::vector<RpgParser::CsORxxContext *> RpgParser::CsDOUxxContext::csORxx() {
  return getRuleContexts<RpgParser::CsORxxContext>();
}

RpgParser::CsORxxContext* RpgParser::CsDOUxxContext::csORxx(size_t i) {
  return getRuleContext<RpgParser::CsORxxContext>(i);
}


size_t RpgParser::CsDOUxxContext::getRuleIndex() const {
  return RpgParser::RuleCsDOUxx;
}

void RpgParser::CsDOUxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOUxx(this);
}

void RpgParser::CsDOUxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOUxx(this);
}


antlrcpp::Any RpgParser::CsDOUxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOUxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOUxxContext* RpgParser::csDOUxx() {
  CsDOUxxContext *_localctx = _tracker.createInstance<CsDOUxxContext>(_ctx, getState());
  enterRule(_localctx, 278, RpgParser::RuleCsDOUxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2558);
    match(RpgParser::CS_FIXED);
    setState(2562);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2559);
        cspec_continuedIndicators(); 
      }
      setState(2564);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
    }
    setState(2565);
    cs_controlLevel();
    setState(2566);
    dynamic_cast<CsDOUxxContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2567);
    dynamic_cast<CsDOUxxContext *>(_localctx)->indicators = cs_indicators();
    setState(2568);
    dynamic_cast<CsDOUxxContext *>(_localctx)->factor1 = factor();
    setState(2575);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_DOUEQ: {
        setState(2569);
        csDOUEQ();
        break;
      }

      case RpgParser::OP_DOUNE: {
        setState(2570);
        csDOUNE();
        break;
      }

      case RpgParser::OP_DOULE: {
        setState(2571);
        csDOULE();
        break;
      }

      case RpgParser::OP_DOULT: {
        setState(2572);
        csDOULT();
        break;
      }

      case RpgParser::OP_DOUGE: {
        setState(2573);
        csDOUGE();
        break;
      }

      case RpgParser::OP_DOUGT: {
        setState(2574);
        csDOUGT();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2580);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2577);
        dynamic_cast<CsDOUxxContext *>(_localctx)->andConds = csANDxx(); 
      }
      setState(2582);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx);
    }
    setState(2586);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2583);
        dynamic_cast<CsDOUxxContext *>(_localctx)->orConds = csORxx(); 
      }
      setState(2588);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWxxContext ------------------------------------------------------------------

RpgParser::CsDOWxxContext::CsDOWxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsDOWxxContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsDOWxxContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsDOWxxContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsDOWxxContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsDOWxxContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsDOWEQContext* RpgParser::CsDOWxxContext::csDOWEQ() {
  return getRuleContext<RpgParser::CsDOWEQContext>(0);
}

RpgParser::CsDOWNEContext* RpgParser::CsDOWxxContext::csDOWNE() {
  return getRuleContext<RpgParser::CsDOWNEContext>(0);
}

RpgParser::CsDOWLEContext* RpgParser::CsDOWxxContext::csDOWLE() {
  return getRuleContext<RpgParser::CsDOWLEContext>(0);
}

RpgParser::CsDOWLTContext* RpgParser::CsDOWxxContext::csDOWLT() {
  return getRuleContext<RpgParser::CsDOWLTContext>(0);
}

RpgParser::CsDOWGEContext* RpgParser::CsDOWxxContext::csDOWGE() {
  return getRuleContext<RpgParser::CsDOWGEContext>(0);
}

RpgParser::CsDOWGTContext* RpgParser::CsDOWxxContext::csDOWGT() {
  return getRuleContext<RpgParser::CsDOWGTContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsDOWxxContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsDOWxxContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

std::vector<RpgParser::CsANDxxContext *> RpgParser::CsDOWxxContext::csANDxx() {
  return getRuleContexts<RpgParser::CsANDxxContext>();
}

RpgParser::CsANDxxContext* RpgParser::CsDOWxxContext::csANDxx(size_t i) {
  return getRuleContext<RpgParser::CsANDxxContext>(i);
}

std::vector<RpgParser::CsORxxContext *> RpgParser::CsDOWxxContext::csORxx() {
  return getRuleContexts<RpgParser::CsORxxContext>();
}

RpgParser::CsORxxContext* RpgParser::CsDOWxxContext::csORxx(size_t i) {
  return getRuleContext<RpgParser::CsORxxContext>(i);
}


size_t RpgParser::CsDOWxxContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWxx;
}

void RpgParser::CsDOWxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWxx(this);
}

void RpgParser::CsDOWxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWxx(this);
}


antlrcpp::Any RpgParser::CsDOWxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWxxContext* RpgParser::csDOWxx() {
  CsDOWxxContext *_localctx = _tracker.createInstance<CsDOWxxContext>(_ctx, getState());
  enterRule(_localctx, 280, RpgParser::RuleCsDOWxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2589);
    match(RpgParser::CS_FIXED);
    setState(2593);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2590);
        cspec_continuedIndicators(); 
      }
      setState(2595);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx);
    }
    setState(2596);
    cs_controlLevel();
    setState(2597);
    dynamic_cast<CsDOWxxContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2598);
    dynamic_cast<CsDOWxxContext *>(_localctx)->indicators = cs_indicators();
    setState(2599);
    dynamic_cast<CsDOWxxContext *>(_localctx)->factor1 = factor();
    setState(2606);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_DOWEQ: {
        setState(2600);
        csDOWEQ();
        break;
      }

      case RpgParser::OP_DOWNE: {
        setState(2601);
        csDOWNE();
        break;
      }

      case RpgParser::OP_DOWLE: {
        setState(2602);
        csDOWLE();
        break;
      }

      case RpgParser::OP_DOWLT: {
        setState(2603);
        csDOWLT();
        break;
      }

      case RpgParser::OP_DOWGE: {
        setState(2604);
        csDOWGE();
        break;
      }

      case RpgParser::OP_DOWGT: {
        setState(2605);
        csDOWGT();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2611);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2608);
        dynamic_cast<CsDOWxxContext *>(_localctx)->andConds = csANDxx(); 
      }
      setState(2613);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
    }
    setState(2617);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2614);
        dynamic_cast<CsDOWxxContext *>(_localctx)->orConds = csORxx(); 
      }
      setState(2619);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComplexCondxxContext ------------------------------------------------------------------

RpgParser::ComplexCondxxContext::ComplexCondxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsANDxxContext* RpgParser::ComplexCondxxContext::csANDxx() {
  return getRuleContext<RpgParser::CsANDxxContext>(0);
}

RpgParser::CsORxxContext* RpgParser::ComplexCondxxContext::csORxx() {
  return getRuleContext<RpgParser::CsORxxContext>(0);
}


size_t RpgParser::ComplexCondxxContext::getRuleIndex() const {
  return RpgParser::RuleComplexCondxx;
}

void RpgParser::ComplexCondxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComplexCondxx(this);
}

void RpgParser::ComplexCondxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComplexCondxx(this);
}


antlrcpp::Any RpgParser::ComplexCondxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitComplexCondxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ComplexCondxxContext* RpgParser::complexCondxx() {
  ComplexCondxxContext *_localctx = _tracker.createInstance<ComplexCondxxContext>(_ctx, getState());
  enterRule(_localctx, 282, RpgParser::RuleComplexCondxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2622);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2620);
      csANDxx();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2621);
      csORxx();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDxxContext ------------------------------------------------------------------

RpgParser::CsANDxxContext::CsANDxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsANDxxContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsANDxxContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsANDxxContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsANDxxContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsANDxxContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsANDEQContext* RpgParser::CsANDxxContext::csANDEQ() {
  return getRuleContext<RpgParser::CsANDEQContext>(0);
}

RpgParser::CsANDNEContext* RpgParser::CsANDxxContext::csANDNE() {
  return getRuleContext<RpgParser::CsANDNEContext>(0);
}

RpgParser::CsANDLEContext* RpgParser::CsANDxxContext::csANDLE() {
  return getRuleContext<RpgParser::CsANDLEContext>(0);
}

RpgParser::CsANDLTContext* RpgParser::CsANDxxContext::csANDLT() {
  return getRuleContext<RpgParser::CsANDLTContext>(0);
}

RpgParser::CsANDGEContext* RpgParser::CsANDxxContext::csANDGE() {
  return getRuleContext<RpgParser::CsANDGEContext>(0);
}

RpgParser::CsANDGTContext* RpgParser::CsANDxxContext::csANDGT() {
  return getRuleContext<RpgParser::CsANDGTContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsANDxxContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsANDxxContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::CsANDxxContext::getRuleIndex() const {
  return RpgParser::RuleCsANDxx;
}

void RpgParser::CsANDxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDxx(this);
}

void RpgParser::CsANDxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDxx(this);
}


antlrcpp::Any RpgParser::CsANDxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDxxContext* RpgParser::csANDxx() {
  CsANDxxContext *_localctx = _tracker.createInstance<CsANDxxContext>(_ctx, getState());
  enterRule(_localctx, 284, RpgParser::RuleCsANDxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2624);
    match(RpgParser::CS_FIXED);
    setState(2628);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2625);
        cspec_continuedIndicators(); 
      }
      setState(2630);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    }
    setState(2631);
    cs_controlLevel();
    setState(2632);
    dynamic_cast<CsANDxxContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2633);
    dynamic_cast<CsANDxxContext *>(_localctx)->indicators = cs_indicators();
    setState(2634);
    dynamic_cast<CsANDxxContext *>(_localctx)->factor1 = factor();
    setState(2641);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_ANDEQ: {
        setState(2635);
        csANDEQ();
        break;
      }

      case RpgParser::OP_ANDNE: {
        setState(2636);
        csANDNE();
        break;
      }

      case RpgParser::OP_ANDLE: {
        setState(2637);
        csANDLE();
        break;
      }

      case RpgParser::OP_ANDLT: {
        setState(2638);
        csANDLT();
        break;
      }

      case RpgParser::OP_ANDGE: {
        setState(2639);
        csANDGE();
        break;
      }

      case RpgParser::OP_ANDGT: {
        setState(2640);
        csANDGT();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsORxxContext ------------------------------------------------------------------

RpgParser::CsORxxContext::CsORxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsORxxContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsORxxContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsORxxContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsORxxContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsORxxContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsOREQContext* RpgParser::CsORxxContext::csOREQ() {
  return getRuleContext<RpgParser::CsOREQContext>(0);
}

RpgParser::CsORNEContext* RpgParser::CsORxxContext::csORNE() {
  return getRuleContext<RpgParser::CsORNEContext>(0);
}

RpgParser::CsORLEContext* RpgParser::CsORxxContext::csORLE() {
  return getRuleContext<RpgParser::CsORLEContext>(0);
}

RpgParser::CsORLTContext* RpgParser::CsORxxContext::csORLT() {
  return getRuleContext<RpgParser::CsORLTContext>(0);
}

RpgParser::CsORGEContext* RpgParser::CsORxxContext::csORGE() {
  return getRuleContext<RpgParser::CsORGEContext>(0);
}

RpgParser::CsORGTContext* RpgParser::CsORxxContext::csORGT() {
  return getRuleContext<RpgParser::CsORGTContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsORxxContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsORxxContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

std::vector<RpgParser::CsANDxxContext *> RpgParser::CsORxxContext::csANDxx() {
  return getRuleContexts<RpgParser::CsANDxxContext>();
}

RpgParser::CsANDxxContext* RpgParser::CsORxxContext::csANDxx(size_t i) {
  return getRuleContext<RpgParser::CsANDxxContext>(i);
}


size_t RpgParser::CsORxxContext::getRuleIndex() const {
  return RpgParser::RuleCsORxx;
}

void RpgParser::CsORxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsORxx(this);
}

void RpgParser::CsORxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsORxx(this);
}


antlrcpp::Any RpgParser::CsORxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsORxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsORxxContext* RpgParser::csORxx() {
  CsORxxContext *_localctx = _tracker.createInstance<CsORxxContext>(_ctx, getState());
  enterRule(_localctx, 286, RpgParser::RuleCsORxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2643);
    match(RpgParser::CS_FIXED);
    setState(2647);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2644);
        cspec_continuedIndicators(); 
      }
      setState(2649);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
    }
    setState(2650);
    cs_controlLevel();
    setState(2651);
    dynamic_cast<CsORxxContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2652);
    dynamic_cast<CsORxxContext *>(_localctx)->indicators = cs_indicators();
    setState(2653);
    dynamic_cast<CsORxxContext *>(_localctx)->factor1 = factor();
    setState(2660);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_OREQ: {
        setState(2654);
        csOREQ();
        break;
      }

      case RpgParser::OP_ORNE: {
        setState(2655);
        csORNE();
        break;
      }

      case RpgParser::OP_ORLE: {
        setState(2656);
        csORLE();
        break;
      }

      case RpgParser::OP_ORLT: {
        setState(2657);
        csORLT();
        break;
      }

      case RpgParser::OP_ORGE: {
        setState(2658);
        csORGE();
        break;
      }

      case RpgParser::OP_ORGT: {
        setState(2659);
        csORGT();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2665);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2662);
        dynamic_cast<CsORxxContext *>(_localctx)->andConds = csANDxx(); 
      }
      setState(2667);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForstatementContext ------------------------------------------------------------------

RpgParser::ForstatementContext::ForstatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::BeginforContext* RpgParser::ForstatementContext::beginfor() {
  return getRuleContext<RpgParser::BeginforContext>(0);
}

RpgParser::EndforContext* RpgParser::ForstatementContext::endfor() {
  return getRuleContext<RpgParser::EndforContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::ForstatementContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::ForstatementContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}


size_t RpgParser::ForstatementContext::getRuleIndex() const {
  return RpgParser::RuleForstatement;
}

void RpgParser::ForstatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForstatement(this);
}

void RpgParser::ForstatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForstatement(this);
}


antlrcpp::Any RpgParser::ForstatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitForstatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ForstatementContext* RpgParser::forstatement() {
  ForstatementContext *_localctx = _tracker.createInstance<ForstatementContext>(_ctx, getState());
  enterRule(_localctx, 288, RpgParser::RuleForstatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2668);
    beginfor();
    setState(2672);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2669);
        statement(); 
      }
      setState(2674);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    }
    setState(2675);
    endfor();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginforContext ------------------------------------------------------------------

RpgParser::BeginforContext::BeginforContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::BeginforContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::BeginforContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::CsFORContext* RpgParser::BeginforContext::csFOR() {
  return getRuleContext<RpgParser::CsFORContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::BeginforContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::BeginforContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::BeginforContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::BeginforContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::BeginforContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_forContext* RpgParser::BeginforContext::op_for() {
  return getRuleContext<RpgParser::Op_forContext>(0);
}

tree::TerminalNode* RpgParser::BeginforContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::BeginforContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::BeginforContext::getRuleIndex() const {
  return RpgParser::RuleBeginfor;
}

void RpgParser::BeginforContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginfor(this);
}

void RpgParser::BeginforContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginfor(this);
}


antlrcpp::Any RpgParser::BeginforContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBeginfor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BeginforContext* RpgParser::beginfor() {
  BeginforContext *_localctx = _tracker.createInstance<BeginforContext>(_ctx, getState());
  enterRule(_localctx, 290, RpgParser::RuleBeginfor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2695);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2677);
        match(RpgParser::CS_FIXED);
        setState(2681);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2678);
            cspec_continuedIndicators(); 
          }
          setState(2683);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
        }
        setState(2684);
        cs_controlLevel();
        setState(2685);
        dynamic_cast<BeginforContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2686);
        dynamic_cast<BeginforContext *>(_localctx)->indicators = cs_indicators();
        setState(2687);
        dynamic_cast<BeginforContext *>(_localctx)->factor1 = factor();
        setState(2688);
        csFOR();
        break;
      }

      case RpgParser::OP_FOR: {
        enterOuterAlt(_localctx, 2);
        setState(2690);
        op_for();
        setState(2691);
        match(RpgParser::FREE_SEMI);
        setState(2693);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
        case 1: {
          setState(2692);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndifContext ------------------------------------------------------------------

RpgParser::EndifContext::EndifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::EndifContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::EndifContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::EndifContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::EndifContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::EndifContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsENDContext* RpgParser::EndifContext::csEND() {
  return getRuleContext<RpgParser::CsENDContext>(0);
}

RpgParser::CsENDIFContext* RpgParser::EndifContext::csENDIF() {
  return getRuleContext<RpgParser::CsENDIFContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::EndifContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::EndifContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_endifContext* RpgParser::EndifContext::op_endif() {
  return getRuleContext<RpgParser::Op_endifContext>(0);
}

tree::TerminalNode* RpgParser::EndifContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::EndifContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::EndifContext::getRuleIndex() const {
  return RpgParser::RuleEndif;
}

void RpgParser::EndifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndif(this);
}

void RpgParser::EndifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndif(this);
}


antlrcpp::Any RpgParser::EndifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndifContext* RpgParser::endif() {
  EndifContext *_localctx = _tracker.createInstance<EndifContext>(_ctx, getState());
  enterRule(_localctx, 292, RpgParser::RuleEndif);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2717);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2697);
        match(RpgParser::CS_FIXED);
        setState(2701);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2698);
            cspec_continuedIndicators(); 
          }
          setState(2703);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx);
        }
        setState(2704);
        cs_controlLevel();
        setState(2705);
        dynamic_cast<EndifContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2706);
        dynamic_cast<EndifContext *>(_localctx)->indicators = cs_indicators();
        setState(2707);
        dynamic_cast<EndifContext *>(_localctx)->factor1 = factor();
        setState(2710);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::OP_END: {
            setState(2708);
            csEND();
            break;
          }

          case RpgParser::OP_ENDIF: {
            setState(2709);
            csENDIF();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case RpgParser::OP_ENDIF: {
        enterOuterAlt(_localctx, 2);
        setState(2712);
        op_endif();
        setState(2713);
        match(RpgParser::FREE_SEMI);
        setState(2715);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
        case 1: {
          setState(2714);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnddoContext ------------------------------------------------------------------

RpgParser::EnddoContext::EnddoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::EnddoContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::EnddoContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::EnddoContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::EnddoContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::EnddoContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsENDContext* RpgParser::EnddoContext::csEND() {
  return getRuleContext<RpgParser::CsENDContext>(0);
}

RpgParser::CsENDDOContext* RpgParser::EnddoContext::csENDDO() {
  return getRuleContext<RpgParser::CsENDDOContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::EnddoContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::EnddoContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_enddoContext* RpgParser::EnddoContext::op_enddo() {
  return getRuleContext<RpgParser::Op_enddoContext>(0);
}

tree::TerminalNode* RpgParser::EnddoContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::EnddoContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::EnddoContext::getRuleIndex() const {
  return RpgParser::RuleEnddo;
}

void RpgParser::EnddoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnddo(this);
}

void RpgParser::EnddoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnddo(this);
}


antlrcpp::Any RpgParser::EnddoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEnddo(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EnddoContext* RpgParser::enddo() {
  EnddoContext *_localctx = _tracker.createInstance<EnddoContext>(_ctx, getState());
  enterRule(_localctx, 294, RpgParser::RuleEnddo);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2739);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2719);
        match(RpgParser::CS_FIXED);
        setState(2723);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2720);
            cspec_continuedIndicators(); 
          }
          setState(2725);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
        }
        setState(2726);
        cs_controlLevel();
        setState(2727);
        dynamic_cast<EnddoContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2728);
        dynamic_cast<EnddoContext *>(_localctx)->indicators = cs_indicators();
        setState(2729);
        dynamic_cast<EnddoContext *>(_localctx)->factor1 = factor();
        setState(2732);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::OP_END: {
            setState(2730);
            csEND();
            break;
          }

          case RpgParser::OP_ENDDO: {
            setState(2731);
            csENDDO();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case RpgParser::OP_ENDDO: {
        enterOuterAlt(_localctx, 2);
        setState(2734);
        op_enddo();
        setState(2735);
        match(RpgParser::FREE_SEMI);
        setState(2737);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
        case 1: {
          setState(2736);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndforContext ------------------------------------------------------------------

RpgParser::EndforContext::EndforContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::EndforContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::EndforContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::EndforContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::EndforContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::EndforContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::CsENDContext* RpgParser::EndforContext::csEND() {
  return getRuleContext<RpgParser::CsENDContext>(0);
}

RpgParser::CsENDFORContext* RpgParser::EndforContext::csENDFOR() {
  return getRuleContext<RpgParser::CsENDFORContext>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::EndforContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::EndforContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}

RpgParser::Op_endforContext* RpgParser::EndforContext::op_endfor() {
  return getRuleContext<RpgParser::Op_endforContext>(0);
}

tree::TerminalNode* RpgParser::EndforContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::EndforContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::EndforContext::getRuleIndex() const {
  return RpgParser::RuleEndfor;
}

void RpgParser::EndforContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndfor(this);
}

void RpgParser::EndforContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndfor(this);
}


antlrcpp::Any RpgParser::EndforContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndfor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndforContext* RpgParser::endfor() {
  EndforContext *_localctx = _tracker.createInstance<EndforContext>(_ctx, getState());
  enterRule(_localctx, 296, RpgParser::RuleEndfor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(2761);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2741);
        match(RpgParser::CS_FIXED);
        setState(2745);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2742);
            cspec_continuedIndicators(); 
          }
          setState(2747);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);
        }
        setState(2748);
        cs_controlLevel();
        setState(2749);
        dynamic_cast<EndforContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
        setState(2750);
        dynamic_cast<EndforContext *>(_localctx)->indicators = cs_indicators();
        setState(2751);
        dynamic_cast<EndforContext *>(_localctx)->factor1 = factor();
        setState(2754);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::OP_END: {
            setState(2752);
            csEND();
            break;
          }

          case RpgParser::OP_ENDFOR: {
            setState(2753);
            csENDFOR();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case RpgParser::OP_ENDFOR: {
        enterOuterAlt(_localctx, 2);
        setState(2756);
        op_endfor();
        setState(2757);
        match(RpgParser::FREE_SEMI);
        setState(2759);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
        case 1: {
          setState(2758);
          free_linecomments();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dspec_fixedContext ------------------------------------------------------------------

RpgParser::Dspec_fixedContext::Dspec_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::Dspec_fixedContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::DEF_TYPE() {
  return getToken(RpgParser::DEF_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Dspec_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Dspec_fixedContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Dspec_fixedContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::Dspec_fixedContext::getRuleIndex() const {
  return RpgParser::RuleDspec_fixed;
}

void RpgParser::Dspec_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDspec_fixed(this);
}

void RpgParser::Dspec_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDspec_fixed(this);
}


antlrcpp::Any RpgParser::Dspec_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDspec_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dspec_fixedContext* RpgParser::dspec_fixed() {
  Dspec_fixedContext *_localctx = _tracker.createInstance<Dspec_fixedContext>(_ctx, getState());
  enterRule(_localctx, 298, RpgParser::RuleDspec_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2763);
    match(RpgParser::DS_FIXED);
    setState(2764);
    ds_name();
    setState(2765);
    match(RpgParser::EXTERNAL_DESCRIPTION);
    setState(2766);
    match(RpgParser::DATA_STRUCTURE_TYPE);
    setState(2767);
    match(RpgParser::DEF_TYPE);
    setState(2768);
    match(RpgParser::FROM_POSITION);
    setState(2769);
    match(RpgParser::TO_POSITION);
    setState(2770);
    match(RpgParser::DATA_TYPE);
    setState(2771);
    match(RpgParser::DECIMAL_POSITIONS);
    setState(2772);
    match(RpgParser::RESERVED);
    setState(2776);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(2773);
      keyword();
      setState(2778);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2779);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ds_nameContext ------------------------------------------------------------------

RpgParser::Ds_nameContext::Ds_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Ds_nameContext::NAME() {
  return getToken(RpgParser::NAME, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Ds_nameContext::CONTINUATION_NAME() {
  return getTokens(RpgParser::CONTINUATION_NAME);
}

tree::TerminalNode* RpgParser::Ds_nameContext::CONTINUATION_NAME(size_t i) {
  return getToken(RpgParser::CONTINUATION_NAME, i);
}


size_t RpgParser::Ds_nameContext::getRuleIndex() const {
  return RpgParser::RuleDs_name;
}

void RpgParser::Ds_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDs_name(this);
}

void RpgParser::Ds_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDs_name(this);
}


antlrcpp::Any RpgParser::Ds_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDs_name(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Ds_nameContext* RpgParser::ds_name() {
  Ds_nameContext *_localctx = _tracker.createInstance<Ds_nameContext>(_ctx, getState());
  enterRule(_localctx, 300, RpgParser::RuleDs_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2784);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::CONTINUATION_NAME) {
      setState(2781);
      match(RpgParser::CONTINUATION_NAME);
      setState(2786);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2787);
    match(RpgParser::NAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ospec_fixedContext ------------------------------------------------------------------

RpgParser::Ospec_fixedContext::Ospec_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Ospec_fixedContext::OS_FIXED() {
  return getToken(RpgParser::OS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Ospec_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Ospec_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Os_fixed_pgmdesc_compoundContext* RpgParser::Ospec_fixedContext::os_fixed_pgmdesc_compound() {
  return getRuleContext<RpgParser::Os_fixed_pgmdesc_compoundContext>(0);
}

tree::TerminalNode* RpgParser::Ospec_fixedContext::OS_Comments() {
  return getToken(RpgParser::OS_Comments, 0);
}

RpgParser::Os_fixed_pgmfieldContext* RpgParser::Ospec_fixedContext::os_fixed_pgmfield() {
  return getRuleContext<RpgParser::Os_fixed_pgmfieldContext>(0);
}

tree::TerminalNode* RpgParser::Ospec_fixedContext::OS_RecordName() {
  return getToken(RpgParser::OS_RecordName, 0);
}

tree::TerminalNode* RpgParser::Ospec_fixedContext::OS_Type() {
  return getToken(RpgParser::OS_Type, 0);
}

RpgParser::Os_fixed_pgmdesc1Context* RpgParser::Ospec_fixedContext::os_fixed_pgmdesc1() {
  return getRuleContext<RpgParser::Os_fixed_pgmdesc1Context>(0);
}

RpgParser::Os_fixed_pgmdesc2Context* RpgParser::Ospec_fixedContext::os_fixed_pgmdesc2() {
  return getRuleContext<RpgParser::Os_fixed_pgmdesc2Context>(0);
}


size_t RpgParser::Ospec_fixedContext::getRuleIndex() const {
  return RpgParser::RuleOspec_fixed;
}

void RpgParser::Ospec_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOspec_fixed(this);
}

void RpgParser::Ospec_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOspec_fixed(this);
}


antlrcpp::Any RpgParser::Ospec_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOspec_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Ospec_fixedContext* RpgParser::ospec_fixed() {
  Ospec_fixedContext *_localctx = _tracker.createInstance<Ospec_fixedContext>(_ctx, getState());
  enterRule(_localctx, 302, RpgParser::RuleOspec_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2789);
    match(RpgParser::OS_FIXED);
    setState(2800);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OS_RecordName:
      case RpgParser::OS_FieldReserved: {
        setState(2797);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::OS_RecordName: {
            setState(2790);
            match(RpgParser::OS_RecordName);
            setState(2791);
            match(RpgParser::OS_Type);
            setState(2794);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case RpgParser::OS_FetchOverflow: {
                setState(2792);
                os_fixed_pgmdesc1();
                break;
              }

              case RpgParser::OS_AddDelete: {
                setState(2793);
                os_fixed_pgmdesc2();
                break;
              }

            default:
              throw NoViableAltException(this);
            }
            break;
          }

          case RpgParser::OS_FieldReserved: {
            setState(2796);
            os_fixed_pgmfield();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case RpgParser::OS_AndOr: {
        setState(2799);
        os_fixed_pgmdesc_compound();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2803);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OS_Comments) {
      setState(2802);
      match(RpgParser::OS_Comments);
    }
    setState(2805);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Os_fixed_pgmdesc1Context ------------------------------------------------------------------

RpgParser::Os_fixed_pgmdesc1Context::Os_fixed_pgmdesc1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc1Context::OS_FetchOverflow() {
  return getToken(RpgParser::OS_FetchOverflow, 0);
}

std::vector<RpgParser::OutputConditioningOnOffIndicatorContext *> RpgParser::Os_fixed_pgmdesc1Context::outputConditioningOnOffIndicator() {
  return getRuleContexts<RpgParser::OutputConditioningOnOffIndicatorContext>();
}

RpgParser::OutputConditioningOnOffIndicatorContext* RpgParser::Os_fixed_pgmdesc1Context::outputConditioningOnOffIndicator(size_t i) {
  return getRuleContext<RpgParser::OutputConditioningOnOffIndicatorContext>(i);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc1Context::OS_ExceptName() {
  return getToken(RpgParser::OS_ExceptName, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Os_fixed_pgmdesc1Context::OS_Space3() {
  return getTokens(RpgParser::OS_Space3);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc1Context::OS_Space3(size_t i) {
  return getToken(RpgParser::OS_Space3, i);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc1Context::OS_RemainingSpace() {
  return getToken(RpgParser::OS_RemainingSpace, 0);
}


size_t RpgParser::Os_fixed_pgmdesc1Context::getRuleIndex() const {
  return RpgParser::RuleOs_fixed_pgmdesc1;
}

void RpgParser::Os_fixed_pgmdesc1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOs_fixed_pgmdesc1(this);
}

void RpgParser::Os_fixed_pgmdesc1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOs_fixed_pgmdesc1(this);
}


antlrcpp::Any RpgParser::Os_fixed_pgmdesc1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOs_fixed_pgmdesc1(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Os_fixed_pgmdesc1Context* RpgParser::os_fixed_pgmdesc1() {
  Os_fixed_pgmdesc1Context *_localctx = _tracker.createInstance<Os_fixed_pgmdesc1Context>(_ctx, getState());
  enterRule(_localctx, 304, RpgParser::RuleOs_fixed_pgmdesc1);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2807);
    match(RpgParser::OS_FetchOverflow);
    setState(2808);
    outputConditioningOnOffIndicator();
    setState(2809);
    outputConditioningOnOffIndicator();
    setState(2810);
    outputConditioningOnOffIndicator();
    setState(2811);
    match(RpgParser::OS_ExceptName);
    setState(2812);
    match(RpgParser::OS_Space3);
    setState(2813);
    match(RpgParser::OS_Space3);
    setState(2814);
    match(RpgParser::OS_Space3);
    setState(2815);
    match(RpgParser::OS_Space3);
    setState(2816);
    match(RpgParser::OS_RemainingSpace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OutputConditioningOnOffIndicatorContext ------------------------------------------------------------------

RpgParser::OutputConditioningOnOffIndicatorContext::OutputConditioningOnOffIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::OutputConditioningOnOffIndicatorContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::OutputConditioningIndicatorContext* RpgParser::OutputConditioningOnOffIndicatorContext::outputConditioningIndicator() {
  return getRuleContext<RpgParser::OutputConditioningIndicatorContext>(0);
}


size_t RpgParser::OutputConditioningOnOffIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleOutputConditioningOnOffIndicator;
}

void RpgParser::OutputConditioningOnOffIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutputConditioningOnOffIndicator(this);
}

void RpgParser::OutputConditioningOnOffIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutputConditioningOnOffIndicator(this);
}


antlrcpp::Any RpgParser::OutputConditioningOnOffIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOutputConditioningOnOffIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OutputConditioningOnOffIndicatorContext* RpgParser::outputConditioningOnOffIndicator() {
  OutputConditioningOnOffIndicatorContext *_localctx = _tracker.createInstance<OutputConditioningOnOffIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 306, RpgParser::RuleOutputConditioningOnOffIndicator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2818);
    onOffIndicatorsFlag();
    setState(2819);
    outputConditioningIndicator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OutputConditioningIndicatorContext ------------------------------------------------------------------

RpgParser::OutputConditioningIndicatorContext::OutputConditioningIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::GeneralIndicator() {
  return getToken(RpgParser::GeneralIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::FunctionKeyIndicator() {
  return getToken(RpgParser::FunctionKeyIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::HaltIndicator() {
  return getToken(RpgParser::HaltIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::ExternalIndicator() {
  return getToken(RpgParser::ExternalIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::OverflowIndicator() {
  return getToken(RpgParser::OverflowIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::MatchingRecordIndicator() {
  return getToken(RpgParser::MatchingRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::LastRecordIndicator() {
  return getToken(RpgParser::LastRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::ReturnIndicator() {
  return getToken(RpgParser::ReturnIndicator, 0);
}

tree::TerminalNode* RpgParser::OutputConditioningIndicatorContext::FirstPageIndicator() {
  return getToken(RpgParser::FirstPageIndicator, 0);
}


size_t RpgParser::OutputConditioningIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleOutputConditioningIndicator;
}

void RpgParser::OutputConditioningIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOutputConditioningIndicator(this);
}

void RpgParser::OutputConditioningIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOutputConditioningIndicator(this);
}


antlrcpp::Any RpgParser::OutputConditioningIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOutputConditioningIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OutputConditioningIndicatorContext* RpgParser::outputConditioningIndicator() {
  OutputConditioningIndicatorContext *_localctx = _tracker.createInstance<OutputConditioningIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 308, RpgParser::RuleOutputConditioningIndicator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2821);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::GeneralIndicator - 689))
      | (1ULL << (RpgParser::FunctionKeyIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::LastRecordIndicator - 689))
      | (1ULL << (RpgParser::MatchingRecordIndicator - 689))
      | (1ULL << (RpgParser::HaltIndicator - 689))
      | (1ULL << (RpgParser::ReturnIndicator - 689))
      | (1ULL << (RpgParser::ExternalIndicator - 689))
      | (1ULL << (RpgParser::OverflowIndicator - 689))
      | (1ULL << (RpgParser::FirstPageIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Os_fixed_pgmdesc_compoundContext ------------------------------------------------------------------

RpgParser::Os_fixed_pgmdesc_compoundContext::Os_fixed_pgmdesc_compoundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc_compoundContext::OS_AndOr() {
  return getToken(RpgParser::OS_AndOr, 0);
}

std::vector<RpgParser::OutputConditioningOnOffIndicatorContext *> RpgParser::Os_fixed_pgmdesc_compoundContext::outputConditioningOnOffIndicator() {
  return getRuleContexts<RpgParser::OutputConditioningOnOffIndicatorContext>();
}

RpgParser::OutputConditioningOnOffIndicatorContext* RpgParser::Os_fixed_pgmdesc_compoundContext::outputConditioningOnOffIndicator(size_t i) {
  return getRuleContext<RpgParser::OutputConditioningOnOffIndicatorContext>(i);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc_compoundContext::OS_ExceptName() {
  return getToken(RpgParser::OS_ExceptName, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Os_fixed_pgmdesc_compoundContext::OS_Space3() {
  return getTokens(RpgParser::OS_Space3);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc_compoundContext::OS_Space3(size_t i) {
  return getToken(RpgParser::OS_Space3, i);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc_compoundContext::OS_RemainingSpace() {
  return getToken(RpgParser::OS_RemainingSpace, 0);
}


size_t RpgParser::Os_fixed_pgmdesc_compoundContext::getRuleIndex() const {
  return RpgParser::RuleOs_fixed_pgmdesc_compound;
}

void RpgParser::Os_fixed_pgmdesc_compoundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOs_fixed_pgmdesc_compound(this);
}

void RpgParser::Os_fixed_pgmdesc_compoundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOs_fixed_pgmdesc_compound(this);
}


antlrcpp::Any RpgParser::Os_fixed_pgmdesc_compoundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOs_fixed_pgmdesc_compound(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Os_fixed_pgmdesc_compoundContext* RpgParser::os_fixed_pgmdesc_compound() {
  Os_fixed_pgmdesc_compoundContext *_localctx = _tracker.createInstance<Os_fixed_pgmdesc_compoundContext>(_ctx, getState());
  enterRule(_localctx, 310, RpgParser::RuleOs_fixed_pgmdesc_compound);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2823);
    match(RpgParser::OS_AndOr);
    setState(2824);
    outputConditioningOnOffIndicator();
    setState(2825);
    outputConditioningOnOffIndicator();
    setState(2826);
    outputConditioningOnOffIndicator();
    setState(2827);
    match(RpgParser::OS_ExceptName);
    setState(2828);
    match(RpgParser::OS_Space3);
    setState(2829);
    match(RpgParser::OS_Space3);
    setState(2830);
    match(RpgParser::OS_Space3);
    setState(2831);
    match(RpgParser::OS_Space3);
    setState(2832);
    match(RpgParser::OS_RemainingSpace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Os_fixed_pgmdesc2Context ------------------------------------------------------------------

RpgParser::Os_fixed_pgmdesc2Context::Os_fixed_pgmdesc2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc2Context::OS_AddDelete() {
  return getToken(RpgParser::OS_AddDelete, 0);
}

std::vector<RpgParser::OutputConditioningOnOffIndicatorContext *> RpgParser::Os_fixed_pgmdesc2Context::outputConditioningOnOffIndicator() {
  return getRuleContexts<RpgParser::OutputConditioningOnOffIndicatorContext>();
}

RpgParser::OutputConditioningOnOffIndicatorContext* RpgParser::Os_fixed_pgmdesc2Context::outputConditioningOnOffIndicator(size_t i) {
  return getRuleContext<RpgParser::OutputConditioningOnOffIndicatorContext>(i);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc2Context::OS_ExceptName() {
  return getToken(RpgParser::OS_ExceptName, 0);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmdesc2Context::OS_RemainingSpace() {
  return getToken(RpgParser::OS_RemainingSpace, 0);
}


size_t RpgParser::Os_fixed_pgmdesc2Context::getRuleIndex() const {
  return RpgParser::RuleOs_fixed_pgmdesc2;
}

void RpgParser::Os_fixed_pgmdesc2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOs_fixed_pgmdesc2(this);
}

void RpgParser::Os_fixed_pgmdesc2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOs_fixed_pgmdesc2(this);
}


antlrcpp::Any RpgParser::Os_fixed_pgmdesc2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOs_fixed_pgmdesc2(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Os_fixed_pgmdesc2Context* RpgParser::os_fixed_pgmdesc2() {
  Os_fixed_pgmdesc2Context *_localctx = _tracker.createInstance<Os_fixed_pgmdesc2Context>(_ctx, getState());
  enterRule(_localctx, 312, RpgParser::RuleOs_fixed_pgmdesc2);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2834);
    match(RpgParser::OS_AddDelete);
    setState(2835);
    outputConditioningOnOffIndicator();
    setState(2836);
    outputConditioningOnOffIndicator();
    setState(2837);
    outputConditioningOnOffIndicator();
    setState(2838);
    match(RpgParser::OS_ExceptName);
    setState(2839);
    match(RpgParser::OS_RemainingSpace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Os_fixed_pgmfieldContext ------------------------------------------------------------------

RpgParser::Os_fixed_pgmfieldContext::Os_fixed_pgmfieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Os_fixed_pgmfieldContext::OS_FieldReserved() {
  return getToken(RpgParser::OS_FieldReserved, 0);
}

std::vector<RpgParser::OutputConditioningOnOffIndicatorContext *> RpgParser::Os_fixed_pgmfieldContext::outputConditioningOnOffIndicator() {
  return getRuleContexts<RpgParser::OutputConditioningOnOffIndicatorContext>();
}

RpgParser::OutputConditioningOnOffIndicatorContext* RpgParser::Os_fixed_pgmfieldContext::outputConditioningOnOffIndicator(size_t i) {
  return getRuleContext<RpgParser::OutputConditioningOnOffIndicatorContext>(i);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmfieldContext::OS_FieldName() {
  return getToken(RpgParser::OS_FieldName, 0);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmfieldContext::OS_EditNames() {
  return getToken(RpgParser::OS_EditNames, 0);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmfieldContext::OS_BlankAfter() {
  return getToken(RpgParser::OS_BlankAfter, 0);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmfieldContext::OS_EndPosition() {
  return getToken(RpgParser::OS_EndPosition, 0);
}

tree::TerminalNode* RpgParser::Os_fixed_pgmfieldContext::OS_DataFormat() {
  return getToken(RpgParser::OS_DataFormat, 0);
}

RpgParser::LiteralContext* RpgParser::Os_fixed_pgmfieldContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}


size_t RpgParser::Os_fixed_pgmfieldContext::getRuleIndex() const {
  return RpgParser::RuleOs_fixed_pgmfield;
}

void RpgParser::Os_fixed_pgmfieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOs_fixed_pgmfield(this);
}

void RpgParser::Os_fixed_pgmfieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOs_fixed_pgmfield(this);
}


antlrcpp::Any RpgParser::Os_fixed_pgmfieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOs_fixed_pgmfield(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Os_fixed_pgmfieldContext* RpgParser::os_fixed_pgmfield() {
  Os_fixed_pgmfieldContext *_localctx = _tracker.createInstance<Os_fixed_pgmfieldContext>(_ctx, getState());
  enterRule(_localctx, 314, RpgParser::RuleOs_fixed_pgmfield);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2841);
    match(RpgParser::OS_FieldReserved);
    setState(2842);
    outputConditioningOnOffIndicator();
    setState(2843);
    outputConditioningOnOffIndicator();
    setState(2844);
    outputConditioningOnOffIndicator();
    setState(2845);
    match(RpgParser::OS_FieldName);
    setState(2846);
    match(RpgParser::OS_EditNames);
    setState(2847);
    match(RpgParser::OS_BlankAfter);
    setState(2848);
    match(RpgParser::OS_EndPosition);
    setState(2849);
    match(RpgParser::OS_DataFormat);
    setState(2851);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 449) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 449)) & ((1ULL << (RpgParser::HexLiteralStart - 449))
      | (1ULL << (RpgParser::DateLiteralStart - 449))
      | (1ULL << (RpgParser::TimeLiteralStart - 449))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 449))
      | (1ULL << (RpgParser::GraphicLiteralStart - 449))
      | (1ULL << (RpgParser::UCS2LiteralStart - 449))
      | (1ULL << (RpgParser::StringLiteralStart - 449)))) != 0)) {
      setState(2850);
      literal();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ps_nameContext ------------------------------------------------------------------

RpgParser::Ps_nameContext::Ps_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Ps_nameContext::PS_NAME() {
  return getToken(RpgParser::PS_NAME, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Ps_nameContext::PS_CONTINUATION_NAME() {
  return getTokens(RpgParser::PS_CONTINUATION_NAME);
}

tree::TerminalNode* RpgParser::Ps_nameContext::PS_CONTINUATION_NAME(size_t i) {
  return getToken(RpgParser::PS_CONTINUATION_NAME, i);
}


size_t RpgParser::Ps_nameContext::getRuleIndex() const {
  return RpgParser::RulePs_name;
}

void RpgParser::Ps_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPs_name(this);
}

void RpgParser::Ps_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPs_name(this);
}


antlrcpp::Any RpgParser::Ps_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPs_name(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Ps_nameContext* RpgParser::ps_name() {
  Ps_nameContext *_localctx = _tracker.createInstance<Ps_nameContext>(_ctx, getState());
  enterRule(_localctx, 316, RpgParser::RulePs_name);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2856);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::PS_CONTINUATION_NAME) {
      setState(2853);
      match(RpgParser::PS_CONTINUATION_NAME);
      setState(2858);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2859);
    match(RpgParser::PS_NAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FspecContext ------------------------------------------------------------------

RpgParser::FspecContext::FspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FspecContext::FS_FreeFile() {
  return getToken(RpgParser::FS_FreeFile, 0);
}

RpgParser::FilenameContext* RpgParser::FspecContext::filename() {
  return getRuleContext<RpgParser::FilenameContext>(0);
}

tree::TerminalNode* RpgParser::FspecContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

std::vector<RpgParser::Fs_keywordContext *> RpgParser::FspecContext::fs_keyword() {
  return getRuleContexts<RpgParser::Fs_keywordContext>();
}

RpgParser::Fs_keywordContext* RpgParser::FspecContext::fs_keyword(size_t i) {
  return getRuleContext<RpgParser::Fs_keywordContext>(i);
}


size_t RpgParser::FspecContext::getRuleIndex() const {
  return RpgParser::RuleFspec;
}

void RpgParser::FspecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFspec(this);
}

void RpgParser::FspecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFspec(this);
}


antlrcpp::Any RpgParser::FspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFspec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FspecContext* RpgParser::fspec() {
  FspecContext *_localctx = _tracker.createInstance<FspecContext>(_ctx, getState());
  enterRule(_localctx, 318, RpgParser::RuleFspec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2861);
    match(RpgParser::FS_FreeFile);
    setState(2862);
    filename();
    setState(2866);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::OP_COMMIT || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 339))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 339))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 339))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 339))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 339))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 339))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 339))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 339))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 339))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 339))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 339))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 339))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 339)))) != 0) || ((((_la - 403) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 403)) & ((1ULL << (RpgParser::KEYWORD_PASS - 403))
      | (1ULL << (RpgParser::KEYWORD_PGMNAME - 403))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 403))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 403))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 403))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 403))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 403))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 403))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 403))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 403))
      | (1ULL << (RpgParser::KEYWORD_SLN - 403))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 403))
      | (1ULL << (RpgParser::KEYWORD_DISK - 403))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 403))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 403))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 403))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 403))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 403)))) != 0)) {
      setState(2863);
      fs_keyword();
      setState(2868);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2869);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilenameContext ------------------------------------------------------------------

RpgParser::FilenameContext::FilenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FilenameContext::ID() {
  return getToken(RpgParser::ID, 0);
}


size_t RpgParser::FilenameContext::getRuleIndex() const {
  return RpgParser::RuleFilename;
}

void RpgParser::FilenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilename(this);
}

void RpgParser::FilenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilename(this);
}


antlrcpp::Any RpgParser::FilenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFilename(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FilenameContext* RpgParser::filename() {
  FilenameContext *_localctx = _tracker.createInstance<FilenameContext>(_ctx, getState());
  enterRule(_localctx, 320, RpgParser::RuleFilename);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2871);
    match(RpgParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fs_parmContext ------------------------------------------------------------------

RpgParser::Fs_parmContext::Fs_parmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ExpressionContext* RpgParser::Fs_parmContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::Fs_stringContext* RpgParser::Fs_parmContext::fs_string() {
  return getRuleContext<RpgParser::Fs_stringContext>(0);
}


size_t RpgParser::Fs_parmContext::getRuleIndex() const {
  return RpgParser::RuleFs_parm;
}

void RpgParser::Fs_parmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFs_parm(this);
}

void RpgParser::Fs_parmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFs_parm(this);
}


antlrcpp::Any RpgParser::Fs_parmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFs_parm(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Fs_parmContext* RpgParser::fs_parm() {
  Fs_parmContext *_localctx = _tracker.createInstance<Fs_parmContext>(_ctx, getState());
  enterRule(_localctx, 322, RpgParser::RuleFs_parm);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2875);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2873);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2874);
      fs_string();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fs_stringContext ------------------------------------------------------------------

RpgParser::Fs_stringContext::Fs_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Fs_stringContext::StringLiteralEnd() {
  return getToken(RpgParser::StringLiteralEnd, 0);
}

tree::TerminalNode* RpgParser::Fs_stringContext::StringLiteralStart() {
  return getToken(RpgParser::StringLiteralStart, 0);
}

tree::TerminalNode* RpgParser::Fs_stringContext::HexLiteralStart() {
  return getToken(RpgParser::HexLiteralStart, 0);
}

tree::TerminalNode* RpgParser::Fs_stringContext::DateLiteralStart() {
  return getToken(RpgParser::DateLiteralStart, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Fs_stringContext::StringContent() {
  return getTokens(RpgParser::StringContent);
}

tree::TerminalNode* RpgParser::Fs_stringContext::StringContent(size_t i) {
  return getToken(RpgParser::StringContent, i);
}

std::vector<tree::TerminalNode *> RpgParser::Fs_stringContext::StringEscapedQuote() {
  return getTokens(RpgParser::StringEscapedQuote);
}

tree::TerminalNode* RpgParser::Fs_stringContext::StringEscapedQuote(size_t i) {
  return getToken(RpgParser::StringEscapedQuote, i);
}


size_t RpgParser::Fs_stringContext::getRuleIndex() const {
  return RpgParser::RuleFs_string;
}

void RpgParser::Fs_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFs_string(this);
}

void RpgParser::Fs_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFs_string(this);
}


antlrcpp::Any RpgParser::Fs_stringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFs_string(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Fs_stringContext* RpgParser::fs_string() {
  Fs_stringContext *_localctx = _tracker.createInstance<Fs_stringContext>(_ctx, getState());
  enterRule(_localctx, 324, RpgParser::RuleFs_string);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2877);
    _la = _input->LA(1);
    if (!(((((_la - 449) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 449)) & ((1ULL << (RpgParser::HexLiteralStart - 449))
      | (1ULL << (RpgParser::DateLiteralStart - 449))
      | (1ULL << (RpgParser::StringLiteralStart - 449)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2881);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::StringContent

    || _la == RpgParser::StringEscapedQuote) {
      setState(2878);
      _la = _input->LA(1);
      if (!(_la == RpgParser::StringContent

      || _la == RpgParser::StringEscapedQuote)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2883);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2884);
    match(RpgParser::StringLiteralEnd);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fs_keywordContext ------------------------------------------------------------------

RpgParser::Fs_keywordContext::Fs_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Keyword_aliasContext* RpgParser::Fs_keywordContext::keyword_alias() {
  return getRuleContext<RpgParser::Keyword_aliasContext>(0);
}

RpgParser::Keyword_blockContext* RpgParser::Fs_keywordContext::keyword_block() {
  return getRuleContext<RpgParser::Keyword_blockContext>(0);
}

RpgParser::Keyword_commitContext* RpgParser::Fs_keywordContext::keyword_commit() {
  return getRuleContext<RpgParser::Keyword_commitContext>(0);
}

RpgParser::Keyword_datfmtContext* RpgParser::Fs_keywordContext::keyword_datfmt() {
  return getRuleContext<RpgParser::Keyword_datfmtContext>(0);
}

RpgParser::Keyword_devidContext* RpgParser::Fs_keywordContext::keyword_devid() {
  return getRuleContext<RpgParser::Keyword_devidContext>(0);
}

RpgParser::Keyword_dimContext* RpgParser::Fs_keywordContext::keyword_dim() {
  return getRuleContext<RpgParser::Keyword_dimContext>(0);
}

RpgParser::Keyword_dtaaraContext* RpgParser::Fs_keywordContext::keyword_dtaara() {
  return getRuleContext<RpgParser::Keyword_dtaaraContext>(0);
}

RpgParser::Keyword_extdescContext* RpgParser::Fs_keywordContext::keyword_extdesc() {
  return getRuleContext<RpgParser::Keyword_extdescContext>(0);
}

RpgParser::Keyword_extfileContext* RpgParser::Fs_keywordContext::keyword_extfile() {
  return getRuleContext<RpgParser::Keyword_extfileContext>(0);
}

RpgParser::Keyword_extindContext* RpgParser::Fs_keywordContext::keyword_extind() {
  return getRuleContext<RpgParser::Keyword_extindContext>(0);
}

RpgParser::Keyword_extmbrContext* RpgParser::Fs_keywordContext::keyword_extmbr() {
  return getRuleContext<RpgParser::Keyword_extmbrContext>(0);
}

RpgParser::Keyword_formlenContext* RpgParser::Fs_keywordContext::keyword_formlen() {
  return getRuleContext<RpgParser::Keyword_formlenContext>(0);
}

RpgParser::Keyword_formoflContext* RpgParser::Fs_keywordContext::keyword_formofl() {
  return getRuleContext<RpgParser::Keyword_formoflContext>(0);
}

RpgParser::Keyword_ignoreContext* RpgParser::Fs_keywordContext::keyword_ignore() {
  return getRuleContext<RpgParser::Keyword_ignoreContext>(0);
}

RpgParser::Keyword_includeContext* RpgParser::Fs_keywordContext::keyword_include() {
  return getRuleContext<RpgParser::Keyword_includeContext>(0);
}

RpgParser::Keyword_inddsContext* RpgParser::Fs_keywordContext::keyword_indds() {
  return getRuleContext<RpgParser::Keyword_inddsContext>(0);
}

RpgParser::Keyword_infdsContext* RpgParser::Fs_keywordContext::keyword_infds() {
  return getRuleContext<RpgParser::Keyword_infdsContext>(0);
}

RpgParser::Keyword_infsrContext* RpgParser::Fs_keywordContext::keyword_infsr() {
  return getRuleContext<RpgParser::Keyword_infsrContext>(0);
}

RpgParser::Keyword_keylocContext* RpgParser::Fs_keywordContext::keyword_keyloc() {
  return getRuleContext<RpgParser::Keyword_keylocContext>(0);
}

RpgParser::Keyword_likefileContext* RpgParser::Fs_keywordContext::keyword_likefile() {
  return getRuleContext<RpgParser::Keyword_likefileContext>(0);
}

RpgParser::Keyword_maxdevContext* RpgParser::Fs_keywordContext::keyword_maxdev() {
  return getRuleContext<RpgParser::Keyword_maxdevContext>(0);
}

RpgParser::Keyword_oflindContext* RpgParser::Fs_keywordContext::keyword_oflind() {
  return getRuleContext<RpgParser::Keyword_oflindContext>(0);
}

RpgParser::Keyword_passContext* RpgParser::Fs_keywordContext::keyword_pass() {
  return getRuleContext<RpgParser::Keyword_passContext>(0);
}

RpgParser::Keyword_pgmnameContext* RpgParser::Fs_keywordContext::keyword_pgmname() {
  return getRuleContext<RpgParser::Keyword_pgmnameContext>(0);
}

RpgParser::Keyword_plistContext* RpgParser::Fs_keywordContext::keyword_plist() {
  return getRuleContext<RpgParser::Keyword_plistContext>(0);
}

RpgParser::Keyword_prefixContext* RpgParser::Fs_keywordContext::keyword_prefix() {
  return getRuleContext<RpgParser::Keyword_prefixContext>(0);
}

RpgParser::Keyword_prtctlContext* RpgParser::Fs_keywordContext::keyword_prtctl() {
  return getRuleContext<RpgParser::Keyword_prtctlContext>(0);
}

RpgParser::Keyword_qualifiedContext* RpgParser::Fs_keywordContext::keyword_qualified() {
  return getRuleContext<RpgParser::Keyword_qualifiedContext>(0);
}

RpgParser::Keyword_rafdataContext* RpgParser::Fs_keywordContext::keyword_rafdata() {
  return getRuleContext<RpgParser::Keyword_rafdataContext>(0);
}

RpgParser::Keyword_recnoContext* RpgParser::Fs_keywordContext::keyword_recno() {
  return getRuleContext<RpgParser::Keyword_recnoContext>(0);
}

RpgParser::Keyword_renameContext* RpgParser::Fs_keywordContext::keyword_rename() {
  return getRuleContext<RpgParser::Keyword_renameContext>(0);
}

RpgParser::Keyword_savedsContext* RpgParser::Fs_keywordContext::keyword_saveds() {
  return getRuleContext<RpgParser::Keyword_savedsContext>(0);
}

RpgParser::Keyword_saveindContext* RpgParser::Fs_keywordContext::keyword_saveind() {
  return getRuleContext<RpgParser::Keyword_saveindContext>(0);
}

RpgParser::Keyword_sfileContext* RpgParser::Fs_keywordContext::keyword_sfile() {
  return getRuleContext<RpgParser::Keyword_sfileContext>(0);
}

RpgParser::Keyword_slnContext* RpgParser::Fs_keywordContext::keyword_sln() {
  return getRuleContext<RpgParser::Keyword_slnContext>(0);
}

RpgParser::Keyword_staticContext* RpgParser::Fs_keywordContext::keyword_static() {
  return getRuleContext<RpgParser::Keyword_staticContext>(0);
}

RpgParser::Keyword_templateContext* RpgParser::Fs_keywordContext::keyword_template() {
  return getRuleContext<RpgParser::Keyword_templateContext>(0);
}

RpgParser::Keyword_timfmtContext* RpgParser::Fs_keywordContext::keyword_timfmt() {
  return getRuleContext<RpgParser::Keyword_timfmtContext>(0);
}

RpgParser::Keyword_tofileContext* RpgParser::Fs_keywordContext::keyword_tofile() {
  return getRuleContext<RpgParser::Keyword_tofileContext>(0);
}

RpgParser::Keyword_usropnContext* RpgParser::Fs_keywordContext::keyword_usropn() {
  return getRuleContext<RpgParser::Keyword_usropnContext>(0);
}

RpgParser::Keyword_valueContext* RpgParser::Fs_keywordContext::keyword_value() {
  return getRuleContext<RpgParser::Keyword_valueContext>(0);
}

RpgParser::Keyword_varyingContext* RpgParser::Fs_keywordContext::keyword_varying() {
  return getRuleContext<RpgParser::Keyword_varyingContext>(0);
}

RpgParser::Keyword_diskContext* RpgParser::Fs_keywordContext::keyword_disk() {
  return getRuleContext<RpgParser::Keyword_diskContext>(0);
}

RpgParser::Keyword_workstnContext* RpgParser::Fs_keywordContext::keyword_workstn() {
  return getRuleContext<RpgParser::Keyword_workstnContext>(0);
}

RpgParser::Keyword_printerContext* RpgParser::Fs_keywordContext::keyword_printer() {
  return getRuleContext<RpgParser::Keyword_printerContext>(0);
}

RpgParser::Keyword_specialContext* RpgParser::Fs_keywordContext::keyword_special() {
  return getRuleContext<RpgParser::Keyword_specialContext>(0);
}

RpgParser::Keyword_keyedContext* RpgParser::Fs_keywordContext::keyword_keyed() {
  return getRuleContext<RpgParser::Keyword_keyedContext>(0);
}

RpgParser::Keyword_usageContext* RpgParser::Fs_keywordContext::keyword_usage() {
  return getRuleContext<RpgParser::Keyword_usageContext>(0);
}


size_t RpgParser::Fs_keywordContext::getRuleIndex() const {
  return RpgParser::RuleFs_keyword;
}

void RpgParser::Fs_keywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFs_keyword(this);
}

void RpgParser::Fs_keywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFs_keyword(this);
}


antlrcpp::Any RpgParser::Fs_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFs_keyword(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Fs_keywordContext* RpgParser::fs_keyword() {
  Fs_keywordContext *_localctx = _tracker.createInstance<Fs_keywordContext>(_ctx, getState());
  enterRule(_localctx, 326, RpgParser::RuleFs_keyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2934);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::KEYWORD_ALIAS: {
        enterOuterAlt(_localctx, 1);
        setState(2886);
        keyword_alias();
        break;
      }

      case RpgParser::KEYWORD_BLOCK: {
        enterOuterAlt(_localctx, 2);
        setState(2887);
        keyword_block();
        break;
      }

      case RpgParser::OP_COMMIT:
      case RpgParser::KEYWORD_COMMIT: {
        enterOuterAlt(_localctx, 3);
        setState(2888);
        keyword_commit();
        break;
      }

      case RpgParser::KEYWORD_DATFMT: {
        enterOuterAlt(_localctx, 4);
        setState(2889);
        keyword_datfmt();
        break;
      }

      case RpgParser::KEYWORD_DEVID: {
        enterOuterAlt(_localctx, 5);
        setState(2890);
        keyword_devid();
        break;
      }

      case RpgParser::KEYWORD_DIM: {
        enterOuterAlt(_localctx, 6);
        setState(2891);
        keyword_dim();
        break;
      }

      case RpgParser::KEYWORD_DTAARA: {
        enterOuterAlt(_localctx, 7);
        setState(2892);
        keyword_dtaara();
        break;
      }

      case RpgParser::KEYWORD_EXTDESC: {
        enterOuterAlt(_localctx, 8);
        setState(2893);
        keyword_extdesc();
        break;
      }

      case RpgParser::KEYWORD_EXTFILE: {
        enterOuterAlt(_localctx, 9);
        setState(2894);
        keyword_extfile();
        break;
      }

      case RpgParser::KEYWORD_EXTIND: {
        enterOuterAlt(_localctx, 10);
        setState(2895);
        keyword_extind();
        break;
      }

      case RpgParser::KEYWORD_EXTMBR: {
        enterOuterAlt(_localctx, 11);
        setState(2896);
        keyword_extmbr();
        break;
      }

      case RpgParser::KEYWORD_FORMLEN: {
        enterOuterAlt(_localctx, 12);
        setState(2897);
        keyword_formlen();
        break;
      }

      case RpgParser::KEYWORD_FORMOFL: {
        enterOuterAlt(_localctx, 13);
        setState(2898);
        keyword_formofl();
        break;
      }

      case RpgParser::KEYWORD_IGNORE: {
        enterOuterAlt(_localctx, 14);
        setState(2899);
        keyword_ignore();
        break;
      }

      case RpgParser::KEYWORD_INCLUDE: {
        enterOuterAlt(_localctx, 15);
        setState(2900);
        keyword_include();
        break;
      }

      case RpgParser::KEYWORD_INDDS: {
        enterOuterAlt(_localctx, 16);
        setState(2901);
        keyword_indds();
        break;
      }

      case RpgParser::KEYWORD_INFDS: {
        enterOuterAlt(_localctx, 17);
        setState(2902);
        keyword_infds();
        break;
      }

      case RpgParser::KEYWORD_INFSR: {
        enterOuterAlt(_localctx, 18);
        setState(2903);
        keyword_infsr();
        break;
      }

      case RpgParser::KEYWORD_KEYLOC: {
        enterOuterAlt(_localctx, 19);
        setState(2904);
        keyword_keyloc();
        break;
      }

      case RpgParser::KEYWORD_LIKEFILE: {
        enterOuterAlt(_localctx, 20);
        setState(2905);
        keyword_likefile();
        break;
      }

      case RpgParser::KEYWORD_MAXDEV: {
        enterOuterAlt(_localctx, 21);
        setState(2906);
        keyword_maxdev();
        break;
      }

      case RpgParser::KEYWORD_OFLIND: {
        enterOuterAlt(_localctx, 22);
        setState(2907);
        keyword_oflind();
        break;
      }

      case RpgParser::KEYWORD_PASS: {
        enterOuterAlt(_localctx, 23);
        setState(2908);
        keyword_pass();
        break;
      }

      case RpgParser::KEYWORD_PGMNAME: {
        enterOuterAlt(_localctx, 24);
        setState(2909);
        keyword_pgmname();
        break;
      }

      case RpgParser::KEYWORD_PLIST: {
        enterOuterAlt(_localctx, 25);
        setState(2910);
        keyword_plist();
        break;
      }

      case RpgParser::KEYWORD_PREFIX: {
        enterOuterAlt(_localctx, 26);
        setState(2911);
        keyword_prefix();
        break;
      }

      case RpgParser::KEYWORD_PRTCTL: {
        enterOuterAlt(_localctx, 27);
        setState(2912);
        keyword_prtctl();
        break;
      }

      case RpgParser::KEYWORD_QUALIFIED: {
        enterOuterAlt(_localctx, 28);
        setState(2913);
        keyword_qualified();
        break;
      }

      case RpgParser::KEYWORD_RAFDATA: {
        enterOuterAlt(_localctx, 29);
        setState(2914);
        keyword_rafdata();
        break;
      }

      case RpgParser::KEYWORD_RECNO: {
        enterOuterAlt(_localctx, 30);
        setState(2915);
        keyword_recno();
        break;
      }

      case RpgParser::KEYWORD_RENAME: {
        enterOuterAlt(_localctx, 31);
        setState(2916);
        keyword_rename();
        break;
      }

      case RpgParser::KEYWORD_SAVEDS: {
        enterOuterAlt(_localctx, 32);
        setState(2917);
        keyword_saveds();
        break;
      }

      case RpgParser::KEYWORD_SAVEIND: {
        enterOuterAlt(_localctx, 33);
        setState(2918);
        keyword_saveind();
        break;
      }

      case RpgParser::KEYWORD_SFILE: {
        enterOuterAlt(_localctx, 34);
        setState(2919);
        keyword_sfile();
        break;
      }

      case RpgParser::KEYWORD_SLN: {
        enterOuterAlt(_localctx, 35);
        setState(2920);
        keyword_sln();
        break;
      }

      case RpgParser::KEYWORD_STATIC: {
        enterOuterAlt(_localctx, 36);
        setState(2921);
        keyword_static();
        break;
      }

      case RpgParser::KEYWORD_TEMPLATE: {
        enterOuterAlt(_localctx, 37);
        setState(2922);
        keyword_template();
        break;
      }

      case RpgParser::KEYWORD_TIMFMT: {
        enterOuterAlt(_localctx, 38);
        setState(2923);
        keyword_timfmt();
        break;
      }

      case RpgParser::KEYWORD_TOFILE: {
        enterOuterAlt(_localctx, 39);
        setState(2924);
        keyword_tofile();
        break;
      }

      case RpgParser::KEYWORD_USROPN: {
        enterOuterAlt(_localctx, 40);
        setState(2925);
        keyword_usropn();
        break;
      }

      case RpgParser::KEYWORD_VALUE: {
        enterOuterAlt(_localctx, 41);
        setState(2926);
        keyword_value();
        break;
      }

      case RpgParser::KEYWORD_VARYING: {
        enterOuterAlt(_localctx, 42);
        setState(2927);
        keyword_varying();
        break;
      }

      case RpgParser::KEYWORD_DISK: {
        enterOuterAlt(_localctx, 43);
        setState(2928);
        keyword_disk();
        break;
      }

      case RpgParser::KEYWORD_WORKSTN: {
        enterOuterAlt(_localctx, 44);
        setState(2929);
        keyword_workstn();
        break;
      }

      case RpgParser::KEYWORD_PRINTER: {
        enterOuterAlt(_localctx, 45);
        setState(2930);
        keyword_printer();
        break;
      }

      case RpgParser::KEYWORD_SPECIAL: {
        enterOuterAlt(_localctx, 46);
        setState(2931);
        keyword_special();
        break;
      }

      case RpgParser::KEYWORD_KEYED: {
        enterOuterAlt(_localctx, 47);
        setState(2932);
        keyword_keyed();
        break;
      }

      case RpgParser::KEYWORD_USAGE: {
        enterOuterAlt(_localctx, 48);
        setState(2933);
        keyword_usage();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fspec_fixedContext ------------------------------------------------------------------

RpgParser::Fspec_fixedContext::Fspec_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_FIXED() {
  return getToken(RpgParser::FS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_RecordName() {
  return getToken(RpgParser::FS_RecordName, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Type() {
  return getToken(RpgParser::FS_Type, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Designation() {
  return getToken(RpgParser::FS_Designation, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_EndOfFile() {
  return getToken(RpgParser::FS_EndOfFile, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Addution() {
  return getToken(RpgParser::FS_Addution, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Sequence() {
  return getToken(RpgParser::FS_Sequence, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Format() {
  return getToken(RpgParser::FS_Format, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_RecordLength() {
  return getToken(RpgParser::FS_RecordLength, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Limits() {
  return getToken(RpgParser::FS_Limits, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_LengthOfKey() {
  return getToken(RpgParser::FS_LengthOfKey, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_RecordAddressType() {
  return getToken(RpgParser::FS_RecordAddressType, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Organization() {
  return getToken(RpgParser::FS_Organization, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Device() {
  return getToken(RpgParser::FS_Device, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

tree::TerminalNode* RpgParser::Fspec_fixedContext::FS_Reserved() {
  return getToken(RpgParser::FS_Reserved, 0);
}

std::vector<RpgParser::Fs_keywordContext *> RpgParser::Fspec_fixedContext::fs_keyword() {
  return getRuleContexts<RpgParser::Fs_keywordContext>();
}

RpgParser::Fs_keywordContext* RpgParser::Fspec_fixedContext::fs_keyword(size_t i) {
  return getRuleContext<RpgParser::Fs_keywordContext>(i);
}


size_t RpgParser::Fspec_fixedContext::getRuleIndex() const {
  return RpgParser::RuleFspec_fixed;
}

void RpgParser::Fspec_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFspec_fixed(this);
}

void RpgParser::Fspec_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFspec_fixed(this);
}


antlrcpp::Any RpgParser::Fspec_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFspec_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Fspec_fixedContext* RpgParser::fspec_fixed() {
  Fspec_fixedContext *_localctx = _tracker.createInstance<Fspec_fixedContext>(_ctx, getState());
  enterRule(_localctx, 328, RpgParser::RuleFspec_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2936);
    match(RpgParser::FS_FIXED);
    setState(2937);
    match(RpgParser::FS_RecordName);
    setState(2938);
    match(RpgParser::FS_Type);
    setState(2939);
    match(RpgParser::FS_Designation);
    setState(2940);
    match(RpgParser::FS_EndOfFile);
    setState(2941);
    match(RpgParser::FS_Addution);
    setState(2942);
    match(RpgParser::FS_Sequence);
    setState(2943);
    match(RpgParser::FS_Format);
    setState(2944);
    match(RpgParser::FS_RecordLength);
    setState(2945);
    match(RpgParser::FS_Limits);
    setState(2946);
    match(RpgParser::FS_LengthOfKey);
    setState(2947);
    match(RpgParser::FS_RecordAddressType);
    setState(2948);
    match(RpgParser::FS_Organization);
    setState(2949);
    match(RpgParser::FS_Device);
    setState(2951);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::FS_Reserved) {
      setState(2950);
      match(RpgParser::FS_Reserved);
    }
    setState(2956);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::OP_COMMIT || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 339))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 339))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 339))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 339))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 339))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 339))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 339))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 339))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 339))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 339))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 339))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 339))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 339)))) != 0) || ((((_la - 403) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 403)) & ((1ULL << (RpgParser::KEYWORD_PASS - 403))
      | (1ULL << (RpgParser::KEYWORD_PGMNAME - 403))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 403))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 403))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 403))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 403))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 403))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 403))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 403))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 403))
      | (1ULL << (RpgParser::KEYWORD_SLN - 403))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 403))
      | (1ULL << (RpgParser::KEYWORD_DISK - 403))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 403))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 403))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 403))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 403))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 403)))) != 0)) {
      setState(2953);
      fs_keyword();
      setState(2958);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2959);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_fixedContext ------------------------------------------------------------------

RpgParser::Cspec_fixedContext::Cspec_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cspec_fixedContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::Cspec_fixedContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::Cspec_fixedContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::Cspec_fixedContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::Cspec_fixedContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::Cspec_fixed_standardContext* RpgParser::Cspec_fixedContext::cspec_fixed_standard() {
  return getRuleContext<RpgParser::Cspec_fixed_standardContext>(0);
}

RpgParser::Cspec_fixed_x2Context* RpgParser::Cspec_fixedContext::cspec_fixed_x2() {
  return getRuleContext<RpgParser::Cspec_fixed_x2Context>(0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::Cspec_fixedContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::Cspec_fixedContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::Cspec_fixedContext::getRuleIndex() const {
  return RpgParser::RuleCspec_fixed;
}

void RpgParser::Cspec_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_fixed(this);
}

void RpgParser::Cspec_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_fixed(this);
}


antlrcpp::Any RpgParser::Cspec_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_fixedContext* RpgParser::cspec_fixed() {
  Cspec_fixedContext *_localctx = _tracker.createInstance<Cspec_fixedContext>(_ctx, getState());
  enterRule(_localctx, 330, RpgParser::RuleCspec_fixed);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2961);
    match(RpgParser::CS_FIXED);
    setState(2965);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2962);
        cspec_continuedIndicators(); 
      }
      setState(2967);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx);
    }
    setState(2968);
    cs_controlLevel();
    setState(2969);
    dynamic_cast<Cspec_fixedContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2970);
    dynamic_cast<Cspec_fixedContext *>(_localctx)->indicators = cs_indicators();
    setState(2971);
    dynamic_cast<Cspec_fixedContext *>(_localctx)->factor1 = factor();
    setState(2974);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
    case 1: {
      setState(2972);
      cspec_fixed_standard();
      break;
    }

    case 2: {
      setState(2973);
      cspec_fixed_x2();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_continuedIndicatorsContext ------------------------------------------------------------------

RpgParser::Cspec_continuedIndicatorsContext::Cspec_continuedIndicatorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cs_controlLevelContext* RpgParser::Cspec_continuedIndicatorsContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

tree::TerminalNode* RpgParser::Cspec_continuedIndicatorsContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Cspec_continuedIndicatorsContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::Cspec_continuedIndicatorsContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::Cspec_continuedIndicatorsContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}


size_t RpgParser::Cspec_continuedIndicatorsContext::getRuleIndex() const {
  return RpgParser::RuleCspec_continuedIndicators;
}

void RpgParser::Cspec_continuedIndicatorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_continuedIndicators(this);
}

void RpgParser::Cspec_continuedIndicatorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_continuedIndicators(this);
}


antlrcpp::Any RpgParser::Cspec_continuedIndicatorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_continuedIndicators(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::cspec_continuedIndicators() {
  Cspec_continuedIndicatorsContext *_localctx = _tracker.createInstance<Cspec_continuedIndicatorsContext>(_ctx, getState());
  enterRule(_localctx, 332, RpgParser::RuleCspec_continuedIndicators);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2976);
    cs_controlLevel();
    setState(2977);
    dynamic_cast<Cspec_continuedIndicatorsContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(2978);
    dynamic_cast<Cspec_continuedIndicatorsContext *>(_localctx)->indicators = cs_indicators();
    setState(2979);
    match(RpgParser::EOL);
    setState(2980);
    match(RpgParser::CS_FIXED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_blankContext ------------------------------------------------------------------

RpgParser::Cspec_blankContext::Cspec_blankContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cspec_blankContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Cspec_blankContext::BlankIndicator() {
  return getTokens(RpgParser::BlankIndicator);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::BlankIndicator(size_t i) {
  return getToken(RpgParser::BlankIndicator, i);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::BlankFlag() {
  return getToken(RpgParser::BlankFlag, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Cspec_blankContext::CS_BlankFactor() {
  return getTokens(RpgParser::CS_BlankFactor);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::CS_BlankFactor(size_t i) {
  return getToken(RpgParser::CS_BlankFactor, i);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::CS_OperationAndExtender_Blank() {
  return getToken(RpgParser::CS_OperationAndExtender_Blank, 0);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::CS_FieldLength() {
  return getToken(RpgParser::CS_FieldLength, 0);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::CS_DecimalPositions() {
  return getToken(RpgParser::CS_DecimalPositions, 0);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Cspec_blankContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::Cspec_blankContext::getRuleIndex() const {
  return RpgParser::RuleCspec_blank;
}

void RpgParser::Cspec_blankContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_blank(this);
}

void RpgParser::Cspec_blankContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_blank(this);
}


antlrcpp::Any RpgParser::Cspec_blankContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_blank(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_blankContext* RpgParser::cspec_blank() {
  Cspec_blankContext *_localctx = _tracker.createInstance<Cspec_blankContext>(_ctx, getState());
  enterRule(_localctx, 334, RpgParser::RuleCspec_blank);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2982);
    match(RpgParser::CS_FIXED);
    setState(2983);
    match(RpgParser::BlankIndicator);
    setState(2984);
    match(RpgParser::BlankFlag);
    setState(2985);
    match(RpgParser::BlankIndicator);
    setState(2986);
    match(RpgParser::CS_BlankFactor);
    setState(2987);
    match(RpgParser::CS_OperationAndExtender_Blank);
    setState(2988);
    match(RpgParser::CS_BlankFactor);
    setState(2989);
    match(RpgParser::CS_BlankFactor);
    setState(2990);
    match(RpgParser::CS_FieldLength);
    setState(2991);
    match(RpgParser::CS_DecimalPositions);
    setState(2992);
    match(RpgParser::BlankIndicator);
    setState(2993);
    match(RpgParser::BlankIndicator);
    setState(2994);
    match(RpgParser::BlankIndicator);
    setState(2995);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Blank_specContext ------------------------------------------------------------------

RpgParser::Blank_specContext::Blank_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_blankContext* RpgParser::Blank_specContext::cspec_blank() {
  return getRuleContext<RpgParser::Cspec_blankContext>(0);
}

tree::TerminalNode* RpgParser::Blank_specContext::BLANK_SPEC() {
  return getToken(RpgParser::BLANK_SPEC, 0);
}

tree::TerminalNode* RpgParser::Blank_specContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Blank_specContext::FS_FIXED() {
  return getToken(RpgParser::FS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Blank_specContext::IS_FIXED() {
  return getToken(RpgParser::IS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Blank_specContext::OS_FIXED() {
  return getToken(RpgParser::OS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Blank_specContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Blank_specContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::Blank_specContext::getRuleIndex() const {
  return RpgParser::RuleBlank_spec;
}

void RpgParser::Blank_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlank_spec(this);
}

void RpgParser::Blank_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlank_spec(this);
}


antlrcpp::Any RpgParser::Blank_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBlank_spec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Blank_specContext* RpgParser::blank_spec() {
  Blank_specContext *_localctx = _tracker.createInstance<Blank_specContext>(_ctx, getState());
  enterRule(_localctx, 336, RpgParser::RuleBlank_spec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3001);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(2997);
        cspec_blank();
        break;
      }

      case RpgParser::DS_FIXED:
      case RpgParser::FS_FIXED:
      case RpgParser::OS_FIXED:
      case RpgParser::IS_FIXED: {
        enterOuterAlt(_localctx, 2);
        setState(2998);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << RpgParser::DS_FIXED)
          | (1ULL << RpgParser::FS_FIXED)
          | (1ULL << RpgParser::OS_FIXED)
          | (1ULL << RpgParser::IS_FIXED))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2999);
        match(RpgParser::BLANK_SPEC);
        setState(3000);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PiBeginContext ------------------------------------------------------------------

RpgParser::PiBeginContext::PiBeginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::PiBeginContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::PiBeginContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::PiBeginContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::DEF_TYPE_PI() {
  return getToken(RpgParser::DEF_TYPE_PI, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::PiBeginContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::PiBeginContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::PiBeginContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::PiBeginContext::getRuleIndex() const {
  return RpgParser::RulePiBegin;
}

void RpgParser::PiBeginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPiBegin(this);
}

void RpgParser::PiBeginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPiBegin(this);
}


antlrcpp::Any RpgParser::PiBeginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPiBegin(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::PiBeginContext* RpgParser::piBegin() {
  PiBeginContext *_localctx = _tracker.createInstance<PiBeginContext>(_ctx, getState());
  enterRule(_localctx, 338, RpgParser::RulePiBegin);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3003);
    match(RpgParser::DS_FIXED);
    setState(3004);
    ds_name();
    setState(3005);
    match(RpgParser::EXTERNAL_DESCRIPTION);
    setState(3006);
    match(RpgParser::DATA_STRUCTURE_TYPE);
    setState(3007);
    match(RpgParser::DEF_TYPE_PI);
    setState(3008);
    match(RpgParser::FROM_POSITION);
    setState(3009);
    match(RpgParser::TO_POSITION);
    setState(3010);
    match(RpgParser::DATA_TYPE);
    setState(3011);
    match(RpgParser::DECIMAL_POSITIONS);
    setState(3012);
    match(RpgParser::RESERVED);
    setState(3016);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(3013);
      keyword();
      setState(3018);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3019);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parm_fixedContext ------------------------------------------------------------------

RpgParser::Parm_fixedContext::Parm_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Parm_fixedContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::Parm_fixedContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::DEF_TYPE_BLANK() {
  return getToken(RpgParser::DEF_TYPE_BLANK, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Parm_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Parm_fixedContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Parm_fixedContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::Parm_fixedContext::getRuleIndex() const {
  return RpgParser::RuleParm_fixed;
}

void RpgParser::Parm_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParm_fixed(this);
}

void RpgParser::Parm_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParm_fixed(this);
}


antlrcpp::Any RpgParser::Parm_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitParm_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Parm_fixedContext* RpgParser::parm_fixed() {
  Parm_fixedContext *_localctx = _tracker.createInstance<Parm_fixedContext>(_ctx, getState());
  enterRule(_localctx, 340, RpgParser::RuleParm_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3021);
    match(RpgParser::DS_FIXED);
    setState(3022);
    ds_name();
    setState(3023);
    match(RpgParser::EXTERNAL_DESCRIPTION);
    setState(3024);
    match(RpgParser::DATA_STRUCTURE_TYPE);
    setState(3025);
    match(RpgParser::DEF_TYPE_BLANK);
    setState(3026);
    match(RpgParser::FROM_POSITION);
    setState(3027);
    match(RpgParser::TO_POSITION);
    setState(3028);
    match(RpgParser::DATA_TYPE);
    setState(3029);
    match(RpgParser::DECIMAL_POSITIONS);
    setState(3030);
    match(RpgParser::RESERVED);
    setState(3034);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(3031);
      keyword();
      setState(3036);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3037);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pr_parm_fixedContext ------------------------------------------------------------------

RpgParser::Pr_parm_fixedContext::Pr_parm_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::DEF_TYPE_BLANK() {
  return getToken(RpgParser::DEF_TYPE_BLANK, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Pr_parm_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Ds_nameContext* RpgParser::Pr_parm_fixedContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::Pr_parm_fixedContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::Pr_parm_fixedContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::Pr_parm_fixedContext::getRuleIndex() const {
  return RpgParser::RulePr_parm_fixed;
}

void RpgParser::Pr_parm_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPr_parm_fixed(this);
}

void RpgParser::Pr_parm_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPr_parm_fixed(this);
}


antlrcpp::Any RpgParser::Pr_parm_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPr_parm_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Pr_parm_fixedContext* RpgParser::pr_parm_fixed() {
  Pr_parm_fixedContext *_localctx = _tracker.createInstance<Pr_parm_fixedContext>(_ctx, getState());
  enterRule(_localctx, 342, RpgParser::RulePr_parm_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3039);
    match(RpgParser::DS_FIXED);
    setState(3041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::CONTINUATION_NAME

    || _la == RpgParser::NAME) {
      setState(3040);
      ds_name();
    }
    setState(3043);
    match(RpgParser::EXTERNAL_DESCRIPTION);
    setState(3044);
    match(RpgParser::DATA_STRUCTURE_TYPE);
    setState(3045);
    match(RpgParser::DEF_TYPE_BLANK);
    setState(3046);
    match(RpgParser::FROM_POSITION);
    setState(3047);
    match(RpgParser::TO_POSITION);
    setState(3048);
    match(RpgParser::DATA_TYPE);
    setState(3049);
    match(RpgParser::DECIMAL_POSITIONS);
    setState(3050);
    match(RpgParser::RESERVED);
    setState(3054);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(3051);
      keyword();
      setState(3056);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3057);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pi_parm_fixedContext ------------------------------------------------------------------

RpgParser::Pi_parm_fixedContext::Pi_parm_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Parm_fixedContext* RpgParser::Pi_parm_fixedContext::parm_fixed() {
  return getRuleContext<RpgParser::Parm_fixedContext>(0);
}

RpgParser::PrBeginContext* RpgParser::Pi_parm_fixedContext::prBegin() {
  return getRuleContext<RpgParser::PrBeginContext>(0);
}

std::vector<RpgParser::Pr_parm_fixedContext *> RpgParser::Pi_parm_fixedContext::pr_parm_fixed() {
  return getRuleContexts<RpgParser::Pr_parm_fixedContext>();
}

RpgParser::Pr_parm_fixedContext* RpgParser::Pi_parm_fixedContext::pr_parm_fixed(size_t i) {
  return getRuleContext<RpgParser::Pr_parm_fixedContext>(i);
}


size_t RpgParser::Pi_parm_fixedContext::getRuleIndex() const {
  return RpgParser::RulePi_parm_fixed;
}

void RpgParser::Pi_parm_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPi_parm_fixed(this);
}

void RpgParser::Pi_parm_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPi_parm_fixed(this);
}


antlrcpp::Any RpgParser::Pi_parm_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPi_parm_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Pi_parm_fixedContext* RpgParser::pi_parm_fixed() {
  Pi_parm_fixedContext *_localctx = _tracker.createInstance<Pi_parm_fixedContext>(_ctx, getState());
  enterRule(_localctx, 344, RpgParser::RulePi_parm_fixed);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(3067);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3059);
      parm_fixed();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3060);
      prBegin();
      setState(3064);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3061);
          pr_parm_fixed(); 
        }
        setState(3066);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureContext ------------------------------------------------------------------

RpgParser::ProcedureContext::ProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::BeginProcedureContext* RpgParser::ProcedureContext::beginProcedure() {
  return getRuleContext<RpgParser::BeginProcedureContext>(0);
}

RpgParser::EndProcedureContext* RpgParser::ProcedureContext::endProcedure() {
  return getRuleContext<RpgParser::EndProcedureContext>(0);
}

RpgParser::Dcl_piContext* RpgParser::ProcedureContext::dcl_pi() {
  return getRuleContext<RpgParser::Dcl_piContext>(0);
}

std::vector<RpgParser::SubprocedurestatementContext *> RpgParser::ProcedureContext::subprocedurestatement() {
  return getRuleContexts<RpgParser::SubprocedurestatementContext>();
}

RpgParser::SubprocedurestatementContext* RpgParser::ProcedureContext::subprocedurestatement(size_t i) {
  return getRuleContext<RpgParser::SubprocedurestatementContext>(i);
}


size_t RpgParser::ProcedureContext::getRuleIndex() const {
  return RpgParser::RuleProcedure;
}

void RpgParser::ProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedure(this);
}

void RpgParser::ProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedure(this);
}


antlrcpp::Any RpgParser::ProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitProcedure(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ProcedureContext* RpgParser::procedure() {
  ProcedureContext *_localctx = _tracker.createInstance<ProcedureContext>(_ctx, getState());
  enterRule(_localctx, 346, RpgParser::RuleProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3069);
    beginProcedure();
    setState(3071);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
    case 1: {
      setState(3070);
      dcl_pi();
      break;
    }

    }
    setState(3076);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 5) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 5)) & ((1ULL << (RpgParser::COMMENT_SPEC_FIXED - 5))
      | (1ULL << (RpgParser::DS_FIXED - 5))
      | (1ULL << (RpgParser::FS_FIXED - 5))
      | (1ULL << (RpgParser::OS_FIXED - 5))
      | (1ULL << (RpgParser::CS_FIXED - 5))
      | (1ULL << (RpgParser::CS_ExecSQL - 5))
      | (1ULL << (RpgParser::IS_FIXED - 5))
      | (1ULL << (RpgParser::HS_FIXED - 5))
      | (1ULL << (RpgParser::BLANK_LINE - 5))
      | (1ULL << (RpgParser::COMMENTS - 5))
      | (1ULL << (RpgParser::DIRECTIVE - 5))
      | (1ULL << (RpgParser::OPEN_PAREN - 5))
      | (1ULL << (RpgParser::NUMBER - 5))
      | (1ULL << (RpgParser::ID - 5))
      | (1ULL << (RpgParser::OP_ACQ - 5))
      | (1ULL << (RpgParser::OP_BEGSR - 5))
      | (1ULL << (RpgParser::OP_CALLP - 5))
      | (1ULL << (RpgParser::OP_CHAIN - 5))
      | (1ULL << (RpgParser::OP_CLEAR - 5))
      | (1ULL << (RpgParser::OP_CLOSE - 5))
      | (1ULL << (RpgParser::OP_COMMIT - 5))
      | (1ULL << (RpgParser::OP_DEALLOC - 5))
      | (1ULL << (RpgParser::OP_DELETE - 5))
      | (1ULL << (RpgParser::OP_DOU - 5))
      | (1ULL << (RpgParser::OP_DOW - 5))
      | (1ULL << (RpgParser::OP_DSPLY - 5))
      | (1ULL << (RpgParser::OP_DUMP - 5)))) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & ((1ULL << (RpgParser::OP_ENDSR - 73))
      | (1ULL << (RpgParser::OP_EVAL - 73))
      | (1ULL << (RpgParser::OP_EVALR - 73))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 73))
      | (1ULL << (RpgParser::OP_EXCEPT - 73))
      | (1ULL << (RpgParser::OP_EXFMT - 73))
      | (1ULL << (RpgParser::OP_EXSR - 73))
      | (1ULL << (RpgParser::OP_FEOD - 73))
      | (1ULL << (RpgParser::OP_FOR - 73))
      | (1ULL << (RpgParser::OP_FORCE - 73))
      | (1ULL << (RpgParser::OP_IF - 73))
      | (1ULL << (RpgParser::OP_IN - 73))
      | (1ULL << (RpgParser::OP_ITER - 73))
      | (1ULL << (RpgParser::OP_LEAVE - 73))
      | (1ULL << (RpgParser::OP_LEAVESR - 73))
      | (1ULL << (RpgParser::OP_MONITOR - 73))
      | (1ULL << (RpgParser::OP_NEXT - 73))
      | (1ULL << (RpgParser::OP_OPEN - 73))
      | (1ULL << (RpgParser::OP_OTHER - 73))
      | (1ULL << (RpgParser::OP_OUT - 73))
      | (1ULL << (RpgParser::OP_POST - 73))
      | (1ULL << (RpgParser::OP_READ - 73))
      | (1ULL << (RpgParser::OP_READC - 73))
      | (1ULL << (RpgParser::OP_READE - 73))
      | (1ULL << (RpgParser::OP_READP - 73))
      | (1ULL << (RpgParser::OP_READPE - 73))
      | (1ULL << (RpgParser::OP_REL - 73))
      | (1ULL << (RpgParser::OP_RESET - 73))
      | (1ULL << (RpgParser::OP_RETURN - 73))
      | (1ULL << (RpgParser::OP_ROLBK - 73))
      | (1ULL << (RpgParser::OP_SELECT - 73))
      | (1ULL << (RpgParser::OP_SETGT - 73))
      | (1ULL << (RpgParser::OP_SETLL - 73))
      | (1ULL << (RpgParser::OP_SORTA - 73))
      | (1ULL << (RpgParser::OP_TEST - 73))
      | (1ULL << (RpgParser::OP_UNLOCK - 73))
      | (1ULL << (RpgParser::OP_UPDATE - 73))
      | (1ULL << (RpgParser::OP_WHEN - 73))
      | (1ULL << (RpgParser::OP_WRITE - 73))
      | (1ULL << (RpgParser::OP_XML_INTO - 73))
      | (1ULL << (RpgParser::OP_XML_SAX - 73))
      | (1ULL << (RpgParser::DS_Standalone - 73))
      | (1ULL << (RpgParser::DS_DataStructureStart - 73))
      | (1ULL << (RpgParser::DS_PrototypeStart - 73))
      | (1ULL << (RpgParser::DS_Constant - 73))
      | (1ULL << (RpgParser::FS_FreeFile - 73))
      | (1ULL << (RpgParser::EXEC_SQL - 73))
      | (1ULL << (RpgParser::BIF_ABS - 73))
      | (1ULL << (RpgParser::BIF_ADDR - 73))
      | (1ULL << (RpgParser::BIF_ALLOC - 73))
      | (1ULL << (RpgParser::BIF_BITAND - 73))
      | (1ULL << (RpgParser::BIF_BITNOT - 73)))) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & ((1ULL << (RpgParser::BIF_BITOR - 137))
      | (1ULL << (RpgParser::BIF_BITXOR - 137))
      | (1ULL << (RpgParser::BIF_CHAR - 137))
      | (1ULL << (RpgParser::BIF_CHECK - 137))
      | (1ULL << (RpgParser::BIF_CHECKR - 137))
      | (1ULL << (RpgParser::BIF_DATE - 137))
      | (1ULL << (RpgParser::BIF_DAYS - 137))
      | (1ULL << (RpgParser::BIF_DEC - 137))
      | (1ULL << (RpgParser::BIF_DECH - 137))
      | (1ULL << (RpgParser::BIF_DECPOS - 137))
      | (1ULL << (RpgParser::BIF_DIFF - 137))
      | (1ULL << (RpgParser::BIF_DIV - 137))
      | (1ULL << (RpgParser::BIF_EDITC - 137))
      | (1ULL << (RpgParser::BIF_EDITFLT - 137))
      | (1ULL << (RpgParser::BIF_EDITW - 137))
      | (1ULL << (RpgParser::BIF_ELEM - 137))
      | (1ULL << (RpgParser::BIF_EOF - 137))
      | (1ULL << (RpgParser::BIF_EQUAL - 137))
      | (1ULL << (RpgParser::BIF_ERROR - 137))
      | (1ULL << (RpgParser::BIF_FIELDS - 137))
      | (1ULL << (RpgParser::BIF_FLOAT - 137))
      | (1ULL << (RpgParser::BIF_FOUND - 137))
      | (1ULL << (RpgParser::BIF_GRAPH - 137))
      | (1ULL << (RpgParser::BIF_HANDLER - 137))
      | (1ULL << (RpgParser::BIF_HOURS - 137))
      | (1ULL << (RpgParser::BIF_INT - 137))
      | (1ULL << (RpgParser::BIF_INTH - 137))
      | (1ULL << (RpgParser::BIF_KDS - 137))
      | (1ULL << (RpgParser::BIF_LEN - 137))
      | (1ULL << (RpgParser::BIF_LOOKUP - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 137))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 137))
      | (1ULL << (RpgParser::BIF_MINUTES - 137))
      | (1ULL << (RpgParser::BIF_MONTHS - 137))
      | (1ULL << (RpgParser::BIF_MSECONDS - 137))
      | (1ULL << (RpgParser::BIF_NULLIND - 137))
      | (1ULL << (RpgParser::BIF_OCCUR - 137))
      | (1ULL << (RpgParser::BIF_OPEN - 137))
      | (1ULL << (RpgParser::BIF_PADDR - 137))
      | (1ULL << (RpgParser::BIF_PARMS - 137))
      | (1ULL << (RpgParser::BIF_PARMNUM - 137))
      | (1ULL << (RpgParser::BIF_REALLOC - 137))
      | (1ULL << (RpgParser::BIF_REM - 137))
      | (1ULL << (RpgParser::BIF_REPLACE - 137))
      | (1ULL << (RpgParser::BIF_SCAN - 137))
      | (1ULL << (RpgParser::BIF_SCANRPL - 137))
      | (1ULL << (RpgParser::BIF_SECONDS - 137))
      | (1ULL << (RpgParser::BIF_SHTDN - 137))
      | (1ULL << (RpgParser::BIF_SIZE - 137))
      | (1ULL << (RpgParser::BIF_SQRT - 137))
      | (1ULL << (RpgParser::BIF_STATUS - 137))
      | (1ULL << (RpgParser::BIF_STR - 137))
      | (1ULL << (RpgParser::BIF_SUBARR - 137))
      | (1ULL << (RpgParser::BIF_SUBDT - 137))
      | (1ULL << (RpgParser::BIF_SUBST - 137))
      | (1ULL << (RpgParser::BIF_THIS - 137))
      | (1ULL << (RpgParser::BIF_TIME - 137))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 137))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 137)))) != 0) || ((((_la - 201) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 201)) & ((1ULL << (RpgParser::BIF_TLOOKUPGE - 201))
      | (1ULL << (RpgParser::BIF_TRIM - 201))
      | (1ULL << (RpgParser::BIF_TRIML - 201))
      | (1ULL << (RpgParser::BIF_TRIMR - 201))
      | (1ULL << (RpgParser::BIF_UCS2 - 201))
      | (1ULL << (RpgParser::BIF_UNS - 201))
      | (1ULL << (RpgParser::BIF_UNSH - 201))
      | (1ULL << (RpgParser::BIF_XFOOT - 201))
      | (1ULL << (RpgParser::BIF_XLATE - 201))
      | (1ULL << (RpgParser::BIF_XML - 201))
      | (1ULL << (RpgParser::BIF_YEARS - 201))
      | (1ULL << (RpgParser::SPLAT_ALL - 201))
      | (1ULL << (RpgParser::SPLAT_NONE - 201))
      | (1ULL << (RpgParser::SPLAT_YES - 201))
      | (1ULL << (RpgParser::SPLAT_NO - 201))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 201))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 201))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 201))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 201))
      | (1ULL << (RpgParser::SPLAT_VRM - 201))
      | (1ULL << (RpgParser::SPLAT_ALLG - 201))
      | (1ULL << (RpgParser::SPLAT_ALLU - 201))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 201))
      | (1ULL << (RpgParser::SPLAT_ALLX - 201))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 201))
      | (1ULL << (RpgParser::SPLAT_CANCL - 201))
      | (1ULL << (RpgParser::SPLAT_CYMD - 201))
      | (1ULL << (RpgParser::SPLAT_CMDY - 201))
      | (1ULL << (RpgParser::SPLAT_CDMY - 201))
      | (1ULL << (RpgParser::SPLAT_MDY - 201))
      | (1ULL << (RpgParser::SPLAT_DMY - 201))
      | (1ULL << (RpgParser::SPLAT_DFT - 201))
      | (1ULL << (RpgParser::SPLAT_YMD - 201))
      | (1ULL << (RpgParser::SPLAT_JUL - 201))
      | (1ULL << (RpgParser::SPLAT_JAVA - 201))
      | (1ULL << (RpgParser::SPLAT_ISO - 201))
      | (1ULL << (RpgParser::SPLAT_USA - 201))
      | (1ULL << (RpgParser::SPLAT_EUR - 201))
      | (1ULL << (RpgParser::SPLAT_JIS - 201))
      | (1ULL << (RpgParser::SPLAT_DATE - 201))
      | (1ULL << (RpgParser::SPLAT_DAY - 201))
      | (1ULL << (RpgParser::SPlAT_DETC - 201))
      | (1ULL << (RpgParser::SPLAT_DETL - 201))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 201))
      | (1ULL << (RpgParser::SPLAT_END - 201))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 201))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 201))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 201))
      | (1ULL << (RpgParser::SPLAT_EXT - 201))
      | (1ULL << (RpgParser::SPLAT_FILE - 201))
      | (1ULL << (RpgParser::SPLAT_GETIN - 201))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 201))
      | (1ULL << (RpgParser::SPLAT_INIT - 201))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 201))
      | (1ULL << (RpgParser::SPLAT_INZSR - 201))
      | (1ULL << (RpgParser::SPLAT_IN - 201))
      | (1ULL << (RpgParser::SPLAT_INPUT - 201))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 201))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 201))
      | (1ULL << (RpgParser::SPLAT_JOB - 201))
      | (1ULL << (RpgParser::SPLAT_LDA - 201))
      | (1ULL << (RpgParser::SPLAT_LIKE - 201))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 201))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 201)))) != 0) || ((((_la - 265) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 265)) & ((1ULL << (RpgParser::SPLAT_KEY - 265))
      | (1ULL << (RpgParser::SPLAT_MONTH - 265))
      | (1ULL << (RpgParser::SPLAT_NEXT - 265))
      | (1ULL << (RpgParser::SPLAT_NOIND - 265))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 265))
      | (1ULL << (RpgParser::SPLAT_NULL - 265))
      | (1ULL << (RpgParser::SPLAT_OFL - 265))
      | (1ULL << (RpgParser::SPLAT_ON - 265))
      | (1ULL << (RpgParser::SPLAT_ONLY - 265))
      | (1ULL << (RpgParser::SPLAT_OFF - 265))
      | (1ULL << (RpgParser::SPLAT_PDA - 265))
      | (1ULL << (RpgParser::SPLAT_PLACE - 265))
      | (1ULL << (RpgParser::SPLAT_PSSR - 265))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 265))
      | (1ULL << (RpgParser::SPLAT_START - 265))
      | (1ULL << (RpgParser::SPLAT_SYS - 265))
      | (1ULL << (RpgParser::SPLAT_TERM - 265))
      | (1ULL << (RpgParser::SPLAT_TOTC - 265))
      | (1ULL << (RpgParser::SPLAT_TOTL - 265))
      | (1ULL << (RpgParser::SPLAT_USER - 265))
      | (1ULL << (RpgParser::SPLAT_VAR - 265))
      | (1ULL << (RpgParser::SPLAT_YEAR - 265))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 265))
      | (1ULL << (RpgParser::SPLAT_HMS - 265))
      | (1ULL << (RpgParser::SPLAT_INLR - 265))
      | (1ULL << (RpgParser::SPLAT_INOF - 265))
      | (1ULL << (RpgParser::SPLAT_DATA - 265))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 265))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 265))
      | (1ULL << (RpgParser::SPLAT_MAX - 265))
      | (1ULL << (RpgParser::SPLAT_LOCK - 265))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 265))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 265))
      | (1ULL << (RpgParser::SPLAT_D - 265))
      | (1ULL << (RpgParser::SPLAT_H - 265))
      | (1ULL << (RpgParser::SPLAT_HOURS - 265))
      | (1ULL << (RpgParser::SPLAT_DAYS - 265))
      | (1ULL << (RpgParser::SPLAT_M - 265))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 265))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 265))
      | (1ULL << (RpgParser::SPLAT_MN - 265))
      | (1ULL << (RpgParser::SPLAT_MS - 265))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 265))
      | (1ULL << (RpgParser::SPLAT_S - 265))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 265))
      | (1ULL << (RpgParser::SPLAT_Y - 265))
      | (1ULL << (RpgParser::SPLAT_YEARS - 265))
      | (1ULL << (RpgParser::UDATE - 265))
      | (1ULL << (RpgParser::UMONTH - 265))
      | (1ULL << (RpgParser::UYEAR - 265))
      | (1ULL << (RpgParser::UDAY - 265))
      | (1ULL << (RpgParser::CHAR - 265))
      | (1ULL << (RpgParser::VARCHAR - 265))
      | (1ULL << (RpgParser::UCS2 - 265))
      | (1ULL << (RpgParser::DATE_ - 265))
      | (1ULL << (RpgParser::VARUCS2 - 265))
      | (1ULL << (RpgParser::GRAPH - 265))
      | (1ULL << (RpgParser::VARGRAPH - 265))
      | (1ULL << (RpgParser::IND - 265)))) != 0) || ((((_la - 329) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 329)) & ((1ULL << (RpgParser::PACKED - 329))
      | (1ULL << (RpgParser::ZONED - 329))
      | (1ULL << (RpgParser::BINDEC - 329))
      | (1ULL << (RpgParser::INT - 329))
      | (1ULL << (RpgParser::UNS - 329))
      | (1ULL << (RpgParser::FLOAT - 329))
      | (1ULL << (RpgParser::TIME - 329))
      | (1ULL << (RpgParser::TIMESTAMP - 329))
      | (1ULL << (RpgParser::POINTER - 329))
      | (1ULL << (RpgParser::OBJECT - 329))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 329))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 329))
      | (1ULL << (RpgParser::KEYWORD_ALT - 329))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 329))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 329))
      | (1ULL << (RpgParser::KEYWORD_BASED - 329))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 329))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 329))
      | (1ULL << (RpgParser::KEYWORD_CONST - 329))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 329))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 329))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 329))
      | (1ULL << (RpgParser::KEYWORD_DIM - 329))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 329))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 329))
      | (1ULL << (RpgParser::KEYWORD_EXT - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 329))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 329))
      | (1ULL << (RpgParser::KEYWORD_INZ - 329))
      | (1ULL << (RpgParser::KEYWORD_LEN - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 329))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 329))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 329))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 329))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 329))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 329))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 329))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 329))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 329))
      | (1ULL << (RpgParser::KEYWORD_POS - 329))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 329))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 329))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 329))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 329))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 329))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 329))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 329))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 329))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 329))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 329))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 329))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 329)))) != 0) || ((((_la - 393) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 393)) & ((1ULL << (RpgParser::KEYWORD_FORMLEN - 393))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 393))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 393))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 393))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 393))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 393))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 393))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 393))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 393))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 393))
      | (1ULL << (RpgParser::KEYWORD_PASS - 393))
      | (1ULL << (RpgParser::KEYWORD_PGMNAME - 393))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 393))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 393))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 393))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 393))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 393))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 393))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 393))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 393))
      | (1ULL << (RpgParser::KEYWORD_SLN - 393))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 393))
      | (1ULL << (RpgParser::KEYWORD_DISK - 393))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 393))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 393))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 393))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 393))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 393))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 393))
      | (1ULL << (RpgParser::NOT - 393))
      | (1ULL << (RpgParser::PLUS - 393))
      | (1ULL << (RpgParser::MINUS - 393))
      | (1ULL << (RpgParser::MULT_NOSPACE - 393))
      | (1ULL << (RpgParser::FREE_BY - 393))
      | (1ULL << (RpgParser::FREE_TO - 393))
      | (1ULL << (RpgParser::FREE_DOWNTO - 393))
      | (1ULL << (RpgParser::HexLiteralStart - 393))
      | (1ULL << (RpgParser::DateLiteralStart - 393))
      | (1ULL << (RpgParser::TimeLiteralStart - 393))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 393))
      | (1ULL << (RpgParser::GraphicLiteralStart - 393))
      | (1ULL << (RpgParser::UCS2LiteralStart - 393))
      | (1ULL << (RpgParser::StringLiteralStart - 393)))) != 0)) {
      setState(3073);
      dynamic_cast<ProcedureContext *>(_localctx)->statements = subprocedurestatement();
      setState(3078);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3079);
    endProcedure();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginProcedureContext ------------------------------------------------------------------

RpgParser::BeginProcedureContext::BeginProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::PsBeginContext* RpgParser::BeginProcedureContext::psBegin() {
  return getRuleContext<RpgParser::PsBeginContext>(0);
}

RpgParser::FreeBeginProcedureContext* RpgParser::BeginProcedureContext::freeBeginProcedure() {
  return getRuleContext<RpgParser::FreeBeginProcedureContext>(0);
}


size_t RpgParser::BeginProcedureContext::getRuleIndex() const {
  return RpgParser::RuleBeginProcedure;
}

void RpgParser::BeginProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginProcedure(this);
}

void RpgParser::BeginProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginProcedure(this);
}


antlrcpp::Any RpgParser::BeginProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBeginProcedure(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BeginProcedureContext* RpgParser::beginProcedure() {
  BeginProcedureContext *_localctx = _tracker.createInstance<BeginProcedureContext>(_ctx, getState());
  enterRule(_localctx, 348, RpgParser::RuleBeginProcedure);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3083);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::PS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(3081);
        psBegin();
        break;
      }

      case RpgParser::DS_ProcedureStart: {
        enterOuterAlt(_localctx, 2);
        setState(3082);
        freeBeginProcedure();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndProcedureContext ------------------------------------------------------------------

RpgParser::EndProcedureContext::EndProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::PsEndContext* RpgParser::EndProcedureContext::psEnd() {
  return getRuleContext<RpgParser::PsEndContext>(0);
}

RpgParser::FreeEndProcedureContext* RpgParser::EndProcedureContext::freeEndProcedure() {
  return getRuleContext<RpgParser::FreeEndProcedureContext>(0);
}


size_t RpgParser::EndProcedureContext::getRuleIndex() const {
  return RpgParser::RuleEndProcedure;
}

void RpgParser::EndProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndProcedure(this);
}

void RpgParser::EndProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndProcedure(this);
}


antlrcpp::Any RpgParser::EndProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndProcedure(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndProcedureContext* RpgParser::endProcedure() {
  EndProcedureContext *_localctx = _tracker.createInstance<EndProcedureContext>(_ctx, getState());
  enterRule(_localctx, 350, RpgParser::RuleEndProcedure);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3087);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::PS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(3085);
        psEnd();
        break;
      }

      case RpgParser::DS_ProcedureEnd: {
        enterOuterAlt(_localctx, 2);
        setState(3086);
        freeEndProcedure();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PsBeginContext ------------------------------------------------------------------

RpgParser::PsBeginContext::PsBeginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::PsBeginContext::PS_FIXED() {
  return getToken(RpgParser::PS_FIXED, 0);
}

RpgParser::Ps_nameContext* RpgParser::PsBeginContext::ps_name() {
  return getRuleContext<RpgParser::Ps_nameContext>(0);
}

tree::TerminalNode* RpgParser::PsBeginContext::PS_BEGIN() {
  return getToken(RpgParser::PS_BEGIN, 0);
}

tree::TerminalNode* RpgParser::PsBeginContext::PS_KEYWORDS() {
  return getToken(RpgParser::PS_KEYWORDS, 0);
}


size_t RpgParser::PsBeginContext::getRuleIndex() const {
  return RpgParser::RulePsBegin;
}

void RpgParser::PsBeginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPsBegin(this);
}

void RpgParser::PsBeginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPsBegin(this);
}


antlrcpp::Any RpgParser::PsBeginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPsBegin(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::PsBeginContext* RpgParser::psBegin() {
  PsBeginContext *_localctx = _tracker.createInstance<PsBeginContext>(_ctx, getState());
  enterRule(_localctx, 352, RpgParser::RulePsBegin);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3089);
    match(RpgParser::PS_FIXED);
    setState(3090);
    ps_name();
    setState(3091);
    match(RpgParser::PS_BEGIN);
    setState(3092);
    match(RpgParser::PS_KEYWORDS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FreeBeginProcedureContext ------------------------------------------------------------------

RpgParser::FreeBeginProcedureContext::FreeBeginProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FreeBeginProcedureContext::DS_ProcedureStart() {
  return getToken(RpgParser::DS_ProcedureStart, 0);
}

RpgParser::IdentifierContext* RpgParser::FreeBeginProcedureContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::FreeBeginProcedureContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}


size_t RpgParser::FreeBeginProcedureContext::getRuleIndex() const {
  return RpgParser::RuleFreeBeginProcedure;
}

void RpgParser::FreeBeginProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFreeBeginProcedure(this);
}

void RpgParser::FreeBeginProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFreeBeginProcedure(this);
}


antlrcpp::Any RpgParser::FreeBeginProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFreeBeginProcedure(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FreeBeginProcedureContext* RpgParser::freeBeginProcedure() {
  FreeBeginProcedureContext *_localctx = _tracker.createInstance<FreeBeginProcedureContext>(_ctx, getState());
  enterRule(_localctx, 354, RpgParser::RuleFreeBeginProcedure);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3094);
    match(RpgParser::DS_ProcedureStart);
    setState(3095);
    identifier();
    setState(3096);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PsEndContext ------------------------------------------------------------------

RpgParser::PsEndContext::PsEndContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::PsEndContext::PS_FIXED() {
  return getToken(RpgParser::PS_FIXED, 0);
}

RpgParser::Ps_nameContext* RpgParser::PsEndContext::ps_name() {
  return getRuleContext<RpgParser::Ps_nameContext>(0);
}

tree::TerminalNode* RpgParser::PsEndContext::PS_END() {
  return getToken(RpgParser::PS_END, 0);
}

tree::TerminalNode* RpgParser::PsEndContext::PS_KEYWORDS() {
  return getToken(RpgParser::PS_KEYWORDS, 0);
}


size_t RpgParser::PsEndContext::getRuleIndex() const {
  return RpgParser::RulePsEnd;
}

void RpgParser::PsEndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPsEnd(this);
}

void RpgParser::PsEndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPsEnd(this);
}


antlrcpp::Any RpgParser::PsEndContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPsEnd(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::PsEndContext* RpgParser::psEnd() {
  PsEndContext *_localctx = _tracker.createInstance<PsEndContext>(_ctx, getState());
  enterRule(_localctx, 356, RpgParser::RulePsEnd);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3098);
    match(RpgParser::PS_FIXED);
    setState(3099);
    ps_name();
    setState(3100);
    match(RpgParser::PS_END);
    setState(3101);
    match(RpgParser::PS_KEYWORDS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FreeEndProcedureContext ------------------------------------------------------------------

RpgParser::FreeEndProcedureContext::FreeEndProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FreeEndProcedureContext::DS_ProcedureEnd() {
  return getToken(RpgParser::DS_ProcedureEnd, 0);
}

tree::TerminalNode* RpgParser::FreeEndProcedureContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::IdentifierContext* RpgParser::FreeEndProcedureContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::FreeEndProcedureContext::getRuleIndex() const {
  return RpgParser::RuleFreeEndProcedure;
}

void RpgParser::FreeEndProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFreeEndProcedure(this);
}

void RpgParser::FreeEndProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFreeEndProcedure(this);
}


antlrcpp::Any RpgParser::FreeEndProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFreeEndProcedure(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FreeEndProcedureContext* RpgParser::freeEndProcedure() {
  FreeEndProcedureContext *_localctx = _tracker.createInstance<FreeEndProcedureContext>(_ctx, getState());
  enterRule(_localctx, 358, RpgParser::RuleFreeEndProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3103);
    match(RpgParser::DS_ProcedureEnd);
    setState(3105);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(3104);
      identifier();
    }
    setState(3107);
    match(RpgParser::FREE_SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrBeginContext ------------------------------------------------------------------

RpgParser::PrBeginContext::PrBeginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::PrBeginContext::DS_FIXED() {
  return getToken(RpgParser::DS_FIXED, 0);
}

RpgParser::Ds_nameContext* RpgParser::PrBeginContext::ds_name() {
  return getRuleContext<RpgParser::Ds_nameContext>(0);
}

tree::TerminalNode* RpgParser::PrBeginContext::EXTERNAL_DESCRIPTION() {
  return getToken(RpgParser::EXTERNAL_DESCRIPTION, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::DATA_STRUCTURE_TYPE() {
  return getToken(RpgParser::DATA_STRUCTURE_TYPE, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::DEF_TYPE_PR() {
  return getToken(RpgParser::DEF_TYPE_PR, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::FROM_POSITION() {
  return getToken(RpgParser::FROM_POSITION, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::TO_POSITION() {
  return getToken(RpgParser::TO_POSITION, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::DATA_TYPE() {
  return getToken(RpgParser::DATA_TYPE, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::DECIMAL_POSITIONS() {
  return getToken(RpgParser::DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::RESERVED() {
  return getToken(RpgParser::RESERVED, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::PrBeginContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::KeywordContext *> RpgParser::PrBeginContext::keyword() {
  return getRuleContexts<RpgParser::KeywordContext>();
}

RpgParser::KeywordContext* RpgParser::PrBeginContext::keyword(size_t i) {
  return getRuleContext<RpgParser::KeywordContext>(i);
}


size_t RpgParser::PrBeginContext::getRuleIndex() const {
  return RpgParser::RulePrBegin;
}

void RpgParser::PrBeginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrBegin(this);
}

void RpgParser::PrBeginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrBegin(this);
}


antlrcpp::Any RpgParser::PrBeginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPrBegin(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::PrBeginContext* RpgParser::prBegin() {
  PrBeginContext *_localctx = _tracker.createInstance<PrBeginContext>(_ctx, getState());
  enterRule(_localctx, 360, RpgParser::RulePrBegin);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3109);
    match(RpgParser::DS_FIXED);
    setState(3110);
    ds_name();
    setState(3111);
    match(RpgParser::EXTERNAL_DESCRIPTION);
    setState(3112);
    match(RpgParser::DATA_STRUCTURE_TYPE);
    setState(3113);
    match(RpgParser::DEF_TYPE_PR);
    setState(3114);
    match(RpgParser::FROM_POSITION);
    setState(3115);
    match(RpgParser::TO_POSITION);
    setState(3116);
    match(RpgParser::DATA_TYPE);
    setState(3117);
    match(RpgParser::DECIMAL_POSITIONS);
    setState(3118);
    match(RpgParser::RESERVED);
    setState(3122);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::BIF_ELEM || ((((_la - 339) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 339)) & ((1ULL << (RpgParser::KEYWORD_ALIAS - 339))
      | (1ULL << (RpgParser::KEYWORD_ALIGN - 339))
      | (1ULL << (RpgParser::KEYWORD_ALT - 339))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 339))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_BASED - 339))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 339))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 339))
      | (1ULL << (RpgParser::KEYWORD_CONST - 339))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 339))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 339))
      | (1ULL << (RpgParser::KEYWORD_DIM - 339))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 339))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 339))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 339))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 339))
      | (1ULL << (RpgParser::KEYWORD_INZ - 339))
      | (1ULL << (RpgParser::KEYWORD_LEN - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 339))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 339))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 339))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 339))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 339))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 339))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 339))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 339))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 339))
      | (1ULL << (RpgParser::KEYWORD_POS - 339))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 339))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 339))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 339))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 339))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 339))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 339))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 339))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 339))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 339)))) != 0) || _la == RpgParser::KEYWORD_SQLTYPE

    || _la == RpgParser::KEYWORD_PSDS) {
      setState(3119);
      keyword();
      setState(3124);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3125);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubroutineContext ------------------------------------------------------------------

RpgParser::SubroutineContext::SubroutineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::BegsrContext* RpgParser::SubroutineContext::begsr() {
  return getRuleContext<RpgParser::BegsrContext>(0);
}

RpgParser::EndsrContext* RpgParser::SubroutineContext::endsr() {
  return getRuleContext<RpgParser::EndsrContext>(0);
}

std::vector<RpgParser::StatementContext *> RpgParser::SubroutineContext::statement() {
  return getRuleContexts<RpgParser::StatementContext>();
}

RpgParser::StatementContext* RpgParser::SubroutineContext::statement(size_t i) {
  return getRuleContext<RpgParser::StatementContext>(i);
}


size_t RpgParser::SubroutineContext::getRuleIndex() const {
  return RpgParser::RuleSubroutine;
}

void RpgParser::SubroutineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubroutine(this);
}

void RpgParser::SubroutineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubroutine(this);
}


antlrcpp::Any RpgParser::SubroutineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSubroutine(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::SubroutineContext* RpgParser::subroutine() {
  SubroutineContext *_localctx = _tracker.createInstance<SubroutineContext>(_ctx, getState());
  enterRule(_localctx, 362, RpgParser::RuleSubroutine);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3127);
    dynamic_cast<SubroutineContext *>(_localctx)->begin = begsr();
    setState(3131);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3128);
        statement(); 
      }
      setState(3133);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx);
    }
    setState(3134);
    dynamic_cast<SubroutineContext *>(_localctx)->end = endsr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubprocedurestatementContext ------------------------------------------------------------------

RpgParser::SubprocedurestatementContext::SubprocedurestatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::StatementContext* RpgParser::SubprocedurestatementContext::statement() {
  return getRuleContext<RpgParser::StatementContext>(0);
}

RpgParser::SubroutineContext* RpgParser::SubprocedurestatementContext::subroutine() {
  return getRuleContext<RpgParser::SubroutineContext>(0);
}

RpgParser::Dcl_prContext* RpgParser::SubprocedurestatementContext::dcl_pr() {
  return getRuleContext<RpgParser::Dcl_prContext>(0);
}


size_t RpgParser::SubprocedurestatementContext::getRuleIndex() const {
  return RpgParser::RuleSubprocedurestatement;
}

void RpgParser::SubprocedurestatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubprocedurestatement(this);
}

void RpgParser::SubprocedurestatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubprocedurestatement(this);
}


antlrcpp::Any RpgParser::SubprocedurestatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSubprocedurestatement(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::SubprocedurestatementContext* RpgParser::subprocedurestatement() {
  SubprocedurestatementContext *_localctx = _tracker.createInstance<SubprocedurestatementContext>(_ctx, getState());
  enterRule(_localctx, 364, RpgParser::RuleSubprocedurestatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3139);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3136);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3137);
      subroutine();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3138);
      dcl_pr();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BegsrContext ------------------------------------------------------------------

RpgParser::BegsrContext::BegsrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsBEGSRContext* RpgParser::BegsrContext::csBEGSR() {
  return getRuleContext<RpgParser::CsBEGSRContext>(0);
}

RpgParser::FreeBEGSRContext* RpgParser::BegsrContext::freeBEGSR() {
  return getRuleContext<RpgParser::FreeBEGSRContext>(0);
}


size_t RpgParser::BegsrContext::getRuleIndex() const {
  return RpgParser::RuleBegsr;
}

void RpgParser::BegsrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegsr(this);
}

void RpgParser::BegsrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegsr(this);
}


antlrcpp::Any RpgParser::BegsrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBegsr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BegsrContext* RpgParser::begsr() {
  BegsrContext *_localctx = _tracker.createInstance<BegsrContext>(_ctx, getState());
  enterRule(_localctx, 366, RpgParser::RuleBegsr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3143);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(3141);
        csBEGSR();
        break;
      }

      case RpgParser::OP_BEGSR: {
        enterOuterAlt(_localctx, 2);
        setState(3142);
        freeBEGSR();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndsrContext ------------------------------------------------------------------

RpgParser::EndsrContext::EndsrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsENDSRContext* RpgParser::EndsrContext::csENDSR() {
  return getRuleContext<RpgParser::CsENDSRContext>(0);
}

RpgParser::FreeENDSRContext* RpgParser::EndsrContext::freeENDSR() {
  return getRuleContext<RpgParser::FreeENDSRContext>(0);
}


size_t RpgParser::EndsrContext::getRuleIndex() const {
  return RpgParser::RuleEndsr;
}

void RpgParser::EndsrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndsr(this);
}

void RpgParser::EndsrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndsr(this);
}


antlrcpp::Any RpgParser::EndsrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndsr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EndsrContext* RpgParser::endsr() {
  EndsrContext *_localctx = _tracker.createInstance<EndsrContext>(_ctx, getState());
  enterRule(_localctx, 368, RpgParser::RuleEndsr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3147);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FIXED: {
        enterOuterAlt(_localctx, 1);
        setState(3145);
        csENDSR();
        break;
      }

      case RpgParser::OP_ENDSR: {
        enterOuterAlt(_localctx, 2);
        setState(3146);
        freeENDSR();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsBEGSRContext ------------------------------------------------------------------

RpgParser::CsBEGSRContext::CsBEGSRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsBEGSRContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsBEGSRContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsBEGSRContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsBEGSRContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsBEGSRContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsBEGSRContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

tree::TerminalNode* RpgParser::CsBEGSRContext::OP_BEGSR() {
  return getToken(RpgParser::OP_BEGSR, 0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsBEGSRContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsBEGSRContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::CsBEGSRContext::getRuleIndex() const {
  return RpgParser::RuleCsBEGSR;
}

void RpgParser::CsBEGSRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsBEGSR(this);
}

void RpgParser::CsBEGSRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsBEGSR(this);
}


antlrcpp::Any RpgParser::CsBEGSRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsBEGSR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsBEGSRContext* RpgParser::csBEGSR() {
  CsBEGSRContext *_localctx = _tracker.createInstance<CsBEGSRContext>(_ctx, getState());
  enterRule(_localctx, 370, RpgParser::RuleCsBEGSR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3149);
    match(RpgParser::CS_FIXED);
    setState(3153);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3150);
        cspec_continuedIndicators(); 
      }
      setState(3155);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
    }
    setState(3156);
    cs_controlLevel();
    setState(3157);
    dynamic_cast<CsBEGSRContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(3158);
    dynamic_cast<CsBEGSRContext *>(_localctx)->indicators = cs_indicators();
    setState(3159);
    dynamic_cast<CsBEGSRContext *>(_localctx)->factor1 = factor();
    setState(3160);
    dynamic_cast<CsBEGSRContext *>(_localctx)->operation = match(RpgParser::OP_BEGSR);
    setState(3161);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FreeBEGSRContext ------------------------------------------------------------------

RpgParser::FreeBEGSRContext::FreeBEGSRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FreeBEGSRContext::OP_BEGSR() {
  return getToken(RpgParser::OP_BEGSR, 0);
}

RpgParser::IdentifierContext* RpgParser::FreeBEGSRContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::FreeBEGSRContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::FreeBEGSRContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::FreeBEGSRContext::getRuleIndex() const {
  return RpgParser::RuleFreeBEGSR;
}

void RpgParser::FreeBEGSRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFreeBEGSR(this);
}

void RpgParser::FreeBEGSRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFreeBEGSR(this);
}


antlrcpp::Any RpgParser::FreeBEGSRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFreeBEGSR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FreeBEGSRContext* RpgParser::freeBEGSR() {
  FreeBEGSRContext *_localctx = _tracker.createInstance<FreeBEGSRContext>(_ctx, getState());
  enterRule(_localctx, 372, RpgParser::RuleFreeBEGSR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3163);
    match(RpgParser::OP_BEGSR);
    setState(3164);
    identifier();
    setState(3165);
    match(RpgParser::FREE_SEMI);
    setState(3167);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
    case 1: {
      setState(3166);
      free_linecomments();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDSRContext ------------------------------------------------------------------

RpgParser::CsENDSRContext::CsENDSRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsENDSRContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

RpgParser::Cs_controlLevelContext* RpgParser::CsENDSRContext::cs_controlLevel() {
  return getRuleContext<RpgParser::Cs_controlLevelContext>(0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDSRContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::CsENDSRContext::onOffIndicatorsFlag() {
  return getRuleContext<RpgParser::OnOffIndicatorsFlagContext>(0);
}

RpgParser::Cs_indicatorsContext* RpgParser::CsENDSRContext::cs_indicators() {
  return getRuleContext<RpgParser::Cs_indicatorsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsENDSRContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

tree::TerminalNode* RpgParser::CsENDSRContext::OP_ENDSR() {
  return getToken(RpgParser::OP_ENDSR, 0);
}

std::vector<RpgParser::Cspec_continuedIndicatorsContext *> RpgParser::CsENDSRContext::cspec_continuedIndicators() {
  return getRuleContexts<RpgParser::Cspec_continuedIndicatorsContext>();
}

RpgParser::Cspec_continuedIndicatorsContext* RpgParser::CsENDSRContext::cspec_continuedIndicators(size_t i) {
  return getRuleContext<RpgParser::Cspec_continuedIndicatorsContext>(i);
}


size_t RpgParser::CsENDSRContext::getRuleIndex() const {
  return RpgParser::RuleCsENDSR;
}

void RpgParser::CsENDSRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDSR(this);
}

void RpgParser::CsENDSRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDSR(this);
}


antlrcpp::Any RpgParser::CsENDSRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDSR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDSRContext* RpgParser::csENDSR() {
  CsENDSRContext *_localctx = _tracker.createInstance<CsENDSRContext>(_ctx, getState());
  enterRule(_localctx, 374, RpgParser::RuleCsENDSR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3169);
    match(RpgParser::CS_FIXED);
    setState(3173);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3170);
        cspec_continuedIndicators(); 
      }
      setState(3175);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx);
    }
    setState(3176);
    cs_controlLevel();
    setState(3177);
    dynamic_cast<CsENDSRContext *>(_localctx)->indicatorsOff = onOffIndicatorsFlag();
    setState(3178);
    dynamic_cast<CsENDSRContext *>(_localctx)->indicators = cs_indicators();
    setState(3179);
    dynamic_cast<CsENDSRContext *>(_localctx)->factor1 = factor();
    setState(3180);
    dynamic_cast<CsENDSRContext *>(_localctx)->operation = match(RpgParser::OP_ENDSR);
    setState(3181);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FreeENDSRContext ------------------------------------------------------------------

RpgParser::FreeENDSRContext::FreeENDSRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FreeENDSRContext::OP_ENDSR() {
  return getToken(RpgParser::OP_ENDSR, 0);
}

tree::TerminalNode* RpgParser::FreeENDSRContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::IdentifierContext* RpgParser::FreeENDSRContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::LiteralContext* RpgParser::FreeENDSRContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

RpgParser::Free_linecommentsContext* RpgParser::FreeENDSRContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::FreeENDSRContext::getRuleIndex() const {
  return RpgParser::RuleFreeENDSR;
}

void RpgParser::FreeENDSRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFreeENDSR(this);
}

void RpgParser::FreeENDSRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFreeENDSR(this);
}


antlrcpp::Any RpgParser::FreeENDSRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFreeENDSR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FreeENDSRContext* RpgParser::freeENDSR() {
  FreeENDSRContext *_localctx = _tracker.createInstance<FreeENDSRContext>(_ctx, getState());
  enterRule(_localctx, 376, RpgParser::RuleFreeENDSR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3183);
    match(RpgParser::OP_ENDSR);
    setState(3186);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO: {
        setState(3184);
        identifier();
        break;
      }

      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        setState(3185);
        literal();
        break;
      }

      case RpgParser::FREE_SEMI: {
        break;
      }

    default:
      break;
    }
    setState(3188);
    match(RpgParser::FREE_SEMI);
    setState(3190);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
    case 1: {
      setState(3189);
      free_linecomments();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnOffIndicatorsFlagContext ------------------------------------------------------------------

RpgParser::OnOffIndicatorsFlagContext::OnOffIndicatorsFlagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::OnOffIndicatorsFlagContext::BlankFlag() {
  return getToken(RpgParser::BlankFlag, 0);
}

tree::TerminalNode* RpgParser::OnOffIndicatorsFlagContext::NoFlag() {
  return getToken(RpgParser::NoFlag, 0);
}


size_t RpgParser::OnOffIndicatorsFlagContext::getRuleIndex() const {
  return RpgParser::RuleOnOffIndicatorsFlag;
}

void RpgParser::OnOffIndicatorsFlagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnOffIndicatorsFlag(this);
}

void RpgParser::OnOffIndicatorsFlagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnOffIndicatorsFlag(this);
}


antlrcpp::Any RpgParser::OnOffIndicatorsFlagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOnOffIndicatorsFlag(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OnOffIndicatorsFlagContext* RpgParser::onOffIndicatorsFlag() {
  OnOffIndicatorsFlagContext *_localctx = _tracker.createInstance<OnOffIndicatorsFlagContext>(_ctx, getState());
  enterRule(_localctx, 378, RpgParser::RuleOnOffIndicatorsFlag);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3192);
    _la = _input->LA(1);
    if (!(_la == RpgParser::BlankFlag

    || _la == RpgParser::NoFlag)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cs_controlLevelContext ------------------------------------------------------------------

RpgParser::Cs_controlLevelContext::Cs_controlLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::ControlLevel0Indicator() {
  return getToken(RpgParser::ControlLevel0Indicator, 0);
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::LastRecordIndicator() {
  return getToken(RpgParser::LastRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::SubroutineIndicator() {
  return getToken(RpgParser::SubroutineIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::AndIndicator() {
  return getToken(RpgParser::AndIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_controlLevelContext::OrIndicator() {
  return getToken(RpgParser::OrIndicator, 0);
}


size_t RpgParser::Cs_controlLevelContext::getRuleIndex() const {
  return RpgParser::RuleCs_controlLevel;
}

void RpgParser::Cs_controlLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCs_controlLevel(this);
}

void RpgParser::Cs_controlLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCs_controlLevel(this);
}


antlrcpp::Any RpgParser::Cs_controlLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCs_controlLevel(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cs_controlLevelContext* RpgParser::cs_controlLevel() {
  Cs_controlLevelContext *_localctx = _tracker.createInstance<Cs_controlLevelContext>(_ctx, getState());
  enterRule(_localctx, 380, RpgParser::RuleCs_controlLevel);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3194);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::ControlLevel0Indicator - 689))
      | (1ULL << (RpgParser::LastRecordIndicator - 689))
      | (1ULL << (RpgParser::SubroutineIndicator - 689))
      | (1ULL << (RpgParser::AndIndicator - 689))
      | (1ULL << (RpgParser::OrIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cs_indicatorsContext ------------------------------------------------------------------

RpgParser::Cs_indicatorsContext::Cs_indicatorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::GeneralIndicator() {
  return getToken(RpgParser::GeneralIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::FunctionKeyIndicator() {
  return getToken(RpgParser::FunctionKeyIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::LastRecordIndicator() {
  return getToken(RpgParser::LastRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::MatchingRecordIndicator() {
  return getToken(RpgParser::MatchingRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::HaltIndicator() {
  return getToken(RpgParser::HaltIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::ReturnIndicator() {
  return getToken(RpgParser::ReturnIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::ExternalIndicator() {
  return getToken(RpgParser::ExternalIndicator, 0);
}

tree::TerminalNode* RpgParser::Cs_indicatorsContext::OverflowIndicator() {
  return getToken(RpgParser::OverflowIndicator, 0);
}


size_t RpgParser::Cs_indicatorsContext::getRuleIndex() const {
  return RpgParser::RuleCs_indicators;
}

void RpgParser::Cs_indicatorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCs_indicators(this);
}

void RpgParser::Cs_indicatorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCs_indicators(this);
}


antlrcpp::Any RpgParser::Cs_indicatorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCs_indicators(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cs_indicatorsContext* RpgParser::cs_indicators() {
  Cs_indicatorsContext *_localctx = _tracker.createInstance<Cs_indicatorsContext>(_ctx, getState());
  enterRule(_localctx, 382, RpgParser::RuleCs_indicators);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3196);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::GeneralIndicator - 689))
      | (1ULL << (RpgParser::FunctionKeyIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::LastRecordIndicator - 689))
      | (1ULL << (RpgParser::MatchingRecordIndicator - 689))
      | (1ULL << (RpgParser::HaltIndicator - 689))
      | (1ULL << (RpgParser::ReturnIndicator - 689))
      | (1ULL << (RpgParser::ExternalIndicator - 689))
      | (1ULL << (RpgParser::OverflowIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultIndicatorContext ------------------------------------------------------------------

RpgParser::ResultIndicatorContext::ResultIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::GeneralIndicator() {
  return getToken(RpgParser::GeneralIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::FunctionKeyIndicator() {
  return getToken(RpgParser::FunctionKeyIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::LastRecordIndicator() {
  return getToken(RpgParser::LastRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::MatchingRecordIndicator() {
  return getToken(RpgParser::MatchingRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::HaltIndicator() {
  return getToken(RpgParser::HaltIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::ExternalIndicator() {
  return getToken(RpgParser::ExternalIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::OverflowIndicator() {
  return getToken(RpgParser::OverflowIndicator, 0);
}

tree::TerminalNode* RpgParser::ResultIndicatorContext::ReturnIndicator() {
  return getToken(RpgParser::ReturnIndicator, 0);
}


size_t RpgParser::ResultIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleResultIndicator;
}

void RpgParser::ResultIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResultIndicator(this);
}

void RpgParser::ResultIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResultIndicator(this);
}


antlrcpp::Any RpgParser::ResultIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitResultIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ResultIndicatorContext* RpgParser::resultIndicator() {
  ResultIndicatorContext *_localctx = _tracker.createInstance<ResultIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 384, RpgParser::RuleResultIndicator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3198);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::GeneralIndicator - 689))
      | (1ULL << (RpgParser::FunctionKeyIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::LastRecordIndicator - 689))
      | (1ULL << (RpgParser::MatchingRecordIndicator - 689))
      | (1ULL << (RpgParser::HaltIndicator - 689))
      | (1ULL << (RpgParser::ReturnIndicator - 689))
      | (1ULL << (RpgParser::ExternalIndicator - 689))
      | (1ULL << (RpgParser::OverflowIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_fixed_sqlContext ------------------------------------------------------------------

RpgParser::Cspec_fixed_sqlContext::Cspec_fixed_sqlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cspec_fixed_sqlContext::CS_ExecSQL() {
  return getToken(RpgParser::CS_ExecSQL, 0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_sqlContext::CSQL_END() {
  return getToken(RpgParser::CSQL_END, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Cspec_fixed_sqlContext::CSQL_TEXT() {
  return getTokens(RpgParser::CSQL_TEXT);
}

tree::TerminalNode* RpgParser::Cspec_fixed_sqlContext::CSQL_TEXT(size_t i) {
  return getToken(RpgParser::CSQL_TEXT, i);
}


size_t RpgParser::Cspec_fixed_sqlContext::getRuleIndex() const {
  return RpgParser::RuleCspec_fixed_sql;
}

void RpgParser::Cspec_fixed_sqlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_fixed_sql(this);
}

void RpgParser::Cspec_fixed_sqlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_fixed_sql(this);
}


antlrcpp::Any RpgParser::Cspec_fixed_sqlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_fixed_sql(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_fixed_sqlContext* RpgParser::cspec_fixed_sql() {
  Cspec_fixed_sqlContext *_localctx = _tracker.createInstance<Cspec_fixed_sqlContext>(_ctx, getState());
  enterRule(_localctx, 386, RpgParser::RuleCspec_fixed_sql);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3200);
    match(RpgParser::CS_ExecSQL);
    setState(3202); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3201);
      match(RpgParser::CSQL_TEXT);
      setState(3204); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == RpgParser::CSQL_TEXT);
    setState(3206);
    match(RpgParser::CSQL_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_fixed_standardContext ------------------------------------------------------------------

RpgParser::Cspec_fixed_standardContext::Cspec_fixed_standardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsACQContext* RpgParser::Cspec_fixed_standardContext::csACQ() {
  return getRuleContext<RpgParser::CsACQContext>(0);
}

RpgParser::CsADDContext* RpgParser::Cspec_fixed_standardContext::csADD() {
  return getRuleContext<RpgParser::CsADDContext>(0);
}

RpgParser::CsADDDURContext* RpgParser::Cspec_fixed_standardContext::csADDDUR() {
  return getRuleContext<RpgParser::CsADDDURContext>(0);
}

RpgParser::CsALLOCContext* RpgParser::Cspec_fixed_standardContext::csALLOC() {
  return getRuleContext<RpgParser::CsALLOCContext>(0);
}

RpgParser::CsBITOFFContext* RpgParser::Cspec_fixed_standardContext::csBITOFF() {
  return getRuleContext<RpgParser::CsBITOFFContext>(0);
}

RpgParser::CsBITONContext* RpgParser::Cspec_fixed_standardContext::csBITON() {
  return getRuleContext<RpgParser::CsBITONContext>(0);
}

RpgParser::CsCABxxContext* RpgParser::Cspec_fixed_standardContext::csCABxx() {
  return getRuleContext<RpgParser::CsCABxxContext>(0);
}

RpgParser::CsCABEQContext* RpgParser::Cspec_fixed_standardContext::csCABEQ() {
  return getRuleContext<RpgParser::CsCABEQContext>(0);
}

RpgParser::CsCABNEContext* RpgParser::Cspec_fixed_standardContext::csCABNE() {
  return getRuleContext<RpgParser::CsCABNEContext>(0);
}

RpgParser::CsCABLEContext* RpgParser::Cspec_fixed_standardContext::csCABLE() {
  return getRuleContext<RpgParser::CsCABLEContext>(0);
}

RpgParser::CsCABLTContext* RpgParser::Cspec_fixed_standardContext::csCABLT() {
  return getRuleContext<RpgParser::CsCABLTContext>(0);
}

RpgParser::CsCABGEContext* RpgParser::Cspec_fixed_standardContext::csCABGE() {
  return getRuleContext<RpgParser::CsCABGEContext>(0);
}

RpgParser::CsCABGTContext* RpgParser::Cspec_fixed_standardContext::csCABGT() {
  return getRuleContext<RpgParser::CsCABGTContext>(0);
}

RpgParser::CsCALLContext* RpgParser::Cspec_fixed_standardContext::csCALL() {
  return getRuleContext<RpgParser::CsCALLContext>(0);
}

RpgParser::CsCALLBContext* RpgParser::Cspec_fixed_standardContext::csCALLB() {
  return getRuleContext<RpgParser::CsCALLBContext>(0);
}

RpgParser::CsCATContext* RpgParser::Cspec_fixed_standardContext::csCAT() {
  return getRuleContext<RpgParser::CsCATContext>(0);
}

RpgParser::CsCHAINContext* RpgParser::Cspec_fixed_standardContext::csCHAIN() {
  return getRuleContext<RpgParser::CsCHAINContext>(0);
}

RpgParser::CsCHECKContext* RpgParser::Cspec_fixed_standardContext::csCHECK() {
  return getRuleContext<RpgParser::CsCHECKContext>(0);
}

RpgParser::CsCHECKRContext* RpgParser::Cspec_fixed_standardContext::csCHECKR() {
  return getRuleContext<RpgParser::CsCHECKRContext>(0);
}

RpgParser::CsCLEARContext* RpgParser::Cspec_fixed_standardContext::csCLEAR() {
  return getRuleContext<RpgParser::CsCLEARContext>(0);
}

RpgParser::CsCLOSEContext* RpgParser::Cspec_fixed_standardContext::csCLOSE() {
  return getRuleContext<RpgParser::CsCLOSEContext>(0);
}

RpgParser::CsCOMMITContext* RpgParser::Cspec_fixed_standardContext::csCOMMIT() {
  return getRuleContext<RpgParser::CsCOMMITContext>(0);
}

RpgParser::CsCOMPContext* RpgParser::Cspec_fixed_standardContext::csCOMP() {
  return getRuleContext<RpgParser::CsCOMPContext>(0);
}

RpgParser::CsDEALLOCContext* RpgParser::Cspec_fixed_standardContext::csDEALLOC() {
  return getRuleContext<RpgParser::CsDEALLOCContext>(0);
}

RpgParser::CsDEFINEContext* RpgParser::Cspec_fixed_standardContext::csDEFINE() {
  return getRuleContext<RpgParser::CsDEFINEContext>(0);
}

RpgParser::CsDELETEContext* RpgParser::Cspec_fixed_standardContext::csDELETE() {
  return getRuleContext<RpgParser::CsDELETEContext>(0);
}

RpgParser::CsDIVContext* RpgParser::Cspec_fixed_standardContext::csDIV() {
  return getRuleContext<RpgParser::CsDIVContext>(0);
}

RpgParser::CsDOContext* RpgParser::Cspec_fixed_standardContext::csDO() {
  return getRuleContext<RpgParser::CsDOContext>(0);
}

RpgParser::CsDSPLYContext* RpgParser::Cspec_fixed_standardContext::csDSPLY() {
  return getRuleContext<RpgParser::CsDSPLYContext>(0);
}

RpgParser::CsDUMPContext* RpgParser::Cspec_fixed_standardContext::csDUMP() {
  return getRuleContext<RpgParser::CsDUMPContext>(0);
}

RpgParser::CsEVALContext* RpgParser::Cspec_fixed_standardContext::csEVAL() {
  return getRuleContext<RpgParser::CsEVALContext>(0);
}

RpgParser::CsEVAL_CORRContext* RpgParser::Cspec_fixed_standardContext::csEVAL_CORR() {
  return getRuleContext<RpgParser::CsEVAL_CORRContext>(0);
}

RpgParser::CsEVALRContext* RpgParser::Cspec_fixed_standardContext::csEVALR() {
  return getRuleContext<RpgParser::CsEVALRContext>(0);
}

RpgParser::CsEXCEPTContext* RpgParser::Cspec_fixed_standardContext::csEXCEPT() {
  return getRuleContext<RpgParser::CsEXCEPTContext>(0);
}

RpgParser::CsEXFMTContext* RpgParser::Cspec_fixed_standardContext::csEXFMT() {
  return getRuleContext<RpgParser::CsEXFMTContext>(0);
}

RpgParser::CsEXSRContext* RpgParser::Cspec_fixed_standardContext::csEXSR() {
  return getRuleContext<RpgParser::CsEXSRContext>(0);
}

RpgParser::CsEXTRCTContext* RpgParser::Cspec_fixed_standardContext::csEXTRCT() {
  return getRuleContext<RpgParser::CsEXTRCTContext>(0);
}

RpgParser::CsFEODContext* RpgParser::Cspec_fixed_standardContext::csFEOD() {
  return getRuleContext<RpgParser::CsFEODContext>(0);
}

RpgParser::CsFORCEContext* RpgParser::Cspec_fixed_standardContext::csFORCE() {
  return getRuleContext<RpgParser::CsFORCEContext>(0);
}

RpgParser::CsGOTOContext* RpgParser::Cspec_fixed_standardContext::csGOTO() {
  return getRuleContext<RpgParser::CsGOTOContext>(0);
}

RpgParser::CsINContext* RpgParser::Cspec_fixed_standardContext::csIN() {
  return getRuleContext<RpgParser::CsINContext>(0);
}

RpgParser::CsITERContext* RpgParser::Cspec_fixed_standardContext::csITER() {
  return getRuleContext<RpgParser::CsITERContext>(0);
}

RpgParser::CsKLISTContext* RpgParser::Cspec_fixed_standardContext::csKLIST() {
  return getRuleContext<RpgParser::CsKLISTContext>(0);
}

RpgParser::CsLEAVEContext* RpgParser::Cspec_fixed_standardContext::csLEAVE() {
  return getRuleContext<RpgParser::CsLEAVEContext>(0);
}

RpgParser::CsLEAVESRContext* RpgParser::Cspec_fixed_standardContext::csLEAVESR() {
  return getRuleContext<RpgParser::CsLEAVESRContext>(0);
}

RpgParser::CsLOOKUPContext* RpgParser::Cspec_fixed_standardContext::csLOOKUP() {
  return getRuleContext<RpgParser::CsLOOKUPContext>(0);
}

RpgParser::CsMHHZOContext* RpgParser::Cspec_fixed_standardContext::csMHHZO() {
  return getRuleContext<RpgParser::CsMHHZOContext>(0);
}

RpgParser::CsMHLZOContext* RpgParser::Cspec_fixed_standardContext::csMHLZO() {
  return getRuleContext<RpgParser::CsMHLZOContext>(0);
}

RpgParser::CsMLHZOContext* RpgParser::Cspec_fixed_standardContext::csMLHZO() {
  return getRuleContext<RpgParser::CsMLHZOContext>(0);
}

RpgParser::CsMLLZOContext* RpgParser::Cspec_fixed_standardContext::csMLLZO() {
  return getRuleContext<RpgParser::CsMLLZOContext>(0);
}

RpgParser::CsMOVEContext* RpgParser::Cspec_fixed_standardContext::csMOVE() {
  return getRuleContext<RpgParser::CsMOVEContext>(0);
}

RpgParser::CsMOVEAContext* RpgParser::Cspec_fixed_standardContext::csMOVEA() {
  return getRuleContext<RpgParser::CsMOVEAContext>(0);
}

RpgParser::CsMOVELContext* RpgParser::Cspec_fixed_standardContext::csMOVEL() {
  return getRuleContext<RpgParser::CsMOVELContext>(0);
}

RpgParser::CsMULTContext* RpgParser::Cspec_fixed_standardContext::csMULT() {
  return getRuleContext<RpgParser::CsMULTContext>(0);
}

RpgParser::CsNEXTContext* RpgParser::Cspec_fixed_standardContext::csNEXT() {
  return getRuleContext<RpgParser::CsNEXTContext>(0);
}

RpgParser::CsOCCURContext* RpgParser::Cspec_fixed_standardContext::csOCCUR() {
  return getRuleContext<RpgParser::CsOCCURContext>(0);
}

RpgParser::CsOPENContext* RpgParser::Cspec_fixed_standardContext::csOPEN() {
  return getRuleContext<RpgParser::CsOPENContext>(0);
}

RpgParser::CsOTHERContext* RpgParser::Cspec_fixed_standardContext::csOTHER() {
  return getRuleContext<RpgParser::CsOTHERContext>(0);
}

RpgParser::CsOUTContext* RpgParser::Cspec_fixed_standardContext::csOUT() {
  return getRuleContext<RpgParser::CsOUTContext>(0);
}

RpgParser::CsPLISTContext* RpgParser::Cspec_fixed_standardContext::csPLIST() {
  return getRuleContext<RpgParser::CsPLISTContext>(0);
}

RpgParser::CsPOSTContext* RpgParser::Cspec_fixed_standardContext::csPOST() {
  return getRuleContext<RpgParser::CsPOSTContext>(0);
}

RpgParser::CsREADContext* RpgParser::Cspec_fixed_standardContext::csREAD() {
  return getRuleContext<RpgParser::CsREADContext>(0);
}

RpgParser::CsREADCContext* RpgParser::Cspec_fixed_standardContext::csREADC() {
  return getRuleContext<RpgParser::CsREADCContext>(0);
}

RpgParser::CsREADEContext* RpgParser::Cspec_fixed_standardContext::csREADE() {
  return getRuleContext<RpgParser::CsREADEContext>(0);
}

RpgParser::CsREADPContext* RpgParser::Cspec_fixed_standardContext::csREADP() {
  return getRuleContext<RpgParser::CsREADPContext>(0);
}

RpgParser::CsREADPEContext* RpgParser::Cspec_fixed_standardContext::csREADPE() {
  return getRuleContext<RpgParser::CsREADPEContext>(0);
}

RpgParser::CsREALLOCContext* RpgParser::Cspec_fixed_standardContext::csREALLOC() {
  return getRuleContext<RpgParser::CsREALLOCContext>(0);
}

RpgParser::CsRELContext* RpgParser::Cspec_fixed_standardContext::csREL() {
  return getRuleContext<RpgParser::CsRELContext>(0);
}

RpgParser::CsRESETContext* RpgParser::Cspec_fixed_standardContext::csRESET() {
  return getRuleContext<RpgParser::CsRESETContext>(0);
}

RpgParser::CsRETURNContext* RpgParser::Cspec_fixed_standardContext::csRETURN() {
  return getRuleContext<RpgParser::CsRETURNContext>(0);
}

RpgParser::CsROLBKContext* RpgParser::Cspec_fixed_standardContext::csROLBK() {
  return getRuleContext<RpgParser::CsROLBKContext>(0);
}

RpgParser::CsSCANContext* RpgParser::Cspec_fixed_standardContext::csSCAN() {
  return getRuleContext<RpgParser::CsSCANContext>(0);
}

RpgParser::CsSETGTContext* RpgParser::Cspec_fixed_standardContext::csSETGT() {
  return getRuleContext<RpgParser::CsSETGTContext>(0);
}

RpgParser::CsSETLLContext* RpgParser::Cspec_fixed_standardContext::csSETLL() {
  return getRuleContext<RpgParser::CsSETLLContext>(0);
}

RpgParser::CsSETOFFContext* RpgParser::Cspec_fixed_standardContext::csSETOFF() {
  return getRuleContext<RpgParser::CsSETOFFContext>(0);
}

RpgParser::CsSETONContext* RpgParser::Cspec_fixed_standardContext::csSETON() {
  return getRuleContext<RpgParser::CsSETONContext>(0);
}

RpgParser::CsSHTDNContext* RpgParser::Cspec_fixed_standardContext::csSHTDN() {
  return getRuleContext<RpgParser::CsSHTDNContext>(0);
}

RpgParser::CsSORTAContext* RpgParser::Cspec_fixed_standardContext::csSORTA() {
  return getRuleContext<RpgParser::CsSORTAContext>(0);
}

RpgParser::CsSQRTContext* RpgParser::Cspec_fixed_standardContext::csSQRT() {
  return getRuleContext<RpgParser::CsSQRTContext>(0);
}

RpgParser::CsSUBContext* RpgParser::Cspec_fixed_standardContext::csSUB() {
  return getRuleContext<RpgParser::CsSUBContext>(0);
}

RpgParser::CsSUBDURContext* RpgParser::Cspec_fixed_standardContext::csSUBDUR() {
  return getRuleContext<RpgParser::CsSUBDURContext>(0);
}

RpgParser::CsSUBSTContext* RpgParser::Cspec_fixed_standardContext::csSUBST() {
  return getRuleContext<RpgParser::CsSUBSTContext>(0);
}

RpgParser::CsTAGContext* RpgParser::Cspec_fixed_standardContext::csTAG() {
  return getRuleContext<RpgParser::CsTAGContext>(0);
}

RpgParser::CsTESTContext* RpgParser::Cspec_fixed_standardContext::csTEST() {
  return getRuleContext<RpgParser::CsTESTContext>(0);
}

RpgParser::CsTESTBContext* RpgParser::Cspec_fixed_standardContext::csTESTB() {
  return getRuleContext<RpgParser::CsTESTBContext>(0);
}

RpgParser::CsTESTNContext* RpgParser::Cspec_fixed_standardContext::csTESTN() {
  return getRuleContext<RpgParser::CsTESTNContext>(0);
}

RpgParser::CsTESTZContext* RpgParser::Cspec_fixed_standardContext::csTESTZ() {
  return getRuleContext<RpgParser::CsTESTZContext>(0);
}

RpgParser::CsTIMEContext* RpgParser::Cspec_fixed_standardContext::csTIME() {
  return getRuleContext<RpgParser::CsTIMEContext>(0);
}

RpgParser::CsUNLOCKContext* RpgParser::Cspec_fixed_standardContext::csUNLOCK() {
  return getRuleContext<RpgParser::CsUNLOCKContext>(0);
}

RpgParser::CsUPDATEContext* RpgParser::Cspec_fixed_standardContext::csUPDATE() {
  return getRuleContext<RpgParser::CsUPDATEContext>(0);
}

RpgParser::CsWRITEContext* RpgParser::Cspec_fixed_standardContext::csWRITE() {
  return getRuleContext<RpgParser::CsWRITEContext>(0);
}

RpgParser::CsXFOOTContext* RpgParser::Cspec_fixed_standardContext::csXFOOT() {
  return getRuleContext<RpgParser::CsXFOOTContext>(0);
}

RpgParser::CsXLATEContext* RpgParser::Cspec_fixed_standardContext::csXLATE() {
  return getRuleContext<RpgParser::CsXLATEContext>(0);
}

RpgParser::CsXML_INTOContext* RpgParser::Cspec_fixed_standardContext::csXML_INTO() {
  return getRuleContext<RpgParser::CsXML_INTOContext>(0);
}

RpgParser::CsXML_SAXContext* RpgParser::Cspec_fixed_standardContext::csXML_SAX() {
  return getRuleContext<RpgParser::CsXML_SAXContext>(0);
}

RpgParser::CsZ_ADDContext* RpgParser::Cspec_fixed_standardContext::csZ_ADD() {
  return getRuleContext<RpgParser::CsZ_ADDContext>(0);
}

RpgParser::CsZ_SUBContext* RpgParser::Cspec_fixed_standardContext::csZ_SUB() {
  return getRuleContext<RpgParser::CsZ_SUBContext>(0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::Cspec_fixed_standardContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_standardContext::CS_OperationAndExtender() {
  return getToken(RpgParser::CS_OperationAndExtender, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Cspec_fixed_standardContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Cspec_fixed_standardContext::getRuleIndex() const {
  return RpgParser::RuleCspec_fixed_standard;
}

void RpgParser::Cspec_fixed_standardContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_fixed_standard(this);
}

void RpgParser::Cspec_fixed_standardContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_fixed_standard(this);
}


antlrcpp::Any RpgParser::Cspec_fixed_standardContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_fixed_standard(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_fixed_standardContext* RpgParser::cspec_fixed_standard() {
  Cspec_fixed_standardContext *_localctx = _tracker.createInstance<Cspec_fixed_standardContext>(_ctx, getState());
  enterRule(_localctx, 388, RpgParser::RuleCspec_fixed_standard);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3310);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OP_ACQ: {
        enterOuterAlt(_localctx, 1);
        setState(3208);
        csACQ();
        break;
      }

      case RpgParser::OP_ADD: {
        enterOuterAlt(_localctx, 2);
        setState(3209);
        csADD();
        break;
      }

      case RpgParser::OP_ADDDUR: {
        enterOuterAlt(_localctx, 3);
        setState(3210);
        csADDDUR();
        break;
      }

      case RpgParser::OP_ALLOC: {
        enterOuterAlt(_localctx, 4);
        setState(3211);
        csALLOC();
        break;
      }

      case RpgParser::OP_BITOFF: {
        enterOuterAlt(_localctx, 5);
        setState(3212);
        csBITOFF();
        break;
      }

      case RpgParser::OP_BITON: {
        enterOuterAlt(_localctx, 6);
        setState(3213);
        csBITON();
        break;
      }

      case RpgParser::OP_CABxx: {
        enterOuterAlt(_localctx, 7);
        setState(3214);
        csCABxx();
        break;
      }

      case RpgParser::OP_CABEQ: {
        enterOuterAlt(_localctx, 8);
        setState(3215);
        csCABEQ();
        break;
      }

      case RpgParser::OP_CABNE: {
        enterOuterAlt(_localctx, 9);
        setState(3216);
        csCABNE();
        break;
      }

      case RpgParser::OP_CABLE: {
        enterOuterAlt(_localctx, 10);
        setState(3217);
        csCABLE();
        break;
      }

      case RpgParser::OP_CABLT: {
        enterOuterAlt(_localctx, 11);
        setState(3218);
        csCABLT();
        break;
      }

      case RpgParser::OP_CABGE: {
        enterOuterAlt(_localctx, 12);
        setState(3219);
        csCABGE();
        break;
      }

      case RpgParser::OP_CABGT: {
        enterOuterAlt(_localctx, 13);
        setState(3220);
        csCABGT();
        break;
      }

      case RpgParser::OP_CALL: {
        enterOuterAlt(_localctx, 14);
        setState(3221);
        csCALL();
        break;
      }

      case RpgParser::OP_CALLB: {
        enterOuterAlt(_localctx, 15);
        setState(3222);
        csCALLB();
        break;
      }

      case RpgParser::OP_CAT: {
        enterOuterAlt(_localctx, 16);
        setState(3223);
        csCAT();
        break;
      }

      case RpgParser::OP_CHAIN: {
        enterOuterAlt(_localctx, 17);
        setState(3224);
        csCHAIN();
        break;
      }

      case RpgParser::OP_CHECK: {
        enterOuterAlt(_localctx, 18);
        setState(3225);
        csCHECK();
        break;
      }

      case RpgParser::OP_CHECKR: {
        enterOuterAlt(_localctx, 19);
        setState(3226);
        csCHECKR();
        break;
      }

      case RpgParser::OP_CLEAR: {
        enterOuterAlt(_localctx, 20);
        setState(3227);
        csCLEAR();
        break;
      }

      case RpgParser::OP_CLOSE: {
        enterOuterAlt(_localctx, 21);
        setState(3228);
        csCLOSE();
        break;
      }

      case RpgParser::OP_COMMIT: {
        enterOuterAlt(_localctx, 22);
        setState(3229);
        csCOMMIT();
        break;
      }

      case RpgParser::OP_COMP: {
        enterOuterAlt(_localctx, 23);
        setState(3230);
        csCOMP();
        break;
      }

      case RpgParser::OP_DEALLOC: {
        enterOuterAlt(_localctx, 24);
        setState(3231);
        csDEALLOC();
        break;
      }

      case RpgParser::OP_DEFINE: {
        enterOuterAlt(_localctx, 25);
        setState(3232);
        csDEFINE();
        break;
      }

      case RpgParser::OP_DELETE: {
        enterOuterAlt(_localctx, 26);
        setState(3233);
        csDELETE();
        break;
      }

      case RpgParser::OP_DIV: {
        enterOuterAlt(_localctx, 27);
        setState(3234);
        csDIV();
        break;
      }

      case RpgParser::OP_DO: {
        enterOuterAlt(_localctx, 28);
        setState(3235);
        csDO();
        break;
      }

      case RpgParser::OP_DSPLY: {
        enterOuterAlt(_localctx, 29);
        setState(3236);
        csDSPLY();
        break;
      }

      case RpgParser::OP_DUMP: {
        enterOuterAlt(_localctx, 30);
        setState(3237);
        csDUMP();
        break;
      }

      case RpgParser::OP_EVAL: {
        enterOuterAlt(_localctx, 31);
        setState(3238);
        csEVAL();
        break;
      }

      case RpgParser::OP_EVAL_CORR: {
        enterOuterAlt(_localctx, 32);
        setState(3239);
        csEVAL_CORR();
        break;
      }

      case RpgParser::OP_EVALR: {
        enterOuterAlt(_localctx, 33);
        setState(3240);
        csEVALR();
        break;
      }

      case RpgParser::OP_EXCEPT: {
        enterOuterAlt(_localctx, 34);
        setState(3241);
        csEXCEPT();
        break;
      }

      case RpgParser::OP_EXFMT: {
        enterOuterAlt(_localctx, 35);
        setState(3242);
        csEXFMT();
        break;
      }

      case RpgParser::OP_EXSR: {
        enterOuterAlt(_localctx, 36);
        setState(3243);
        csEXSR();
        break;
      }

      case RpgParser::OP_EXTRCT: {
        enterOuterAlt(_localctx, 37);
        setState(3244);
        csEXTRCT();
        break;
      }

      case RpgParser::OP_FEOD: {
        enterOuterAlt(_localctx, 38);
        setState(3245);
        csFEOD();
        break;
      }

      case RpgParser::OP_FORCE: {
        enterOuterAlt(_localctx, 39);
        setState(3246);
        csFORCE();
        break;
      }

      case RpgParser::OP_GOTO: {
        enterOuterAlt(_localctx, 40);
        setState(3247);
        csGOTO();
        break;
      }

      case RpgParser::OP_IN: {
        enterOuterAlt(_localctx, 41);
        setState(3248);
        csIN();
        break;
      }

      case RpgParser::OP_ITER: {
        enterOuterAlt(_localctx, 42);
        setState(3249);
        csITER();
        break;
      }

      case RpgParser::OP_KLIST: {
        enterOuterAlt(_localctx, 43);
        setState(3250);
        csKLIST();
        break;
      }

      case RpgParser::OP_LEAVE: {
        enterOuterAlt(_localctx, 44);
        setState(3251);
        csLEAVE();
        break;
      }

      case RpgParser::OP_LEAVESR: {
        enterOuterAlt(_localctx, 45);
        setState(3252);
        csLEAVESR();
        break;
      }

      case RpgParser::OP_LOOKUP: {
        enterOuterAlt(_localctx, 46);
        setState(3253);
        csLOOKUP();
        break;
      }

      case RpgParser::OP_MHHZO: {
        enterOuterAlt(_localctx, 47);
        setState(3254);
        csMHHZO();
        break;
      }

      case RpgParser::OP_MHLZO: {
        enterOuterAlt(_localctx, 48);
        setState(3255);
        csMHLZO();
        break;
      }

      case RpgParser::OP_MLHZO: {
        enterOuterAlt(_localctx, 49);
        setState(3256);
        csMLHZO();
        break;
      }

      case RpgParser::OP_MLLZO: {
        enterOuterAlt(_localctx, 50);
        setState(3257);
        csMLLZO();
        break;
      }

      case RpgParser::OP_MOVE: {
        enterOuterAlt(_localctx, 51);
        setState(3258);
        csMOVE();
        break;
      }

      case RpgParser::OP_MOVEA: {
        enterOuterAlt(_localctx, 52);
        setState(3259);
        csMOVEA();
        break;
      }

      case RpgParser::OP_MOVEL: {
        enterOuterAlt(_localctx, 53);
        setState(3260);
        csMOVEL();
        break;
      }

      case RpgParser::OP_MULT: {
        enterOuterAlt(_localctx, 54);
        setState(3261);
        csMULT();
        break;
      }

      case RpgParser::OP_NEXT: {
        enterOuterAlt(_localctx, 55);
        setState(3262);
        csNEXT();
        break;
      }

      case RpgParser::OP_OCCUR: {
        enterOuterAlt(_localctx, 56);
        setState(3263);
        csOCCUR();
        break;
      }

      case RpgParser::OP_OPEN: {
        enterOuterAlt(_localctx, 57);
        setState(3264);
        csOPEN();
        break;
      }

      case RpgParser::OP_OTHER: {
        enterOuterAlt(_localctx, 58);
        setState(3265);
        csOTHER();
        break;
      }

      case RpgParser::OP_OUT: {
        enterOuterAlt(_localctx, 59);
        setState(3266);
        csOUT();
        break;
      }

      case RpgParser::OP_PLIST: {
        enterOuterAlt(_localctx, 60);
        setState(3267);
        csPLIST();
        break;
      }

      case RpgParser::OP_POST: {
        enterOuterAlt(_localctx, 61);
        setState(3268);
        csPOST();
        break;
      }

      case RpgParser::OP_READ: {
        enterOuterAlt(_localctx, 62);
        setState(3269);
        csREAD();
        break;
      }

      case RpgParser::OP_READC: {
        enterOuterAlt(_localctx, 63);
        setState(3270);
        csREADC();
        break;
      }

      case RpgParser::OP_READE: {
        enterOuterAlt(_localctx, 64);
        setState(3271);
        csREADE();
        break;
      }

      case RpgParser::OP_READP: {
        enterOuterAlt(_localctx, 65);
        setState(3272);
        csREADP();
        break;
      }

      case RpgParser::OP_READPE: {
        enterOuterAlt(_localctx, 66);
        setState(3273);
        csREADPE();
        break;
      }

      case RpgParser::OP_REALLOC: {
        enterOuterAlt(_localctx, 67);
        setState(3274);
        csREALLOC();
        break;
      }

      case RpgParser::OP_REL: {
        enterOuterAlt(_localctx, 68);
        setState(3275);
        csREL();
        break;
      }

      case RpgParser::OP_RESET: {
        enterOuterAlt(_localctx, 69);
        setState(3276);
        csRESET();
        break;
      }

      case RpgParser::OP_RETURN: {
        enterOuterAlt(_localctx, 70);
        setState(3277);
        csRETURN();
        break;
      }

      case RpgParser::OP_ROLBK: {
        enterOuterAlt(_localctx, 71);
        setState(3278);
        csROLBK();
        break;
      }

      case RpgParser::OP_SCAN: {
        enterOuterAlt(_localctx, 72);
        setState(3279);
        csSCAN();
        break;
      }

      case RpgParser::OP_SETGT: {
        enterOuterAlt(_localctx, 73);
        setState(3280);
        csSETGT();
        break;
      }

      case RpgParser::OP_SETLL: {
        enterOuterAlt(_localctx, 74);
        setState(3281);
        csSETLL();
        break;
      }

      case RpgParser::OP_SETOFF: {
        enterOuterAlt(_localctx, 75);
        setState(3282);
        csSETOFF();
        break;
      }

      case RpgParser::OP_SETON: {
        enterOuterAlt(_localctx, 76);
        setState(3283);
        csSETON();
        break;
      }

      case RpgParser::OP_SHTDN: {
        enterOuterAlt(_localctx, 77);
        setState(3284);
        csSHTDN();
        break;
      }

      case RpgParser::OP_SORTA: {
        enterOuterAlt(_localctx, 78);
        setState(3285);
        csSORTA();
        break;
      }

      case RpgParser::OP_SQRT: {
        enterOuterAlt(_localctx, 79);
        setState(3286);
        csSQRT();
        break;
      }

      case RpgParser::OP_SUB: {
        enterOuterAlt(_localctx, 80);
        setState(3287);
        csSUB();
        break;
      }

      case RpgParser::OP_SUBDUR: {
        enterOuterAlt(_localctx, 81);
        setState(3288);
        csSUBDUR();
        break;
      }

      case RpgParser::OP_SUBST: {
        enterOuterAlt(_localctx, 82);
        setState(3289);
        csSUBST();
        break;
      }

      case RpgParser::OP_TAG: {
        enterOuterAlt(_localctx, 83);
        setState(3290);
        csTAG();
        break;
      }

      case RpgParser::OP_TEST: {
        enterOuterAlt(_localctx, 84);
        setState(3291);
        csTEST();
        break;
      }

      case RpgParser::OP_TESTB: {
        enterOuterAlt(_localctx, 85);
        setState(3292);
        csTESTB();
        break;
      }

      case RpgParser::OP_TESTN: {
        enterOuterAlt(_localctx, 86);
        setState(3293);
        csTESTN();
        break;
      }

      case RpgParser::OP_TESTZ: {
        enterOuterAlt(_localctx, 87);
        setState(3294);
        csTESTZ();
        break;
      }

      case RpgParser::OP_TIME: {
        enterOuterAlt(_localctx, 88);
        setState(3295);
        csTIME();
        break;
      }

      case RpgParser::OP_UNLOCK: {
        enterOuterAlt(_localctx, 89);
        setState(3296);
        csUNLOCK();
        break;
      }

      case RpgParser::OP_UPDATE: {
        enterOuterAlt(_localctx, 90);
        setState(3297);
        csUPDATE();
        break;
      }

      case RpgParser::OP_WRITE: {
        enterOuterAlt(_localctx, 91);
        setState(3298);
        csWRITE();
        break;
      }

      case RpgParser::OP_XFOOT: {
        enterOuterAlt(_localctx, 92);
        setState(3299);
        csXFOOT();
        break;
      }

      case RpgParser::OP_XLATE: {
        enterOuterAlt(_localctx, 93);
        setState(3300);
        csXLATE();
        break;
      }

      case RpgParser::OP_XML_INTO: {
        enterOuterAlt(_localctx, 94);
        setState(3301);
        csXML_INTO();
        break;
      }

      case RpgParser::OP_XML_SAX: {
        enterOuterAlt(_localctx, 95);
        setState(3302);
        csXML_SAX();
        break;
      }

      case RpgParser::OP_Z_ADD: {
        enterOuterAlt(_localctx, 96);
        setState(3303);
        csZ_ADD();
        break;
      }

      case RpgParser::OP_Z_SUB: {
        enterOuterAlt(_localctx, 97);
        setState(3304);
        csZ_SUB();
        break;
      }

      case RpgParser::CS_OperationAndExtender: {
        enterOuterAlt(_localctx, 98);
        setState(3305);
        dynamic_cast<Cspec_fixed_standardContext *>(_localctx)->operation = match(RpgParser::CS_OperationAndExtender);
        setState(3307);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::OPEN_PAREN) {
          setState(3306);
          dynamic_cast<Cspec_fixed_standardContext *>(_localctx)->operationExtender = cs_operationExtender();
        }
        setState(3309);
        cspec_fixed_standard_parts();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_fixed_standard_partsContext ------------------------------------------------------------------

RpgParser::Cspec_fixed_standard_partsContext::Cspec_fixed_standard_partsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::FactorContext* RpgParser::Cspec_fixed_standard_partsContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

RpgParser::ResultTypeContext* RpgParser::Cspec_fixed_standard_partsContext::resultType() {
  return getRuleContext<RpgParser::ResultTypeContext>(0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_standard_partsContext::CS_FieldLength() {
  return getToken(RpgParser::CS_FieldLength, 0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_standard_partsContext::CS_DecimalPositions() {
  return getToken(RpgParser::CS_DecimalPositions, 0);
}

std::vector<RpgParser::ResultIndicatorContext *> RpgParser::Cspec_fixed_standard_partsContext::resultIndicator() {
  return getRuleContexts<RpgParser::ResultIndicatorContext>();
}

RpgParser::ResultIndicatorContext* RpgParser::Cspec_fixed_standard_partsContext::resultIndicator(size_t i) {
  return getRuleContext<RpgParser::ResultIndicatorContext>(i);
}

tree::TerminalNode* RpgParser::Cspec_fixed_standard_partsContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_standard_partsContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_fixed_commentsContext* RpgParser::Cspec_fixed_standard_partsContext::cs_fixed_comments() {
  return getRuleContext<RpgParser::Cs_fixed_commentsContext>(0);
}


size_t RpgParser::Cspec_fixed_standard_partsContext::getRuleIndex() const {
  return RpgParser::RuleCspec_fixed_standard_parts;
}

void RpgParser::Cspec_fixed_standard_partsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_fixed_standard_parts(this);
}

void RpgParser::Cspec_fixed_standard_partsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_fixed_standard_parts(this);
}


antlrcpp::Any RpgParser::Cspec_fixed_standard_partsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_fixed_standard_parts(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::cspec_fixed_standard_parts() {
  Cspec_fixed_standard_partsContext *_localctx = _tracker.createInstance<Cspec_fixed_standard_partsContext>(_ctx, getState());
  enterRule(_localctx, 390, RpgParser::RuleCspec_fixed_standard_parts);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3312);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->factor2 = factor();
    setState(3313);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->result = resultType();
    setState(3314);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->len = match(RpgParser::CS_FieldLength);
    setState(3315);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->decimalPositions = match(RpgParser::CS_DecimalPositions);
    setState(3316);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->hi = resultIndicator();
    setState(3317);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->lo = resultIndicator();
    setState(3318);
    dynamic_cast<Cspec_fixed_standard_partsContext *>(_localctx)->eq = resultIndicator();
    setState(3320);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::CS_FixedComments) {
      setState(3319);
      cs_fixed_comments();
    }
    setState(3322);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsACQContext ------------------------------------------------------------------

RpgParser::CsACQContext::CsACQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsACQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsACQContext::OP_ACQ() {
  return getToken(RpgParser::OP_ACQ, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsACQContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsACQContext::getRuleIndex() const {
  return RpgParser::RuleCsACQ;
}

void RpgParser::CsACQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsACQ(this);
}

void RpgParser::CsACQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsACQ(this);
}


antlrcpp::Any RpgParser::CsACQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsACQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsACQContext* RpgParser::csACQ() {
  CsACQContext *_localctx = _tracker.createInstance<CsACQContext>(_ctx, getState());
  enterRule(_localctx, 392, RpgParser::RuleCsACQ);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3324);
    dynamic_cast<CsACQContext *>(_localctx)->operation = match(RpgParser::OP_ACQ);
    setState(3326);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3325);
      dynamic_cast<CsACQContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3328);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsADDContext ------------------------------------------------------------------

RpgParser::CsADDContext::CsADDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsADDContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsADDContext::OP_ADD() {
  return getToken(RpgParser::OP_ADD, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsADDContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsADDContext::getRuleIndex() const {
  return RpgParser::RuleCsADD;
}

void RpgParser::CsADDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsADD(this);
}

void RpgParser::CsADDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsADD(this);
}


antlrcpp::Any RpgParser::CsADDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsADD(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsADDContext* RpgParser::csADD() {
  CsADDContext *_localctx = _tracker.createInstance<CsADDContext>(_ctx, getState());
  enterRule(_localctx, 394, RpgParser::RuleCsADD);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3330);
    dynamic_cast<CsADDContext *>(_localctx)->operation = match(RpgParser::OP_ADD);
    setState(3332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3331);
      dynamic_cast<CsADDContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3334);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsADDDURContext ------------------------------------------------------------------

RpgParser::CsADDDURContext::CsADDDURContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsADDDURContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsADDDURContext::OP_ADDDUR() {
  return getToken(RpgParser::OP_ADDDUR, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsADDDURContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsADDDURContext::getRuleIndex() const {
  return RpgParser::RuleCsADDDUR;
}

void RpgParser::CsADDDURContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsADDDUR(this);
}

void RpgParser::CsADDDURContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsADDDUR(this);
}


antlrcpp::Any RpgParser::CsADDDURContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsADDDUR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsADDDURContext* RpgParser::csADDDUR() {
  CsADDDURContext *_localctx = _tracker.createInstance<CsADDDURContext>(_ctx, getState());
  enterRule(_localctx, 396, RpgParser::RuleCsADDDUR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3336);
    dynamic_cast<CsADDDURContext *>(_localctx)->operation = match(RpgParser::OP_ADDDUR);
    setState(3338);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3337);
      dynamic_cast<CsADDDURContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3340);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsALLOCContext ------------------------------------------------------------------

RpgParser::CsALLOCContext::CsALLOCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsALLOCContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsALLOCContext::OP_ALLOC() {
  return getToken(RpgParser::OP_ALLOC, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsALLOCContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsALLOCContext::getRuleIndex() const {
  return RpgParser::RuleCsALLOC;
}

void RpgParser::CsALLOCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsALLOC(this);
}

void RpgParser::CsALLOCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsALLOC(this);
}


antlrcpp::Any RpgParser::CsALLOCContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsALLOC(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsALLOCContext* RpgParser::csALLOC() {
  CsALLOCContext *_localctx = _tracker.createInstance<CsALLOCContext>(_ctx, getState());
  enterRule(_localctx, 398, RpgParser::RuleCsALLOC);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3342);
    dynamic_cast<CsALLOCContext *>(_localctx)->operation = match(RpgParser::OP_ALLOC);
    setState(3344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3343);
      dynamic_cast<CsALLOCContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3346);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDEQContext ------------------------------------------------------------------

RpgParser::CsANDEQContext::CsANDEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsANDEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsANDEQContext::OP_ANDEQ() {
  return getToken(RpgParser::OP_ANDEQ, 0);
}


size_t RpgParser::CsANDEQContext::getRuleIndex() const {
  return RpgParser::RuleCsANDEQ;
}

void RpgParser::CsANDEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDEQ(this);
}

void RpgParser::CsANDEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDEQ(this);
}


antlrcpp::Any RpgParser::CsANDEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDEQContext* RpgParser::csANDEQ() {
  CsANDEQContext *_localctx = _tracker.createInstance<CsANDEQContext>(_ctx, getState());
  enterRule(_localctx, 400, RpgParser::RuleCsANDEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3348);
    dynamic_cast<CsANDEQContext *>(_localctx)->operation = match(RpgParser::OP_ANDEQ);
    setState(3349);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDNEContext ------------------------------------------------------------------

RpgParser::CsANDNEContext::CsANDNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsANDNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsANDNEContext::OP_ANDNE() {
  return getToken(RpgParser::OP_ANDNE, 0);
}


size_t RpgParser::CsANDNEContext::getRuleIndex() const {
  return RpgParser::RuleCsANDNE;
}

void RpgParser::CsANDNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDNE(this);
}

void RpgParser::CsANDNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDNE(this);
}


antlrcpp::Any RpgParser::CsANDNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDNEContext* RpgParser::csANDNE() {
  CsANDNEContext *_localctx = _tracker.createInstance<CsANDNEContext>(_ctx, getState());
  enterRule(_localctx, 402, RpgParser::RuleCsANDNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3351);
    dynamic_cast<CsANDNEContext *>(_localctx)->operation = match(RpgParser::OP_ANDNE);
    setState(3352);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDLEContext ------------------------------------------------------------------

RpgParser::CsANDLEContext::CsANDLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsANDLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsANDLEContext::OP_ANDLE() {
  return getToken(RpgParser::OP_ANDLE, 0);
}


size_t RpgParser::CsANDLEContext::getRuleIndex() const {
  return RpgParser::RuleCsANDLE;
}

void RpgParser::CsANDLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDLE(this);
}

void RpgParser::CsANDLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDLE(this);
}


antlrcpp::Any RpgParser::CsANDLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDLEContext* RpgParser::csANDLE() {
  CsANDLEContext *_localctx = _tracker.createInstance<CsANDLEContext>(_ctx, getState());
  enterRule(_localctx, 404, RpgParser::RuleCsANDLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3354);
    dynamic_cast<CsANDLEContext *>(_localctx)->operation = match(RpgParser::OP_ANDLE);
    setState(3355);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDLTContext ------------------------------------------------------------------

RpgParser::CsANDLTContext::CsANDLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsANDLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsANDLTContext::OP_ANDLT() {
  return getToken(RpgParser::OP_ANDLT, 0);
}


size_t RpgParser::CsANDLTContext::getRuleIndex() const {
  return RpgParser::RuleCsANDLT;
}

void RpgParser::CsANDLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDLT(this);
}

void RpgParser::CsANDLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDLT(this);
}


antlrcpp::Any RpgParser::CsANDLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDLTContext* RpgParser::csANDLT() {
  CsANDLTContext *_localctx = _tracker.createInstance<CsANDLTContext>(_ctx, getState());
  enterRule(_localctx, 406, RpgParser::RuleCsANDLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3357);
    dynamic_cast<CsANDLTContext *>(_localctx)->operation = match(RpgParser::OP_ANDLT);
    setState(3358);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDGEContext ------------------------------------------------------------------

RpgParser::CsANDGEContext::CsANDGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsANDGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsANDGEContext::OP_ANDGE() {
  return getToken(RpgParser::OP_ANDGE, 0);
}


size_t RpgParser::CsANDGEContext::getRuleIndex() const {
  return RpgParser::RuleCsANDGE;
}

void RpgParser::CsANDGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDGE(this);
}

void RpgParser::CsANDGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDGE(this);
}


antlrcpp::Any RpgParser::CsANDGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDGEContext* RpgParser::csANDGE() {
  CsANDGEContext *_localctx = _tracker.createInstance<CsANDGEContext>(_ctx, getState());
  enterRule(_localctx, 408, RpgParser::RuleCsANDGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3360);
    dynamic_cast<CsANDGEContext *>(_localctx)->operation = match(RpgParser::OP_ANDGE);
    setState(3361);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsANDGTContext ------------------------------------------------------------------

RpgParser::CsANDGTContext::CsANDGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsANDGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsANDGTContext::OP_ANDGT() {
  return getToken(RpgParser::OP_ANDGT, 0);
}


size_t RpgParser::CsANDGTContext::getRuleIndex() const {
  return RpgParser::RuleCsANDGT;
}

void RpgParser::CsANDGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsANDGT(this);
}

void RpgParser::CsANDGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsANDGT(this);
}


antlrcpp::Any RpgParser::CsANDGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsANDGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsANDGTContext* RpgParser::csANDGT() {
  CsANDGTContext *_localctx = _tracker.createInstance<CsANDGTContext>(_ctx, getState());
  enterRule(_localctx, 410, RpgParser::RuleCsANDGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3363);
    dynamic_cast<CsANDGTContext *>(_localctx)->operation = match(RpgParser::OP_ANDGT);
    setState(3364);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsBITOFFContext ------------------------------------------------------------------

RpgParser::CsBITOFFContext::CsBITOFFContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsBITOFFContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsBITOFFContext::OP_BITOFF() {
  return getToken(RpgParser::OP_BITOFF, 0);
}


size_t RpgParser::CsBITOFFContext::getRuleIndex() const {
  return RpgParser::RuleCsBITOFF;
}

void RpgParser::CsBITOFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsBITOFF(this);
}

void RpgParser::CsBITOFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsBITOFF(this);
}


antlrcpp::Any RpgParser::CsBITOFFContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsBITOFF(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsBITOFFContext* RpgParser::csBITOFF() {
  CsBITOFFContext *_localctx = _tracker.createInstance<CsBITOFFContext>(_ctx, getState());
  enterRule(_localctx, 412, RpgParser::RuleCsBITOFF);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3366);
    dynamic_cast<CsBITOFFContext *>(_localctx)->operation = match(RpgParser::OP_BITOFF);
    setState(3367);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsBITONContext ------------------------------------------------------------------

RpgParser::CsBITONContext::CsBITONContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsBITONContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsBITONContext::OP_BITON() {
  return getToken(RpgParser::OP_BITON, 0);
}


size_t RpgParser::CsBITONContext::getRuleIndex() const {
  return RpgParser::RuleCsBITON;
}

void RpgParser::CsBITONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsBITON(this);
}

void RpgParser::CsBITONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsBITON(this);
}


antlrcpp::Any RpgParser::CsBITONContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsBITON(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsBITONContext* RpgParser::csBITON() {
  CsBITONContext *_localctx = _tracker.createInstance<CsBITONContext>(_ctx, getState());
  enterRule(_localctx, 414, RpgParser::RuleCsBITON);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3369);
    dynamic_cast<CsBITONContext *>(_localctx)->operation = match(RpgParser::OP_BITON);
    setState(3370);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABxxContext ------------------------------------------------------------------

RpgParser::CsCABxxContext::CsCABxxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABxxContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABxxContext::OP_CABxx() {
  return getToken(RpgParser::OP_CABxx, 0);
}


size_t RpgParser::CsCABxxContext::getRuleIndex() const {
  return RpgParser::RuleCsCABxx;
}

void RpgParser::CsCABxxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABxx(this);
}

void RpgParser::CsCABxxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABxx(this);
}


antlrcpp::Any RpgParser::CsCABxxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABxx(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABxxContext* RpgParser::csCABxx() {
  CsCABxxContext *_localctx = _tracker.createInstance<CsCABxxContext>(_ctx, getState());
  enterRule(_localctx, 416, RpgParser::RuleCsCABxx);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3372);
    dynamic_cast<CsCABxxContext *>(_localctx)->operation = match(RpgParser::OP_CABxx);
    setState(3373);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABEQContext ------------------------------------------------------------------

RpgParser::CsCABEQContext::CsCABEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABEQContext::OP_CABEQ() {
  return getToken(RpgParser::OP_CABEQ, 0);
}


size_t RpgParser::CsCABEQContext::getRuleIndex() const {
  return RpgParser::RuleCsCABEQ;
}

void RpgParser::CsCABEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABEQ(this);
}

void RpgParser::CsCABEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABEQ(this);
}


antlrcpp::Any RpgParser::CsCABEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABEQContext* RpgParser::csCABEQ() {
  CsCABEQContext *_localctx = _tracker.createInstance<CsCABEQContext>(_ctx, getState());
  enterRule(_localctx, 418, RpgParser::RuleCsCABEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3375);
    dynamic_cast<CsCABEQContext *>(_localctx)->operation = match(RpgParser::OP_CABEQ);
    setState(3376);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABNEContext ------------------------------------------------------------------

RpgParser::CsCABNEContext::CsCABNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABNEContext::OP_CABNE() {
  return getToken(RpgParser::OP_CABNE, 0);
}


size_t RpgParser::CsCABNEContext::getRuleIndex() const {
  return RpgParser::RuleCsCABNE;
}

void RpgParser::CsCABNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABNE(this);
}

void RpgParser::CsCABNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABNE(this);
}


antlrcpp::Any RpgParser::CsCABNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABNEContext* RpgParser::csCABNE() {
  CsCABNEContext *_localctx = _tracker.createInstance<CsCABNEContext>(_ctx, getState());
  enterRule(_localctx, 420, RpgParser::RuleCsCABNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3378);
    dynamic_cast<CsCABNEContext *>(_localctx)->operation = match(RpgParser::OP_CABNE);
    setState(3379);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABLEContext ------------------------------------------------------------------

RpgParser::CsCABLEContext::CsCABLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABLEContext::OP_CABLE() {
  return getToken(RpgParser::OP_CABLE, 0);
}


size_t RpgParser::CsCABLEContext::getRuleIndex() const {
  return RpgParser::RuleCsCABLE;
}

void RpgParser::CsCABLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABLE(this);
}

void RpgParser::CsCABLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABLE(this);
}


antlrcpp::Any RpgParser::CsCABLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABLEContext* RpgParser::csCABLE() {
  CsCABLEContext *_localctx = _tracker.createInstance<CsCABLEContext>(_ctx, getState());
  enterRule(_localctx, 422, RpgParser::RuleCsCABLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3381);
    dynamic_cast<CsCABLEContext *>(_localctx)->operation = match(RpgParser::OP_CABLE);
    setState(3382);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABLTContext ------------------------------------------------------------------

RpgParser::CsCABLTContext::CsCABLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABLTContext::OP_CABLT() {
  return getToken(RpgParser::OP_CABLT, 0);
}


size_t RpgParser::CsCABLTContext::getRuleIndex() const {
  return RpgParser::RuleCsCABLT;
}

void RpgParser::CsCABLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABLT(this);
}

void RpgParser::CsCABLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABLT(this);
}


antlrcpp::Any RpgParser::CsCABLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABLTContext* RpgParser::csCABLT() {
  CsCABLTContext *_localctx = _tracker.createInstance<CsCABLTContext>(_ctx, getState());
  enterRule(_localctx, 424, RpgParser::RuleCsCABLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3384);
    dynamic_cast<CsCABLTContext *>(_localctx)->operation = match(RpgParser::OP_CABLT);
    setState(3385);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABGEContext ------------------------------------------------------------------

RpgParser::CsCABGEContext::CsCABGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABGEContext::OP_CABGE() {
  return getToken(RpgParser::OP_CABGE, 0);
}


size_t RpgParser::CsCABGEContext::getRuleIndex() const {
  return RpgParser::RuleCsCABGE;
}

void RpgParser::CsCABGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABGE(this);
}

void RpgParser::CsCABGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABGE(this);
}


antlrcpp::Any RpgParser::CsCABGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABGEContext* RpgParser::csCABGE() {
  CsCABGEContext *_localctx = _tracker.createInstance<CsCABGEContext>(_ctx, getState());
  enterRule(_localctx, 426, RpgParser::RuleCsCABGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3387);
    dynamic_cast<CsCABGEContext *>(_localctx)->operation = match(RpgParser::OP_CABGE);
    setState(3388);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCABGTContext ------------------------------------------------------------------

RpgParser::CsCABGTContext::CsCABGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCABGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCABGTContext::OP_CABGT() {
  return getToken(RpgParser::OP_CABGT, 0);
}


size_t RpgParser::CsCABGTContext::getRuleIndex() const {
  return RpgParser::RuleCsCABGT;
}

void RpgParser::CsCABGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCABGT(this);
}

void RpgParser::CsCABGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCABGT(this);
}


antlrcpp::Any RpgParser::CsCABGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCABGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCABGTContext* RpgParser::csCABGT() {
  CsCABGTContext *_localctx = _tracker.createInstance<CsCABGTContext>(_ctx, getState());
  enterRule(_localctx, 428, RpgParser::RuleCsCABGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3390);
    dynamic_cast<CsCABGTContext *>(_localctx)->operation = match(RpgParser::OP_CABGT);
    setState(3391);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCALLContext ------------------------------------------------------------------

RpgParser::CsCALLContext::CsCALLContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCALLContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCALLContext::OP_CALL() {
  return getToken(RpgParser::OP_CALL, 0);
}

std::vector<RpgParser::CsPARMContext *> RpgParser::CsCALLContext::csPARM() {
  return getRuleContexts<RpgParser::CsPARMContext>();
}

RpgParser::CsPARMContext* RpgParser::CsCALLContext::csPARM(size_t i) {
  return getRuleContext<RpgParser::CsPARMContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCALLContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCALLContext::getRuleIndex() const {
  return RpgParser::RuleCsCALL;
}

void RpgParser::CsCALLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCALL(this);
}

void RpgParser::CsCALLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCALL(this);
}


antlrcpp::Any RpgParser::CsCALLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCALL(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCALLContext* RpgParser::csCALL() {
  CsCALLContext *_localctx = _tracker.createInstance<CsCALLContext>(_ctx, getState());
  enterRule(_localctx, 430, RpgParser::RuleCsCALL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3393);
    dynamic_cast<CsCALLContext *>(_localctx)->operation = match(RpgParser::OP_CALL);
    setState(3395);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3394);
      dynamic_cast<CsCALLContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3397);
    cspec_fixed_standard_parts();
    setState(3401);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3398);
        csPARM(); 
      }
      setState(3403);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCALLBContext ------------------------------------------------------------------

RpgParser::CsCALLBContext::CsCALLBContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCALLBContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCALLBContext::OP_CALLB() {
  return getToken(RpgParser::OP_CALLB, 0);
}

std::vector<RpgParser::CsPARMContext *> RpgParser::CsCALLBContext::csPARM() {
  return getRuleContexts<RpgParser::CsPARMContext>();
}

RpgParser::CsPARMContext* RpgParser::CsCALLBContext::csPARM(size_t i) {
  return getRuleContext<RpgParser::CsPARMContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCALLBContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCALLBContext::getRuleIndex() const {
  return RpgParser::RuleCsCALLB;
}

void RpgParser::CsCALLBContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCALLB(this);
}

void RpgParser::CsCALLBContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCALLB(this);
}


antlrcpp::Any RpgParser::CsCALLBContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCALLB(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCALLBContext* RpgParser::csCALLB() {
  CsCALLBContext *_localctx = _tracker.createInstance<CsCALLBContext>(_ctx, getState());
  enterRule(_localctx, 432, RpgParser::RuleCsCALLB);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3404);
    dynamic_cast<CsCALLBContext *>(_localctx)->operation = match(RpgParser::OP_CALLB);
    setState(3406);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3405);
      dynamic_cast<CsCALLBContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3408);
    cspec_fixed_standard_parts();
    setState(3412);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3409);
        csPARM(); 
      }
      setState(3414);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCALLPContext ------------------------------------------------------------------

RpgParser::CsCALLPContext::CsCALLPContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsCALLPContext::OP_CALLP() {
  return getToken(RpgParser::OP_CALLP, 0);
}

RpgParser::C_freeContext* RpgParser::CsCALLPContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsCALLPContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsCALLPContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCALLPContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCALLPContext::getRuleIndex() const {
  return RpgParser::RuleCsCALLP;
}

void RpgParser::CsCALLPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCALLP(this);
}

void RpgParser::CsCALLPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCALLP(this);
}


antlrcpp::Any RpgParser::CsCALLPContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCALLP(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCALLPContext* RpgParser::csCALLP() {
  CsCALLPContext *_localctx = _tracker.createInstance<CsCALLPContext>(_ctx, getState());
  enterRule(_localctx, 434, RpgParser::RuleCsCALLP);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3415);
    dynamic_cast<CsCALLPContext *>(_localctx)->operation = match(RpgParser::OP_CALLP);
    setState(3417);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
    case 1: {
      setState(3416);
      dynamic_cast<CsCALLPContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3419);
    dynamic_cast<CsCALLPContext *>(_localctx)->fixedexpression = c_free();
    setState(3420);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASEQContext ------------------------------------------------------------------

RpgParser::CsCASEQContext::CsCASEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASEQContext::OP_CASEQ() {
  return getToken(RpgParser::OP_CASEQ, 0);
}


size_t RpgParser::CsCASEQContext::getRuleIndex() const {
  return RpgParser::RuleCsCASEQ;
}

void RpgParser::CsCASEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCASEQ(this);
}

void RpgParser::CsCASEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCASEQ(this);
}


antlrcpp::Any RpgParser::CsCASEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCASEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASEQContext* RpgParser::csCASEQ() {
  CsCASEQContext *_localctx = _tracker.createInstance<CsCASEQContext>(_ctx, getState());
  enterRule(_localctx, 436, RpgParser::RuleCsCASEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3422);
    dynamic_cast<CsCASEQContext *>(_localctx)->operation = match(RpgParser::OP_CASEQ);
    setState(3423);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASNEContext ------------------------------------------------------------------

RpgParser::CsCASNEContext::CsCASNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASNEContext::OP_CASNE() {
  return getToken(RpgParser::OP_CASNE, 0);
}


size_t RpgParser::CsCASNEContext::getRuleIndex() const {
  return RpgParser::RuleCsCASNE;
}

void RpgParser::CsCASNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCASNE(this);
}

void RpgParser::CsCASNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCASNE(this);
}


antlrcpp::Any RpgParser::CsCASNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCASNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASNEContext* RpgParser::csCASNE() {
  CsCASNEContext *_localctx = _tracker.createInstance<CsCASNEContext>(_ctx, getState());
  enterRule(_localctx, 438, RpgParser::RuleCsCASNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3425);
    dynamic_cast<CsCASNEContext *>(_localctx)->operation = match(RpgParser::OP_CASNE);
    setState(3426);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASLEContext ------------------------------------------------------------------

RpgParser::CsCASLEContext::CsCASLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASLEContext::OP_CASLE() {
  return getToken(RpgParser::OP_CASLE, 0);
}


size_t RpgParser::CsCASLEContext::getRuleIndex() const {
  return RpgParser::RuleCsCASLE;
}

void RpgParser::CsCASLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCASLE(this);
}

void RpgParser::CsCASLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCASLE(this);
}


antlrcpp::Any RpgParser::CsCASLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCASLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASLEContext* RpgParser::csCASLE() {
  CsCASLEContext *_localctx = _tracker.createInstance<CsCASLEContext>(_ctx, getState());
  enterRule(_localctx, 440, RpgParser::RuleCsCASLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3428);
    dynamic_cast<CsCASLEContext *>(_localctx)->operation = match(RpgParser::OP_CASLE);
    setState(3429);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASLTContext ------------------------------------------------------------------

RpgParser::CsCASLTContext::CsCASLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASLTContext::OP_CASLT() {
  return getToken(RpgParser::OP_CASLT, 0);
}


size_t RpgParser::CsCASLTContext::getRuleIndex() const {
  return RpgParser::RuleCsCASLT;
}

void RpgParser::CsCASLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCASLT(this);
}

void RpgParser::CsCASLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCASLT(this);
}


antlrcpp::Any RpgParser::CsCASLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCASLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASLTContext* RpgParser::csCASLT() {
  CsCASLTContext *_localctx = _tracker.createInstance<CsCASLTContext>(_ctx, getState());
  enterRule(_localctx, 442, RpgParser::RuleCsCASLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3431);
    dynamic_cast<CsCASLTContext *>(_localctx)->operation = match(RpgParser::OP_CASLT);
    setState(3432);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASGEContext ------------------------------------------------------------------

RpgParser::CsCASGEContext::CsCASGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASGEContext::OP_CASGE() {
  return getToken(RpgParser::OP_CASGE, 0);
}


size_t RpgParser::CsCASGEContext::getRuleIndex() const {
  return RpgParser::RuleCsCASGE;
}

void RpgParser::CsCASGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCASGE(this);
}

void RpgParser::CsCASGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCASGE(this);
}


antlrcpp::Any RpgParser::CsCASGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCASGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASGEContext* RpgParser::csCASGE() {
  CsCASGEContext *_localctx = _tracker.createInstance<CsCASGEContext>(_ctx, getState());
  enterRule(_localctx, 444, RpgParser::RuleCsCASGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3434);
    dynamic_cast<CsCASGEContext *>(_localctx)->operation = match(RpgParser::OP_CASGE);
    setState(3435);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASGTContext ------------------------------------------------------------------

RpgParser::CsCASGTContext::CsCASGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASGTContext::OP_CASGT() {
  return getToken(RpgParser::OP_CASGT, 0);
}


size_t RpgParser::CsCASGTContext::getRuleIndex() const {
  return RpgParser::RuleCsCASGT;
}

void RpgParser::CsCASGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCASGT(this);
}

void RpgParser::CsCASGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCASGT(this);
}


antlrcpp::Any RpgParser::CsCASGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCASGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASGTContext* RpgParser::csCASGT() {
  CsCASGTContext *_localctx = _tracker.createInstance<CsCASGTContext>(_ctx, getState());
  enterRule(_localctx, 446, RpgParser::RuleCsCASGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3437);
    dynamic_cast<CsCASGTContext *>(_localctx)->operation = match(RpgParser::OP_CASGT);
    setState(3438);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCASContext ------------------------------------------------------------------

RpgParser::CsCASContext::CsCASContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCASContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCASContext::OP_CAS() {
  return getToken(RpgParser::OP_CAS, 0);
}


size_t RpgParser::CsCASContext::getRuleIndex() const {
  return RpgParser::RuleCsCAS;
}

void RpgParser::CsCASContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCAS(this);
}

void RpgParser::CsCASContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCAS(this);
}


antlrcpp::Any RpgParser::CsCASContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCAS(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCASContext* RpgParser::csCAS() {
  CsCASContext *_localctx = _tracker.createInstance<CsCASContext>(_ctx, getState());
  enterRule(_localctx, 448, RpgParser::RuleCsCAS);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3440);
    dynamic_cast<CsCASContext *>(_localctx)->operation = match(RpgParser::OP_CAS);
    setState(3441);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCATContext ------------------------------------------------------------------

RpgParser::CsCATContext::CsCATContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCATContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCATContext::OP_CAT() {
  return getToken(RpgParser::OP_CAT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCATContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCATContext::getRuleIndex() const {
  return RpgParser::RuleCsCAT;
}

void RpgParser::CsCATContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCAT(this);
}

void RpgParser::CsCATContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCAT(this);
}


antlrcpp::Any RpgParser::CsCATContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCAT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCATContext* RpgParser::csCAT() {
  CsCATContext *_localctx = _tracker.createInstance<CsCATContext>(_ctx, getState());
  enterRule(_localctx, 450, RpgParser::RuleCsCAT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3443);
    dynamic_cast<CsCATContext *>(_localctx)->operation = match(RpgParser::OP_CAT);
    setState(3445);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3444);
      dynamic_cast<CsCATContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3447);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCHAINContext ------------------------------------------------------------------

RpgParser::CsCHAINContext::CsCHAINContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCHAINContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCHAINContext::OP_CHAIN() {
  return getToken(RpgParser::OP_CHAIN, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCHAINContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCHAINContext::getRuleIndex() const {
  return RpgParser::RuleCsCHAIN;
}

void RpgParser::CsCHAINContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCHAIN(this);
}

void RpgParser::CsCHAINContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCHAIN(this);
}


antlrcpp::Any RpgParser::CsCHAINContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCHAIN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCHAINContext* RpgParser::csCHAIN() {
  CsCHAINContext *_localctx = _tracker.createInstance<CsCHAINContext>(_ctx, getState());
  enterRule(_localctx, 452, RpgParser::RuleCsCHAIN);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3449);
    dynamic_cast<CsCHAINContext *>(_localctx)->operation = match(RpgParser::OP_CHAIN);
    setState(3451);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3450);
      dynamic_cast<CsCHAINContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3453);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCHECKContext ------------------------------------------------------------------

RpgParser::CsCHECKContext::CsCHECKContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCHECKContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCHECKContext::OP_CHECK() {
  return getToken(RpgParser::OP_CHECK, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCHECKContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCHECKContext::getRuleIndex() const {
  return RpgParser::RuleCsCHECK;
}

void RpgParser::CsCHECKContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCHECK(this);
}

void RpgParser::CsCHECKContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCHECK(this);
}


antlrcpp::Any RpgParser::CsCHECKContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCHECK(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCHECKContext* RpgParser::csCHECK() {
  CsCHECKContext *_localctx = _tracker.createInstance<CsCHECKContext>(_ctx, getState());
  enterRule(_localctx, 454, RpgParser::RuleCsCHECK);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3455);
    dynamic_cast<CsCHECKContext *>(_localctx)->operation = match(RpgParser::OP_CHECK);
    setState(3457);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3456);
      dynamic_cast<CsCHECKContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3459);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCHECKRContext ------------------------------------------------------------------

RpgParser::CsCHECKRContext::CsCHECKRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCHECKRContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCHECKRContext::OP_CHECKR() {
  return getToken(RpgParser::OP_CHECKR, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCHECKRContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCHECKRContext::getRuleIndex() const {
  return RpgParser::RuleCsCHECKR;
}

void RpgParser::CsCHECKRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCHECKR(this);
}

void RpgParser::CsCHECKRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCHECKR(this);
}


antlrcpp::Any RpgParser::CsCHECKRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCHECKR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCHECKRContext* RpgParser::csCHECKR() {
  CsCHECKRContext *_localctx = _tracker.createInstance<CsCHECKRContext>(_ctx, getState());
  enterRule(_localctx, 456, RpgParser::RuleCsCHECKR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3461);
    dynamic_cast<CsCHECKRContext *>(_localctx)->operation = match(RpgParser::OP_CHECKR);
    setState(3463);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3462);
      dynamic_cast<CsCHECKRContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3465);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCLEARContext ------------------------------------------------------------------

RpgParser::CsCLEARContext::CsCLEARContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCLEARContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCLEARContext::OP_CLEAR() {
  return getToken(RpgParser::OP_CLEAR, 0);
}


size_t RpgParser::CsCLEARContext::getRuleIndex() const {
  return RpgParser::RuleCsCLEAR;
}

void RpgParser::CsCLEARContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCLEAR(this);
}

void RpgParser::CsCLEARContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCLEAR(this);
}


antlrcpp::Any RpgParser::CsCLEARContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCLEAR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCLEARContext* RpgParser::csCLEAR() {
  CsCLEARContext *_localctx = _tracker.createInstance<CsCLEARContext>(_ctx, getState());
  enterRule(_localctx, 458, RpgParser::RuleCsCLEAR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3467);
    dynamic_cast<CsCLEARContext *>(_localctx)->operation = match(RpgParser::OP_CLEAR);
    setState(3468);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCLOSEContext ------------------------------------------------------------------

RpgParser::CsCLOSEContext::CsCLOSEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCLOSEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCLOSEContext::OP_CLOSE() {
  return getToken(RpgParser::OP_CLOSE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCLOSEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCLOSEContext::getRuleIndex() const {
  return RpgParser::RuleCsCLOSE;
}

void RpgParser::CsCLOSEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCLOSE(this);
}

void RpgParser::CsCLOSEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCLOSE(this);
}


antlrcpp::Any RpgParser::CsCLOSEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCLOSE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCLOSEContext* RpgParser::csCLOSE() {
  CsCLOSEContext *_localctx = _tracker.createInstance<CsCLOSEContext>(_ctx, getState());
  enterRule(_localctx, 460, RpgParser::RuleCsCLOSE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3470);
    dynamic_cast<CsCLOSEContext *>(_localctx)->operation = match(RpgParser::OP_CLOSE);
    setState(3472);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3471);
      dynamic_cast<CsCLOSEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3474);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCOMMITContext ------------------------------------------------------------------

RpgParser::CsCOMMITContext::CsCOMMITContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCOMMITContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCOMMITContext::OP_COMMIT() {
  return getToken(RpgParser::OP_COMMIT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsCOMMITContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsCOMMITContext::getRuleIndex() const {
  return RpgParser::RuleCsCOMMIT;
}

void RpgParser::CsCOMMITContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCOMMIT(this);
}

void RpgParser::CsCOMMITContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCOMMIT(this);
}


antlrcpp::Any RpgParser::CsCOMMITContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCOMMIT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCOMMITContext* RpgParser::csCOMMIT() {
  CsCOMMITContext *_localctx = _tracker.createInstance<CsCOMMITContext>(_ctx, getState());
  enterRule(_localctx, 462, RpgParser::RuleCsCOMMIT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3476);
    dynamic_cast<CsCOMMITContext *>(_localctx)->operation = match(RpgParser::OP_COMMIT);
    setState(3478);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3477);
      dynamic_cast<CsCOMMITContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3480);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsCOMPContext ------------------------------------------------------------------

RpgParser::CsCOMPContext::CsCOMPContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsCOMPContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsCOMPContext::OP_COMP() {
  return getToken(RpgParser::OP_COMP, 0);
}


size_t RpgParser::CsCOMPContext::getRuleIndex() const {
  return RpgParser::RuleCsCOMP;
}

void RpgParser::CsCOMPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsCOMP(this);
}

void RpgParser::CsCOMPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsCOMP(this);
}


antlrcpp::Any RpgParser::CsCOMPContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsCOMP(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsCOMPContext* RpgParser::csCOMP() {
  CsCOMPContext *_localctx = _tracker.createInstance<CsCOMPContext>(_ctx, getState());
  enterRule(_localctx, 464, RpgParser::RuleCsCOMP);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3482);
    dynamic_cast<CsCOMPContext *>(_localctx)->operation = match(RpgParser::OP_COMP);
    setState(3483);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDEALLOCContext ------------------------------------------------------------------

RpgParser::CsDEALLOCContext::CsDEALLOCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDEALLOCContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDEALLOCContext::OP_DEALLOC() {
  return getToken(RpgParser::OP_DEALLOC, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDEALLOCContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDEALLOCContext::getRuleIndex() const {
  return RpgParser::RuleCsDEALLOC;
}

void RpgParser::CsDEALLOCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDEALLOC(this);
}

void RpgParser::CsDEALLOCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDEALLOC(this);
}


antlrcpp::Any RpgParser::CsDEALLOCContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDEALLOC(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDEALLOCContext* RpgParser::csDEALLOC() {
  CsDEALLOCContext *_localctx = _tracker.createInstance<CsDEALLOCContext>(_ctx, getState());
  enterRule(_localctx, 466, RpgParser::RuleCsDEALLOC);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3485);
    dynamic_cast<CsDEALLOCContext *>(_localctx)->operation = match(RpgParser::OP_DEALLOC);
    setState(3487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3486);
      dynamic_cast<CsDEALLOCContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3489);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDEFINEContext ------------------------------------------------------------------

RpgParser::CsDEFINEContext::CsDEFINEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDEFINEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDEFINEContext::OP_DEFINE() {
  return getToken(RpgParser::OP_DEFINE, 0);
}


size_t RpgParser::CsDEFINEContext::getRuleIndex() const {
  return RpgParser::RuleCsDEFINE;
}

void RpgParser::CsDEFINEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDEFINE(this);
}

void RpgParser::CsDEFINEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDEFINE(this);
}


antlrcpp::Any RpgParser::CsDEFINEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDEFINE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDEFINEContext* RpgParser::csDEFINE() {
  CsDEFINEContext *_localctx = _tracker.createInstance<CsDEFINEContext>(_ctx, getState());
  enterRule(_localctx, 468, RpgParser::RuleCsDEFINE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3491);
    dynamic_cast<CsDEFINEContext *>(_localctx)->operation = match(RpgParser::OP_DEFINE);
    setState(3492);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDELETEContext ------------------------------------------------------------------

RpgParser::CsDELETEContext::CsDELETEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDELETEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDELETEContext::OP_DELETE() {
  return getToken(RpgParser::OP_DELETE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDELETEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDELETEContext::getRuleIndex() const {
  return RpgParser::RuleCsDELETE;
}

void RpgParser::CsDELETEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDELETE(this);
}

void RpgParser::CsDELETEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDELETE(this);
}


antlrcpp::Any RpgParser::CsDELETEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDELETE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDELETEContext* RpgParser::csDELETE() {
  CsDELETEContext *_localctx = _tracker.createInstance<CsDELETEContext>(_ctx, getState());
  enterRule(_localctx, 470, RpgParser::RuleCsDELETE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3494);
    dynamic_cast<CsDELETEContext *>(_localctx)->operation = match(RpgParser::OP_DELETE);
    setState(3496);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3495);
      dynamic_cast<CsDELETEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3498);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDIVContext ------------------------------------------------------------------

RpgParser::CsDIVContext::CsDIVContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDIVContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDIVContext::OP_DIV() {
  return getToken(RpgParser::OP_DIV, 0);
}

RpgParser::CsMVRContext* RpgParser::CsDIVContext::csMVR() {
  return getRuleContext<RpgParser::CsMVRContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDIVContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDIVContext::getRuleIndex() const {
  return RpgParser::RuleCsDIV;
}

void RpgParser::CsDIVContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDIV(this);
}

void RpgParser::CsDIVContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDIV(this);
}


antlrcpp::Any RpgParser::CsDIVContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDIV(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDIVContext* RpgParser::csDIV() {
  CsDIVContext *_localctx = _tracker.createInstance<CsDIVContext>(_ctx, getState());
  enterRule(_localctx, 472, RpgParser::RuleCsDIV);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3500);
    dynamic_cast<CsDIVContext *>(_localctx)->operation = match(RpgParser::OP_DIV);
    setState(3502);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3501);
      dynamic_cast<CsDIVContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3504);
    cspec_fixed_standard_parts();
    setState(3506);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
    case 1: {
      setState(3505);
      csMVR();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOContext ------------------------------------------------------------------

RpgParser::CsDOContext::CsDOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOContext::OP_DO() {
  return getToken(RpgParser::OP_DO, 0);
}


size_t RpgParser::CsDOContext::getRuleIndex() const {
  return RpgParser::RuleCsDO;
}

void RpgParser::CsDOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDO(this);
}

void RpgParser::CsDOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDO(this);
}


antlrcpp::Any RpgParser::CsDOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOContext* RpgParser::csDO() {
  CsDOContext *_localctx = _tracker.createInstance<CsDOContext>(_ctx, getState());
  enterRule(_localctx, 474, RpgParser::RuleCsDO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3508);
    dynamic_cast<CsDOContext *>(_localctx)->operation = match(RpgParser::OP_DO);
    setState(3509);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOUContext ------------------------------------------------------------------

RpgParser::CsDOUContext::CsDOUContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsDOUContext::OP_DOU() {
  return getToken(RpgParser::OP_DOU, 0);
}

RpgParser::C_freeContext* RpgParser::CsDOUContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsDOUContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsDOUContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDOUContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDOUContext::getRuleIndex() const {
  return RpgParser::RuleCsDOU;
}

void RpgParser::CsDOUContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOU(this);
}

void RpgParser::CsDOUContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOU(this);
}


antlrcpp::Any RpgParser::CsDOUContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOU(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOUContext* RpgParser::csDOU() {
  CsDOUContext *_localctx = _tracker.createInstance<CsDOUContext>(_ctx, getState());
  enterRule(_localctx, 476, RpgParser::RuleCsDOU);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3511);
    dynamic_cast<CsDOUContext *>(_localctx)->operation = match(RpgParser::OP_DOU);
    setState(3513);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      setState(3512);
      dynamic_cast<CsDOUContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3515);
    dynamic_cast<CsDOUContext *>(_localctx)->fixedexpression = c_free();
    setState(3516);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOUEQContext ------------------------------------------------------------------

RpgParser::CsDOUEQContext::CsDOUEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOUEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOUEQContext::OP_DOUEQ() {
  return getToken(RpgParser::OP_DOUEQ, 0);
}


size_t RpgParser::CsDOUEQContext::getRuleIndex() const {
  return RpgParser::RuleCsDOUEQ;
}

void RpgParser::CsDOUEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOUEQ(this);
}

void RpgParser::CsDOUEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOUEQ(this);
}


antlrcpp::Any RpgParser::CsDOUEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOUEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOUEQContext* RpgParser::csDOUEQ() {
  CsDOUEQContext *_localctx = _tracker.createInstance<CsDOUEQContext>(_ctx, getState());
  enterRule(_localctx, 478, RpgParser::RuleCsDOUEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3518);
    dynamic_cast<CsDOUEQContext *>(_localctx)->operation = match(RpgParser::OP_DOUEQ);
    setState(3519);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOUNEContext ------------------------------------------------------------------

RpgParser::CsDOUNEContext::CsDOUNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOUNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOUNEContext::OP_DOUNE() {
  return getToken(RpgParser::OP_DOUNE, 0);
}


size_t RpgParser::CsDOUNEContext::getRuleIndex() const {
  return RpgParser::RuleCsDOUNE;
}

void RpgParser::CsDOUNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOUNE(this);
}

void RpgParser::CsDOUNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOUNE(this);
}


antlrcpp::Any RpgParser::CsDOUNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOUNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOUNEContext* RpgParser::csDOUNE() {
  CsDOUNEContext *_localctx = _tracker.createInstance<CsDOUNEContext>(_ctx, getState());
  enterRule(_localctx, 480, RpgParser::RuleCsDOUNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3521);
    dynamic_cast<CsDOUNEContext *>(_localctx)->operation = match(RpgParser::OP_DOUNE);
    setState(3522);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOULEContext ------------------------------------------------------------------

RpgParser::CsDOULEContext::CsDOULEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOULEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOULEContext::OP_DOULE() {
  return getToken(RpgParser::OP_DOULE, 0);
}


size_t RpgParser::CsDOULEContext::getRuleIndex() const {
  return RpgParser::RuleCsDOULE;
}

void RpgParser::CsDOULEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOULE(this);
}

void RpgParser::CsDOULEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOULE(this);
}


antlrcpp::Any RpgParser::CsDOULEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOULE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOULEContext* RpgParser::csDOULE() {
  CsDOULEContext *_localctx = _tracker.createInstance<CsDOULEContext>(_ctx, getState());
  enterRule(_localctx, 482, RpgParser::RuleCsDOULE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3524);
    dynamic_cast<CsDOULEContext *>(_localctx)->operation = match(RpgParser::OP_DOULE);
    setState(3525);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOULTContext ------------------------------------------------------------------

RpgParser::CsDOULTContext::CsDOULTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOULTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOULTContext::OP_DOULT() {
  return getToken(RpgParser::OP_DOULT, 0);
}


size_t RpgParser::CsDOULTContext::getRuleIndex() const {
  return RpgParser::RuleCsDOULT;
}

void RpgParser::CsDOULTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOULT(this);
}

void RpgParser::CsDOULTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOULT(this);
}


antlrcpp::Any RpgParser::CsDOULTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOULT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOULTContext* RpgParser::csDOULT() {
  CsDOULTContext *_localctx = _tracker.createInstance<CsDOULTContext>(_ctx, getState());
  enterRule(_localctx, 484, RpgParser::RuleCsDOULT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3527);
    dynamic_cast<CsDOULTContext *>(_localctx)->operation = match(RpgParser::OP_DOULT);
    setState(3528);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOUGEContext ------------------------------------------------------------------

RpgParser::CsDOUGEContext::CsDOUGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOUGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOUGEContext::OP_DOUGE() {
  return getToken(RpgParser::OP_DOUGE, 0);
}


size_t RpgParser::CsDOUGEContext::getRuleIndex() const {
  return RpgParser::RuleCsDOUGE;
}

void RpgParser::CsDOUGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOUGE(this);
}

void RpgParser::CsDOUGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOUGE(this);
}


antlrcpp::Any RpgParser::CsDOUGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOUGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOUGEContext* RpgParser::csDOUGE() {
  CsDOUGEContext *_localctx = _tracker.createInstance<CsDOUGEContext>(_ctx, getState());
  enterRule(_localctx, 486, RpgParser::RuleCsDOUGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3530);
    dynamic_cast<CsDOUGEContext *>(_localctx)->operation = match(RpgParser::OP_DOUGE);
    setState(3531);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOUGTContext ------------------------------------------------------------------

RpgParser::CsDOUGTContext::CsDOUGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOUGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOUGTContext::OP_DOUGT() {
  return getToken(RpgParser::OP_DOUGT, 0);
}


size_t RpgParser::CsDOUGTContext::getRuleIndex() const {
  return RpgParser::RuleCsDOUGT;
}

void RpgParser::CsDOUGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOUGT(this);
}

void RpgParser::CsDOUGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOUGT(this);
}


antlrcpp::Any RpgParser::CsDOUGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOUGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOUGTContext* RpgParser::csDOUGT() {
  CsDOUGTContext *_localctx = _tracker.createInstance<CsDOUGTContext>(_ctx, getState());
  enterRule(_localctx, 488, RpgParser::RuleCsDOUGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3533);
    dynamic_cast<CsDOUGTContext *>(_localctx)->operation = match(RpgParser::OP_DOUGT);
    setState(3534);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWContext ------------------------------------------------------------------

RpgParser::CsDOWContext::CsDOWContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsDOWContext::OP_DOW() {
  return getToken(RpgParser::OP_DOW, 0);
}

RpgParser::C_freeContext* RpgParser::CsDOWContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsDOWContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDOWContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDOWContext::getRuleIndex() const {
  return RpgParser::RuleCsDOW;
}

void RpgParser::CsDOWContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOW(this);
}

void RpgParser::CsDOWContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOW(this);
}


antlrcpp::Any RpgParser::CsDOWContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOW(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWContext* RpgParser::csDOW() {
  CsDOWContext *_localctx = _tracker.createInstance<CsDOWContext>(_ctx, getState());
  enterRule(_localctx, 490, RpgParser::RuleCsDOW);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3536);
    dynamic_cast<CsDOWContext *>(_localctx)->operation = match(RpgParser::OP_DOW);
    setState(3538);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      setState(3537);
      dynamic_cast<CsDOWContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3540);
    dynamic_cast<CsDOWContext *>(_localctx)->fixedexpression = c_free();
    setState(3541);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWEQContext ------------------------------------------------------------------

RpgParser::CsDOWEQContext::CsDOWEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOWEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWEQContext::OP_DOWEQ() {
  return getToken(RpgParser::OP_DOWEQ, 0);
}


size_t RpgParser::CsDOWEQContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWEQ;
}

void RpgParser::CsDOWEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWEQ(this);
}

void RpgParser::CsDOWEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWEQ(this);
}


antlrcpp::Any RpgParser::CsDOWEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWEQContext* RpgParser::csDOWEQ() {
  CsDOWEQContext *_localctx = _tracker.createInstance<CsDOWEQContext>(_ctx, getState());
  enterRule(_localctx, 492, RpgParser::RuleCsDOWEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3543);
    dynamic_cast<CsDOWEQContext *>(_localctx)->operation = match(RpgParser::OP_DOWEQ);
    setState(3544);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWNEContext ------------------------------------------------------------------

RpgParser::CsDOWNEContext::CsDOWNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOWNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWNEContext::OP_DOWNE() {
  return getToken(RpgParser::OP_DOWNE, 0);
}


size_t RpgParser::CsDOWNEContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWNE;
}

void RpgParser::CsDOWNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWNE(this);
}

void RpgParser::CsDOWNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWNE(this);
}


antlrcpp::Any RpgParser::CsDOWNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWNEContext* RpgParser::csDOWNE() {
  CsDOWNEContext *_localctx = _tracker.createInstance<CsDOWNEContext>(_ctx, getState());
  enterRule(_localctx, 494, RpgParser::RuleCsDOWNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3546);
    dynamic_cast<CsDOWNEContext *>(_localctx)->operation = match(RpgParser::OP_DOWNE);
    setState(3547);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWLEContext ------------------------------------------------------------------

RpgParser::CsDOWLEContext::CsDOWLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOWLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWLEContext::OP_DOWLE() {
  return getToken(RpgParser::OP_DOWLE, 0);
}


size_t RpgParser::CsDOWLEContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWLE;
}

void RpgParser::CsDOWLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWLE(this);
}

void RpgParser::CsDOWLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWLE(this);
}


antlrcpp::Any RpgParser::CsDOWLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWLEContext* RpgParser::csDOWLE() {
  CsDOWLEContext *_localctx = _tracker.createInstance<CsDOWLEContext>(_ctx, getState());
  enterRule(_localctx, 496, RpgParser::RuleCsDOWLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3549);
    dynamic_cast<CsDOWLEContext *>(_localctx)->operation = match(RpgParser::OP_DOWLE);
    setState(3550);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWLTContext ------------------------------------------------------------------

RpgParser::CsDOWLTContext::CsDOWLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOWLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWLTContext::OP_DOWLT() {
  return getToken(RpgParser::OP_DOWLT, 0);
}


size_t RpgParser::CsDOWLTContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWLT;
}

void RpgParser::CsDOWLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWLT(this);
}

void RpgParser::CsDOWLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWLT(this);
}


antlrcpp::Any RpgParser::CsDOWLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWLTContext* RpgParser::csDOWLT() {
  CsDOWLTContext *_localctx = _tracker.createInstance<CsDOWLTContext>(_ctx, getState());
  enterRule(_localctx, 498, RpgParser::RuleCsDOWLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3552);
    dynamic_cast<CsDOWLTContext *>(_localctx)->operation = match(RpgParser::OP_DOWLT);
    setState(3553);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWGEContext ------------------------------------------------------------------

RpgParser::CsDOWGEContext::CsDOWGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOWGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWGEContext::OP_DOWGE() {
  return getToken(RpgParser::OP_DOWGE, 0);
}


size_t RpgParser::CsDOWGEContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWGE;
}

void RpgParser::CsDOWGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWGE(this);
}

void RpgParser::CsDOWGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWGE(this);
}


antlrcpp::Any RpgParser::CsDOWGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWGEContext* RpgParser::csDOWGE() {
  CsDOWGEContext *_localctx = _tracker.createInstance<CsDOWGEContext>(_ctx, getState());
  enterRule(_localctx, 500, RpgParser::RuleCsDOWGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3555);
    dynamic_cast<CsDOWGEContext *>(_localctx)->operation = match(RpgParser::OP_DOWGE);
    setState(3556);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDOWGTContext ------------------------------------------------------------------

RpgParser::CsDOWGTContext::CsDOWGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDOWGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDOWGTContext::OP_DOWGT() {
  return getToken(RpgParser::OP_DOWGT, 0);
}


size_t RpgParser::CsDOWGTContext::getRuleIndex() const {
  return RpgParser::RuleCsDOWGT;
}

void RpgParser::CsDOWGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDOWGT(this);
}

void RpgParser::CsDOWGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDOWGT(this);
}


antlrcpp::Any RpgParser::CsDOWGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDOWGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDOWGTContext* RpgParser::csDOWGT() {
  CsDOWGTContext *_localctx = _tracker.createInstance<CsDOWGTContext>(_ctx, getState());
  enterRule(_localctx, 502, RpgParser::RuleCsDOWGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3558);
    dynamic_cast<CsDOWGTContext *>(_localctx)->operation = match(RpgParser::OP_DOWGT);
    setState(3559);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDSPLYContext ------------------------------------------------------------------

RpgParser::CsDSPLYContext::CsDSPLYContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDSPLYContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDSPLYContext::OP_DSPLY() {
  return getToken(RpgParser::OP_DSPLY, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDSPLYContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDSPLYContext::getRuleIndex() const {
  return RpgParser::RuleCsDSPLY;
}

void RpgParser::CsDSPLYContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDSPLY(this);
}

void RpgParser::CsDSPLYContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDSPLY(this);
}


antlrcpp::Any RpgParser::CsDSPLYContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDSPLY(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDSPLYContext* RpgParser::csDSPLY() {
  CsDSPLYContext *_localctx = _tracker.createInstance<CsDSPLYContext>(_ctx, getState());
  enterRule(_localctx, 504, RpgParser::RuleCsDSPLY);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3561);
    dynamic_cast<CsDSPLYContext *>(_localctx)->operation = match(RpgParser::OP_DSPLY);
    setState(3563);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3562);
      dynamic_cast<CsDSPLYContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3565);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsDUMPContext ------------------------------------------------------------------

RpgParser::CsDUMPContext::CsDUMPContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsDUMPContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsDUMPContext::OP_DUMP() {
  return getToken(RpgParser::OP_DUMP, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsDUMPContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsDUMPContext::getRuleIndex() const {
  return RpgParser::RuleCsDUMP;
}

void RpgParser::CsDUMPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsDUMP(this);
}

void RpgParser::CsDUMPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsDUMP(this);
}


antlrcpp::Any RpgParser::CsDUMPContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsDUMP(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsDUMPContext* RpgParser::csDUMP() {
  CsDUMPContext *_localctx = _tracker.createInstance<CsDUMPContext>(_ctx, getState());
  enterRule(_localctx, 506, RpgParser::RuleCsDUMP);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3567);
    dynamic_cast<CsDUMPContext *>(_localctx)->operation = match(RpgParser::OP_DUMP);
    setState(3569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3568);
      dynamic_cast<CsDUMPContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3571);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsELSEContext ------------------------------------------------------------------

RpgParser::CsELSEContext::CsELSEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsELSEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsELSEContext::OP_ELSE() {
  return getToken(RpgParser::OP_ELSE, 0);
}


size_t RpgParser::CsELSEContext::getRuleIndex() const {
  return RpgParser::RuleCsELSE;
}

void RpgParser::CsELSEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsELSE(this);
}

void RpgParser::CsELSEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsELSE(this);
}


antlrcpp::Any RpgParser::CsELSEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsELSE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsELSEContext* RpgParser::csELSE() {
  CsELSEContext *_localctx = _tracker.createInstance<CsELSEContext>(_ctx, getState());
  enterRule(_localctx, 508, RpgParser::RuleCsELSE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3573);
    dynamic_cast<CsELSEContext *>(_localctx)->operation = match(RpgParser::OP_ELSE);
    setState(3574);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsELSEIFContext ------------------------------------------------------------------

RpgParser::CsELSEIFContext::CsELSEIFContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsELSEIFContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsELSEIFContext::OP_ELSEIF() {
  return getToken(RpgParser::OP_ELSEIF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsELSEIFContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsELSEIFContext::getRuleIndex() const {
  return RpgParser::RuleCsELSEIF;
}

void RpgParser::CsELSEIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsELSEIF(this);
}

void RpgParser::CsELSEIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsELSEIF(this);
}


antlrcpp::Any RpgParser::CsELSEIFContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsELSEIF(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsELSEIFContext* RpgParser::csELSEIF() {
  CsELSEIFContext *_localctx = _tracker.createInstance<CsELSEIFContext>(_ctx, getState());
  enterRule(_localctx, 510, RpgParser::RuleCsELSEIF);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3576);
    dynamic_cast<CsELSEIFContext *>(_localctx)->operation = match(RpgParser::OP_ELSEIF);
    setState(3578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3577);
      dynamic_cast<CsELSEIFContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3580);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDContext ------------------------------------------------------------------

RpgParser::CsENDContext::CsENDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDContext::OP_END() {
  return getToken(RpgParser::OP_END, 0);
}


size_t RpgParser::CsENDContext::getRuleIndex() const {
  return RpgParser::RuleCsEND;
}

void RpgParser::CsENDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEND(this);
}

void RpgParser::CsENDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEND(this);
}


antlrcpp::Any RpgParser::CsENDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEND(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDContext* RpgParser::csEND() {
  CsENDContext *_localctx = _tracker.createInstance<CsENDContext>(_ctx, getState());
  enterRule(_localctx, 512, RpgParser::RuleCsEND);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3582);
    dynamic_cast<CsENDContext *>(_localctx)->operation = match(RpgParser::OP_END);
    setState(3583);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDCSContext ------------------------------------------------------------------

RpgParser::CsENDCSContext::CsENDCSContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDCSContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDCSContext::OP_ENDCS() {
  return getToken(RpgParser::OP_ENDCS, 0);
}


size_t RpgParser::CsENDCSContext::getRuleIndex() const {
  return RpgParser::RuleCsENDCS;
}

void RpgParser::CsENDCSContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDCS(this);
}

void RpgParser::CsENDCSContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDCS(this);
}


antlrcpp::Any RpgParser::CsENDCSContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDCS(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDCSContext* RpgParser::csENDCS() {
  CsENDCSContext *_localctx = _tracker.createInstance<CsENDCSContext>(_ctx, getState());
  enterRule(_localctx, 514, RpgParser::RuleCsENDCS);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3585);
    dynamic_cast<CsENDCSContext *>(_localctx)->operation = match(RpgParser::OP_ENDCS);
    setState(3586);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDDOContext ------------------------------------------------------------------

RpgParser::CsENDDOContext::CsENDDOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDDOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDDOContext::OP_ENDDO() {
  return getToken(RpgParser::OP_ENDDO, 0);
}


size_t RpgParser::CsENDDOContext::getRuleIndex() const {
  return RpgParser::RuleCsENDDO;
}

void RpgParser::CsENDDOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDDO(this);
}

void RpgParser::CsENDDOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDDO(this);
}


antlrcpp::Any RpgParser::CsENDDOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDDO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDDOContext* RpgParser::csENDDO() {
  CsENDDOContext *_localctx = _tracker.createInstance<CsENDDOContext>(_ctx, getState());
  enterRule(_localctx, 516, RpgParser::RuleCsENDDO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3588);
    dynamic_cast<CsENDDOContext *>(_localctx)->operation = match(RpgParser::OP_ENDDO);
    setState(3589);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDFORContext ------------------------------------------------------------------

RpgParser::CsENDFORContext::CsENDFORContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDFORContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDFORContext::OP_ENDFOR() {
  return getToken(RpgParser::OP_ENDFOR, 0);
}


size_t RpgParser::CsENDFORContext::getRuleIndex() const {
  return RpgParser::RuleCsENDFOR;
}

void RpgParser::CsENDFORContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDFOR(this);
}

void RpgParser::CsENDFORContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDFOR(this);
}


antlrcpp::Any RpgParser::CsENDFORContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDFOR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDFORContext* RpgParser::csENDFOR() {
  CsENDFORContext *_localctx = _tracker.createInstance<CsENDFORContext>(_ctx, getState());
  enterRule(_localctx, 518, RpgParser::RuleCsENDFOR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3591);
    dynamic_cast<CsENDFORContext *>(_localctx)->operation = match(RpgParser::OP_ENDFOR);
    setState(3592);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDIFContext ------------------------------------------------------------------

RpgParser::CsENDIFContext::CsENDIFContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDIFContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDIFContext::OP_ENDIF() {
  return getToken(RpgParser::OP_ENDIF, 0);
}


size_t RpgParser::CsENDIFContext::getRuleIndex() const {
  return RpgParser::RuleCsENDIF;
}

void RpgParser::CsENDIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDIF(this);
}

void RpgParser::CsENDIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDIF(this);
}


antlrcpp::Any RpgParser::CsENDIFContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDIF(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDIFContext* RpgParser::csENDIF() {
  CsENDIFContext *_localctx = _tracker.createInstance<CsENDIFContext>(_ctx, getState());
  enterRule(_localctx, 520, RpgParser::RuleCsENDIF);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3594);
    dynamic_cast<CsENDIFContext *>(_localctx)->operation = match(RpgParser::OP_ENDIF);
    setState(3595);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDMONContext ------------------------------------------------------------------

RpgParser::CsENDMONContext::CsENDMONContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDMONContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDMONContext::OP_ENDMON() {
  return getToken(RpgParser::OP_ENDMON, 0);
}


size_t RpgParser::CsENDMONContext::getRuleIndex() const {
  return RpgParser::RuleCsENDMON;
}

void RpgParser::CsENDMONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDMON(this);
}

void RpgParser::CsENDMONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDMON(this);
}


antlrcpp::Any RpgParser::CsENDMONContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDMON(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDMONContext* RpgParser::csENDMON() {
  CsENDMONContext *_localctx = _tracker.createInstance<CsENDMONContext>(_ctx, getState());
  enterRule(_localctx, 522, RpgParser::RuleCsENDMON);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3597);
    dynamic_cast<CsENDMONContext *>(_localctx)->operation = match(RpgParser::OP_ENDMON);
    setState(3598);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsENDSLContext ------------------------------------------------------------------

RpgParser::CsENDSLContext::CsENDSLContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsENDSLContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsENDSLContext::OP_ENDSL() {
  return getToken(RpgParser::OP_ENDSL, 0);
}


size_t RpgParser::CsENDSLContext::getRuleIndex() const {
  return RpgParser::RuleCsENDSL;
}

void RpgParser::CsENDSLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsENDSL(this);
}

void RpgParser::CsENDSLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsENDSL(this);
}


antlrcpp::Any RpgParser::CsENDSLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsENDSL(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsENDSLContext* RpgParser::csENDSL() {
  CsENDSLContext *_localctx = _tracker.createInstance<CsENDSLContext>(_ctx, getState());
  enterRule(_localctx, 524, RpgParser::RuleCsENDSL);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3600);
    dynamic_cast<CsENDSLContext *>(_localctx)->operation = match(RpgParser::OP_ENDSL);
    setState(3601);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEVALContext ------------------------------------------------------------------

RpgParser::CsEVALContext::CsEVALContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::TargetContext* RpgParser::CsEVALContext::target() {
  return getRuleContext<RpgParser::TargetContext>(0);
}

tree::TerminalNode* RpgParser::CsEVALContext::OP_EVAL() {
  return getToken(RpgParser::OP_EVAL, 0);
}

RpgParser::AssignmentOperatorIncludingEqualContext* RpgParser::CsEVALContext::assignmentOperatorIncludingEqual() {
  return getRuleContext<RpgParser::AssignmentOperatorIncludingEqualContext>(0);
}

RpgParser::C_freeContext* RpgParser::CsEVALContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsEVALContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsEVALContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsEVALContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsEVALContext::getRuleIndex() const {
  return RpgParser::RuleCsEVAL;
}

void RpgParser::CsEVALContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEVAL(this);
}

void RpgParser::CsEVALContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEVAL(this);
}


antlrcpp::Any RpgParser::CsEVALContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEVAL(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEVALContext* RpgParser::csEVAL() {
  CsEVALContext *_localctx = _tracker.createInstance<CsEVALContext>(_ctx, getState());
  enterRule(_localctx, 526, RpgParser::RuleCsEVAL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3603);
    dynamic_cast<CsEVALContext *>(_localctx)->operation = match(RpgParser::OP_EVAL);
    setState(3605);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3604);
      dynamic_cast<CsEVALContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3607);
    target(0);
    setState(3608);
    dynamic_cast<CsEVALContext *>(_localctx)->operator1 = assignmentOperatorIncludingEqual();
    setState(3609);
    dynamic_cast<CsEVALContext *>(_localctx)->fixedexpression = c_free();
    setState(3610);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEVAL_CORRContext ------------------------------------------------------------------

RpgParser::CsEVAL_CORRContext::CsEVAL_CORRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsEVAL_CORRContext::OP_EVAL_CORR() {
  return getToken(RpgParser::OP_EVAL_CORR, 0);
}

RpgParser::C_freeContext* RpgParser::CsEVAL_CORRContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsEVAL_CORRContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsEVAL_CORRContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::CsEVAL_CORRContext::getRuleIndex() const {
  return RpgParser::RuleCsEVAL_CORR;
}

void RpgParser::CsEVAL_CORRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEVAL_CORR(this);
}

void RpgParser::CsEVAL_CORRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEVAL_CORR(this);
}


antlrcpp::Any RpgParser::CsEVAL_CORRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEVAL_CORR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEVAL_CORRContext* RpgParser::csEVAL_CORR() {
  CsEVAL_CORRContext *_localctx = _tracker.createInstance<CsEVAL_CORRContext>(_ctx, getState());
  enterRule(_localctx, 528, RpgParser::RuleCsEVAL_CORR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3612);
    dynamic_cast<CsEVAL_CORRContext *>(_localctx)->operation = match(RpgParser::OP_EVAL_CORR);
    setState(3613);
    dynamic_cast<CsEVAL_CORRContext *>(_localctx)->fixedexpression = c_free();
    setState(3614);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEVALRContext ------------------------------------------------------------------

RpgParser::CsEVALRContext::CsEVALRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsEVALRContext::OP_EVALR() {
  return getToken(RpgParser::OP_EVALR, 0);
}

RpgParser::C_freeContext* RpgParser::CsEVALRContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsEVALRContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsEVALRContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsEVALRContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsEVALRContext::getRuleIndex() const {
  return RpgParser::RuleCsEVALR;
}

void RpgParser::CsEVALRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEVALR(this);
}

void RpgParser::CsEVALRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEVALR(this);
}


antlrcpp::Any RpgParser::CsEVALRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEVALR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEVALRContext* RpgParser::csEVALR() {
  CsEVALRContext *_localctx = _tracker.createInstance<CsEVALRContext>(_ctx, getState());
  enterRule(_localctx, 530, RpgParser::RuleCsEVALR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3616);
    dynamic_cast<CsEVALRContext *>(_localctx)->operation = match(RpgParser::OP_EVALR);
    setState(3618);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
    case 1: {
      setState(3617);
      dynamic_cast<CsEVALRContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3620);
    dynamic_cast<CsEVALRContext *>(_localctx)->fixedexpression = c_free();
    setState(3621);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEXCEPTContext ------------------------------------------------------------------

RpgParser::CsEXCEPTContext::CsEXCEPTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsEXCEPTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsEXCEPTContext::OP_EXCEPT() {
  return getToken(RpgParser::OP_EXCEPT, 0);
}


size_t RpgParser::CsEXCEPTContext::getRuleIndex() const {
  return RpgParser::RuleCsEXCEPT;
}

void RpgParser::CsEXCEPTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEXCEPT(this);
}

void RpgParser::CsEXCEPTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEXCEPT(this);
}


antlrcpp::Any RpgParser::CsEXCEPTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEXCEPT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEXCEPTContext* RpgParser::csEXCEPT() {
  CsEXCEPTContext *_localctx = _tracker.createInstance<CsEXCEPTContext>(_ctx, getState());
  enterRule(_localctx, 532, RpgParser::RuleCsEXCEPT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3623);
    dynamic_cast<CsEXCEPTContext *>(_localctx)->operation = match(RpgParser::OP_EXCEPT);
    setState(3624);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEXFMTContext ------------------------------------------------------------------

RpgParser::CsEXFMTContext::CsEXFMTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsEXFMTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsEXFMTContext::OP_EXFMT() {
  return getToken(RpgParser::OP_EXFMT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsEXFMTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsEXFMTContext::getRuleIndex() const {
  return RpgParser::RuleCsEXFMT;
}

void RpgParser::CsEXFMTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEXFMT(this);
}

void RpgParser::CsEXFMTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEXFMT(this);
}


antlrcpp::Any RpgParser::CsEXFMTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEXFMT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEXFMTContext* RpgParser::csEXFMT() {
  CsEXFMTContext *_localctx = _tracker.createInstance<CsEXFMTContext>(_ctx, getState());
  enterRule(_localctx, 534, RpgParser::RuleCsEXFMT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3626);
    dynamic_cast<CsEXFMTContext *>(_localctx)->operation = match(RpgParser::OP_EXFMT);
    setState(3628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3627);
      dynamic_cast<CsEXFMTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3630);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEXSRContext ------------------------------------------------------------------

RpgParser::CsEXSRContext::CsEXSRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsEXSRContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsEXSRContext::OP_EXSR() {
  return getToken(RpgParser::OP_EXSR, 0);
}


size_t RpgParser::CsEXSRContext::getRuleIndex() const {
  return RpgParser::RuleCsEXSR;
}

void RpgParser::CsEXSRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEXSR(this);
}

void RpgParser::CsEXSRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEXSR(this);
}


antlrcpp::Any RpgParser::CsEXSRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEXSR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEXSRContext* RpgParser::csEXSR() {
  CsEXSRContext *_localctx = _tracker.createInstance<CsEXSRContext>(_ctx, getState());
  enterRule(_localctx, 536, RpgParser::RuleCsEXSR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3632);
    dynamic_cast<CsEXSRContext *>(_localctx)->operation = match(RpgParser::OP_EXSR);
    setState(3633);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsEXTRCTContext ------------------------------------------------------------------

RpgParser::CsEXTRCTContext::CsEXTRCTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsEXTRCTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsEXTRCTContext::OP_EXTRCT() {
  return getToken(RpgParser::OP_EXTRCT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsEXTRCTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsEXTRCTContext::getRuleIndex() const {
  return RpgParser::RuleCsEXTRCT;
}

void RpgParser::CsEXTRCTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsEXTRCT(this);
}

void RpgParser::CsEXTRCTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsEXTRCT(this);
}


antlrcpp::Any RpgParser::CsEXTRCTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsEXTRCT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsEXTRCTContext* RpgParser::csEXTRCT() {
  CsEXTRCTContext *_localctx = _tracker.createInstance<CsEXTRCTContext>(_ctx, getState());
  enterRule(_localctx, 538, RpgParser::RuleCsEXTRCT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3635);
    dynamic_cast<CsEXTRCTContext *>(_localctx)->operation = match(RpgParser::OP_EXTRCT);
    setState(3637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3636);
      dynamic_cast<CsEXTRCTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3639);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsFEODContext ------------------------------------------------------------------

RpgParser::CsFEODContext::CsFEODContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsFEODContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsFEODContext::OP_FEOD() {
  return getToken(RpgParser::OP_FEOD, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsFEODContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsFEODContext::getRuleIndex() const {
  return RpgParser::RuleCsFEOD;
}

void RpgParser::CsFEODContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsFEOD(this);
}

void RpgParser::CsFEODContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsFEOD(this);
}


antlrcpp::Any RpgParser::CsFEODContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsFEOD(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsFEODContext* RpgParser::csFEOD() {
  CsFEODContext *_localctx = _tracker.createInstance<CsFEODContext>(_ctx, getState());
  enterRule(_localctx, 540, RpgParser::RuleCsFEOD);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3641);
    dynamic_cast<CsFEODContext *>(_localctx)->operation = match(RpgParser::OP_FEOD);
    setState(3643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3642);
      dynamic_cast<CsFEODContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3645);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsFORContext ------------------------------------------------------------------

RpgParser::CsFORContext::CsFORContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::ExpressionContext *> RpgParser::CsFORContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::CsFORContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::CsFORContext::OP_FOR() {
  return getToken(RpgParser::OP_FOR, 0);
}

tree::TerminalNode* RpgParser::CsFORContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsFORContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

tree::TerminalNode* RpgParser::CsFORContext::EQUAL() {
  return getToken(RpgParser::EQUAL, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsFORContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

tree::TerminalNode* RpgParser::CsFORContext::FREE_BY() {
  return getToken(RpgParser::FREE_BY, 0);
}

RpgParser::ByExpressionContext* RpgParser::CsFORContext::byExpression() {
  return getRuleContext<RpgParser::ByExpressionContext>(0);
}

RpgParser::StopExpressionContext* RpgParser::CsFORContext::stopExpression() {
  return getRuleContext<RpgParser::StopExpressionContext>(0);
}

tree::TerminalNode* RpgParser::CsFORContext::FREE_TO() {
  return getToken(RpgParser::FREE_TO, 0);
}

tree::TerminalNode* RpgParser::CsFORContext::FREE_DOWNTO() {
  return getToken(RpgParser::FREE_DOWNTO, 0);
}


size_t RpgParser::CsFORContext::getRuleIndex() const {
  return RpgParser::RuleCsFOR;
}

void RpgParser::CsFORContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsFOR(this);
}

void RpgParser::CsFORContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsFOR(this);
}


antlrcpp::Any RpgParser::CsFORContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsFOR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsFORContext* RpgParser::csFOR() {
  CsFORContext *_localctx = _tracker.createInstance<CsFORContext>(_ctx, getState());
  enterRule(_localctx, 542, RpgParser::RuleCsFOR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3647);
    dynamic_cast<CsFORContext *>(_localctx)->operation = match(RpgParser::OP_FOR);
    setState(3649);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
    case 1: {
      setState(3648);
      dynamic_cast<CsFORContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3651);
    expression(0);
    setState(3654);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::EQUAL) {
      setState(3652);
      match(RpgParser::EQUAL);
      setState(3653);
      expression(0);
    }
    setState(3672);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
    case 1: {
      setState(3658);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::FREE_BY) {
        setState(3656);
        match(RpgParser::FREE_BY);
        setState(3657);
        byExpression();
      }
      setState(3662);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::FREE_TO

      || _la == RpgParser::FREE_DOWNTO) {
        setState(3660);
        _la = _input->LA(1);
        if (!(_la == RpgParser::FREE_TO

        || _la == RpgParser::FREE_DOWNTO)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3661);
        stopExpression();
      }
      break;
    }

    case 2: {
      setState(3666);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::FREE_TO

      || _la == RpgParser::FREE_DOWNTO) {
        setState(3664);
        _la = _input->LA(1);
        if (!(_la == RpgParser::FREE_TO

        || _la == RpgParser::FREE_DOWNTO)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3665);
        stopExpression();
      }
      setState(3670);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::FREE_BY) {
        setState(3668);
        match(RpgParser::FREE_BY);
        setState(3669);
        byExpression();
      }
      break;
    }

    }
    setState(3674);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ByExpressionContext ------------------------------------------------------------------

RpgParser::ByExpressionContext::ByExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ExpressionContext* RpgParser::ByExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::ByExpressionContext::getRuleIndex() const {
  return RpgParser::RuleByExpression;
}

void RpgParser::ByExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterByExpression(this);
}

void RpgParser::ByExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitByExpression(this);
}


antlrcpp::Any RpgParser::ByExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitByExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ByExpressionContext* RpgParser::byExpression() {
  ByExpressionContext *_localctx = _tracker.createInstance<ByExpressionContext>(_ctx, getState());
  enterRule(_localctx, 544, RpgParser::RuleByExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3676);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopExpressionContext ------------------------------------------------------------------

RpgParser::StopExpressionContext::StopExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ExpressionContext* RpgParser::StopExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::StopExpressionContext::getRuleIndex() const {
  return RpgParser::RuleStopExpression;
}

void RpgParser::StopExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopExpression(this);
}

void RpgParser::StopExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopExpression(this);
}


antlrcpp::Any RpgParser::StopExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitStopExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::StopExpressionContext* RpgParser::stopExpression() {
  StopExpressionContext *_localctx = _tracker.createInstance<StopExpressionContext>(_ctx, getState());
  enterRule(_localctx, 546, RpgParser::RuleStopExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3678);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsFORCEContext ------------------------------------------------------------------

RpgParser::CsFORCEContext::CsFORCEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsFORCEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsFORCEContext::OP_FORCE() {
  return getToken(RpgParser::OP_FORCE, 0);
}


size_t RpgParser::CsFORCEContext::getRuleIndex() const {
  return RpgParser::RuleCsFORCE;
}

void RpgParser::CsFORCEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsFORCE(this);
}

void RpgParser::CsFORCEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsFORCE(this);
}


antlrcpp::Any RpgParser::CsFORCEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsFORCE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsFORCEContext* RpgParser::csFORCE() {
  CsFORCEContext *_localctx = _tracker.createInstance<CsFORCEContext>(_ctx, getState());
  enterRule(_localctx, 548, RpgParser::RuleCsFORCE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3680);
    dynamic_cast<CsFORCEContext *>(_localctx)->operation = match(RpgParser::OP_FORCE);
    setState(3681);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsGOTOContext ------------------------------------------------------------------

RpgParser::CsGOTOContext::CsGOTOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsGOTOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsGOTOContext::OP_GOTO() {
  return getToken(RpgParser::OP_GOTO, 0);
}


size_t RpgParser::CsGOTOContext::getRuleIndex() const {
  return RpgParser::RuleCsGOTO;
}

void RpgParser::CsGOTOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsGOTO(this);
}

void RpgParser::CsGOTOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsGOTO(this);
}


antlrcpp::Any RpgParser::CsGOTOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsGOTO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsGOTOContext* RpgParser::csGOTO() {
  CsGOTOContext *_localctx = _tracker.createInstance<CsGOTOContext>(_ctx, getState());
  enterRule(_localctx, 550, RpgParser::RuleCsGOTO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3683);
    dynamic_cast<CsGOTOContext *>(_localctx)->operation = match(RpgParser::OP_GOTO);
    setState(3684);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFContext ------------------------------------------------------------------

RpgParser::CsIFContext::CsIFContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsIFContext::OP_IF() {
  return getToken(RpgParser::OP_IF, 0);
}

RpgParser::C_freeContext* RpgParser::CsIFContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsIFContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsIFContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsIFContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsIFContext::getRuleIndex() const {
  return RpgParser::RuleCsIF;
}

void RpgParser::CsIFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIF(this);
}

void RpgParser::CsIFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIF(this);
}


antlrcpp::Any RpgParser::CsIFContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIF(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFContext* RpgParser::csIF() {
  CsIFContext *_localctx = _tracker.createInstance<CsIFContext>(_ctx, getState());
  enterRule(_localctx, 552, RpgParser::RuleCsIF);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3686);
    dynamic_cast<CsIFContext *>(_localctx)->operation = match(RpgParser::OP_IF);
    setState(3688);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
    case 1: {
      setState(3687);
      dynamic_cast<CsIFContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3690);
    dynamic_cast<CsIFContext *>(_localctx)->fixedexpression = c_free();
    setState(3691);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFEQContext ------------------------------------------------------------------

RpgParser::CsIFEQContext::CsIFEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsIFEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsIFEQContext::OP_IFEQ() {
  return getToken(RpgParser::OP_IFEQ, 0);
}


size_t RpgParser::CsIFEQContext::getRuleIndex() const {
  return RpgParser::RuleCsIFEQ;
}

void RpgParser::CsIFEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFEQ(this);
}

void RpgParser::CsIFEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFEQ(this);
}


antlrcpp::Any RpgParser::CsIFEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFEQContext* RpgParser::csIFEQ() {
  CsIFEQContext *_localctx = _tracker.createInstance<CsIFEQContext>(_ctx, getState());
  enterRule(_localctx, 554, RpgParser::RuleCsIFEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3693);
    dynamic_cast<CsIFEQContext *>(_localctx)->operation = match(RpgParser::OP_IFEQ);
    setState(3694);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFNEContext ------------------------------------------------------------------

RpgParser::CsIFNEContext::CsIFNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsIFNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsIFNEContext::OP_IFNE() {
  return getToken(RpgParser::OP_IFNE, 0);
}


size_t RpgParser::CsIFNEContext::getRuleIndex() const {
  return RpgParser::RuleCsIFNE;
}

void RpgParser::CsIFNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFNE(this);
}

void RpgParser::CsIFNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFNE(this);
}


antlrcpp::Any RpgParser::CsIFNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFNEContext* RpgParser::csIFNE() {
  CsIFNEContext *_localctx = _tracker.createInstance<CsIFNEContext>(_ctx, getState());
  enterRule(_localctx, 556, RpgParser::RuleCsIFNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3696);
    dynamic_cast<CsIFNEContext *>(_localctx)->operation = match(RpgParser::OP_IFNE);
    setState(3697);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFLEContext ------------------------------------------------------------------

RpgParser::CsIFLEContext::CsIFLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsIFLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsIFLEContext::OP_IFLE() {
  return getToken(RpgParser::OP_IFLE, 0);
}


size_t RpgParser::CsIFLEContext::getRuleIndex() const {
  return RpgParser::RuleCsIFLE;
}

void RpgParser::CsIFLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFLE(this);
}

void RpgParser::CsIFLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFLE(this);
}


antlrcpp::Any RpgParser::CsIFLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFLEContext* RpgParser::csIFLE() {
  CsIFLEContext *_localctx = _tracker.createInstance<CsIFLEContext>(_ctx, getState());
  enterRule(_localctx, 558, RpgParser::RuleCsIFLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3699);
    dynamic_cast<CsIFLEContext *>(_localctx)->operation = match(RpgParser::OP_IFLE);
    setState(3700);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFLTContext ------------------------------------------------------------------

RpgParser::CsIFLTContext::CsIFLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsIFLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsIFLTContext::OP_IFLT() {
  return getToken(RpgParser::OP_IFLT, 0);
}


size_t RpgParser::CsIFLTContext::getRuleIndex() const {
  return RpgParser::RuleCsIFLT;
}

void RpgParser::CsIFLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFLT(this);
}

void RpgParser::CsIFLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFLT(this);
}


antlrcpp::Any RpgParser::CsIFLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFLTContext* RpgParser::csIFLT() {
  CsIFLTContext *_localctx = _tracker.createInstance<CsIFLTContext>(_ctx, getState());
  enterRule(_localctx, 560, RpgParser::RuleCsIFLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3702);
    dynamic_cast<CsIFLTContext *>(_localctx)->operation = match(RpgParser::OP_IFLT);
    setState(3703);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFGEContext ------------------------------------------------------------------

RpgParser::CsIFGEContext::CsIFGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsIFGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsIFGEContext::OP_IFGE() {
  return getToken(RpgParser::OP_IFGE, 0);
}


size_t RpgParser::CsIFGEContext::getRuleIndex() const {
  return RpgParser::RuleCsIFGE;
}

void RpgParser::CsIFGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFGE(this);
}

void RpgParser::CsIFGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFGE(this);
}


antlrcpp::Any RpgParser::CsIFGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFGEContext* RpgParser::csIFGE() {
  CsIFGEContext *_localctx = _tracker.createInstance<CsIFGEContext>(_ctx, getState());
  enterRule(_localctx, 562, RpgParser::RuleCsIFGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3705);
    dynamic_cast<CsIFGEContext *>(_localctx)->operation = match(RpgParser::OP_IFGE);
    setState(3706);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsIFGTContext ------------------------------------------------------------------

RpgParser::CsIFGTContext::CsIFGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsIFGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsIFGTContext::OP_IFGT() {
  return getToken(RpgParser::OP_IFGT, 0);
}


size_t RpgParser::CsIFGTContext::getRuleIndex() const {
  return RpgParser::RuleCsIFGT;
}

void RpgParser::CsIFGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIFGT(this);
}

void RpgParser::CsIFGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIFGT(this);
}


antlrcpp::Any RpgParser::CsIFGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIFGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsIFGTContext* RpgParser::csIFGT() {
  CsIFGTContext *_localctx = _tracker.createInstance<CsIFGTContext>(_ctx, getState());
  enterRule(_localctx, 564, RpgParser::RuleCsIFGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3708);
    dynamic_cast<CsIFGTContext *>(_localctx)->operation = match(RpgParser::OP_IFGT);
    setState(3709);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsINContext ------------------------------------------------------------------

RpgParser::CsINContext::CsINContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsINContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsINContext::OP_IN() {
  return getToken(RpgParser::OP_IN, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsINContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsINContext::getRuleIndex() const {
  return RpgParser::RuleCsIN;
}

void RpgParser::CsINContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsIN(this);
}

void RpgParser::CsINContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsIN(this);
}


antlrcpp::Any RpgParser::CsINContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsIN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsINContext* RpgParser::csIN() {
  CsINContext *_localctx = _tracker.createInstance<CsINContext>(_ctx, getState());
  enterRule(_localctx, 566, RpgParser::RuleCsIN);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3711);
    dynamic_cast<CsINContext *>(_localctx)->operation = match(RpgParser::OP_IN);
    setState(3713);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3712);
      dynamic_cast<CsINContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3715);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsITERContext ------------------------------------------------------------------

RpgParser::CsITERContext::CsITERContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsITERContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsITERContext::OP_ITER() {
  return getToken(RpgParser::OP_ITER, 0);
}


size_t RpgParser::CsITERContext::getRuleIndex() const {
  return RpgParser::RuleCsITER;
}

void RpgParser::CsITERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsITER(this);
}

void RpgParser::CsITERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsITER(this);
}


antlrcpp::Any RpgParser::CsITERContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsITER(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsITERContext* RpgParser::csITER() {
  CsITERContext *_localctx = _tracker.createInstance<CsITERContext>(_ctx, getState());
  enterRule(_localctx, 568, RpgParser::RuleCsITER);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3717);
    dynamic_cast<CsITERContext *>(_localctx)->operation = match(RpgParser::OP_ITER);
    setState(3718);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsKLISTContext ------------------------------------------------------------------

RpgParser::CsKLISTContext::CsKLISTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsKLISTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsKLISTContext::OP_KLIST() {
  return getToken(RpgParser::OP_KLIST, 0);
}

std::vector<RpgParser::CsKFLDContext *> RpgParser::CsKLISTContext::csKFLD() {
  return getRuleContexts<RpgParser::CsKFLDContext>();
}

RpgParser::CsKFLDContext* RpgParser::CsKLISTContext::csKFLD(size_t i) {
  return getRuleContext<RpgParser::CsKFLDContext>(i);
}


size_t RpgParser::CsKLISTContext::getRuleIndex() const {
  return RpgParser::RuleCsKLIST;
}

void RpgParser::CsKLISTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsKLIST(this);
}

void RpgParser::CsKLISTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsKLIST(this);
}


antlrcpp::Any RpgParser::CsKLISTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsKLIST(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsKLISTContext* RpgParser::csKLIST() {
  CsKLISTContext *_localctx = _tracker.createInstance<CsKLISTContext>(_ctx, getState());
  enterRule(_localctx, 570, RpgParser::RuleCsKLIST);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3720);
    dynamic_cast<CsKLISTContext *>(_localctx)->operation = match(RpgParser::OP_KLIST);
    setState(3721);
    cspec_fixed_standard_parts();
    setState(3725);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3722);
        csKFLD(); 
      }
      setState(3727);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsKFLDContext ------------------------------------------------------------------

RpgParser::CsKFLDContext::CsKFLDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsKFLDContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

std::vector<tree::TerminalNode *> RpgParser::CsKFLDContext::BlankIndicator() {
  return getTokens(RpgParser::BlankIndicator);
}

tree::TerminalNode* RpgParser::CsKFLDContext::BlankIndicator(size_t i) {
  return getToken(RpgParser::BlankIndicator, i);
}

tree::TerminalNode* RpgParser::CsKFLDContext::BlankFlag() {
  return getToken(RpgParser::BlankFlag, 0);
}

tree::TerminalNode* RpgParser::CsKFLDContext::CS_BlankFactor() {
  return getToken(RpgParser::CS_BlankFactor, 0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsKFLDContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsKFLDContext::OP_KFLD() {
  return getToken(RpgParser::OP_KFLD, 0);
}


size_t RpgParser::CsKFLDContext::getRuleIndex() const {
  return RpgParser::RuleCsKFLD;
}

void RpgParser::CsKFLDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsKFLD(this);
}

void RpgParser::CsKFLDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsKFLD(this);
}


antlrcpp::Any RpgParser::CsKFLDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsKFLD(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsKFLDContext* RpgParser::csKFLD() {
  CsKFLDContext *_localctx = _tracker.createInstance<CsKFLDContext>(_ctx, getState());
  enterRule(_localctx, 572, RpgParser::RuleCsKFLD);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3728);
    match(RpgParser::CS_FIXED);
    setState(3729);
    match(RpgParser::BlankIndicator);
    setState(3730);
    match(RpgParser::BlankFlag);
    setState(3731);
    match(RpgParser::BlankIndicator);
    setState(3732);
    match(RpgParser::CS_BlankFactor);
    setState(3733);
    dynamic_cast<CsKFLDContext *>(_localctx)->operation = match(RpgParser::OP_KFLD);
    setState(3734);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsLEAVEContext ------------------------------------------------------------------

RpgParser::CsLEAVEContext::CsLEAVEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsLEAVEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsLEAVEContext::OP_LEAVE() {
  return getToken(RpgParser::OP_LEAVE, 0);
}


size_t RpgParser::CsLEAVEContext::getRuleIndex() const {
  return RpgParser::RuleCsLEAVE;
}

void RpgParser::CsLEAVEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsLEAVE(this);
}

void RpgParser::CsLEAVEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsLEAVE(this);
}


antlrcpp::Any RpgParser::CsLEAVEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsLEAVE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsLEAVEContext* RpgParser::csLEAVE() {
  CsLEAVEContext *_localctx = _tracker.createInstance<CsLEAVEContext>(_ctx, getState());
  enterRule(_localctx, 574, RpgParser::RuleCsLEAVE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3736);
    dynamic_cast<CsLEAVEContext *>(_localctx)->operation = match(RpgParser::OP_LEAVE);
    setState(3737);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsLEAVESRContext ------------------------------------------------------------------

RpgParser::CsLEAVESRContext::CsLEAVESRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsLEAVESRContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsLEAVESRContext::OP_LEAVESR() {
  return getToken(RpgParser::OP_LEAVESR, 0);
}


size_t RpgParser::CsLEAVESRContext::getRuleIndex() const {
  return RpgParser::RuleCsLEAVESR;
}

void RpgParser::CsLEAVESRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsLEAVESR(this);
}

void RpgParser::CsLEAVESRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsLEAVESR(this);
}


antlrcpp::Any RpgParser::CsLEAVESRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsLEAVESR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsLEAVESRContext* RpgParser::csLEAVESR() {
  CsLEAVESRContext *_localctx = _tracker.createInstance<CsLEAVESRContext>(_ctx, getState());
  enterRule(_localctx, 576, RpgParser::RuleCsLEAVESR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3739);
    dynamic_cast<CsLEAVESRContext *>(_localctx)->operation = match(RpgParser::OP_LEAVESR);
    setState(3740);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsLOOKUPContext ------------------------------------------------------------------

RpgParser::CsLOOKUPContext::CsLOOKUPContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsLOOKUPContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsLOOKUPContext::OP_LOOKUP() {
  return getToken(RpgParser::OP_LOOKUP, 0);
}


size_t RpgParser::CsLOOKUPContext::getRuleIndex() const {
  return RpgParser::RuleCsLOOKUP;
}

void RpgParser::CsLOOKUPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsLOOKUP(this);
}

void RpgParser::CsLOOKUPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsLOOKUP(this);
}


antlrcpp::Any RpgParser::CsLOOKUPContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsLOOKUP(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsLOOKUPContext* RpgParser::csLOOKUP() {
  CsLOOKUPContext *_localctx = _tracker.createInstance<CsLOOKUPContext>(_ctx, getState());
  enterRule(_localctx, 578, RpgParser::RuleCsLOOKUP);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3742);
    dynamic_cast<CsLOOKUPContext *>(_localctx)->operation = match(RpgParser::OP_LOOKUP);
    setState(3743);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMHHZOContext ------------------------------------------------------------------

RpgParser::CsMHHZOContext::CsMHHZOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMHHZOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMHHZOContext::OP_MHHZO() {
  return getToken(RpgParser::OP_MHHZO, 0);
}


size_t RpgParser::CsMHHZOContext::getRuleIndex() const {
  return RpgParser::RuleCsMHHZO;
}

void RpgParser::CsMHHZOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMHHZO(this);
}

void RpgParser::CsMHHZOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMHHZO(this);
}


antlrcpp::Any RpgParser::CsMHHZOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMHHZO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMHHZOContext* RpgParser::csMHHZO() {
  CsMHHZOContext *_localctx = _tracker.createInstance<CsMHHZOContext>(_ctx, getState());
  enterRule(_localctx, 580, RpgParser::RuleCsMHHZO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3745);
    dynamic_cast<CsMHHZOContext *>(_localctx)->operation = match(RpgParser::OP_MHHZO);
    setState(3746);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMHLZOContext ------------------------------------------------------------------

RpgParser::CsMHLZOContext::CsMHLZOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMHLZOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMHLZOContext::OP_MHLZO() {
  return getToken(RpgParser::OP_MHLZO, 0);
}


size_t RpgParser::CsMHLZOContext::getRuleIndex() const {
  return RpgParser::RuleCsMHLZO;
}

void RpgParser::CsMHLZOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMHLZO(this);
}

void RpgParser::CsMHLZOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMHLZO(this);
}


antlrcpp::Any RpgParser::CsMHLZOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMHLZO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMHLZOContext* RpgParser::csMHLZO() {
  CsMHLZOContext *_localctx = _tracker.createInstance<CsMHLZOContext>(_ctx, getState());
  enterRule(_localctx, 582, RpgParser::RuleCsMHLZO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3748);
    dynamic_cast<CsMHLZOContext *>(_localctx)->operation = match(RpgParser::OP_MHLZO);
    setState(3749);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMLHZOContext ------------------------------------------------------------------

RpgParser::CsMLHZOContext::CsMLHZOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMLHZOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMLHZOContext::OP_MLHZO() {
  return getToken(RpgParser::OP_MLHZO, 0);
}


size_t RpgParser::CsMLHZOContext::getRuleIndex() const {
  return RpgParser::RuleCsMLHZO;
}

void RpgParser::CsMLHZOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMLHZO(this);
}

void RpgParser::CsMLHZOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMLHZO(this);
}


antlrcpp::Any RpgParser::CsMLHZOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMLHZO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMLHZOContext* RpgParser::csMLHZO() {
  CsMLHZOContext *_localctx = _tracker.createInstance<CsMLHZOContext>(_ctx, getState());
  enterRule(_localctx, 584, RpgParser::RuleCsMLHZO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3751);
    dynamic_cast<CsMLHZOContext *>(_localctx)->operation = match(RpgParser::OP_MLHZO);
    setState(3752);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMLLZOContext ------------------------------------------------------------------

RpgParser::CsMLLZOContext::CsMLLZOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMLLZOContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMLLZOContext::OP_MLLZO() {
  return getToken(RpgParser::OP_MLLZO, 0);
}


size_t RpgParser::CsMLLZOContext::getRuleIndex() const {
  return RpgParser::RuleCsMLLZO;
}

void RpgParser::CsMLLZOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMLLZO(this);
}

void RpgParser::CsMLLZOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMLLZO(this);
}


antlrcpp::Any RpgParser::CsMLLZOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMLLZO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMLLZOContext* RpgParser::csMLLZO() {
  CsMLLZOContext *_localctx = _tracker.createInstance<CsMLLZOContext>(_ctx, getState());
  enterRule(_localctx, 586, RpgParser::RuleCsMLLZO);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3754);
    dynamic_cast<CsMLLZOContext *>(_localctx)->operation = match(RpgParser::OP_MLLZO);
    setState(3755);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMONITORContext ------------------------------------------------------------------

RpgParser::CsMONITORContext::CsMONITORContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMONITORContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMONITORContext::OP_MONITOR() {
  return getToken(RpgParser::OP_MONITOR, 0);
}


size_t RpgParser::CsMONITORContext::getRuleIndex() const {
  return RpgParser::RuleCsMONITOR;
}

void RpgParser::CsMONITORContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMONITOR(this);
}

void RpgParser::CsMONITORContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMONITOR(this);
}


antlrcpp::Any RpgParser::CsMONITORContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMONITOR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMONITORContext* RpgParser::csMONITOR() {
  CsMONITORContext *_localctx = _tracker.createInstance<CsMONITORContext>(_ctx, getState());
  enterRule(_localctx, 588, RpgParser::RuleCsMONITOR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3757);
    dynamic_cast<CsMONITORContext *>(_localctx)->operation = match(RpgParser::OP_MONITOR);
    setState(3758);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMOVEContext ------------------------------------------------------------------

RpgParser::CsMOVEContext::CsMOVEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMOVEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMOVEContext::OP_MOVE() {
  return getToken(RpgParser::OP_MOVE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsMOVEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsMOVEContext::getRuleIndex() const {
  return RpgParser::RuleCsMOVE;
}

void RpgParser::CsMOVEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMOVE(this);
}

void RpgParser::CsMOVEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMOVE(this);
}


antlrcpp::Any RpgParser::CsMOVEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMOVE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMOVEContext* RpgParser::csMOVE() {
  CsMOVEContext *_localctx = _tracker.createInstance<CsMOVEContext>(_ctx, getState());
  enterRule(_localctx, 590, RpgParser::RuleCsMOVE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3760);
    dynamic_cast<CsMOVEContext *>(_localctx)->operation = match(RpgParser::OP_MOVE);
    setState(3762);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3761);
      dynamic_cast<CsMOVEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3764);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMOVEAContext ------------------------------------------------------------------

RpgParser::CsMOVEAContext::CsMOVEAContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMOVEAContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMOVEAContext::OP_MOVEA() {
  return getToken(RpgParser::OP_MOVEA, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsMOVEAContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsMOVEAContext::getRuleIndex() const {
  return RpgParser::RuleCsMOVEA;
}

void RpgParser::CsMOVEAContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMOVEA(this);
}

void RpgParser::CsMOVEAContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMOVEA(this);
}


antlrcpp::Any RpgParser::CsMOVEAContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMOVEA(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMOVEAContext* RpgParser::csMOVEA() {
  CsMOVEAContext *_localctx = _tracker.createInstance<CsMOVEAContext>(_ctx, getState());
  enterRule(_localctx, 592, RpgParser::RuleCsMOVEA);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3766);
    dynamic_cast<CsMOVEAContext *>(_localctx)->operation = match(RpgParser::OP_MOVEA);
    setState(3768);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3767);
      dynamic_cast<CsMOVEAContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3770);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMOVELContext ------------------------------------------------------------------

RpgParser::CsMOVELContext::CsMOVELContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMOVELContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMOVELContext::OP_MOVEL() {
  return getToken(RpgParser::OP_MOVEL, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsMOVELContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsMOVELContext::getRuleIndex() const {
  return RpgParser::RuleCsMOVEL;
}

void RpgParser::CsMOVELContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMOVEL(this);
}

void RpgParser::CsMOVELContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMOVEL(this);
}


antlrcpp::Any RpgParser::CsMOVELContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMOVEL(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMOVELContext* RpgParser::csMOVEL() {
  CsMOVELContext *_localctx = _tracker.createInstance<CsMOVELContext>(_ctx, getState());
  enterRule(_localctx, 594, RpgParser::RuleCsMOVEL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3772);
    dynamic_cast<CsMOVELContext *>(_localctx)->operation = match(RpgParser::OP_MOVEL);
    setState(3774);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3773);
      dynamic_cast<CsMOVELContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3776);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMULTContext ------------------------------------------------------------------

RpgParser::CsMULTContext::CsMULTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMULTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMULTContext::OP_MULT() {
  return getToken(RpgParser::OP_MULT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsMULTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsMULTContext::getRuleIndex() const {
  return RpgParser::RuleCsMULT;
}

void RpgParser::CsMULTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMULT(this);
}

void RpgParser::CsMULTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMULT(this);
}


antlrcpp::Any RpgParser::CsMULTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMULT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMULTContext* RpgParser::csMULT() {
  CsMULTContext *_localctx = _tracker.createInstance<CsMULTContext>(_ctx, getState());
  enterRule(_localctx, 596, RpgParser::RuleCsMULT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3778);
    dynamic_cast<CsMULTContext *>(_localctx)->operation = match(RpgParser::OP_MULT);
    setState(3780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3779);
      dynamic_cast<CsMULTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3782);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsMVRContext ------------------------------------------------------------------

RpgParser::CsMVRContext::CsMVRContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsMVRContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

std::vector<tree::TerminalNode *> RpgParser::CsMVRContext::BlankIndicator() {
  return getTokens(RpgParser::BlankIndicator);
}

tree::TerminalNode* RpgParser::CsMVRContext::BlankIndicator(size_t i) {
  return getToken(RpgParser::BlankIndicator, i);
}

tree::TerminalNode* RpgParser::CsMVRContext::BlankFlag() {
  return getToken(RpgParser::BlankFlag, 0);
}

tree::TerminalNode* RpgParser::CsMVRContext::CS_BlankFactor() {
  return getToken(RpgParser::CS_BlankFactor, 0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsMVRContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsMVRContext::OP_MVR() {
  return getToken(RpgParser::OP_MVR, 0);
}


size_t RpgParser::CsMVRContext::getRuleIndex() const {
  return RpgParser::RuleCsMVR;
}

void RpgParser::CsMVRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsMVR(this);
}

void RpgParser::CsMVRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsMVR(this);
}


antlrcpp::Any RpgParser::CsMVRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsMVR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsMVRContext* RpgParser::csMVR() {
  CsMVRContext *_localctx = _tracker.createInstance<CsMVRContext>(_ctx, getState());
  enterRule(_localctx, 598, RpgParser::RuleCsMVR);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3784);
    match(RpgParser::CS_FIXED);
    setState(3785);
    match(RpgParser::BlankIndicator);
    setState(3786);
    match(RpgParser::BlankFlag);
    setState(3787);
    match(RpgParser::BlankIndicator);
    setState(3788);
    match(RpgParser::CS_BlankFactor);
    setState(3789);
    dynamic_cast<CsMVRContext *>(_localctx)->operation = match(RpgParser::OP_MVR);
    setState(3790);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsNEXTContext ------------------------------------------------------------------

RpgParser::CsNEXTContext::CsNEXTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsNEXTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsNEXTContext::OP_NEXT() {
  return getToken(RpgParser::OP_NEXT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsNEXTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsNEXTContext::getRuleIndex() const {
  return RpgParser::RuleCsNEXT;
}

void RpgParser::CsNEXTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsNEXT(this);
}

void RpgParser::CsNEXTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsNEXT(this);
}


antlrcpp::Any RpgParser::CsNEXTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsNEXT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsNEXTContext* RpgParser::csNEXT() {
  CsNEXTContext *_localctx = _tracker.createInstance<CsNEXTContext>(_ctx, getState());
  enterRule(_localctx, 600, RpgParser::RuleCsNEXT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3792);
    dynamic_cast<CsNEXTContext *>(_localctx)->operation = match(RpgParser::OP_NEXT);
    setState(3794);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3793);
      dynamic_cast<CsNEXTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3796);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsOCCURContext ------------------------------------------------------------------

RpgParser::CsOCCURContext::CsOCCURContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsOCCURContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsOCCURContext::OP_OCCUR() {
  return getToken(RpgParser::OP_OCCUR, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsOCCURContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsOCCURContext::getRuleIndex() const {
  return RpgParser::RuleCsOCCUR;
}

void RpgParser::CsOCCURContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsOCCUR(this);
}

void RpgParser::CsOCCURContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsOCCUR(this);
}


antlrcpp::Any RpgParser::CsOCCURContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsOCCUR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsOCCURContext* RpgParser::csOCCUR() {
  CsOCCURContext *_localctx = _tracker.createInstance<CsOCCURContext>(_ctx, getState());
  enterRule(_localctx, 602, RpgParser::RuleCsOCCUR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3798);
    dynamic_cast<CsOCCURContext *>(_localctx)->operation = match(RpgParser::OP_OCCUR);
    setState(3800);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3799);
      dynamic_cast<CsOCCURContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3802);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsON_ERRORContext ------------------------------------------------------------------

RpgParser::CsON_ERRORContext::CsON_ERRORContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsON_ERRORContext::OP_ON_ERROR() {
  return getToken(RpgParser::OP_ON_ERROR, 0);
}

tree::TerminalNode* RpgParser::CsON_ERRORContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsON_ERRORContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

std::vector<RpgParser::OnErrorCodeContext *> RpgParser::CsON_ERRORContext::onErrorCode() {
  return getRuleContexts<RpgParser::OnErrorCodeContext>();
}

RpgParser::OnErrorCodeContext* RpgParser::CsON_ERRORContext::onErrorCode(size_t i) {
  return getRuleContext<RpgParser::OnErrorCodeContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::CsON_ERRORContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::CsON_ERRORContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::CsON_ERRORContext::getRuleIndex() const {
  return RpgParser::RuleCsON_ERROR;
}

void RpgParser::CsON_ERRORContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsON_ERROR(this);
}

void RpgParser::CsON_ERRORContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsON_ERROR(this);
}


antlrcpp::Any RpgParser::CsON_ERRORContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsON_ERROR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsON_ERRORContext* RpgParser::csON_ERROR() {
  CsON_ERRORContext *_localctx = _tracker.createInstance<CsON_ERRORContext>(_ctx, getState());
  enterRule(_localctx, 604, RpgParser::RuleCsON_ERROR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3804);
    dynamic_cast<CsON_ERRORContext *>(_localctx)->operation = match(RpgParser::OP_ON_ERROR);
    setState(3813);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::NUMBER)
      | (1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(3805);
      onErrorCode();
      setState(3810);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == RpgParser::COLON) {
        setState(3806);
        match(RpgParser::COLON);
        setState(3807);
        onErrorCode();
        setState(3812);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3815);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnErrorCodeContext ------------------------------------------------------------------

RpgParser::OnErrorCodeContext::OnErrorCodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::IdentifierContext* RpgParser::OnErrorCodeContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::NumberContext* RpgParser::OnErrorCodeContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}


size_t RpgParser::OnErrorCodeContext::getRuleIndex() const {
  return RpgParser::RuleOnErrorCode;
}

void RpgParser::OnErrorCodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnErrorCode(this);
}

void RpgParser::OnErrorCodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnErrorCode(this);
}


antlrcpp::Any RpgParser::OnErrorCodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOnErrorCode(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OnErrorCodeContext* RpgParser::onErrorCode() {
  OnErrorCodeContext *_localctx = _tracker.createInstance<OnErrorCodeContext>(_ctx, getState());
  enterRule(_localctx, 606, RpgParser::RuleOnErrorCode);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3819);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO: {
        setState(3817);
        identifier();
        break;
      }

      case RpgParser::NUMBER:
      case RpgParser::MINUS: {
        setState(3818);
        number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsOPENContext ------------------------------------------------------------------

RpgParser::CsOPENContext::CsOPENContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsOPENContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsOPENContext::OP_OPEN() {
  return getToken(RpgParser::OP_OPEN, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsOPENContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsOPENContext::getRuleIndex() const {
  return RpgParser::RuleCsOPEN;
}

void RpgParser::CsOPENContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsOPEN(this);
}

void RpgParser::CsOPENContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsOPEN(this);
}


antlrcpp::Any RpgParser::CsOPENContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsOPEN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsOPENContext* RpgParser::csOPEN() {
  CsOPENContext *_localctx = _tracker.createInstance<CsOPENContext>(_ctx, getState());
  enterRule(_localctx, 608, RpgParser::RuleCsOPEN);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3821);
    dynamic_cast<CsOPENContext *>(_localctx)->operation = match(RpgParser::OP_OPEN);
    setState(3823);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3822);
      dynamic_cast<CsOPENContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3825);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsOREQContext ------------------------------------------------------------------

RpgParser::CsOREQContext::CsOREQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsOREQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsOREQContext::OP_OREQ() {
  return getToken(RpgParser::OP_OREQ, 0);
}


size_t RpgParser::CsOREQContext::getRuleIndex() const {
  return RpgParser::RuleCsOREQ;
}

void RpgParser::CsOREQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsOREQ(this);
}

void RpgParser::CsOREQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsOREQ(this);
}


antlrcpp::Any RpgParser::CsOREQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsOREQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsOREQContext* RpgParser::csOREQ() {
  CsOREQContext *_localctx = _tracker.createInstance<CsOREQContext>(_ctx, getState());
  enterRule(_localctx, 610, RpgParser::RuleCsOREQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3827);
    dynamic_cast<CsOREQContext *>(_localctx)->operation = match(RpgParser::OP_OREQ);
    setState(3828);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsORNEContext ------------------------------------------------------------------

RpgParser::CsORNEContext::CsORNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsORNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsORNEContext::OP_ORNE() {
  return getToken(RpgParser::OP_ORNE, 0);
}


size_t RpgParser::CsORNEContext::getRuleIndex() const {
  return RpgParser::RuleCsORNE;
}

void RpgParser::CsORNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsORNE(this);
}

void RpgParser::CsORNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsORNE(this);
}


antlrcpp::Any RpgParser::CsORNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsORNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsORNEContext* RpgParser::csORNE() {
  CsORNEContext *_localctx = _tracker.createInstance<CsORNEContext>(_ctx, getState());
  enterRule(_localctx, 612, RpgParser::RuleCsORNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3830);
    dynamic_cast<CsORNEContext *>(_localctx)->operation = match(RpgParser::OP_ORNE);
    setState(3831);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsORLEContext ------------------------------------------------------------------

RpgParser::CsORLEContext::CsORLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsORLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsORLEContext::OP_ORLE() {
  return getToken(RpgParser::OP_ORLE, 0);
}


size_t RpgParser::CsORLEContext::getRuleIndex() const {
  return RpgParser::RuleCsORLE;
}

void RpgParser::CsORLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsORLE(this);
}

void RpgParser::CsORLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsORLE(this);
}


antlrcpp::Any RpgParser::CsORLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsORLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsORLEContext* RpgParser::csORLE() {
  CsORLEContext *_localctx = _tracker.createInstance<CsORLEContext>(_ctx, getState());
  enterRule(_localctx, 614, RpgParser::RuleCsORLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3833);
    dynamic_cast<CsORLEContext *>(_localctx)->operation = match(RpgParser::OP_ORLE);
    setState(3834);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsORLTContext ------------------------------------------------------------------

RpgParser::CsORLTContext::CsORLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsORLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsORLTContext::OP_ORLT() {
  return getToken(RpgParser::OP_ORLT, 0);
}


size_t RpgParser::CsORLTContext::getRuleIndex() const {
  return RpgParser::RuleCsORLT;
}

void RpgParser::CsORLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsORLT(this);
}

void RpgParser::CsORLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsORLT(this);
}


antlrcpp::Any RpgParser::CsORLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsORLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsORLTContext* RpgParser::csORLT() {
  CsORLTContext *_localctx = _tracker.createInstance<CsORLTContext>(_ctx, getState());
  enterRule(_localctx, 616, RpgParser::RuleCsORLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3836);
    dynamic_cast<CsORLTContext *>(_localctx)->operation = match(RpgParser::OP_ORLT);
    setState(3837);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsORGEContext ------------------------------------------------------------------

RpgParser::CsORGEContext::CsORGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsORGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsORGEContext::OP_ORGE() {
  return getToken(RpgParser::OP_ORGE, 0);
}


size_t RpgParser::CsORGEContext::getRuleIndex() const {
  return RpgParser::RuleCsORGE;
}

void RpgParser::CsORGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsORGE(this);
}

void RpgParser::CsORGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsORGE(this);
}


antlrcpp::Any RpgParser::CsORGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsORGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsORGEContext* RpgParser::csORGE() {
  CsORGEContext *_localctx = _tracker.createInstance<CsORGEContext>(_ctx, getState());
  enterRule(_localctx, 618, RpgParser::RuleCsORGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3839);
    dynamic_cast<CsORGEContext *>(_localctx)->operation = match(RpgParser::OP_ORGE);
    setState(3840);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsORGTContext ------------------------------------------------------------------

RpgParser::CsORGTContext::CsORGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsORGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsORGTContext::OP_ORGT() {
  return getToken(RpgParser::OP_ORGT, 0);
}


size_t RpgParser::CsORGTContext::getRuleIndex() const {
  return RpgParser::RuleCsORGT;
}

void RpgParser::CsORGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsORGT(this);
}

void RpgParser::CsORGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsORGT(this);
}


antlrcpp::Any RpgParser::CsORGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsORGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsORGTContext* RpgParser::csORGT() {
  CsORGTContext *_localctx = _tracker.createInstance<CsORGTContext>(_ctx, getState());
  enterRule(_localctx, 620, RpgParser::RuleCsORGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3842);
    dynamic_cast<CsORGTContext *>(_localctx)->operation = match(RpgParser::OP_ORGT);
    setState(3843);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsOTHERContext ------------------------------------------------------------------

RpgParser::CsOTHERContext::CsOTHERContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsOTHERContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsOTHERContext::OP_OTHER() {
  return getToken(RpgParser::OP_OTHER, 0);
}


size_t RpgParser::CsOTHERContext::getRuleIndex() const {
  return RpgParser::RuleCsOTHER;
}

void RpgParser::CsOTHERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsOTHER(this);
}

void RpgParser::CsOTHERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsOTHER(this);
}


antlrcpp::Any RpgParser::CsOTHERContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsOTHER(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsOTHERContext* RpgParser::csOTHER() {
  CsOTHERContext *_localctx = _tracker.createInstance<CsOTHERContext>(_ctx, getState());
  enterRule(_localctx, 622, RpgParser::RuleCsOTHER);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3845);
    dynamic_cast<CsOTHERContext *>(_localctx)->operation = match(RpgParser::OP_OTHER);
    setState(3846);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsOUTContext ------------------------------------------------------------------

RpgParser::CsOUTContext::CsOUTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsOUTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsOUTContext::OP_OUT() {
  return getToken(RpgParser::OP_OUT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsOUTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsOUTContext::getRuleIndex() const {
  return RpgParser::RuleCsOUT;
}

void RpgParser::CsOUTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsOUT(this);
}

void RpgParser::CsOUTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsOUT(this);
}


antlrcpp::Any RpgParser::CsOUTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsOUT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsOUTContext* RpgParser::csOUT() {
  CsOUTContext *_localctx = _tracker.createInstance<CsOUTContext>(_ctx, getState());
  enterRule(_localctx, 624, RpgParser::RuleCsOUT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3848);
    dynamic_cast<CsOUTContext *>(_localctx)->operation = match(RpgParser::OP_OUT);
    setState(3850);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3849);
      dynamic_cast<CsOUTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3852);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsPARMContext ------------------------------------------------------------------

RpgParser::CsPARMContext::CsPARMContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsPARMContext::CS_FIXED() {
  return getToken(RpgParser::CS_FIXED, 0);
}

std::vector<tree::TerminalNode *> RpgParser::CsPARMContext::BlankIndicator() {
  return getTokens(RpgParser::BlankIndicator);
}

tree::TerminalNode* RpgParser::CsPARMContext::BlankIndicator(size_t i) {
  return getToken(RpgParser::BlankIndicator, i);
}

tree::TerminalNode* RpgParser::CsPARMContext::BlankFlag() {
  return getToken(RpgParser::BlankFlag, 0);
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsPARMContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

RpgParser::FactorContext* RpgParser::CsPARMContext::factor() {
  return getRuleContext<RpgParser::FactorContext>(0);
}

tree::TerminalNode* RpgParser::CsPARMContext::OP_PARM() {
  return getToken(RpgParser::OP_PARM, 0);
}


size_t RpgParser::CsPARMContext::getRuleIndex() const {
  return RpgParser::RuleCsPARM;
}

void RpgParser::CsPARMContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsPARM(this);
}

void RpgParser::CsPARMContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsPARM(this);
}


antlrcpp::Any RpgParser::CsPARMContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsPARM(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsPARMContext* RpgParser::csPARM() {
  CsPARMContext *_localctx = _tracker.createInstance<CsPARMContext>(_ctx, getState());
  enterRule(_localctx, 626, RpgParser::RuleCsPARM);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3854);
    match(RpgParser::CS_FIXED);
    setState(3855);
    match(RpgParser::BlankIndicator);
    setState(3856);
    match(RpgParser::BlankFlag);
    setState(3857);
    match(RpgParser::BlankIndicator);
    setState(3858);
    dynamic_cast<CsPARMContext *>(_localctx)->factor1 = factor();
    setState(3859);
    dynamic_cast<CsPARMContext *>(_localctx)->operation = match(RpgParser::OP_PARM);
    setState(3860);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsPLISTContext ------------------------------------------------------------------

RpgParser::CsPLISTContext::CsPLISTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsPLISTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsPLISTContext::OP_PLIST() {
  return getToken(RpgParser::OP_PLIST, 0);
}

std::vector<RpgParser::CsPARMContext *> RpgParser::CsPLISTContext::csPARM() {
  return getRuleContexts<RpgParser::CsPARMContext>();
}

RpgParser::CsPARMContext* RpgParser::CsPLISTContext::csPARM(size_t i) {
  return getRuleContext<RpgParser::CsPARMContext>(i);
}


size_t RpgParser::CsPLISTContext::getRuleIndex() const {
  return RpgParser::RuleCsPLIST;
}

void RpgParser::CsPLISTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsPLIST(this);
}

void RpgParser::CsPLISTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsPLIST(this);
}


antlrcpp::Any RpgParser::CsPLISTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsPLIST(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsPLISTContext* RpgParser::csPLIST() {
  CsPLISTContext *_localctx = _tracker.createInstance<CsPLISTContext>(_ctx, getState());
  enterRule(_localctx, 628, RpgParser::RuleCsPLIST);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3862);
    dynamic_cast<CsPLISTContext *>(_localctx)->operation = match(RpgParser::OP_PLIST);
    setState(3863);
    cspec_fixed_standard_parts();
    setState(3867);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3864);
        csPARM(); 
      }
      setState(3869);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsPOSTContext ------------------------------------------------------------------

RpgParser::CsPOSTContext::CsPOSTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsPOSTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsPOSTContext::OP_POST() {
  return getToken(RpgParser::OP_POST, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsPOSTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsPOSTContext::getRuleIndex() const {
  return RpgParser::RuleCsPOST;
}

void RpgParser::CsPOSTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsPOST(this);
}

void RpgParser::CsPOSTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsPOST(this);
}


antlrcpp::Any RpgParser::CsPOSTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsPOST(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsPOSTContext* RpgParser::csPOST() {
  CsPOSTContext *_localctx = _tracker.createInstance<CsPOSTContext>(_ctx, getState());
  enterRule(_localctx, 630, RpgParser::RuleCsPOST);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3870);
    dynamic_cast<CsPOSTContext *>(_localctx)->operation = match(RpgParser::OP_POST);
    setState(3872);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3871);
      dynamic_cast<CsPOSTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3874);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsREADContext ------------------------------------------------------------------

RpgParser::CsREADContext::CsREADContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsREADContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsREADContext::OP_READ() {
  return getToken(RpgParser::OP_READ, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsREADContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsREADContext::getRuleIndex() const {
  return RpgParser::RuleCsREAD;
}

void RpgParser::CsREADContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREAD(this);
}

void RpgParser::CsREADContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREAD(this);
}


antlrcpp::Any RpgParser::CsREADContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREAD(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsREADContext* RpgParser::csREAD() {
  CsREADContext *_localctx = _tracker.createInstance<CsREADContext>(_ctx, getState());
  enterRule(_localctx, 632, RpgParser::RuleCsREAD);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3876);
    dynamic_cast<CsREADContext *>(_localctx)->operation = match(RpgParser::OP_READ);
    setState(3878);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3877);
      dynamic_cast<CsREADContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3880);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsREADCContext ------------------------------------------------------------------

RpgParser::CsREADCContext::CsREADCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsREADCContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsREADCContext::OP_READC() {
  return getToken(RpgParser::OP_READC, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsREADCContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsREADCContext::getRuleIndex() const {
  return RpgParser::RuleCsREADC;
}

void RpgParser::CsREADCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREADC(this);
}

void RpgParser::CsREADCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREADC(this);
}


antlrcpp::Any RpgParser::CsREADCContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREADC(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsREADCContext* RpgParser::csREADC() {
  CsREADCContext *_localctx = _tracker.createInstance<CsREADCContext>(_ctx, getState());
  enterRule(_localctx, 634, RpgParser::RuleCsREADC);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3882);
    dynamic_cast<CsREADCContext *>(_localctx)->operation = match(RpgParser::OP_READC);
    setState(3884);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3883);
      dynamic_cast<CsREADCContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3886);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsREADEContext ------------------------------------------------------------------

RpgParser::CsREADEContext::CsREADEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsREADEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsREADEContext::OP_READE() {
  return getToken(RpgParser::OP_READE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsREADEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsREADEContext::getRuleIndex() const {
  return RpgParser::RuleCsREADE;
}

void RpgParser::CsREADEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREADE(this);
}

void RpgParser::CsREADEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREADE(this);
}


antlrcpp::Any RpgParser::CsREADEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREADE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsREADEContext* RpgParser::csREADE() {
  CsREADEContext *_localctx = _tracker.createInstance<CsREADEContext>(_ctx, getState());
  enterRule(_localctx, 636, RpgParser::RuleCsREADE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3888);
    dynamic_cast<CsREADEContext *>(_localctx)->operation = match(RpgParser::OP_READE);
    setState(3890);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3889);
      dynamic_cast<CsREADEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3892);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsREADPContext ------------------------------------------------------------------

RpgParser::CsREADPContext::CsREADPContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsREADPContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsREADPContext::OP_READP() {
  return getToken(RpgParser::OP_READP, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsREADPContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsREADPContext::getRuleIndex() const {
  return RpgParser::RuleCsREADP;
}

void RpgParser::CsREADPContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREADP(this);
}

void RpgParser::CsREADPContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREADP(this);
}


antlrcpp::Any RpgParser::CsREADPContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREADP(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsREADPContext* RpgParser::csREADP() {
  CsREADPContext *_localctx = _tracker.createInstance<CsREADPContext>(_ctx, getState());
  enterRule(_localctx, 638, RpgParser::RuleCsREADP);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3894);
    dynamic_cast<CsREADPContext *>(_localctx)->operation = match(RpgParser::OP_READP);
    setState(3896);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3895);
      dynamic_cast<CsREADPContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3898);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsREADPEContext ------------------------------------------------------------------

RpgParser::CsREADPEContext::CsREADPEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsREADPEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsREADPEContext::OP_READPE() {
  return getToken(RpgParser::OP_READPE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsREADPEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsREADPEContext::getRuleIndex() const {
  return RpgParser::RuleCsREADPE;
}

void RpgParser::CsREADPEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREADPE(this);
}

void RpgParser::CsREADPEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREADPE(this);
}


antlrcpp::Any RpgParser::CsREADPEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREADPE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsREADPEContext* RpgParser::csREADPE() {
  CsREADPEContext *_localctx = _tracker.createInstance<CsREADPEContext>(_ctx, getState());
  enterRule(_localctx, 640, RpgParser::RuleCsREADPE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3900);
    dynamic_cast<CsREADPEContext *>(_localctx)->operation = match(RpgParser::OP_READPE);
    setState(3902);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3901);
      dynamic_cast<CsREADPEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3904);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsREALLOCContext ------------------------------------------------------------------

RpgParser::CsREALLOCContext::CsREALLOCContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsREALLOCContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsREALLOCContext::OP_REALLOC() {
  return getToken(RpgParser::OP_REALLOC, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsREALLOCContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsREALLOCContext::getRuleIndex() const {
  return RpgParser::RuleCsREALLOC;
}

void RpgParser::CsREALLOCContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREALLOC(this);
}

void RpgParser::CsREALLOCContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREALLOC(this);
}


antlrcpp::Any RpgParser::CsREALLOCContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREALLOC(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsREALLOCContext* RpgParser::csREALLOC() {
  CsREALLOCContext *_localctx = _tracker.createInstance<CsREALLOCContext>(_ctx, getState());
  enterRule(_localctx, 642, RpgParser::RuleCsREALLOC);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3906);
    dynamic_cast<CsREALLOCContext *>(_localctx)->operation = match(RpgParser::OP_REALLOC);
    setState(3908);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3907);
      dynamic_cast<CsREALLOCContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3910);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsRELContext ------------------------------------------------------------------

RpgParser::CsRELContext::CsRELContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsRELContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsRELContext::OP_REL() {
  return getToken(RpgParser::OP_REL, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsRELContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsRELContext::getRuleIndex() const {
  return RpgParser::RuleCsREL;
}

void RpgParser::CsRELContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsREL(this);
}

void RpgParser::CsRELContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsREL(this);
}


antlrcpp::Any RpgParser::CsRELContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsREL(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsRELContext* RpgParser::csREL() {
  CsRELContext *_localctx = _tracker.createInstance<CsRELContext>(_ctx, getState());
  enterRule(_localctx, 644, RpgParser::RuleCsREL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3912);
    dynamic_cast<CsRELContext *>(_localctx)->operation = match(RpgParser::OP_REL);
    setState(3914);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3913);
      dynamic_cast<CsRELContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3916);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsRESETContext ------------------------------------------------------------------

RpgParser::CsRESETContext::CsRESETContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsRESETContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsRESETContext::OP_RESET() {
  return getToken(RpgParser::OP_RESET, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsRESETContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsRESETContext::getRuleIndex() const {
  return RpgParser::RuleCsRESET;
}

void RpgParser::CsRESETContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsRESET(this);
}

void RpgParser::CsRESETContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsRESET(this);
}


antlrcpp::Any RpgParser::CsRESETContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsRESET(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsRESETContext* RpgParser::csRESET() {
  CsRESETContext *_localctx = _tracker.createInstance<CsRESETContext>(_ctx, getState());
  enterRule(_localctx, 646, RpgParser::RuleCsRESET);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3918);
    dynamic_cast<CsRESETContext *>(_localctx)->operation = match(RpgParser::OP_RESET);
    setState(3920);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3919);
      dynamic_cast<CsRESETContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3922);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsRETURNContext ------------------------------------------------------------------

RpgParser::CsRETURNContext::CsRETURNContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsRETURNContext::OP_RETURN() {
  return getToken(RpgParser::OP_RETURN, 0);
}

tree::TerminalNode* RpgParser::CsRETURNContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsRETURNContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsRETURNContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::C_freeContext* RpgParser::CsRETURNContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}


size_t RpgParser::CsRETURNContext::getRuleIndex() const {
  return RpgParser::RuleCsRETURN;
}

void RpgParser::CsRETURNContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsRETURN(this);
}

void RpgParser::CsRETURNContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsRETURN(this);
}


antlrcpp::Any RpgParser::CsRETURNContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsRETURN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsRETURNContext* RpgParser::csRETURN() {
  CsRETURNContext *_localctx = _tracker.createInstance<CsRETURNContext>(_ctx, getState());
  enterRule(_localctx, 648, RpgParser::RuleCsRETURN);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3924);
    dynamic_cast<CsRETURNContext *>(_localctx)->operation = match(RpgParser::OP_RETURN);
    setState(3926);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
    case 1: {
      setState(3925);
      dynamic_cast<CsRETURNContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3929);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::EXEC_SQL - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::PLUS - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(3928);
      dynamic_cast<CsRETURNContext *>(_localctx)->fixedexpression = c_free();
    }
    setState(3931);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsROLBKContext ------------------------------------------------------------------

RpgParser::CsROLBKContext::CsROLBKContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsROLBKContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsROLBKContext::OP_ROLBK() {
  return getToken(RpgParser::OP_ROLBK, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsROLBKContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsROLBKContext::getRuleIndex() const {
  return RpgParser::RuleCsROLBK;
}

void RpgParser::CsROLBKContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsROLBK(this);
}

void RpgParser::CsROLBKContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsROLBK(this);
}


antlrcpp::Any RpgParser::CsROLBKContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsROLBK(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsROLBKContext* RpgParser::csROLBK() {
  CsROLBKContext *_localctx = _tracker.createInstance<CsROLBKContext>(_ctx, getState());
  enterRule(_localctx, 650, RpgParser::RuleCsROLBK);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3933);
    dynamic_cast<CsROLBKContext *>(_localctx)->operation = match(RpgParser::OP_ROLBK);
    setState(3935);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3934);
      dynamic_cast<CsROLBKContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3937);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSCANContext ------------------------------------------------------------------

RpgParser::CsSCANContext::CsSCANContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSCANContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSCANContext::OP_SCAN() {
  return getToken(RpgParser::OP_SCAN, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSCANContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSCANContext::getRuleIndex() const {
  return RpgParser::RuleCsSCAN;
}

void RpgParser::CsSCANContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSCAN(this);
}

void RpgParser::CsSCANContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSCAN(this);
}


antlrcpp::Any RpgParser::CsSCANContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSCAN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSCANContext* RpgParser::csSCAN() {
  CsSCANContext *_localctx = _tracker.createInstance<CsSCANContext>(_ctx, getState());
  enterRule(_localctx, 652, RpgParser::RuleCsSCAN);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3939);
    dynamic_cast<CsSCANContext *>(_localctx)->operation = match(RpgParser::OP_SCAN);
    setState(3941);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3940);
      dynamic_cast<CsSCANContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3943);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSELECTContext ------------------------------------------------------------------

RpgParser::CsSELECTContext::CsSELECTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSELECTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSELECTContext::OP_SELECT() {
  return getToken(RpgParser::OP_SELECT, 0);
}


size_t RpgParser::CsSELECTContext::getRuleIndex() const {
  return RpgParser::RuleCsSELECT;
}

void RpgParser::CsSELECTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSELECT(this);
}

void RpgParser::CsSELECTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSELECT(this);
}


antlrcpp::Any RpgParser::CsSELECTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSELECT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSELECTContext* RpgParser::csSELECT() {
  CsSELECTContext *_localctx = _tracker.createInstance<CsSELECTContext>(_ctx, getState());
  enterRule(_localctx, 654, RpgParser::RuleCsSELECT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3945);
    dynamic_cast<CsSELECTContext *>(_localctx)->operation = match(RpgParser::OP_SELECT);
    setState(3946);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSETGTContext ------------------------------------------------------------------

RpgParser::CsSETGTContext::CsSETGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSETGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSETGTContext::OP_SETGT() {
  return getToken(RpgParser::OP_SETGT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSETGTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSETGTContext::getRuleIndex() const {
  return RpgParser::RuleCsSETGT;
}

void RpgParser::CsSETGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSETGT(this);
}

void RpgParser::CsSETGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSETGT(this);
}


antlrcpp::Any RpgParser::CsSETGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSETGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSETGTContext* RpgParser::csSETGT() {
  CsSETGTContext *_localctx = _tracker.createInstance<CsSETGTContext>(_ctx, getState());
  enterRule(_localctx, 656, RpgParser::RuleCsSETGT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3948);
    dynamic_cast<CsSETGTContext *>(_localctx)->operation = match(RpgParser::OP_SETGT);
    setState(3950);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3949);
      dynamic_cast<CsSETGTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3952);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSETLLContext ------------------------------------------------------------------

RpgParser::CsSETLLContext::CsSETLLContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSETLLContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSETLLContext::OP_SETLL() {
  return getToken(RpgParser::OP_SETLL, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSETLLContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSETLLContext::getRuleIndex() const {
  return RpgParser::RuleCsSETLL;
}

void RpgParser::CsSETLLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSETLL(this);
}

void RpgParser::CsSETLLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSETLL(this);
}


antlrcpp::Any RpgParser::CsSETLLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSETLL(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSETLLContext* RpgParser::csSETLL() {
  CsSETLLContext *_localctx = _tracker.createInstance<CsSETLLContext>(_ctx, getState());
  enterRule(_localctx, 658, RpgParser::RuleCsSETLL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3954);
    dynamic_cast<CsSETLLContext *>(_localctx)->operation = match(RpgParser::OP_SETLL);
    setState(3956);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3955);
      dynamic_cast<CsSETLLContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3958);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSETOFFContext ------------------------------------------------------------------

RpgParser::CsSETOFFContext::CsSETOFFContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSETOFFContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSETOFFContext::OP_SETOFF() {
  return getToken(RpgParser::OP_SETOFF, 0);
}


size_t RpgParser::CsSETOFFContext::getRuleIndex() const {
  return RpgParser::RuleCsSETOFF;
}

void RpgParser::CsSETOFFContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSETOFF(this);
}

void RpgParser::CsSETOFFContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSETOFF(this);
}


antlrcpp::Any RpgParser::CsSETOFFContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSETOFF(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSETOFFContext* RpgParser::csSETOFF() {
  CsSETOFFContext *_localctx = _tracker.createInstance<CsSETOFFContext>(_ctx, getState());
  enterRule(_localctx, 660, RpgParser::RuleCsSETOFF);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3960);
    dynamic_cast<CsSETOFFContext *>(_localctx)->operation = match(RpgParser::OP_SETOFF);
    setState(3961);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSETONContext ------------------------------------------------------------------

RpgParser::CsSETONContext::CsSETONContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSETONContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSETONContext::OP_SETON() {
  return getToken(RpgParser::OP_SETON, 0);
}


size_t RpgParser::CsSETONContext::getRuleIndex() const {
  return RpgParser::RuleCsSETON;
}

void RpgParser::CsSETONContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSETON(this);
}

void RpgParser::CsSETONContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSETON(this);
}


antlrcpp::Any RpgParser::CsSETONContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSETON(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSETONContext* RpgParser::csSETON() {
  CsSETONContext *_localctx = _tracker.createInstance<CsSETONContext>(_ctx, getState());
  enterRule(_localctx, 662, RpgParser::RuleCsSETON);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3963);
    dynamic_cast<CsSETONContext *>(_localctx)->operation = match(RpgParser::OP_SETON);
    setState(3964);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSHTDNContext ------------------------------------------------------------------

RpgParser::CsSHTDNContext::CsSHTDNContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSHTDNContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSHTDNContext::OP_SHTDN() {
  return getToken(RpgParser::OP_SHTDN, 0);
}


size_t RpgParser::CsSHTDNContext::getRuleIndex() const {
  return RpgParser::RuleCsSHTDN;
}

void RpgParser::CsSHTDNContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSHTDN(this);
}

void RpgParser::CsSHTDNContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSHTDN(this);
}


antlrcpp::Any RpgParser::CsSHTDNContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSHTDN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSHTDNContext* RpgParser::csSHTDN() {
  CsSHTDNContext *_localctx = _tracker.createInstance<CsSHTDNContext>(_ctx, getState());
  enterRule(_localctx, 664, RpgParser::RuleCsSHTDN);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3966);
    dynamic_cast<CsSHTDNContext *>(_localctx)->operation = match(RpgParser::OP_SHTDN);
    setState(3967);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSORTAContext ------------------------------------------------------------------

RpgParser::CsSORTAContext::CsSORTAContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsSORTAContext::OP_SORTA() {
  return getToken(RpgParser::OP_SORTA, 0);
}

RpgParser::C_freeContext* RpgParser::CsSORTAContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsSORTAContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsSORTAContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSORTAContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSORTAContext::getRuleIndex() const {
  return RpgParser::RuleCsSORTA;
}

void RpgParser::CsSORTAContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSORTA(this);
}

void RpgParser::CsSORTAContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSORTA(this);
}


antlrcpp::Any RpgParser::CsSORTAContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSORTA(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSORTAContext* RpgParser::csSORTA() {
  CsSORTAContext *_localctx = _tracker.createInstance<CsSORTAContext>(_ctx, getState());
  enterRule(_localctx, 666, RpgParser::RuleCsSORTA);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3969);
    dynamic_cast<CsSORTAContext *>(_localctx)->operation = match(RpgParser::OP_SORTA);
    setState(3971);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
    case 1: {
      setState(3970);
      dynamic_cast<CsSORTAContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(3973);
    dynamic_cast<CsSORTAContext *>(_localctx)->fixedexpression = c_free();
    setState(3974);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSQRTContext ------------------------------------------------------------------

RpgParser::CsSQRTContext::CsSQRTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSQRTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSQRTContext::OP_SQRT() {
  return getToken(RpgParser::OP_SQRT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSQRTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSQRTContext::getRuleIndex() const {
  return RpgParser::RuleCsSQRT;
}

void RpgParser::CsSQRTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSQRT(this);
}

void RpgParser::CsSQRTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSQRT(this);
}


antlrcpp::Any RpgParser::CsSQRTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSQRT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSQRTContext* RpgParser::csSQRT() {
  CsSQRTContext *_localctx = _tracker.createInstance<CsSQRTContext>(_ctx, getState());
  enterRule(_localctx, 668, RpgParser::RuleCsSQRT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3976);
    dynamic_cast<CsSQRTContext *>(_localctx)->operation = match(RpgParser::OP_SQRT);
    setState(3978);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3977);
      dynamic_cast<CsSQRTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3980);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSUBContext ------------------------------------------------------------------

RpgParser::CsSUBContext::CsSUBContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSUBContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSUBContext::OP_SUB() {
  return getToken(RpgParser::OP_SUB, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSUBContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSUBContext::getRuleIndex() const {
  return RpgParser::RuleCsSUB;
}

void RpgParser::CsSUBContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSUB(this);
}

void RpgParser::CsSUBContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSUB(this);
}


antlrcpp::Any RpgParser::CsSUBContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSUB(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSUBContext* RpgParser::csSUB() {
  CsSUBContext *_localctx = _tracker.createInstance<CsSUBContext>(_ctx, getState());
  enterRule(_localctx, 670, RpgParser::RuleCsSUB);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3982);
    dynamic_cast<CsSUBContext *>(_localctx)->operation = match(RpgParser::OP_SUB);
    setState(3984);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3983);
      dynamic_cast<CsSUBContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3986);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSUBDURContext ------------------------------------------------------------------

RpgParser::CsSUBDURContext::CsSUBDURContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSUBDURContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSUBDURContext::OP_SUBDUR() {
  return getToken(RpgParser::OP_SUBDUR, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSUBDURContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSUBDURContext::getRuleIndex() const {
  return RpgParser::RuleCsSUBDUR;
}

void RpgParser::CsSUBDURContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSUBDUR(this);
}

void RpgParser::CsSUBDURContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSUBDUR(this);
}


antlrcpp::Any RpgParser::CsSUBDURContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSUBDUR(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSUBDURContext* RpgParser::csSUBDUR() {
  CsSUBDURContext *_localctx = _tracker.createInstance<CsSUBDURContext>(_ctx, getState());
  enterRule(_localctx, 672, RpgParser::RuleCsSUBDUR);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3988);
    dynamic_cast<CsSUBDURContext *>(_localctx)->operation = match(RpgParser::OP_SUBDUR);
    setState(3990);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3989);
      dynamic_cast<CsSUBDURContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3992);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsSUBSTContext ------------------------------------------------------------------

RpgParser::CsSUBSTContext::CsSUBSTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsSUBSTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsSUBSTContext::OP_SUBST() {
  return getToken(RpgParser::OP_SUBST, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsSUBSTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsSUBSTContext::getRuleIndex() const {
  return RpgParser::RuleCsSUBST;
}

void RpgParser::CsSUBSTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsSUBST(this);
}

void RpgParser::CsSUBSTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsSUBST(this);
}


antlrcpp::Any RpgParser::CsSUBSTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsSUBST(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsSUBSTContext* RpgParser::csSUBST() {
  CsSUBSTContext *_localctx = _tracker.createInstance<CsSUBSTContext>(_ctx, getState());
  enterRule(_localctx, 674, RpgParser::RuleCsSUBST);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3994);
    dynamic_cast<CsSUBSTContext *>(_localctx)->operation = match(RpgParser::OP_SUBST);
    setState(3996);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(3995);
      dynamic_cast<CsSUBSTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(3998);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsTAGContext ------------------------------------------------------------------

RpgParser::CsTAGContext::CsTAGContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsTAGContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsTAGContext::OP_TAG() {
  return getToken(RpgParser::OP_TAG, 0);
}


size_t RpgParser::CsTAGContext::getRuleIndex() const {
  return RpgParser::RuleCsTAG;
}

void RpgParser::CsTAGContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsTAG(this);
}

void RpgParser::CsTAGContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsTAG(this);
}


antlrcpp::Any RpgParser::CsTAGContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsTAG(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsTAGContext* RpgParser::csTAG() {
  CsTAGContext *_localctx = _tracker.createInstance<CsTAGContext>(_ctx, getState());
  enterRule(_localctx, 676, RpgParser::RuleCsTAG);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4000);
    dynamic_cast<CsTAGContext *>(_localctx)->operation = match(RpgParser::OP_TAG);
    setState(4001);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsTESTContext ------------------------------------------------------------------

RpgParser::CsTESTContext::CsTESTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsTESTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsTESTContext::OP_TEST() {
  return getToken(RpgParser::OP_TEST, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsTESTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsTESTContext::getRuleIndex() const {
  return RpgParser::RuleCsTEST;
}

void RpgParser::CsTESTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsTEST(this);
}

void RpgParser::CsTESTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsTEST(this);
}


antlrcpp::Any RpgParser::CsTESTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsTEST(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsTESTContext* RpgParser::csTEST() {
  CsTESTContext *_localctx = _tracker.createInstance<CsTESTContext>(_ctx, getState());
  enterRule(_localctx, 678, RpgParser::RuleCsTEST);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4003);
    dynamic_cast<CsTESTContext *>(_localctx)->operation = match(RpgParser::OP_TEST);
    setState(4005);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4004);
      dynamic_cast<CsTESTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4007);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsTESTBContext ------------------------------------------------------------------

RpgParser::CsTESTBContext::CsTESTBContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsTESTBContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsTESTBContext::OP_TESTB() {
  return getToken(RpgParser::OP_TESTB, 0);
}


size_t RpgParser::CsTESTBContext::getRuleIndex() const {
  return RpgParser::RuleCsTESTB;
}

void RpgParser::CsTESTBContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsTESTB(this);
}

void RpgParser::CsTESTBContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsTESTB(this);
}


antlrcpp::Any RpgParser::CsTESTBContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsTESTB(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsTESTBContext* RpgParser::csTESTB() {
  CsTESTBContext *_localctx = _tracker.createInstance<CsTESTBContext>(_ctx, getState());
  enterRule(_localctx, 680, RpgParser::RuleCsTESTB);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4009);
    dynamic_cast<CsTESTBContext *>(_localctx)->operation = match(RpgParser::OP_TESTB);
    setState(4010);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsTESTNContext ------------------------------------------------------------------

RpgParser::CsTESTNContext::CsTESTNContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsTESTNContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsTESTNContext::OP_TESTN() {
  return getToken(RpgParser::OP_TESTN, 0);
}


size_t RpgParser::CsTESTNContext::getRuleIndex() const {
  return RpgParser::RuleCsTESTN;
}

void RpgParser::CsTESTNContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsTESTN(this);
}

void RpgParser::CsTESTNContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsTESTN(this);
}


antlrcpp::Any RpgParser::CsTESTNContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsTESTN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsTESTNContext* RpgParser::csTESTN() {
  CsTESTNContext *_localctx = _tracker.createInstance<CsTESTNContext>(_ctx, getState());
  enterRule(_localctx, 682, RpgParser::RuleCsTESTN);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4012);
    dynamic_cast<CsTESTNContext *>(_localctx)->operation = match(RpgParser::OP_TESTN);
    setState(4013);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsTESTZContext ------------------------------------------------------------------

RpgParser::CsTESTZContext::CsTESTZContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsTESTZContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsTESTZContext::OP_TESTZ() {
  return getToken(RpgParser::OP_TESTZ, 0);
}


size_t RpgParser::CsTESTZContext::getRuleIndex() const {
  return RpgParser::RuleCsTESTZ;
}

void RpgParser::CsTESTZContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsTESTZ(this);
}

void RpgParser::CsTESTZContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsTESTZ(this);
}


antlrcpp::Any RpgParser::CsTESTZContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsTESTZ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsTESTZContext* RpgParser::csTESTZ() {
  CsTESTZContext *_localctx = _tracker.createInstance<CsTESTZContext>(_ctx, getState());
  enterRule(_localctx, 684, RpgParser::RuleCsTESTZ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4015);
    dynamic_cast<CsTESTZContext *>(_localctx)->operation = match(RpgParser::OP_TESTZ);
    setState(4016);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsTIMEContext ------------------------------------------------------------------

RpgParser::CsTIMEContext::CsTIMEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsTIMEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsTIMEContext::OP_TIME() {
  return getToken(RpgParser::OP_TIME, 0);
}


size_t RpgParser::CsTIMEContext::getRuleIndex() const {
  return RpgParser::RuleCsTIME;
}

void RpgParser::CsTIMEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsTIME(this);
}

void RpgParser::CsTIMEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsTIME(this);
}


antlrcpp::Any RpgParser::CsTIMEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsTIME(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsTIMEContext* RpgParser::csTIME() {
  CsTIMEContext *_localctx = _tracker.createInstance<CsTIMEContext>(_ctx, getState());
  enterRule(_localctx, 686, RpgParser::RuleCsTIME);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4018);
    dynamic_cast<CsTIMEContext *>(_localctx)->operation = match(RpgParser::OP_TIME);
    setState(4019);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsUNLOCKContext ------------------------------------------------------------------

RpgParser::CsUNLOCKContext::CsUNLOCKContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsUNLOCKContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsUNLOCKContext::OP_UNLOCK() {
  return getToken(RpgParser::OP_UNLOCK, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsUNLOCKContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsUNLOCKContext::getRuleIndex() const {
  return RpgParser::RuleCsUNLOCK;
}

void RpgParser::CsUNLOCKContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsUNLOCK(this);
}

void RpgParser::CsUNLOCKContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsUNLOCK(this);
}


antlrcpp::Any RpgParser::CsUNLOCKContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsUNLOCK(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsUNLOCKContext* RpgParser::csUNLOCK() {
  CsUNLOCKContext *_localctx = _tracker.createInstance<CsUNLOCKContext>(_ctx, getState());
  enterRule(_localctx, 688, RpgParser::RuleCsUNLOCK);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4021);
    dynamic_cast<CsUNLOCKContext *>(_localctx)->operation = match(RpgParser::OP_UNLOCK);
    setState(4023);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4022);
      dynamic_cast<CsUNLOCKContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4025);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsUPDATEContext ------------------------------------------------------------------

RpgParser::CsUPDATEContext::CsUPDATEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsUPDATEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsUPDATEContext::OP_UPDATE() {
  return getToken(RpgParser::OP_UPDATE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsUPDATEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsUPDATEContext::getRuleIndex() const {
  return RpgParser::RuleCsUPDATE;
}

void RpgParser::CsUPDATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsUPDATE(this);
}

void RpgParser::CsUPDATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsUPDATE(this);
}


antlrcpp::Any RpgParser::CsUPDATEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsUPDATE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsUPDATEContext* RpgParser::csUPDATE() {
  CsUPDATEContext *_localctx = _tracker.createInstance<CsUPDATEContext>(_ctx, getState());
  enterRule(_localctx, 690, RpgParser::RuleCsUPDATE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4027);
    dynamic_cast<CsUPDATEContext *>(_localctx)->operation = match(RpgParser::OP_UPDATE);
    setState(4029);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4028);
      dynamic_cast<CsUPDATEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4031);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENContext ------------------------------------------------------------------

RpgParser::CsWHENContext::CsWHENContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsWHENContext::OP_WHEN() {
  return getToken(RpgParser::OP_WHEN, 0);
}

RpgParser::C_freeContext* RpgParser::CsWHENContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsWHENContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsWHENContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsWHENContext::getRuleIndex() const {
  return RpgParser::RuleCsWHEN;
}

void RpgParser::CsWHENContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHEN(this);
}

void RpgParser::CsWHENContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHEN(this);
}


antlrcpp::Any RpgParser::CsWHENContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHEN(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENContext* RpgParser::csWHEN() {
  CsWHENContext *_localctx = _tracker.createInstance<CsWHENContext>(_ctx, getState());
  enterRule(_localctx, 692, RpgParser::RuleCsWHEN);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4033);
    match(RpgParser::OP_WHEN);
    setState(4035);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      setState(4034);
      dynamic_cast<CsWHENContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(4037);
    dynamic_cast<CsWHENContext *>(_localctx)->fixedexpression = c_free();
    setState(4038);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENEQContext ------------------------------------------------------------------

RpgParser::CsWHENEQContext::CsWHENEQContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWHENEQContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENEQContext::OP_WHENEQ() {
  return getToken(RpgParser::OP_WHENEQ, 0);
}


size_t RpgParser::CsWHENEQContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENEQ;
}

void RpgParser::CsWHENEQContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENEQ(this);
}

void RpgParser::CsWHENEQContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENEQ(this);
}


antlrcpp::Any RpgParser::CsWHENEQContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENEQ(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENEQContext* RpgParser::csWHENEQ() {
  CsWHENEQContext *_localctx = _tracker.createInstance<CsWHENEQContext>(_ctx, getState());
  enterRule(_localctx, 694, RpgParser::RuleCsWHENEQ);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4040);
    dynamic_cast<CsWHENEQContext *>(_localctx)->operation = match(RpgParser::OP_WHENEQ);
    setState(4041);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENNEContext ------------------------------------------------------------------

RpgParser::CsWHENNEContext::CsWHENNEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWHENNEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENNEContext::OP_WHENNE() {
  return getToken(RpgParser::OP_WHENNE, 0);
}


size_t RpgParser::CsWHENNEContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENNE;
}

void RpgParser::CsWHENNEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENNE(this);
}

void RpgParser::CsWHENNEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENNE(this);
}


antlrcpp::Any RpgParser::CsWHENNEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENNE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENNEContext* RpgParser::csWHENNE() {
  CsWHENNEContext *_localctx = _tracker.createInstance<CsWHENNEContext>(_ctx, getState());
  enterRule(_localctx, 696, RpgParser::RuleCsWHENNE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4043);
    dynamic_cast<CsWHENNEContext *>(_localctx)->operation = match(RpgParser::OP_WHENNE);
    setState(4044);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENLEContext ------------------------------------------------------------------

RpgParser::CsWHENLEContext::CsWHENLEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWHENLEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENLEContext::OP_WHENLE() {
  return getToken(RpgParser::OP_WHENLE, 0);
}


size_t RpgParser::CsWHENLEContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENLE;
}

void RpgParser::CsWHENLEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENLE(this);
}

void RpgParser::CsWHENLEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENLE(this);
}


antlrcpp::Any RpgParser::CsWHENLEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENLE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENLEContext* RpgParser::csWHENLE() {
  CsWHENLEContext *_localctx = _tracker.createInstance<CsWHENLEContext>(_ctx, getState());
  enterRule(_localctx, 698, RpgParser::RuleCsWHENLE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4046);
    dynamic_cast<CsWHENLEContext *>(_localctx)->operation = match(RpgParser::OP_WHENLE);
    setState(4047);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENLTContext ------------------------------------------------------------------

RpgParser::CsWHENLTContext::CsWHENLTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWHENLTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENLTContext::OP_WHENLT() {
  return getToken(RpgParser::OP_WHENLT, 0);
}


size_t RpgParser::CsWHENLTContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENLT;
}

void RpgParser::CsWHENLTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENLT(this);
}

void RpgParser::CsWHENLTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENLT(this);
}


antlrcpp::Any RpgParser::CsWHENLTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENLT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENLTContext* RpgParser::csWHENLT() {
  CsWHENLTContext *_localctx = _tracker.createInstance<CsWHENLTContext>(_ctx, getState());
  enterRule(_localctx, 700, RpgParser::RuleCsWHENLT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4049);
    dynamic_cast<CsWHENLTContext *>(_localctx)->operation = match(RpgParser::OP_WHENLT);
    setState(4050);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENGEContext ------------------------------------------------------------------

RpgParser::CsWHENGEContext::CsWHENGEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWHENGEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENGEContext::OP_WHENGE() {
  return getToken(RpgParser::OP_WHENGE, 0);
}


size_t RpgParser::CsWHENGEContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENGE;
}

void RpgParser::CsWHENGEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENGE(this);
}

void RpgParser::CsWHENGEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENGE(this);
}


antlrcpp::Any RpgParser::CsWHENGEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENGE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENGEContext* RpgParser::csWHENGE() {
  CsWHENGEContext *_localctx = _tracker.createInstance<CsWHENGEContext>(_ctx, getState());
  enterRule(_localctx, 702, RpgParser::RuleCsWHENGE);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4052);
    dynamic_cast<CsWHENGEContext *>(_localctx)->operation = match(RpgParser::OP_WHENGE);
    setState(4053);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWHENGTContext ------------------------------------------------------------------

RpgParser::CsWHENGTContext::CsWHENGTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWHENGTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWHENGTContext::OP_WHENGT() {
  return getToken(RpgParser::OP_WHENGT, 0);
}


size_t RpgParser::CsWHENGTContext::getRuleIndex() const {
  return RpgParser::RuleCsWHENGT;
}

void RpgParser::CsWHENGTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWHENGT(this);
}

void RpgParser::CsWHENGTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWHENGT(this);
}


antlrcpp::Any RpgParser::CsWHENGTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWHENGT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWHENGTContext* RpgParser::csWHENGT() {
  CsWHENGTContext *_localctx = _tracker.createInstance<CsWHENGTContext>(_ctx, getState());
  enterRule(_localctx, 704, RpgParser::RuleCsWHENGT);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4055);
    dynamic_cast<CsWHENGTContext *>(_localctx)->operation = match(RpgParser::OP_WHENGT);
    setState(4056);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsWRITEContext ------------------------------------------------------------------

RpgParser::CsWRITEContext::CsWRITEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsWRITEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsWRITEContext::OP_WRITE() {
  return getToken(RpgParser::OP_WRITE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsWRITEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsWRITEContext::getRuleIndex() const {
  return RpgParser::RuleCsWRITE;
}

void RpgParser::CsWRITEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsWRITE(this);
}

void RpgParser::CsWRITEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsWRITE(this);
}


antlrcpp::Any RpgParser::CsWRITEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsWRITE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsWRITEContext* RpgParser::csWRITE() {
  CsWRITEContext *_localctx = _tracker.createInstance<CsWRITEContext>(_ctx, getState());
  enterRule(_localctx, 706, RpgParser::RuleCsWRITE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4058);
    dynamic_cast<CsWRITEContext *>(_localctx)->operation = match(RpgParser::OP_WRITE);
    setState(4060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4059);
      dynamic_cast<CsWRITEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4062);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsXFOOTContext ------------------------------------------------------------------

RpgParser::CsXFOOTContext::CsXFOOTContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsXFOOTContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsXFOOTContext::OP_XFOOT() {
  return getToken(RpgParser::OP_XFOOT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsXFOOTContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsXFOOTContext::getRuleIndex() const {
  return RpgParser::RuleCsXFOOT;
}

void RpgParser::CsXFOOTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsXFOOT(this);
}

void RpgParser::CsXFOOTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsXFOOT(this);
}


antlrcpp::Any RpgParser::CsXFOOTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsXFOOT(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsXFOOTContext* RpgParser::csXFOOT() {
  CsXFOOTContext *_localctx = _tracker.createInstance<CsXFOOTContext>(_ctx, getState());
  enterRule(_localctx, 708, RpgParser::RuleCsXFOOT);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4064);
    dynamic_cast<CsXFOOTContext *>(_localctx)->operation = match(RpgParser::OP_XFOOT);
    setState(4066);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4065);
      dynamic_cast<CsXFOOTContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4068);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsXLATEContext ------------------------------------------------------------------

RpgParser::CsXLATEContext::CsXLATEContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsXLATEContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsXLATEContext::OP_XLATE() {
  return getToken(RpgParser::OP_XLATE, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsXLATEContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsXLATEContext::getRuleIndex() const {
  return RpgParser::RuleCsXLATE;
}

void RpgParser::CsXLATEContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsXLATE(this);
}

void RpgParser::CsXLATEContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsXLATE(this);
}


antlrcpp::Any RpgParser::CsXLATEContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsXLATE(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsXLATEContext* RpgParser::csXLATE() {
  CsXLATEContext *_localctx = _tracker.createInstance<CsXLATEContext>(_ctx, getState());
  enterRule(_localctx, 710, RpgParser::RuleCsXLATE);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4070);
    dynamic_cast<CsXLATEContext *>(_localctx)->operation = match(RpgParser::OP_XLATE);
    setState(4072);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4071);
      dynamic_cast<CsXLATEContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4074);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsXML_INTOContext ------------------------------------------------------------------

RpgParser::CsXML_INTOContext::CsXML_INTOContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsXML_INTOContext::OP_XML_INTO() {
  return getToken(RpgParser::OP_XML_INTO, 0);
}

RpgParser::C_freeContext* RpgParser::CsXML_INTOContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsXML_INTOContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsXML_INTOContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsXML_INTOContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsXML_INTOContext::getRuleIndex() const {
  return RpgParser::RuleCsXML_INTO;
}

void RpgParser::CsXML_INTOContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsXML_INTO(this);
}

void RpgParser::CsXML_INTOContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsXML_INTO(this);
}


antlrcpp::Any RpgParser::CsXML_INTOContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsXML_INTO(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsXML_INTOContext* RpgParser::csXML_INTO() {
  CsXML_INTOContext *_localctx = _tracker.createInstance<CsXML_INTOContext>(_ctx, getState());
  enterRule(_localctx, 712, RpgParser::RuleCsXML_INTO);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4076);
    dynamic_cast<CsXML_INTOContext *>(_localctx)->operation = match(RpgParser::OP_XML_INTO);
    setState(4078);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
    case 1: {
      setState(4077);
      dynamic_cast<CsXML_INTOContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(4080);
    dynamic_cast<CsXML_INTOContext *>(_localctx)->fixedexpression = c_free();
    setState(4081);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsXML_SAXContext ------------------------------------------------------------------

RpgParser::CsXML_SAXContext::CsXML_SAXContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsXML_SAXContext::OP_XML_SAX() {
  return getToken(RpgParser::OP_XML_SAX, 0);
}

RpgParser::C_freeContext* RpgParser::CsXML_SAXContext::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::CsXML_SAXContext::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::CsXML_SAXContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsXML_SAXContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsXML_SAXContext::getRuleIndex() const {
  return RpgParser::RuleCsXML_SAX;
}

void RpgParser::CsXML_SAXContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsXML_SAX(this);
}

void RpgParser::CsXML_SAXContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsXML_SAX(this);
}


antlrcpp::Any RpgParser::CsXML_SAXContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsXML_SAX(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsXML_SAXContext* RpgParser::csXML_SAX() {
  CsXML_SAXContext *_localctx = _tracker.createInstance<CsXML_SAXContext>(_ctx, getState());
  enterRule(_localctx, 714, RpgParser::RuleCsXML_SAX);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4083);
    dynamic_cast<CsXML_SAXContext *>(_localctx)->operation = match(RpgParser::OP_XML_SAX);
    setState(4085);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(4084);
      dynamic_cast<CsXML_SAXContext *>(_localctx)->operationExtender = cs_operationExtender();
      break;
    }

    }
    setState(4087);
    dynamic_cast<CsXML_SAXContext *>(_localctx)->fixedexpression = c_free();
    setState(4088);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsZ_ADDContext ------------------------------------------------------------------

RpgParser::CsZ_ADDContext::CsZ_ADDContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsZ_ADDContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsZ_ADDContext::OP_Z_ADD() {
  return getToken(RpgParser::OP_Z_ADD, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsZ_ADDContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsZ_ADDContext::getRuleIndex() const {
  return RpgParser::RuleCsZ_ADD;
}

void RpgParser::CsZ_ADDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsZ_ADD(this);
}

void RpgParser::CsZ_ADDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsZ_ADD(this);
}


antlrcpp::Any RpgParser::CsZ_ADDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsZ_ADD(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsZ_ADDContext* RpgParser::csZ_ADD() {
  CsZ_ADDContext *_localctx = _tracker.createInstance<CsZ_ADDContext>(_ctx, getState());
  enterRule(_localctx, 716, RpgParser::RuleCsZ_ADD);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4090);
    dynamic_cast<CsZ_ADDContext *>(_localctx)->operation = match(RpgParser::OP_Z_ADD);
    setState(4092);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4091);
      dynamic_cast<CsZ_ADDContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4094);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsZ_SUBContext ------------------------------------------------------------------

RpgParser::CsZ_SUBContext::CsZ_SUBContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Cspec_fixed_standard_partsContext* RpgParser::CsZ_SUBContext::cspec_fixed_standard_parts() {
  return getRuleContext<RpgParser::Cspec_fixed_standard_partsContext>(0);
}

tree::TerminalNode* RpgParser::CsZ_SUBContext::OP_Z_SUB() {
  return getToken(RpgParser::OP_Z_SUB, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsZ_SUBContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsZ_SUBContext::getRuleIndex() const {
  return RpgParser::RuleCsZ_SUB;
}

void RpgParser::CsZ_SUBContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsZ_SUB(this);
}

void RpgParser::CsZ_SUBContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsZ_SUB(this);
}


antlrcpp::Any RpgParser::CsZ_SUBContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsZ_SUB(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsZ_SUBContext* RpgParser::csZ_SUB() {
  CsZ_SUBContext *_localctx = _tracker.createInstance<CsZ_SUBContext>(_ctx, getState());
  enterRule(_localctx, 718, RpgParser::RuleCsZ_SUB);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4096);
    dynamic_cast<CsZ_SUBContext *>(_localctx)->operation = match(RpgParser::OP_Z_SUB);
    setState(4098);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4097);
      dynamic_cast<CsZ_SUBContext *>(_localctx)->operationExtender = cs_operationExtender();
    }
    setState(4100);
    cspec_fixed_standard_parts();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cs_operationExtenderContext ------------------------------------------------------------------

RpgParser::Cs_operationExtenderContext::Cs_operationExtenderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cs_operationExtenderContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Cs_operationExtenderContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Cs_operationExtenderContext::CS_OperationAndExtender() {
  return getTokens(RpgParser::CS_OperationAndExtender);
}

tree::TerminalNode* RpgParser::Cs_operationExtenderContext::CS_OperationAndExtender(size_t i) {
  return getToken(RpgParser::CS_OperationAndExtender, i);
}


size_t RpgParser::Cs_operationExtenderContext::getRuleIndex() const {
  return RpgParser::RuleCs_operationExtender;
}

void RpgParser::Cs_operationExtenderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCs_operationExtender(this);
}

void RpgParser::Cs_operationExtenderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCs_operationExtender(this);
}


antlrcpp::Any RpgParser::Cs_operationExtenderContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCs_operationExtender(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cs_operationExtenderContext* RpgParser::cs_operationExtender() {
  Cs_operationExtenderContext *_localctx = _tracker.createInstance<Cs_operationExtenderContext>(_ctx, getState());
  enterRule(_localctx, 720, RpgParser::RuleCs_operationExtender);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4102);
    match(RpgParser::OPEN_PAREN);
    setState(4103);
    dynamic_cast<Cs_operationExtenderContext *>(_localctx)->extender = match(RpgParser::CS_OperationAndExtender);
    setState(4105);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
    case 1: {
      setState(4104);
      dynamic_cast<Cs_operationExtenderContext *>(_localctx)->extender2 = match(RpgParser::CS_OperationAndExtender);
      break;
    }

    }
    setState(4108);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
    case 1: {
      setState(4107);
      dynamic_cast<Cs_operationExtenderContext *>(_localctx)->extender3 = match(RpgParser::CS_OperationAndExtender);
      break;
    }

    }
    setState(4111);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::CS_OperationAndExtender) {
      setState(4110);
      dynamic_cast<Cs_operationExtenderContext *>(_localctx)->extender4 = match(RpgParser::CS_OperationAndExtender);
    }
    setState(4113);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactorContext ------------------------------------------------------------------

RpgParser::FactorContext::FactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::FactorContentContext *> RpgParser::FactorContext::factorContent() {
  return getRuleContexts<RpgParser::FactorContentContext>();
}

RpgParser::FactorContentContext* RpgParser::FactorContext::factorContent(size_t i) {
  return getRuleContext<RpgParser::FactorContentContext>(i);
}

tree::TerminalNode* RpgParser::FactorContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::FactorContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

tree::TerminalNode* RpgParser::FactorContext::CS_BlankFactor() {
  return getToken(RpgParser::CS_BlankFactor, 0);
}

RpgParser::LiteralContext* RpgParser::FactorContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}


size_t RpgParser::FactorContext::getRuleIndex() const {
  return RpgParser::RuleFactor;
}

void RpgParser::FactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactor(this);
}

void RpgParser::FactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactor(this);
}


antlrcpp::Any RpgParser::FactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFactor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FactorContext* RpgParser::factor() {
  FactorContext *_localctx = _tracker.createInstance<FactorContext>(_ctx, getState());
  enterRule(_localctx, 722, RpgParser::RuleFactor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4128);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart:
      case RpgParser::CS_FactorContent: {
        enterOuterAlt(_localctx, 1);
        setState(4115);
        dynamic_cast<FactorContext *>(_localctx)->content = factorContent();
        setState(4121);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::COLON) {
          setState(4116);
          match(RpgParser::COLON);
          setState(4119);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case RpgParser::HexLiteralStart:
            case RpgParser::DateLiteralStart:
            case RpgParser::TimeLiteralStart:
            case RpgParser::TimeStampLiteralStart:
            case RpgParser::GraphicLiteralStart:
            case RpgParser::UCS2LiteralStart:
            case RpgParser::StringLiteralStart:
            case RpgParser::CS_FactorContent: {
              setState(4117);
              dynamic_cast<FactorContext *>(_localctx)->content2 = factorContent();
              break;
            }

            case RpgParser::SPLAT_ALL:
            case RpgParser::SPLAT_NONE:
            case RpgParser::SPLAT_YES:
            case RpgParser::SPLAT_NO:
            case RpgParser::SPLAT_ILERPG:
            case RpgParser::SPLAT_COMPAT:
            case RpgParser::SPLAT_CRTBNDRPG:
            case RpgParser::SPLAT_CRTRPGMOD:
            case RpgParser::SPLAT_VRM:
            case RpgParser::SPLAT_ALLG:
            case RpgParser::SPLAT_ALLU:
            case RpgParser::SPLAT_ALLTHREAD:
            case RpgParser::SPLAT_ALLX:
            case RpgParser::SPLAT_BLANKS:
            case RpgParser::SPLAT_CANCL:
            case RpgParser::SPLAT_CYMD:
            case RpgParser::SPLAT_CMDY:
            case RpgParser::SPLAT_CDMY:
            case RpgParser::SPLAT_MDY:
            case RpgParser::SPLAT_DMY:
            case RpgParser::SPLAT_DFT:
            case RpgParser::SPLAT_YMD:
            case RpgParser::SPLAT_JUL:
            case RpgParser::SPLAT_JAVA:
            case RpgParser::SPLAT_ISO:
            case RpgParser::SPLAT_USA:
            case RpgParser::SPLAT_EUR:
            case RpgParser::SPLAT_JIS:
            case RpgParser::SPLAT_DATE:
            case RpgParser::SPLAT_DAY:
            case RpgParser::SPlAT_DETC:
            case RpgParser::SPLAT_DETL:
            case RpgParser::SPLAT_DTAARA:
            case RpgParser::SPLAT_END:
            case RpgParser::SPLAT_ENTRY:
            case RpgParser::SPLAT_EQUATE:
            case RpgParser::SPLAT_EXTDFT:
            case RpgParser::SPLAT_EXT:
            case RpgParser::SPLAT_FILE:
            case RpgParser::SPLAT_GETIN:
            case RpgParser::SPLAT_HIVAL:
            case RpgParser::SPLAT_INIT:
            case RpgParser::SPLAT_INDICATOR:
            case RpgParser::SPLAT_INZSR:
            case RpgParser::SPLAT_IN:
            case RpgParser::SPLAT_INPUT:
            case RpgParser::SPLAT_OUTPUT:
            case RpgParser::SPLAT_JOBRUN:
            case RpgParser::SPLAT_JOB:
            case RpgParser::SPLAT_LDA:
            case RpgParser::SPLAT_LIKE:
            case RpgParser::SPLAT_LONGJUL:
            case RpgParser::SPLAT_LOVAL:
            case RpgParser::SPLAT_KEY:
            case RpgParser::SPLAT_MONTH:
            case RpgParser::SPLAT_NEXT:
            case RpgParser::SPLAT_NOIND:
            case RpgParser::SPLAT_NOKEY:
            case RpgParser::SPLAT_NULL:
            case RpgParser::SPLAT_OFL:
            case RpgParser::SPLAT_ON:
            case RpgParser::SPLAT_ONLY:
            case RpgParser::SPLAT_OFF:
            case RpgParser::SPLAT_PDA:
            case RpgParser::SPLAT_PLACE:
            case RpgParser::SPLAT_PSSR:
            case RpgParser::SPLAT_ROUTINE:
            case RpgParser::SPLAT_START:
            case RpgParser::SPLAT_SYS:
            case RpgParser::SPLAT_TERM:
            case RpgParser::SPLAT_TOTC:
            case RpgParser::SPLAT_TOTL:
            case RpgParser::SPLAT_USER:
            case RpgParser::SPLAT_VAR:
            case RpgParser::SPLAT_YEAR:
            case RpgParser::SPLAT_ZEROS:
            case RpgParser::SPLAT_HMS:
            case RpgParser::SPLAT_INLR:
            case RpgParser::SPLAT_INOF:
            case RpgParser::SPLAT_DATA:
            case RpgParser::SPLAT_ASTFILL:
            case RpgParser::SPLAT_CURSYM:
            case RpgParser::SPLAT_MAX:
            case RpgParser::SPLAT_LOCK:
            case RpgParser::SPLAT_PROGRAM:
            case RpgParser::SPLAT_EXTDESC:
            case RpgParser::SPLAT_D:
            case RpgParser::SPLAT_H:
            case RpgParser::SPLAT_HOURS:
            case RpgParser::SPLAT_DAYS:
            case RpgParser::SPLAT_M:
            case RpgParser::SPLAT_MINUTES:
            case RpgParser::SPLAT_MONTHS:
            case RpgParser::SPLAT_MN:
            case RpgParser::SPLAT_MS:
            case RpgParser::SPLAT_MSECONDS:
            case RpgParser::SPLAT_S:
            case RpgParser::SPLAT_SECONDS:
            case RpgParser::SPLAT_Y:
            case RpgParser::SPLAT_YEARS: {
              setState(4118);
              dynamic_cast<FactorContext *>(_localctx)->constant2 = symbolicConstants();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
        }
        break;
      }

      case RpgParser::CS_BlankFactor: {
        enterOuterAlt(_localctx, 2);
        setState(4123);
        match(RpgParser::CS_BlankFactor);
        break;
      }

      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS: {
        enterOuterAlt(_localctx, 3);
        setState(4124);
        dynamic_cast<FactorContext *>(_localctx)->constant = symbolicConstants();
        setState(4126);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
        case 1: {
          setState(4125);
          literal();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactorContentContext ------------------------------------------------------------------

RpgParser::FactorContentContext::FactorContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FactorContentContext::CS_FactorContent() {
  return getToken(RpgParser::CS_FactorContent, 0);
}

RpgParser::LiteralContext* RpgParser::FactorContentContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}


size_t RpgParser::FactorContentContext::getRuleIndex() const {
  return RpgParser::RuleFactorContent;
}

void RpgParser::FactorContentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactorContent(this);
}

void RpgParser::FactorContentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactorContent(this);
}


antlrcpp::Any RpgParser::FactorContentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFactorContent(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FactorContentContext* RpgParser::factorContent() {
  FactorContentContext *_localctx = _tracker.createInstance<FactorContentContext>(_ctx, getState());
  enterRule(_localctx, 724, RpgParser::RuleFactorContent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4132);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FactorContent: {
        enterOuterAlt(_localctx, 1);
        setState(4130);
        match(RpgParser::CS_FactorContent);
        break;
      }

      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        enterOuterAlt(_localctx, 2);
        setState(4131);
        literal();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultTypeContext ------------------------------------------------------------------

RpgParser::ResultTypeContext::ResultTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ResultTypeContext::CS_FactorContent() {
  return getToken(RpgParser::CS_FactorContent, 0);
}

tree::TerminalNode* RpgParser::ResultTypeContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::SymbolicConstantsContext* RpgParser::ResultTypeContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

tree::TerminalNode* RpgParser::ResultTypeContext::CS_BlankFactor() {
  return getToken(RpgParser::CS_BlankFactor, 0);
}


size_t RpgParser::ResultTypeContext::getRuleIndex() const {
  return RpgParser::RuleResultType;
}

void RpgParser::ResultTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResultType(this);
}

void RpgParser::ResultTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResultType(this);
}


antlrcpp::Any RpgParser::ResultTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitResultType(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ResultTypeContext* RpgParser::resultType() {
  ResultTypeContext *_localctx = _tracker.createInstance<ResultTypeContext>(_ctx, getState());
  enterRule(_localctx, 726, RpgParser::RuleResultType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4140);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::CS_FactorContent: {
        enterOuterAlt(_localctx, 1);
        setState(4134);
        match(RpgParser::CS_FactorContent);
        setState(4137);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::COLON) {
          setState(4135);
          match(RpgParser::COLON);

          setState(4136);
          dynamic_cast<ResultTypeContext *>(_localctx)->constant = symbolicConstants();
        }
        break;
      }

      case RpgParser::CS_BlankFactor: {
        enterOuterAlt(_localctx, 2);
        setState(4139);
        match(RpgParser::CS_BlankFactor);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cs_fixed_commentsContext ------------------------------------------------------------------

RpgParser::Cs_fixed_commentsContext::Cs_fixed_commentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Cs_fixed_commentsContext::CS_FixedComments() {
  return getToken(RpgParser::CS_FixedComments, 0);
}


size_t RpgParser::Cs_fixed_commentsContext::getRuleIndex() const {
  return RpgParser::RuleCs_fixed_comments;
}

void RpgParser::Cs_fixed_commentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCs_fixed_comments(this);
}

void RpgParser::Cs_fixed_commentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCs_fixed_comments(this);
}


antlrcpp::Any RpgParser::Cs_fixed_commentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCs_fixed_comments(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cs_fixed_commentsContext* RpgParser::cs_fixed_comments() {
  Cs_fixed_commentsContext *_localctx = _tracker.createInstance<Cs_fixed_commentsContext>(_ctx, getState());
  enterRule(_localctx, 728, RpgParser::RuleCs_fixed_comments);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4142);
    match(RpgParser::CS_FixedComments);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cspec_fixed_x2Context ------------------------------------------------------------------

RpgParser::Cspec_fixed_x2Context::Cspec_fixed_x2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::CsOperationAndExtendedFactor2Context* RpgParser::Cspec_fixed_x2Context::csOperationAndExtendedFactor2() {
  return getRuleContext<RpgParser::CsOperationAndExtendedFactor2Context>(0);
}

RpgParser::C_freeContext* RpgParser::Cspec_fixed_x2Context::c_free() {
  return getRuleContext<RpgParser::C_freeContext>(0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_x2Context::C_FREE_NEWLINE() {
  return getToken(RpgParser::C_FREE_NEWLINE, 0);
}

tree::TerminalNode* RpgParser::Cspec_fixed_x2Context::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::Cspec_fixed_x2Context::getRuleIndex() const {
  return RpgParser::RuleCspec_fixed_x2;
}

void RpgParser::Cspec_fixed_x2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCspec_fixed_x2(this);
}

void RpgParser::Cspec_fixed_x2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCspec_fixed_x2(this);
}


antlrcpp::Any RpgParser::Cspec_fixed_x2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCspec_fixed_x2(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Cspec_fixed_x2Context* RpgParser::cspec_fixed_x2() {
  Cspec_fixed_x2Context *_localctx = _tracker.createInstance<Cspec_fixed_x2Context>(_ctx, getState());
  enterRule(_localctx, 730, RpgParser::RuleCspec_fixed_x2);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4144);
    csOperationAndExtendedFactor2();
    setState(4145);
    dynamic_cast<Cspec_fixed_x2Context *>(_localctx)->fixedexpression = c_free();
    setState(4146);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::C_FREE_NEWLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsOperationAndExtendedFactor2Context ------------------------------------------------------------------

RpgParser::CsOperationAndExtendedFactor2Context::CsOperationAndExtendedFactor2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CsOperationAndExtendedFactor2Context::OP_CALLP() {
  return getToken(RpgParser::OP_CALLP, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::CsOperationAndExtendedFactor2Context::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::CsOperationAndExtendedFactor2Context::getRuleIndex() const {
  return RpgParser::RuleCsOperationAndExtendedFactor2;
}

void RpgParser::CsOperationAndExtendedFactor2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsOperationAndExtendedFactor2(this);
}

void RpgParser::CsOperationAndExtendedFactor2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsOperationAndExtendedFactor2(this);
}


antlrcpp::Any RpgParser::CsOperationAndExtendedFactor2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCsOperationAndExtendedFactor2(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CsOperationAndExtendedFactor2Context* RpgParser::csOperationAndExtendedFactor2() {
  CsOperationAndExtendedFactor2Context *_localctx = _tracker.createInstance<CsOperationAndExtendedFactor2Context>(_ctx, getState());
  enterRule(_localctx, 732, RpgParser::RuleCsOperationAndExtendedFactor2);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4153);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);

      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4149);
      dynamic_cast<CsOperationAndExtendedFactor2Context *>(_localctx)->operation = match(RpgParser::OP_CALLP);
      setState(4151);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
      case 1: {
        setState(4150);
        dynamic_cast<CsOperationAndExtendedFactor2Context *>(_localctx)->operationExtender = cs_operationExtender();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ispec_fixedContext ------------------------------------------------------------------

RpgParser::Ispec_fixedContext::Ispec_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IS_FIXED() {
  return getToken(RpgParser::IS_FIXED, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IS_FileName() {
  return getToken(RpgParser::IS_FileName, 0);
}

RpgParser::Is_external_fieldContext* RpgParser::Ispec_fixedContext::is_external_field() {
  return getRuleContext<RpgParser::Is_external_fieldContext>(0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_DATA_ATTR() {
  return getToken(RpgParser::IFD_DATA_ATTR, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_DATETIME_SEP() {
  return getToken(RpgParser::IFD_DATETIME_SEP, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_DATA_FORMAT() {
  return getToken(RpgParser::IFD_DATA_FORMAT, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_FIELD_LOCATION() {
  return getToken(RpgParser::IFD_FIELD_LOCATION, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_DECIMAL_POSITIONS() {
  return getToken(RpgParser::IFD_DECIMAL_POSITIONS, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_FIELD_NAME() {
  return getToken(RpgParser::IFD_FIELD_NAME, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_CONTROL_LEVEL() {
  return getToken(RpgParser::IFD_CONTROL_LEVEL, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_MATCHING_FIELDS() {
  return getToken(RpgParser::IFD_MATCHING_FIELDS, 0);
}

RpgParser::FieldRecordRelationContext* RpgParser::Ispec_fixedContext::fieldRecordRelation() {
  return getRuleContext<RpgParser::FieldRecordRelationContext>(0);
}

std::vector<RpgParser::FieldIndicatorContext *> RpgParser::Ispec_fixedContext::fieldIndicator() {
  return getRuleContexts<RpgParser::FieldIndicatorContext>();
}

RpgParser::FieldIndicatorContext* RpgParser::Ispec_fixedContext::fieldIndicator(size_t i) {
  return getRuleContext<RpgParser::FieldIndicatorContext>(i);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Is_external_recContext* RpgParser::Ispec_fixedContext::is_external_rec() {
  return getRuleContext<RpgParser::Is_external_recContext>(0);
}

RpgParser::Is_recContext* RpgParser::Ispec_fixedContext::is_rec() {
  return getRuleContext<RpgParser::Is_recContext>(0);
}

tree::TerminalNode* RpgParser::Ispec_fixedContext::IFD_COMMENTS() {
  return getToken(RpgParser::IFD_COMMENTS, 0);
}


size_t RpgParser::Ispec_fixedContext::getRuleIndex() const {
  return RpgParser::RuleIspec_fixed;
}

void RpgParser::Ispec_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIspec_fixed(this);
}

void RpgParser::Ispec_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIspec_fixed(this);
}


antlrcpp::Any RpgParser::Ispec_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIspec_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Ispec_fixedContext* RpgParser::ispec_fixed() {
  Ispec_fixedContext *_localctx = _tracker.createInstance<Ispec_fixedContext>(_ctx, getState());
  enterRule(_localctx, 734, RpgParser::RuleIspec_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4155);
    match(RpgParser::IS_FIXED);
    setState(4183);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::IS_FileName: {
        setState(4156);
        match(RpgParser::IS_FileName);
        setState(4159);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case RpgParser::IS_ExtRecordReserved: {
            setState(4157);
            is_external_rec();
            break;
          }

          case RpgParser::IS_Sequence: {
            setState(4158);
            is_rec();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(4161);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case RpgParser::IF_Name: {
        setState(4163);
        is_external_field();
        setState(4164);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case RpgParser::IFD_DATA_ATTR: {
        setState(4166);
        match(RpgParser::IFD_DATA_ATTR);
        setState(4167);
        match(RpgParser::IFD_DATETIME_SEP);
        setState(4168);
        match(RpgParser::IFD_DATA_FORMAT);
        setState(4169);
        match(RpgParser::IFD_FIELD_LOCATION);
        setState(4170);
        match(RpgParser::IFD_DECIMAL_POSITIONS);
        setState(4171);
        match(RpgParser::IFD_FIELD_NAME);
        setState(4172);
        match(RpgParser::IFD_CONTROL_LEVEL);
        setState(4173);
        match(RpgParser::IFD_MATCHING_FIELDS);
        setState(4174);
        fieldRecordRelation();
        setState(4175);
        fieldIndicator();
        setState(4176);
        fieldIndicator();
        setState(4177);
        fieldIndicator();
        setState(4179);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::IFD_COMMENTS) {
          setState(4178);
          match(RpgParser::IFD_COMMENTS);
        }
        setState(4181);
        _la = _input->LA(1);
        if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldRecordRelationContext ------------------------------------------------------------------

RpgParser::FieldRecordRelationContext::FieldRecordRelationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::GeneralIndicator() {
  return getToken(RpgParser::GeneralIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::MatchingRecordIndicator() {
  return getToken(RpgParser::MatchingRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::ExternalIndicator() {
  return getToken(RpgParser::ExternalIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::HaltIndicator() {
  return getToken(RpgParser::HaltIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldRecordRelationContext::ReturnIndicator() {
  return getToken(RpgParser::ReturnIndicator, 0);
}


size_t RpgParser::FieldRecordRelationContext::getRuleIndex() const {
  return RpgParser::RuleFieldRecordRelation;
}

void RpgParser::FieldRecordRelationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldRecordRelation(this);
}

void RpgParser::FieldRecordRelationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldRecordRelation(this);
}


antlrcpp::Any RpgParser::FieldRecordRelationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFieldRecordRelation(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FieldRecordRelationContext* RpgParser::fieldRecordRelation() {
  FieldRecordRelationContext *_localctx = _tracker.createInstance<FieldRecordRelationContext>(_ctx, getState());
  enterRule(_localctx, 736, RpgParser::RuleFieldRecordRelation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4185);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::GeneralIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::MatchingRecordIndicator - 689))
      | (1ULL << (RpgParser::HaltIndicator - 689))
      | (1ULL << (RpgParser::ReturnIndicator - 689))
      | (1ULL << (RpgParser::ExternalIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldIndicatorContext ------------------------------------------------------------------

RpgParser::FieldIndicatorContext::FieldIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::FieldIndicatorContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldIndicatorContext::GeneralIndicator() {
  return getToken(RpgParser::GeneralIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldIndicatorContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldIndicatorContext::HaltIndicator() {
  return getToken(RpgParser::HaltIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldIndicatorContext::ExternalIndicator() {
  return getToken(RpgParser::ExternalIndicator, 0);
}

tree::TerminalNode* RpgParser::FieldIndicatorContext::ReturnIndicator() {
  return getToken(RpgParser::ReturnIndicator, 0);
}


size_t RpgParser::FieldIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleFieldIndicator;
}

void RpgParser::FieldIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldIndicator(this);
}

void RpgParser::FieldIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldIndicator(this);
}


antlrcpp::Any RpgParser::FieldIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFieldIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FieldIndicatorContext* RpgParser::fieldIndicator() {
  FieldIndicatorContext *_localctx = _tracker.createInstance<FieldIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 738, RpgParser::RuleFieldIndicator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4187);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::GeneralIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::HaltIndicator - 689))
      | (1ULL << (RpgParser::ReturnIndicator - 689))
      | (1ULL << (RpgParser::ExternalIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Is_external_recContext ------------------------------------------------------------------

RpgParser::Is_external_recContext::Is_external_recContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Is_external_recContext::IS_ExtRecordReserved() {
  return getToken(RpgParser::IS_ExtRecordReserved, 0);
}

RpgParser::ResultIndicatorContext* RpgParser::Is_external_recContext::resultIndicator() {
  return getRuleContext<RpgParser::ResultIndicatorContext>(0);
}

tree::TerminalNode* RpgParser::Is_external_recContext::WS() {
  return getToken(RpgParser::WS, 0);
}


size_t RpgParser::Is_external_recContext::getRuleIndex() const {
  return RpgParser::RuleIs_external_rec;
}

void RpgParser::Is_external_recContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIs_external_rec(this);
}

void RpgParser::Is_external_recContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIs_external_rec(this);
}


antlrcpp::Any RpgParser::Is_external_recContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIs_external_rec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Is_external_recContext* RpgParser::is_external_rec() {
  Is_external_recContext *_localctx = _tracker.createInstance<Is_external_recContext>(_ctx, getState());
  enterRule(_localctx, 740, RpgParser::RuleIs_external_rec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4189);
    match(RpgParser::IS_ExtRecordReserved);
    setState(4190);
    resultIndicator();
    setState(4192);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::WS) {
      setState(4191);
      match(RpgParser::WS);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Is_recContext ------------------------------------------------------------------

RpgParser::Is_recContext::Is_recContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Is_recContext::IS_Sequence() {
  return getToken(RpgParser::IS_Sequence, 0);
}

tree::TerminalNode* RpgParser::Is_recContext::IS_Number() {
  return getToken(RpgParser::IS_Number, 0);
}

tree::TerminalNode* RpgParser::Is_recContext::IS_Option() {
  return getToken(RpgParser::IS_Option, 0);
}

RpgParser::RecordIdIndicatorContext* RpgParser::Is_recContext::recordIdIndicator() {
  return getRuleContext<RpgParser::RecordIdIndicatorContext>(0);
}

tree::TerminalNode* RpgParser::Is_recContext::IS_RecordIdCode() {
  return getToken(RpgParser::IS_RecordIdCode, 0);
}


size_t RpgParser::Is_recContext::getRuleIndex() const {
  return RpgParser::RuleIs_rec;
}

void RpgParser::Is_recContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIs_rec(this);
}

void RpgParser::Is_recContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIs_rec(this);
}


antlrcpp::Any RpgParser::Is_recContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIs_rec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Is_recContext* RpgParser::is_rec() {
  Is_recContext *_localctx = _tracker.createInstance<Is_recContext>(_ctx, getState());
  enterRule(_localctx, 742, RpgParser::RuleIs_rec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4194);
    match(RpgParser::IS_Sequence);
    setState(4195);
    match(RpgParser::IS_Number);
    setState(4196);
    match(RpgParser::IS_Option);
    setState(4197);
    recordIdIndicator();
    setState(4198);
    match(RpgParser::IS_RecordIdCode);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RecordIdIndicatorContext ------------------------------------------------------------------

RpgParser::RecordIdIndicatorContext::RecordIdIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::GeneralIndicator() {
  return getToken(RpgParser::GeneralIndicator, 0);
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::HaltIndicator() {
  return getToken(RpgParser::HaltIndicator, 0);
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::LastRecordIndicator() {
  return getToken(RpgParser::LastRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::ExternalIndicator() {
  return getToken(RpgParser::ExternalIndicator, 0);
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::ReturnIndicator() {
  return getToken(RpgParser::ReturnIndicator, 0);
}

tree::TerminalNode* RpgParser::RecordIdIndicatorContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}


size_t RpgParser::RecordIdIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleRecordIdIndicator;
}

void RpgParser::RecordIdIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecordIdIndicator(this);
}

void RpgParser::RecordIdIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecordIdIndicator(this);
}


antlrcpp::Any RpgParser::RecordIdIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitRecordIdIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::RecordIdIndicatorContext* RpgParser::recordIdIndicator() {
  RecordIdIndicatorContext *_localctx = _tracker.createInstance<RecordIdIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 744, RpgParser::RuleRecordIdIndicator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4200);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & ((1ULL << (RpgParser::BlankIndicator - 689))
      | (1ULL << (RpgParser::GeneralIndicator - 689))
      | (1ULL << (RpgParser::ControlLevelIndicator - 689))
      | (1ULL << (RpgParser::LastRecordIndicator - 689))
      | (1ULL << (RpgParser::HaltIndicator - 689))
      | (1ULL << (RpgParser::ReturnIndicator - 689))
      | (1ULL << (RpgParser::ExternalIndicator - 689)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Is_external_fieldContext ------------------------------------------------------------------

RpgParser::Is_external_fieldContext::Is_external_fieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Is_external_fieldContext::IF_Name() {
  return getToken(RpgParser::IF_Name, 0);
}

tree::TerminalNode* RpgParser::Is_external_fieldContext::IF_FieldName() {
  return getToken(RpgParser::IF_FieldName, 0);
}

RpgParser::ControlLevelIndicatorContext* RpgParser::Is_external_fieldContext::controlLevelIndicator() {
  return getRuleContext<RpgParser::ControlLevelIndicatorContext>(0);
}

RpgParser::MatchingFieldsIndicatorContext* RpgParser::Is_external_fieldContext::matchingFieldsIndicator() {
  return getRuleContext<RpgParser::MatchingFieldsIndicatorContext>(0);
}

std::vector<RpgParser::ResultIndicatorContext *> RpgParser::Is_external_fieldContext::resultIndicator() {
  return getRuleContexts<RpgParser::ResultIndicatorContext>();
}

RpgParser::ResultIndicatorContext* RpgParser::Is_external_fieldContext::resultIndicator(size_t i) {
  return getRuleContext<RpgParser::ResultIndicatorContext>(i);
}


size_t RpgParser::Is_external_fieldContext::getRuleIndex() const {
  return RpgParser::RuleIs_external_field;
}

void RpgParser::Is_external_fieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIs_external_field(this);
}

void RpgParser::Is_external_fieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIs_external_field(this);
}


antlrcpp::Any RpgParser::Is_external_fieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIs_external_field(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Is_external_fieldContext* RpgParser::is_external_field() {
  Is_external_fieldContext *_localctx = _tracker.createInstance<Is_external_fieldContext>(_ctx, getState());
  enterRule(_localctx, 746, RpgParser::RuleIs_external_field);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4202);
    match(RpgParser::IF_Name);
    setState(4203);
    match(RpgParser::IF_FieldName);
    setState(4204);
    controlLevelIndicator();
    setState(4205);
    matchingFieldsIndicator();
    setState(4206);
    resultIndicator();
    setState(4207);
    resultIndicator();
    setState(4208);
    resultIndicator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ControlLevelIndicatorContext ------------------------------------------------------------------

RpgParser::ControlLevelIndicatorContext::ControlLevelIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ControlLevelIndicatorContext::ControlLevelIndicator() {
  return getToken(RpgParser::ControlLevelIndicator, 0);
}

tree::TerminalNode* RpgParser::ControlLevelIndicatorContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}


size_t RpgParser::ControlLevelIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleControlLevelIndicator;
}

void RpgParser::ControlLevelIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControlLevelIndicator(this);
}

void RpgParser::ControlLevelIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControlLevelIndicator(this);
}


antlrcpp::Any RpgParser::ControlLevelIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitControlLevelIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ControlLevelIndicatorContext* RpgParser::controlLevelIndicator() {
  ControlLevelIndicatorContext *_localctx = _tracker.createInstance<ControlLevelIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 748, RpgParser::RuleControlLevelIndicator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4210);
    _la = _input->LA(1);
    if (!(_la == RpgParser::BlankIndicator

    || _la == RpgParser::ControlLevelIndicator)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchingFieldsIndicatorContext ------------------------------------------------------------------

RpgParser::MatchingFieldsIndicatorContext::MatchingFieldsIndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::MatchingFieldsIndicatorContext::MatchingRecordIndicator() {
  return getToken(RpgParser::MatchingRecordIndicator, 0);
}

tree::TerminalNode* RpgParser::MatchingFieldsIndicatorContext::BlankIndicator() {
  return getToken(RpgParser::BlankIndicator, 0);
}


size_t RpgParser::MatchingFieldsIndicatorContext::getRuleIndex() const {
  return RpgParser::RuleMatchingFieldsIndicator;
}

void RpgParser::MatchingFieldsIndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchingFieldsIndicator(this);
}

void RpgParser::MatchingFieldsIndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchingFieldsIndicator(this);
}


antlrcpp::Any RpgParser::MatchingFieldsIndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitMatchingFieldsIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::MatchingFieldsIndicatorContext* RpgParser::matchingFieldsIndicator() {
  MatchingFieldsIndicatorContext *_localctx = _tracker.createInstance<MatchingFieldsIndicatorContext>(_ctx, getState());
  enterRule(_localctx, 750, RpgParser::RuleMatchingFieldsIndicator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4212);
    _la = _input->LA(1);
    if (!(_la == RpgParser::BlankIndicator

    || _la == RpgParser::MatchingRecordIndicator)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hspec_fixedContext ------------------------------------------------------------------

RpgParser::Hspec_fixedContext::Hspec_fixedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Hspec_fixedContext::HS_FIXED() {
  return getToken(RpgParser::HS_FIXED, 0);
}

RpgParser::Hspec_contentContext* RpgParser::Hspec_fixedContext::hspec_content() {
  return getRuleContext<RpgParser::Hspec_contentContext>(0);
}

tree::TerminalNode* RpgParser::Hspec_fixedContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::Hspec_fixedContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}


size_t RpgParser::Hspec_fixedContext::getRuleIndex() const {
  return RpgParser::RuleHspec_fixed;
}

void RpgParser::Hspec_fixedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHspec_fixed(this);
}

void RpgParser::Hspec_fixedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHspec_fixed(this);
}


antlrcpp::Any RpgParser::Hspec_fixedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitHspec_fixed(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Hspec_fixedContext* RpgParser::hspec_fixed() {
  Hspec_fixedContext *_localctx = _tracker.createInstance<Hspec_fixedContext>(_ctx, getState());
  enterRule(_localctx, 752, RpgParser::RuleHspec_fixed);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4214);
    match(RpgParser::HS_FIXED);
    setState(4215);
    dynamic_cast<Hspec_fixedContext *>(_localctx)->content = hspec_content();
    setState(4216);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hspec_contentContext ------------------------------------------------------------------

RpgParser::Hspec_contentContext::Hspec_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t RpgParser::Hspec_contentContext::getRuleIndex() const {
  return RpgParser::RuleHspec_content;
}

void RpgParser::Hspec_contentContext::copyFrom(Hspec_contentContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SetDeceditContext ------------------------------------------------------------------

RpgParser::Hs_decedit_setContext* RpgParser::SetDeceditContext::hs_decedit_set() {
  return getRuleContext<RpgParser::Hs_decedit_setContext>(0);
}

RpgParser::SetDeceditContext::SetDeceditContext(Hspec_contentContext *ctx) { copyFrom(ctx); }

void RpgParser::SetDeceditContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetDecedit(this);
}
void RpgParser::SetDeceditContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetDecedit(this);
}

antlrcpp::Any RpgParser::SetDeceditContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSetDecedit(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HspecExpressionsContext ------------------------------------------------------------------

std::vector<RpgParser::Hs_expressionContext *> RpgParser::HspecExpressionsContext::hs_expression() {
  return getRuleContexts<RpgParser::Hs_expressionContext>();
}

RpgParser::Hs_expressionContext* RpgParser::HspecExpressionsContext::hs_expression(size_t i) {
  return getRuleContext<RpgParser::Hs_expressionContext>(i);
}

RpgParser::HspecExpressionsContext::HspecExpressionsContext(Hspec_contentContext *ctx) { copyFrom(ctx); }

void RpgParser::HspecExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHspecExpressions(this);
}
void RpgParser::HspecExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHspecExpressions(this);
}

antlrcpp::Any RpgParser::HspecExpressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitHspecExpressions(this);
  else
    return visitor->visitChildren(this);
}
RpgParser::Hspec_contentContext* RpgParser::hspec_content() {
  Hspec_contentContext *_localctx = _tracker.createInstance<Hspec_contentContext>(_ctx, getState());
  enterRule(_localctx, 754, RpgParser::RuleHspec_content);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4225);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::HS_DECEDIT: {
        _localctx = dynamic_cast<Hspec_contentContext *>(_tracker.createInstance<RpgParser::SetDeceditContext>(_localctx));
        enterOuterAlt(_localctx, 1);
        setState(4218);
        hs_decedit_set();
        break;
      }

      case RpgParser::EOF:
      case RpgParser::ID:
      case RpgParser::EOL: {
        _localctx = dynamic_cast<Hspec_contentContext *>(_tracker.createInstance<RpgParser::HspecExpressionsContext>(_localctx));
        enterOuterAlt(_localctx, 2);
        setState(4222);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == RpgParser::ID) {
          setState(4219);
          hs_expression();
          setState(4224);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hs_decedit_setContext ------------------------------------------------------------------

RpgParser::Hs_decedit_setContext::Hs_decedit_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Hs_decedit_setContext::HS_DECEDIT() {
  return getToken(RpgParser::HS_DECEDIT, 0);
}

tree::TerminalNode* RpgParser::Hs_decedit_setContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::Hs_parmContext* RpgParser::Hs_decedit_setContext::hs_parm() {
  return getRuleContext<RpgParser::Hs_parmContext>(0);
}

tree::TerminalNode* RpgParser::Hs_decedit_setContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Hs_decedit_setContext::getRuleIndex() const {
  return RpgParser::RuleHs_decedit_set;
}

void RpgParser::Hs_decedit_setContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHs_decedit_set(this);
}

void RpgParser::Hs_decedit_setContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHs_decedit_set(this);
}


antlrcpp::Any RpgParser::Hs_decedit_setContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitHs_decedit_set(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Hs_decedit_setContext* RpgParser::hs_decedit_set() {
  Hs_decedit_setContext *_localctx = _tracker.createInstance<Hs_decedit_setContext>(_ctx, getState());
  enterRule(_localctx, 756, RpgParser::RuleHs_decedit_set);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4227);
    match(RpgParser::HS_DECEDIT);
    setState(4232);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4228);
      match(RpgParser::OPEN_PAREN);
      setState(4229);
      hs_parm();
      setState(4230);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hs_expressionContext ------------------------------------------------------------------

RpgParser::Hs_expressionContext::Hs_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Hs_expressionContext::ID() {
  return getToken(RpgParser::ID, 0);
}

tree::TerminalNode* RpgParser::Hs_expressionContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Hs_expressionContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::Hs_parmContext *> RpgParser::Hs_expressionContext::hs_parm() {
  return getRuleContexts<RpgParser::Hs_parmContext>();
}

RpgParser::Hs_parmContext* RpgParser::Hs_expressionContext::hs_parm(size_t i) {
  return getRuleContext<RpgParser::Hs_parmContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Hs_expressionContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Hs_expressionContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Hs_expressionContext::getRuleIndex() const {
  return RpgParser::RuleHs_expression;
}

void RpgParser::Hs_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHs_expression(this);
}

void RpgParser::Hs_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHs_expression(this);
}


antlrcpp::Any RpgParser::Hs_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitHs_expression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Hs_expressionContext* RpgParser::hs_expression() {
  Hs_expressionContext *_localctx = _tracker.createInstance<Hs_expressionContext>(_ctx, getState());
  enterRule(_localctx, 758, RpgParser::RuleHs_expression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4234);
    match(RpgParser::ID);
    setState(4247);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4235);
      match(RpgParser::OPEN_PAREN);
      setState(4244);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::ID || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276)))) != 0) || _la == RpgParser::StringLiteralStart) {
        setState(4236);
        hs_parm();
        setState(4241);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == RpgParser::COLON) {
          setState(4237);
          match(RpgParser::COLON);
          setState(4238);
          hs_parm();
          setState(4243);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(4246);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hs_parmContext ------------------------------------------------------------------

RpgParser::Hs_parmContext::Hs_parmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Hs_parmContext::ID() {
  return getToken(RpgParser::ID, 0);
}

RpgParser::Hs_stringContext* RpgParser::Hs_parmContext::hs_string() {
  return getRuleContext<RpgParser::Hs_stringContext>(0);
}

RpgParser::SymbolicConstantsContext* RpgParser::Hs_parmContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}


size_t RpgParser::Hs_parmContext::getRuleIndex() const {
  return RpgParser::RuleHs_parm;
}

void RpgParser::Hs_parmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHs_parm(this);
}

void RpgParser::Hs_parmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHs_parm(this);
}


antlrcpp::Any RpgParser::Hs_parmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitHs_parm(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Hs_parmContext* RpgParser::hs_parm() {
  Hs_parmContext *_localctx = _tracker.createInstance<Hs_parmContext>(_ctx, getState());
  enterRule(_localctx, 760, RpgParser::RuleHs_parm);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4252);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(4249);
        match(RpgParser::ID);
        break;
      }

      case RpgParser::StringLiteralStart: {
        enterOuterAlt(_localctx, 2);
        setState(4250);
        hs_string();
        break;
      }

      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS: {
        enterOuterAlt(_localctx, 3);
        setState(4251);
        symbolicConstants();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hs_stringContext ------------------------------------------------------------------

RpgParser::Hs_stringContext::Hs_stringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Hs_stringContext::StringLiteralStart() {
  return getToken(RpgParser::StringLiteralStart, 0);
}

tree::TerminalNode* RpgParser::Hs_stringContext::StringLiteralEnd() {
  return getToken(RpgParser::StringLiteralEnd, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Hs_stringContext::StringContent() {
  return getTokens(RpgParser::StringContent);
}

tree::TerminalNode* RpgParser::Hs_stringContext::StringContent(size_t i) {
  return getToken(RpgParser::StringContent, i);
}

std::vector<tree::TerminalNode *> RpgParser::Hs_stringContext::StringEscapedQuote() {
  return getTokens(RpgParser::StringEscapedQuote);
}

tree::TerminalNode* RpgParser::Hs_stringContext::StringEscapedQuote(size_t i) {
  return getToken(RpgParser::StringEscapedQuote, i);
}


size_t RpgParser::Hs_stringContext::getRuleIndex() const {
  return RpgParser::RuleHs_string;
}

void RpgParser::Hs_stringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHs_string(this);
}

void RpgParser::Hs_stringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHs_string(this);
}


antlrcpp::Any RpgParser::Hs_stringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitHs_string(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Hs_stringContext* RpgParser::hs_string() {
  Hs_stringContext *_localctx = _tracker.createInstance<Hs_stringContext>(_ctx, getState());
  enterRule(_localctx, 762, RpgParser::RuleHs_string);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4254);
    match(RpgParser::StringLiteralStart);
    setState(4258);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::StringContent

    || _la == RpgParser::StringEscapedQuote) {
      setState(4255);
      dynamic_cast<Hs_stringContext *>(_localctx)->_tset8132 = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == RpgParser::StringContent

      || _la == RpgParser::StringEscapedQuote)) {
        dynamic_cast<Hs_stringContext *>(_localctx)->_tset8132 = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      dynamic_cast<Hs_stringContext *>(_localctx)->content.push_back(dynamic_cast<Hs_stringContext *>(_localctx)->_tset8132);
      setState(4260);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4261);
    match(RpgParser::StringLiteralEnd);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Blank_lineContext ------------------------------------------------------------------

RpgParser::Blank_lineContext::Blank_lineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Blank_lineContext::BLANK_LINE() {
  return getToken(RpgParser::BLANK_LINE, 0);
}


size_t RpgParser::Blank_lineContext::getRuleIndex() const {
  return RpgParser::RuleBlank_line;
}

void RpgParser::Blank_lineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlank_line(this);
}

void RpgParser::Blank_lineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlank_line(this);
}


antlrcpp::Any RpgParser::Blank_lineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBlank_line(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Blank_lineContext* RpgParser::blank_line() {
  Blank_lineContext *_localctx = _tracker.createInstance<Blank_lineContext>(_ctx, getState());
  enterRule(_localctx, 764, RpgParser::RuleBlank_line);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4263);
    match(RpgParser::BLANK_LINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectiveContext ------------------------------------------------------------------

RpgParser::DirectiveContext::DirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::DirectiveContext::DIRECTIVE() {
  return getToken(RpgParser::DIRECTIVE, 0);
}

tree::TerminalNode* RpgParser::DirectiveContext::EOL() {
  return getToken(RpgParser::EOL, 0);
}

tree::TerminalNode* RpgParser::DirectiveContext::EOF() {
  return getToken(RpgParser::EOF, 0);
}

RpgParser::Beginfree_directiveContext* RpgParser::DirectiveContext::beginfree_directive() {
  return getRuleContext<RpgParser::Beginfree_directiveContext>(0);
}

RpgParser::Endfree_directiveContext* RpgParser::DirectiveContext::endfree_directive() {
  return getRuleContext<RpgParser::Endfree_directiveContext>(0);
}

RpgParser::Title_directiveContext* RpgParser::DirectiveContext::title_directive() {
  return getRuleContext<RpgParser::Title_directiveContext>(0);
}

tree::TerminalNode* RpgParser::DirectiveContext::DIR_EJECT() {
  return getToken(RpgParser::DIR_EJECT, 0);
}

RpgParser::Space_directiveContext* RpgParser::DirectiveContext::space_directive() {
  return getRuleContext<RpgParser::Space_directiveContext>(0);
}

tree::TerminalNode* RpgParser::DirectiveContext::DIR_SET() {
  return getToken(RpgParser::DIR_SET, 0);
}

tree::TerminalNode* RpgParser::DirectiveContext::DIR_RESTORE() {
  return getToken(RpgParser::DIR_RESTORE, 0);
}

RpgParser::Dir_copyContext* RpgParser::DirectiveContext::dir_copy() {
  return getRuleContext<RpgParser::Dir_copyContext>(0);
}

RpgParser::Dir_includeContext* RpgParser::DirectiveContext::dir_include() {
  return getRuleContext<RpgParser::Dir_includeContext>(0);
}

RpgParser::Dir_eofContext* RpgParser::DirectiveContext::dir_eof() {
  return getRuleContext<RpgParser::Dir_eofContext>(0);
}

RpgParser::Dir_defineContext* RpgParser::DirectiveContext::dir_define() {
  return getRuleContext<RpgParser::Dir_defineContext>(0);
}

RpgParser::Dir_undefineContext* RpgParser::DirectiveContext::dir_undefine() {
  return getRuleContext<RpgParser::Dir_undefineContext>(0);
}

RpgParser::Dir_ifContext* RpgParser::DirectiveContext::dir_if() {
  return getRuleContext<RpgParser::Dir_ifContext>(0);
}

RpgParser::Dir_elseifContext* RpgParser::DirectiveContext::dir_elseif() {
  return getRuleContext<RpgParser::Dir_elseifContext>(0);
}

RpgParser::Dir_elseContext* RpgParser::DirectiveContext::dir_else() {
  return getRuleContext<RpgParser::Dir_elseContext>(0);
}

RpgParser::Dir_endifContext* RpgParser::DirectiveContext::dir_endif() {
  return getRuleContext<RpgParser::Dir_endifContext>(0);
}


size_t RpgParser::DirectiveContext::getRuleIndex() const {
  return RpgParser::RuleDirective;
}

void RpgParser::DirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirective(this);
}

void RpgParser::DirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirective(this);
}


antlrcpp::Any RpgParser::DirectiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDirective(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DirectiveContext* RpgParser::directive() {
  DirectiveContext *_localctx = _tracker.createInstance<DirectiveContext>(_ctx, getState());
  enterRule(_localctx, 766, RpgParser::RuleDirective);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4265);
    match(RpgParser::DIRECTIVE);
    setState(4282);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::DIR_FREE: {
        setState(4266);
        beginfree_directive();
        break;
      }

      case RpgParser::DIR_ENDFREE: {
        setState(4267);
        endfree_directive();
        break;
      }

      case RpgParser::DIR_TITLE: {
        setState(4268);
        title_directive();
        break;
      }

      case RpgParser::DIR_EJECT: {
        setState(4269);
        match(RpgParser::DIR_EJECT);
        break;
      }

      case RpgParser::DIR_SPACE: {
        setState(4270);
        space_directive();
        break;
      }

      case RpgParser::DIR_SET: {
        setState(4271);
        match(RpgParser::DIR_SET);
        break;
      }

      case RpgParser::DIR_RESTORE: {
        setState(4272);
        match(RpgParser::DIR_RESTORE);
        break;
      }

      case RpgParser::DIR_COPY: {
        setState(4273);
        dir_copy();
        break;
      }

      case RpgParser::DIR_INCLUDE: {
        setState(4274);
        dir_include();
        break;
      }

      case RpgParser::DIR_EOF: {
        setState(4275);
        dir_eof();
        break;
      }

      case RpgParser::DIR_DEFINE: {
        setState(4276);
        dir_define();
        break;
      }

      case RpgParser::DIR_UNDEFINE: {
        setState(4277);
        dir_undefine();
        break;
      }

      case RpgParser::DIR_IF: {
        setState(4278);
        dir_if();
        break;
      }

      case RpgParser::DIR_ELSEIF: {
        setState(4279);
        dir_elseif();
        break;
      }

      case RpgParser::DIR_ELSE: {
        setState(4280);
        dir_else();
        break;
      }

      case RpgParser::DIR_ENDIF: {
        setState(4281);
        dir_endif();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4284);
    _la = _input->LA(1);
    if (!(_la == RpgParser::EOF || _la == RpgParser::EOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Space_directiveContext ------------------------------------------------------------------

RpgParser::Space_directiveContext::Space_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Space_directiveContext::DIR_SPACE() {
  return getToken(RpgParser::DIR_SPACE, 0);
}

tree::TerminalNode* RpgParser::Space_directiveContext::NUMBER() {
  return getToken(RpgParser::NUMBER, 0);
}


size_t RpgParser::Space_directiveContext::getRuleIndex() const {
  return RpgParser::RuleSpace_directive;
}

void RpgParser::Space_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpace_directive(this);
}

void RpgParser::Space_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpace_directive(this);
}


antlrcpp::Any RpgParser::Space_directiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSpace_directive(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Space_directiveContext* RpgParser::space_directive() {
  Space_directiveContext *_localctx = _tracker.createInstance<Space_directiveContext>(_ctx, getState());
  enterRule(_localctx, 768, RpgParser::RuleSpace_directive);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4286);
    match(RpgParser::DIR_SPACE);
    setState(4288);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::NUMBER) {
      setState(4287);
      match(RpgParser::NUMBER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_copyContext ------------------------------------------------------------------

RpgParser::Dir_copyContext::Dir_copyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_copyContext::DIR_COPY() {
  return getToken(RpgParser::DIR_COPY, 0);
}

std::vector<RpgParser::CopyTextContext *> RpgParser::Dir_copyContext::copyText() {
  return getRuleContexts<RpgParser::CopyTextContext>();
}

RpgParser::CopyTextContext* RpgParser::Dir_copyContext::copyText(size_t i) {
  return getRuleContext<RpgParser::CopyTextContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Dir_copyContext::DIR_Slash() {
  return getTokens(RpgParser::DIR_Slash);
}

tree::TerminalNode* RpgParser::Dir_copyContext::DIR_Slash(size_t i) {
  return getToken(RpgParser::DIR_Slash, i);
}


size_t RpgParser::Dir_copyContext::getRuleIndex() const {
  return RpgParser::RuleDir_copy;
}

void RpgParser::Dir_copyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_copy(this);
}

void RpgParser::Dir_copyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_copy(this);
}


antlrcpp::Any RpgParser::Dir_copyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_copy(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_copyContext* RpgParser::dir_copy() {
  Dir_copyContext *_localctx = _tracker.createInstance<Dir_copyContext>(_ctx, getState());
  enterRule(_localctx, 770, RpgParser::RuleDir_copy);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4290);
    match(RpgParser::DIR_COPY);
    setState(4312);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
    case 1: {
      setState(4297);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
      case 1: {
        setState(4294);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
        case 1: {
          setState(4291);
          dynamic_cast<Dir_copyContext *>(_localctx)->library = copyText();
          setState(4292);
          match(RpgParser::DIR_Slash);
          break;
        }

        }
        setState(4296);
        dynamic_cast<Dir_copyContext *>(_localctx)->file = copyText();
        break;
      }

      }
      setState(4299);
      dynamic_cast<Dir_copyContext *>(_localctx)->member = copyText();
      break;
    }

    case 2: {
      setState(4301);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::DIR_Slash) {
        setState(4300);
        match(RpgParser::DIR_Slash);
      }
      setState(4306); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4303);
                copyText();
                setState(4304);
                match(RpgParser::DIR_Slash);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4308); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(4310);
      copyText();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_includeContext ------------------------------------------------------------------

RpgParser::Dir_includeContext::Dir_includeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_includeContext::DIR_INCLUDE() {
  return getToken(RpgParser::DIR_INCLUDE, 0);
}

std::vector<RpgParser::CopyTextContext *> RpgParser::Dir_includeContext::copyText() {
  return getRuleContexts<RpgParser::CopyTextContext>();
}

RpgParser::CopyTextContext* RpgParser::Dir_includeContext::copyText(size_t i) {
  return getRuleContext<RpgParser::CopyTextContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Dir_includeContext::DIR_Slash() {
  return getTokens(RpgParser::DIR_Slash);
}

tree::TerminalNode* RpgParser::Dir_includeContext::DIR_Slash(size_t i) {
  return getToken(RpgParser::DIR_Slash, i);
}


size_t RpgParser::Dir_includeContext::getRuleIndex() const {
  return RpgParser::RuleDir_include;
}

void RpgParser::Dir_includeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_include(this);
}

void RpgParser::Dir_includeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_include(this);
}


antlrcpp::Any RpgParser::Dir_includeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_include(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_includeContext* RpgParser::dir_include() {
  Dir_includeContext *_localctx = _tracker.createInstance<Dir_includeContext>(_ctx, getState());
  enterRule(_localctx, 772, RpgParser::RuleDir_include);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4314);
    match(RpgParser::DIR_INCLUDE);
    setState(4336);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
    case 1: {
      setState(4321);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
      case 1: {
        setState(4318);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
        case 1: {
          setState(4315);
          dynamic_cast<Dir_includeContext *>(_localctx)->library = copyText();
          setState(4316);
          match(RpgParser::DIR_Slash);
          break;
        }

        }
        setState(4320);
        dynamic_cast<Dir_includeContext *>(_localctx)->file = copyText();
        break;
      }

      }
      setState(4323);
      dynamic_cast<Dir_includeContext *>(_localctx)->member = copyText();
      break;
    }

    case 2: {
      setState(4325);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::DIR_Slash) {
        setState(4324);
        match(RpgParser::DIR_Slash);
      }
      setState(4330); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4327);
                copyText();
                setState(4328);
                match(RpgParser::DIR_Slash);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4332); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(4334);
      copyText();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_ifContext ------------------------------------------------------------------

RpgParser::Dir_ifContext::Dir_ifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_ifContext::DIR_IF() {
  return getToken(RpgParser::DIR_IF, 0);
}

tree::TerminalNode* RpgParser::Dir_ifContext::DIR_DEFINED() {
  return getToken(RpgParser::DIR_DEFINED, 0);
}

tree::TerminalNode* RpgParser::Dir_ifContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::CopyTextContext* RpgParser::Dir_ifContext::copyText() {
  return getRuleContext<RpgParser::CopyTextContext>(0);
}

tree::TerminalNode* RpgParser::Dir_ifContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Dir_ifContext::DIR_NOT() {
  return getToken(RpgParser::DIR_NOT, 0);
}


size_t RpgParser::Dir_ifContext::getRuleIndex() const {
  return RpgParser::RuleDir_if;
}

void RpgParser::Dir_ifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_if(this);
}

void RpgParser::Dir_ifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_if(this);
}


antlrcpp::Any RpgParser::Dir_ifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_if(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_ifContext* RpgParser::dir_if() {
  Dir_ifContext *_localctx = _tracker.createInstance<Dir_ifContext>(_ctx, getState());
  enterRule(_localctx, 774, RpgParser::RuleDir_if);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4338);
    match(RpgParser::DIR_IF);
    setState(4340);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::DIR_NOT) {
      setState(4339);
      dynamic_cast<Dir_ifContext *>(_localctx)->noot = match(RpgParser::DIR_NOT);
    }
    setState(4342);
    match(RpgParser::DIR_DEFINED);
    setState(4343);
    match(RpgParser::OPEN_PAREN);
    setState(4344);
    copyText();
    setState(4345);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_elseifContext ------------------------------------------------------------------

RpgParser::Dir_elseifContext::Dir_elseifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_elseifContext::DIR_ELSEIF() {
  return getToken(RpgParser::DIR_ELSEIF, 0);
}

tree::TerminalNode* RpgParser::Dir_elseifContext::DIR_DEFINED() {
  return getToken(RpgParser::DIR_DEFINED, 0);
}

tree::TerminalNode* RpgParser::Dir_elseifContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::CopyTextContext* RpgParser::Dir_elseifContext::copyText() {
  return getRuleContext<RpgParser::CopyTextContext>(0);
}

tree::TerminalNode* RpgParser::Dir_elseifContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Dir_elseifContext::DIR_NOT() {
  return getToken(RpgParser::DIR_NOT, 0);
}


size_t RpgParser::Dir_elseifContext::getRuleIndex() const {
  return RpgParser::RuleDir_elseif;
}

void RpgParser::Dir_elseifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_elseif(this);
}

void RpgParser::Dir_elseifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_elseif(this);
}


antlrcpp::Any RpgParser::Dir_elseifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_elseif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_elseifContext* RpgParser::dir_elseif() {
  Dir_elseifContext *_localctx = _tracker.createInstance<Dir_elseifContext>(_ctx, getState());
  enterRule(_localctx, 776, RpgParser::RuleDir_elseif);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4347);
    match(RpgParser::DIR_ELSEIF);
    setState(4349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::DIR_NOT) {
      setState(4348);
      dynamic_cast<Dir_elseifContext *>(_localctx)->noot = match(RpgParser::DIR_NOT);
    }
    setState(4351);
    match(RpgParser::DIR_DEFINED);
    setState(4352);
    match(RpgParser::OPEN_PAREN);
    setState(4353);
    copyText();
    setState(4354);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_elseContext ------------------------------------------------------------------

RpgParser::Dir_elseContext::Dir_elseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_elseContext::DIR_ELSE() {
  return getToken(RpgParser::DIR_ELSE, 0);
}


size_t RpgParser::Dir_elseContext::getRuleIndex() const {
  return RpgParser::RuleDir_else;
}

void RpgParser::Dir_elseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_else(this);
}

void RpgParser::Dir_elseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_else(this);
}


antlrcpp::Any RpgParser::Dir_elseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_else(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_elseContext* RpgParser::dir_else() {
  Dir_elseContext *_localctx = _tracker.createInstance<Dir_elseContext>(_ctx, getState());
  enterRule(_localctx, 778, RpgParser::RuleDir_else);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4356);
    match(RpgParser::DIR_ELSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_endifContext ------------------------------------------------------------------

RpgParser::Dir_endifContext::Dir_endifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_endifContext::DIR_ENDIF() {
  return getToken(RpgParser::DIR_ENDIF, 0);
}


size_t RpgParser::Dir_endifContext::getRuleIndex() const {
  return RpgParser::RuleDir_endif;
}

void RpgParser::Dir_endifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_endif(this);
}

void RpgParser::Dir_endifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_endif(this);
}


antlrcpp::Any RpgParser::Dir_endifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_endif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_endifContext* RpgParser::dir_endif() {
  Dir_endifContext *_localctx = _tracker.createInstance<Dir_endifContext>(_ctx, getState());
  enterRule(_localctx, 780, RpgParser::RuleDir_endif);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4358);
    match(RpgParser::DIR_ENDIF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_defineContext ------------------------------------------------------------------

RpgParser::Dir_defineContext::Dir_defineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_defineContext::DIR_DEFINE() {
  return getToken(RpgParser::DIR_DEFINE, 0);
}

tree::TerminalNode* RpgParser::Dir_defineContext::DIR_OtherText() {
  return getToken(RpgParser::DIR_OtherText, 0);
}


size_t RpgParser::Dir_defineContext::getRuleIndex() const {
  return RpgParser::RuleDir_define;
}

void RpgParser::Dir_defineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_define(this);
}

void RpgParser::Dir_defineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_define(this);
}


antlrcpp::Any RpgParser::Dir_defineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_define(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_defineContext* RpgParser::dir_define() {
  Dir_defineContext *_localctx = _tracker.createInstance<Dir_defineContext>(_ctx, getState());
  enterRule(_localctx, 782, RpgParser::RuleDir_define);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4360);
    match(RpgParser::DIR_DEFINE);
    setState(4361);
    dynamic_cast<Dir_defineContext *>(_localctx)->name = match(RpgParser::DIR_OtherText);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_undefineContext ------------------------------------------------------------------

RpgParser::Dir_undefineContext::Dir_undefineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_undefineContext::DIR_UNDEFINE() {
  return getToken(RpgParser::DIR_UNDEFINE, 0);
}

tree::TerminalNode* RpgParser::Dir_undefineContext::DIR_OtherText() {
  return getToken(RpgParser::DIR_OtherText, 0);
}


size_t RpgParser::Dir_undefineContext::getRuleIndex() const {
  return RpgParser::RuleDir_undefine;
}

void RpgParser::Dir_undefineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_undefine(this);
}

void RpgParser::Dir_undefineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_undefine(this);
}


antlrcpp::Any RpgParser::Dir_undefineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_undefine(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_undefineContext* RpgParser::dir_undefine() {
  Dir_undefineContext *_localctx = _tracker.createInstance<Dir_undefineContext>(_ctx, getState());
  enterRule(_localctx, 784, RpgParser::RuleDir_undefine);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4363);
    match(RpgParser::DIR_UNDEFINE);
    setState(4364);
    dynamic_cast<Dir_undefineContext *>(_localctx)->name = match(RpgParser::DIR_OtherText);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dir_eofContext ------------------------------------------------------------------

RpgParser::Dir_eofContext::Dir_eofContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Dir_eofContext::DIR_EOF() {
  return getToken(RpgParser::DIR_EOF, 0);
}


size_t RpgParser::Dir_eofContext::getRuleIndex() const {
  return RpgParser::RuleDir_eof;
}

void RpgParser::Dir_eofContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDir_eof(this);
}

void RpgParser::Dir_eofContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDir_eof(this);
}


antlrcpp::Any RpgParser::Dir_eofContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDir_eof(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Dir_eofContext* RpgParser::dir_eof() {
  Dir_eofContext *_localctx = _tracker.createInstance<Dir_eofContext>(_ctx, getState());
  enterRule(_localctx, 786, RpgParser::RuleDir_eof);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4366);
    match(RpgParser::DIR_EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Beginfree_directiveContext ------------------------------------------------------------------

RpgParser::Beginfree_directiveContext::Beginfree_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Beginfree_directiveContext::DIR_FREE() {
  return getToken(RpgParser::DIR_FREE, 0);
}


size_t RpgParser::Beginfree_directiveContext::getRuleIndex() const {
  return RpgParser::RuleBeginfree_directive;
}

void RpgParser::Beginfree_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginfree_directive(this);
}

void RpgParser::Beginfree_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginfree_directive(this);
}


antlrcpp::Any RpgParser::Beginfree_directiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBeginfree_directive(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Beginfree_directiveContext* RpgParser::beginfree_directive() {
  Beginfree_directiveContext *_localctx = _tracker.createInstance<Beginfree_directiveContext>(_ctx, getState());
  enterRule(_localctx, 788, RpgParser::RuleBeginfree_directive);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4368);
    match(RpgParser::DIR_FREE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Endfree_directiveContext ------------------------------------------------------------------

RpgParser::Endfree_directiveContext::Endfree_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Endfree_directiveContext::DIR_ENDFREE() {
  return getToken(RpgParser::DIR_ENDFREE, 0);
}


size_t RpgParser::Endfree_directiveContext::getRuleIndex() const {
  return RpgParser::RuleEndfree_directive;
}

void RpgParser::Endfree_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEndfree_directive(this);
}

void RpgParser::Endfree_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEndfree_directive(this);
}


antlrcpp::Any RpgParser::Endfree_directiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEndfree_directive(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Endfree_directiveContext* RpgParser::endfree_directive() {
  Endfree_directiveContext *_localctx = _tracker.createInstance<Endfree_directiveContext>(_ctx, getState());
  enterRule(_localctx, 790, RpgParser::RuleEndfree_directive);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4370);
    match(RpgParser::DIR_ENDFREE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CopyTextContext ------------------------------------------------------------------

RpgParser::CopyTextContext::CopyTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::CopyTextContext::DIR_OtherText() {
  return getToken(RpgParser::DIR_OtherText, 0);
}

tree::TerminalNode* RpgParser::CopyTextContext::StringLiteralStart() {
  return getToken(RpgParser::StringLiteralStart, 0);
}

tree::TerminalNode* RpgParser::CopyTextContext::StringContent() {
  return getToken(RpgParser::StringContent, 0);
}

tree::TerminalNode* RpgParser::CopyTextContext::StringLiteralEnd() {
  return getToken(RpgParser::StringLiteralEnd, 0);
}

tree::TerminalNode* RpgParser::CopyTextContext::DIR_NOT() {
  return getToken(RpgParser::DIR_NOT, 0);
}

tree::TerminalNode* RpgParser::CopyTextContext::DIR_DEFINE() {
  return getToken(RpgParser::DIR_DEFINE, 0);
}


size_t RpgParser::CopyTextContext::getRuleIndex() const {
  return RpgParser::RuleCopyText;
}

void RpgParser::CopyTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopyText(this);
}

void RpgParser::CopyTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopyText(this);
}


antlrcpp::Any RpgParser::CopyTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitCopyText(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::CopyTextContext* RpgParser::copyText() {
  CopyTextContext *_localctx = _tracker.createInstance<CopyTextContext>(_ctx, getState());
  enterRule(_localctx, 792, RpgParser::RuleCopyText);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4378);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::DIR_OtherText: {
        enterOuterAlt(_localctx, 1);
        setState(4372);
        match(RpgParser::DIR_OtherText);
        break;
      }

      case RpgParser::StringLiteralStart: {
        enterOuterAlt(_localctx, 2);
        setState(4373);
        match(RpgParser::StringLiteralStart);
        setState(4374);
        match(RpgParser::StringContent);
        setState(4375);
        match(RpgParser::StringLiteralEnd);
        break;
      }

      case RpgParser::DIR_NOT: {
        enterOuterAlt(_localctx, 3);
        setState(4376);
        match(RpgParser::DIR_NOT);
        break;
      }

      case RpgParser::DIR_DEFINE: {
        enterOuterAlt(_localctx, 4);
        setState(4377);
        match(RpgParser::DIR_DEFINE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trailing_wsContext ------------------------------------------------------------------

RpgParser::Trailing_wsContext::Trailing_wsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Trailing_wsContext::DIR_FREE_OTHER_TEXT() {
  return getToken(RpgParser::DIR_FREE_OTHER_TEXT, 0);
}


size_t RpgParser::Trailing_wsContext::getRuleIndex() const {
  return RpgParser::RuleTrailing_ws;
}

void RpgParser::Trailing_wsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailing_ws(this);
}

void RpgParser::Trailing_wsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailing_ws(this);
}


antlrcpp::Any RpgParser::Trailing_wsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitTrailing_ws(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Trailing_wsContext* RpgParser::trailing_ws() {
  Trailing_wsContext *_localctx = _tracker.createInstance<Trailing_wsContext>(_ctx, getState());
  enterRule(_localctx, 794, RpgParser::RuleTrailing_ws);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4380);
    match(RpgParser::DIR_FREE_OTHER_TEXT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Title_directiveContext ------------------------------------------------------------------

RpgParser::Title_directiveContext::Title_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Title_directiveContext::DIR_TITLE() {
  return getToken(RpgParser::DIR_TITLE, 0);
}

std::vector<RpgParser::Title_textContext *> RpgParser::Title_directiveContext::title_text() {
  return getRuleContexts<RpgParser::Title_textContext>();
}

RpgParser::Title_textContext* RpgParser::Title_directiveContext::title_text(size_t i) {
  return getRuleContext<RpgParser::Title_textContext>(i);
}


size_t RpgParser::Title_directiveContext::getRuleIndex() const {
  return RpgParser::RuleTitle_directive;
}

void RpgParser::Title_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTitle_directive(this);
}

void RpgParser::Title_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTitle_directive(this);
}


antlrcpp::Any RpgParser::Title_directiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitTitle_directive(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Title_directiveContext* RpgParser::title_directive() {
  Title_directiveContext *_localctx = _tracker.createInstance<Title_directiveContext>(_ctx, getState());
  enterRule(_localctx, 796, RpgParser::RuleTitle_directive);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4382);
    match(RpgParser::DIR_TITLE);
    setState(4386);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::NUMBER

    || _la == RpgParser::DIR_OtherText) {
      setState(4383);
      title_text();
      setState(4388);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Title_textContext ------------------------------------------------------------------

RpgParser::Title_textContext::Title_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Title_textContext::NUMBER() {
  return getToken(RpgParser::NUMBER, 0);
}

tree::TerminalNode* RpgParser::Title_textContext::DIR_OtherText() {
  return getToken(RpgParser::DIR_OtherText, 0);
}


size_t RpgParser::Title_textContext::getRuleIndex() const {
  return RpgParser::RuleTitle_text;
}

void RpgParser::Title_textContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTitle_text(this);
}

void RpgParser::Title_textContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTitle_text(this);
}


antlrcpp::Any RpgParser::Title_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitTitle_text(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Title_textContext* RpgParser::title_text() {
  Title_textContext *_localctx = _tracker.createInstance<Title_textContext>(_ctx, getState());
  enterRule(_localctx, 798, RpgParser::RuleTitle_text);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4389);
    _la = _input->LA(1);
    if (!(_la == RpgParser::NUMBER

    || _la == RpgParser::DIR_OtherText)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpContext ------------------------------------------------------------------

RpgParser::OpContext::OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Op_acqContext* RpgParser::OpContext::op_acq() {
  return getRuleContext<RpgParser::Op_acqContext>(0);
}

RpgParser::Op_callpContext* RpgParser::OpContext::op_callp() {
  return getRuleContext<RpgParser::Op_callpContext>(0);
}

RpgParser::Op_chainContext* RpgParser::OpContext::op_chain() {
  return getRuleContext<RpgParser::Op_chainContext>(0);
}

RpgParser::Op_clearContext* RpgParser::OpContext::op_clear() {
  return getRuleContext<RpgParser::Op_clearContext>(0);
}

RpgParser::Op_closeContext* RpgParser::OpContext::op_close() {
  return getRuleContext<RpgParser::Op_closeContext>(0);
}

RpgParser::Op_commitContext* RpgParser::OpContext::op_commit() {
  return getRuleContext<RpgParser::Op_commitContext>(0);
}

RpgParser::Op_deallocContext* RpgParser::OpContext::op_dealloc() {
  return getRuleContext<RpgParser::Op_deallocContext>(0);
}

RpgParser::Op_deleteContext* RpgParser::OpContext::op_delete() {
  return getRuleContext<RpgParser::Op_deleteContext>(0);
}

RpgParser::Op_dsplyContext* RpgParser::OpContext::op_dsply() {
  return getRuleContext<RpgParser::Op_dsplyContext>(0);
}

RpgParser::Op_dumpContext* RpgParser::OpContext::op_dump() {
  return getRuleContext<RpgParser::Op_dumpContext>(0);
}

RpgParser::Op_evalContext* RpgParser::OpContext::op_eval() {
  return getRuleContext<RpgParser::Op_evalContext>(0);
}

RpgParser::Op_evalrContext* RpgParser::OpContext::op_evalr() {
  return getRuleContext<RpgParser::Op_evalrContext>(0);
}

RpgParser::Op_eval_corrContext* RpgParser::OpContext::op_eval_corr() {
  return getRuleContext<RpgParser::Op_eval_corrContext>(0);
}

RpgParser::Op_exceptContext* RpgParser::OpContext::op_except() {
  return getRuleContext<RpgParser::Op_exceptContext>(0);
}

RpgParser::Op_exfmtContext* RpgParser::OpContext::op_exfmt() {
  return getRuleContext<RpgParser::Op_exfmtContext>(0);
}

RpgParser::Op_exsrContext* RpgParser::OpContext::op_exsr() {
  return getRuleContext<RpgParser::Op_exsrContext>(0);
}

RpgParser::Op_feodContext* RpgParser::OpContext::op_feod() {
  return getRuleContext<RpgParser::Op_feodContext>(0);
}

RpgParser::Op_forceContext* RpgParser::OpContext::op_force() {
  return getRuleContext<RpgParser::Op_forceContext>(0);
}

RpgParser::Op_inContext* RpgParser::OpContext::op_in() {
  return getRuleContext<RpgParser::Op_inContext>(0);
}

RpgParser::Op_iterContext* RpgParser::OpContext::op_iter() {
  return getRuleContext<RpgParser::Op_iterContext>(0);
}

RpgParser::Op_leaveContext* RpgParser::OpContext::op_leave() {
  return getRuleContext<RpgParser::Op_leaveContext>(0);
}

RpgParser::Op_leavesrContext* RpgParser::OpContext::op_leavesr() {
  return getRuleContext<RpgParser::Op_leavesrContext>(0);
}

RpgParser::Op_nextContext* RpgParser::OpContext::op_next() {
  return getRuleContext<RpgParser::Op_nextContext>(0);
}

RpgParser::Op_openContext* RpgParser::OpContext::op_open() {
  return getRuleContext<RpgParser::Op_openContext>(0);
}

RpgParser::Op_outContext* RpgParser::OpContext::op_out() {
  return getRuleContext<RpgParser::Op_outContext>(0);
}

RpgParser::Op_postContext* RpgParser::OpContext::op_post() {
  return getRuleContext<RpgParser::Op_postContext>(0);
}

RpgParser::Op_readContext* RpgParser::OpContext::op_read() {
  return getRuleContext<RpgParser::Op_readContext>(0);
}

RpgParser::Op_readcContext* RpgParser::OpContext::op_readc() {
  return getRuleContext<RpgParser::Op_readcContext>(0);
}

RpgParser::Op_readeContext* RpgParser::OpContext::op_reade() {
  return getRuleContext<RpgParser::Op_readeContext>(0);
}

RpgParser::Op_readpContext* RpgParser::OpContext::op_readp() {
  return getRuleContext<RpgParser::Op_readpContext>(0);
}

RpgParser::Op_readpeContext* RpgParser::OpContext::op_readpe() {
  return getRuleContext<RpgParser::Op_readpeContext>(0);
}

RpgParser::Op_relContext* RpgParser::OpContext::op_rel() {
  return getRuleContext<RpgParser::Op_relContext>(0);
}

RpgParser::Op_resetContext* RpgParser::OpContext::op_reset() {
  return getRuleContext<RpgParser::Op_resetContext>(0);
}

RpgParser::Op_reset2Context* RpgParser::OpContext::op_reset2() {
  return getRuleContext<RpgParser::Op_reset2Context>(0);
}

RpgParser::Op_returnContext* RpgParser::OpContext::op_return() {
  return getRuleContext<RpgParser::Op_returnContext>(0);
}

RpgParser::Op_rolbkContext* RpgParser::OpContext::op_rolbk() {
  return getRuleContext<RpgParser::Op_rolbkContext>(0);
}

RpgParser::Op_setgtContext* RpgParser::OpContext::op_setgt() {
  return getRuleContext<RpgParser::Op_setgtContext>(0);
}

RpgParser::Op_setllContext* RpgParser::OpContext::op_setll() {
  return getRuleContext<RpgParser::Op_setllContext>(0);
}

RpgParser::Op_sortaContext* RpgParser::OpContext::op_sorta() {
  return getRuleContext<RpgParser::Op_sortaContext>(0);
}

RpgParser::Op_testContext* RpgParser::OpContext::op_test() {
  return getRuleContext<RpgParser::Op_testContext>(0);
}

RpgParser::Op_unlockContext* RpgParser::OpContext::op_unlock() {
  return getRuleContext<RpgParser::Op_unlockContext>(0);
}

RpgParser::Op_updateContext* RpgParser::OpContext::op_update() {
  return getRuleContext<RpgParser::Op_updateContext>(0);
}

RpgParser::Op_writeContext* RpgParser::OpContext::op_write() {
  return getRuleContext<RpgParser::Op_writeContext>(0);
}

RpgParser::Op_xml_intoContext* RpgParser::OpContext::op_xml_into() {
  return getRuleContext<RpgParser::Op_xml_intoContext>(0);
}

RpgParser::Op_xml_saxContext* RpgParser::OpContext::op_xml_sax() {
  return getRuleContext<RpgParser::Op_xml_saxContext>(0);
}


size_t RpgParser::OpContext::getRuleIndex() const {
  return RpgParser::RuleOp;
}

void RpgParser::OpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp(this);
}

void RpgParser::OpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp(this);
}


antlrcpp::Any RpgParser::OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OpContext* RpgParser::op() {
  OpContext *_localctx = _tracker.createInstance<OpContext>(_ctx, getState());
  enterRule(_localctx, 800, RpgParser::RuleOp);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4436);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4391);
      op_acq();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4392);
      op_callp();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4393);
      op_chain();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4394);
      op_clear();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4395);
      op_close();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4396);
      op_commit();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4397);
      op_dealloc();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4398);
      op_delete();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4399);
      op_dsply();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4400);
      op_dump();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4401);
      op_eval();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4402);
      op_evalr();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4403);
      op_eval_corr();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(4404);
      op_except();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(4405);
      op_exfmt();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(4406);
      op_exsr();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(4407);
      op_feod();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(4408);
      op_force();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(4409);
      op_in();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(4410);
      op_iter();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(4411);
      op_leave();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(4412);
      op_leavesr();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(4413);
      op_next();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(4414);
      op_open();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(4415);
      op_out();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(4416);
      op_post();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(4417);
      op_read();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(4418);
      op_readc();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(4419);
      op_reade();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(4420);
      op_readp();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(4421);
      op_readpe();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(4422);
      op_rel();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(4423);
      op_reset();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(4424);
      op_reset2();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(4425);
      op_return();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(4426);
      op_rolbk();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(4427);
      op_setgt();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(4428);
      op_setll();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(4429);
      op_sorta();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(4430);
      op_test();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(4431);
      op_unlock();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(4432);
      op_update();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(4433);
      op_write();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(4434);
      op_xml_into();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(4435);
      op_xml_sax();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_acqContext ------------------------------------------------------------------

RpgParser::Op_acqContext::Op_acqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_acqContext::OP_ACQ() {
  return getToken(RpgParser::OP_ACQ, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_acqContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_acqContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_acqContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_acqContext::getRuleIndex() const {
  return RpgParser::RuleOp_acq;
}

void RpgParser::Op_acqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_acq(this);
}

void RpgParser::Op_acqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_acq(this);
}


antlrcpp::Any RpgParser::Op_acqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_acq(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_acqContext* RpgParser::op_acq() {
  Op_acqContext *_localctx = _tracker.createInstance<Op_acqContext>(_ctx, getState());
  enterRule(_localctx, 802, RpgParser::RuleOp_acq);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4438);
    match(RpgParser::OP_ACQ);
    setState(4440);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4439);
      cs_operationExtender();
    }
    setState(4442);
    identifier();
    setState(4443);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_callpContext ------------------------------------------------------------------

RpgParser::Op_callpContext::Op_callpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::IdentifierContext* RpgParser::Op_callpContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::Op_callpContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Op_callpContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Op_callpContext::OP_CALLP() {
  return getToken(RpgParser::OP_CALLP, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Op_callpContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Op_callpContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_callpContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

std::vector<tree::TerminalNode *> RpgParser::Op_callpContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Op_callpContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Op_callpContext::getRuleIndex() const {
  return RpgParser::RuleOp_callp;
}

void RpgParser::Op_callpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_callp(this);
}

void RpgParser::Op_callpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_callp(this);
}


antlrcpp::Any RpgParser::Op_callpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_callp(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_callpContext* RpgParser::op_callp() {
  Op_callpContext *_localctx = _tracker.createInstance<Op_callpContext>(_ctx, getState());
  enterRule(_localctx, 804, RpgParser::RuleOp_callp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4449);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
    case 1: {
      setState(4445);
      match(RpgParser::OP_CALLP);
      setState(4447);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::OPEN_PAREN) {
        setState(4446);
        cs_operationExtender();
      }
      break;
    }

    }
    setState(4451);
    identifier();
    setState(4452);
    match(RpgParser::OPEN_PAREN);
    setState(4461);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::PLUS - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(4453);
      expression(0);
      setState(4458);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == RpgParser::COLON) {
        setState(4454);
        match(RpgParser::COLON);
        setState(4455);
        expression(0);
        setState(4460);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(4463);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_chainContext ------------------------------------------------------------------

RpgParser::Op_chainContext::Op_chainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_chainContext::OP_CHAIN() {
  return getToken(RpgParser::OP_CHAIN, 0);
}

RpgParser::Search_argContext* RpgParser::Op_chainContext::search_arg() {
  return getRuleContext<RpgParser::Search_argContext>(0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_chainContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_chainContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_chainContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_chainContext::getRuleIndex() const {
  return RpgParser::RuleOp_chain;
}

void RpgParser::Op_chainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_chain(this);
}

void RpgParser::Op_chainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_chain(this);
}


antlrcpp::Any RpgParser::Op_chainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_chain(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_chainContext* RpgParser::op_chain() {
  Op_chainContext *_localctx = _tracker.createInstance<Op_chainContext>(_ctx, getState());
  enterRule(_localctx, 806, RpgParser::RuleOp_chain);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4465);
    match(RpgParser::OP_CHAIN);
    setState(4467);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
    case 1: {
      setState(4466);
      cs_operationExtender();
      break;
    }

    }
    setState(4469);
    search_arg();
    setState(4470);
    identifier();
    setState(4472);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4471);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_clearContext ------------------------------------------------------------------

RpgParser::Op_clearContext::Op_clearContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_clearContext::OP_CLEAR() {
  return getToken(RpgParser::OP_CLEAR, 0);
}

RpgParser::ExpressionContext* RpgParser::Op_clearContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_clearContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_clearContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}


size_t RpgParser::Op_clearContext::getRuleIndex() const {
  return RpgParser::RuleOp_clear;
}

void RpgParser::Op_clearContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_clear(this);
}

void RpgParser::Op_clearContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_clear(this);
}


antlrcpp::Any RpgParser::Op_clearContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_clear(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_clearContext* RpgParser::op_clear() {
  Op_clearContext *_localctx = _tracker.createInstance<Op_clearContext>(_ctx, getState());
  enterRule(_localctx, 808, RpgParser::RuleOp_clear);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4474);
    match(RpgParser::OP_CLEAR);
    setState(4476);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
    case 1: {
      setState(4475);
      identifier();
      break;
    }

    }
    setState(4479);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 361, _ctx)) {
    case 1: {
      setState(4478);
      identifier();
      break;
    }

    }
    setState(4481);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_closeContext ------------------------------------------------------------------

RpgParser::Op_closeContext::Op_closeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_closeContext::OP_CLOSE() {
  return getToken(RpgParser::OP_CLOSE, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_closeContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_closeContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_closeContext::getRuleIndex() const {
  return RpgParser::RuleOp_close;
}

void RpgParser::Op_closeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_close(this);
}

void RpgParser::Op_closeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_close(this);
}


antlrcpp::Any RpgParser::Op_closeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_close(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_closeContext* RpgParser::op_close() {
  Op_closeContext *_localctx = _tracker.createInstance<Op_closeContext>(_ctx, getState());
  enterRule(_localctx, 810, RpgParser::RuleOp_close);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4483);
    match(RpgParser::OP_CLOSE);
    setState(4485);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4484);
      cs_operationExtender();
    }
    setState(4487);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_commitContext ------------------------------------------------------------------

RpgParser::Op_commitContext::Op_commitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_commitContext::OP_COMMIT() {
  return getToken(RpgParser::OP_COMMIT, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_commitContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::IdentifierContext* RpgParser::Op_commitContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Op_commitContext::getRuleIndex() const {
  return RpgParser::RuleOp_commit;
}

void RpgParser::Op_commitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_commit(this);
}

void RpgParser::Op_commitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_commit(this);
}


antlrcpp::Any RpgParser::Op_commitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_commit(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_commitContext* RpgParser::op_commit() {
  Op_commitContext *_localctx = _tracker.createInstance<Op_commitContext>(_ctx, getState());
  enterRule(_localctx, 812, RpgParser::RuleOp_commit);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4489);
    match(RpgParser::OP_COMMIT);
    setState(4491);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4490);
      cs_operationExtender();
    }
    setState(4494);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4493);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_deallocContext ------------------------------------------------------------------

RpgParser::Op_deallocContext::Op_deallocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_deallocContext::OP_DEALLOC() {
  return getToken(RpgParser::OP_DEALLOC, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_deallocContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_deallocContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_deallocContext::getRuleIndex() const {
  return RpgParser::RuleOp_dealloc;
}

void RpgParser::Op_deallocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_dealloc(this);
}

void RpgParser::Op_deallocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_dealloc(this);
}


antlrcpp::Any RpgParser::Op_deallocContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_dealloc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_deallocContext* RpgParser::op_dealloc() {
  Op_deallocContext *_localctx = _tracker.createInstance<Op_deallocContext>(_ctx, getState());
  enterRule(_localctx, 814, RpgParser::RuleOp_dealloc);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4496);
    match(RpgParser::OP_DEALLOC);
    setState(4498);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4497);
      cs_operationExtender();
    }
    setState(4500);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_deleteContext ------------------------------------------------------------------

RpgParser::Op_deleteContext::Op_deleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_deleteContext::OP_DELETE() {
  return getToken(RpgParser::OP_DELETE, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_deleteContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_deleteContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::Search_argContext* RpgParser::Op_deleteContext::search_arg() {
  return getRuleContext<RpgParser::Search_argContext>(0);
}


size_t RpgParser::Op_deleteContext::getRuleIndex() const {
  return RpgParser::RuleOp_delete;
}

void RpgParser::Op_deleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_delete(this);
}

void RpgParser::Op_deleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_delete(this);
}


antlrcpp::Any RpgParser::Op_deleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_delete(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_deleteContext* RpgParser::op_delete() {
  Op_deleteContext *_localctx = _tracker.createInstance<Op_deleteContext>(_ctx, getState());
  enterRule(_localctx, 816, RpgParser::RuleOp_delete);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4502);
    match(RpgParser::OP_DELETE);
    setState(4504);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
    case 1: {
      setState(4503);
      cs_operationExtender();
      break;
    }

    }
    setState(4507);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 367, _ctx)) {
    case 1: {
      setState(4506);
      search_arg();
      break;
    }

    }
    setState(4509);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_douContext ------------------------------------------------------------------

RpgParser::Op_douContext::Op_douContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_douContext::OP_DOU() {
  return getToken(RpgParser::OP_DOU, 0);
}

RpgParser::Indicator_exprContext* RpgParser::Op_douContext::indicator_expr() {
  return getRuleContext<RpgParser::Indicator_exprContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_douContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_douContext::getRuleIndex() const {
  return RpgParser::RuleOp_dou;
}

void RpgParser::Op_douContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_dou(this);
}

void RpgParser::Op_douContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_dou(this);
}


antlrcpp::Any RpgParser::Op_douContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_dou(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_douContext* RpgParser::op_dou() {
  Op_douContext *_localctx = _tracker.createInstance<Op_douContext>(_ctx, getState());
  enterRule(_localctx, 818, RpgParser::RuleOp_dou);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4511);
    match(RpgParser::OP_DOU);
    setState(4513);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      setState(4512);
      cs_operationExtender();
      break;
    }

    }
    setState(4515);
    indicator_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_dowContext ------------------------------------------------------------------

RpgParser::Op_dowContext::Op_dowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_dowContext::OP_DOW() {
  return getToken(RpgParser::OP_DOW, 0);
}

RpgParser::Indicator_exprContext* RpgParser::Op_dowContext::indicator_expr() {
  return getRuleContext<RpgParser::Indicator_exprContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_dowContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_dowContext::getRuleIndex() const {
  return RpgParser::RuleOp_dow;
}

void RpgParser::Op_dowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_dow(this);
}

void RpgParser::Op_dowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_dow(this);
}


antlrcpp::Any RpgParser::Op_dowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_dow(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_dowContext* RpgParser::op_dow() {
  Op_dowContext *_localctx = _tracker.createInstance<Op_dowContext>(_ctx, getState());
  enterRule(_localctx, 820, RpgParser::RuleOp_dow);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4517);
    match(RpgParser::OP_DOW);
    setState(4519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
    case 1: {
      setState(4518);
      cs_operationExtender();
      break;
    }

    }
    setState(4521);
    indicator_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_dsplyContext ------------------------------------------------------------------

RpgParser::Op_dsplyContext::Op_dsplyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_dsplyContext::OP_DSPLY() {
  return getToken(RpgParser::OP_DSPLY, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_dsplyContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Op_dsplyContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Op_dsplyContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Op_dsplyContext::getRuleIndex() const {
  return RpgParser::RuleOp_dsply;
}

void RpgParser::Op_dsplyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_dsply(this);
}

void RpgParser::Op_dsplyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_dsply(this);
}


antlrcpp::Any RpgParser::Op_dsplyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_dsply(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_dsplyContext* RpgParser::op_dsply() {
  Op_dsplyContext *_localctx = _tracker.createInstance<Op_dsplyContext>(_ctx, getState());
  enterRule(_localctx, 822, RpgParser::RuleOp_dsply);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4523);
    match(RpgParser::OP_DSPLY);
    setState(4525);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
    case 1: {
      setState(4524);
      cs_operationExtender();
      break;
    }

    }
    setState(4534);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::PLUS - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(4527);
      expression(0);
      setState(4532);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
        | (1ULL << (RpgParser::NUMBER - 20))
        | (1ULL << (RpgParser::ID - 20))
        | (1ULL << (RpgParser::OP_ACQ - 20))
        | (1ULL << (RpgParser::OP_BEGSR - 20))
        | (1ULL << (RpgParser::OP_CALLP - 20))
        | (1ULL << (RpgParser::OP_CHAIN - 20))
        | (1ULL << (RpgParser::OP_CLEAR - 20))
        | (1ULL << (RpgParser::OP_CLOSE - 20))
        | (1ULL << (RpgParser::OP_COMMIT - 20))
        | (1ULL << (RpgParser::OP_DEALLOC - 20))
        | (1ULL << (RpgParser::OP_DELETE - 20))
        | (1ULL << (RpgParser::OP_DSPLY - 20))
        | (1ULL << (RpgParser::OP_DUMP - 20))
        | (1ULL << (RpgParser::OP_ENDSR - 20))
        | (1ULL << (RpgParser::OP_EVAL - 20))
        | (1ULL << (RpgParser::OP_EVALR - 20))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
        | (1ULL << (RpgParser::OP_EXCEPT - 20))
        | (1ULL << (RpgParser::OP_EXFMT - 20))
        | (1ULL << (RpgParser::OP_EXSR - 20))
        | (1ULL << (RpgParser::OP_FEOD - 20))
        | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
        | (1ULL << (RpgParser::OP_ITER - 84))
        | (1ULL << (RpgParser::OP_LEAVE - 84))
        | (1ULL << (RpgParser::OP_LEAVESR - 84))
        | (1ULL << (RpgParser::OP_NEXT - 84))
        | (1ULL << (RpgParser::OP_OPEN - 84))
        | (1ULL << (RpgParser::OP_OTHER - 84))
        | (1ULL << (RpgParser::OP_OUT - 84))
        | (1ULL << (RpgParser::OP_POST - 84))
        | (1ULL << (RpgParser::OP_READ - 84))
        | (1ULL << (RpgParser::OP_READC - 84))
        | (1ULL << (RpgParser::OP_READE - 84))
        | (1ULL << (RpgParser::OP_READP - 84))
        | (1ULL << (RpgParser::OP_READPE - 84))
        | (1ULL << (RpgParser::OP_REL - 84))
        | (1ULL << (RpgParser::OP_RESET - 84))
        | (1ULL << (RpgParser::OP_RETURN - 84))
        | (1ULL << (RpgParser::OP_ROLBK - 84))
        | (1ULL << (RpgParser::OP_SELECT - 84))
        | (1ULL << (RpgParser::OP_SETGT - 84))
        | (1ULL << (RpgParser::OP_SETLL - 84))
        | (1ULL << (RpgParser::OP_SORTA - 84))
        | (1ULL << (RpgParser::OP_TEST - 84))
        | (1ULL << (RpgParser::OP_UNLOCK - 84))
        | (1ULL << (RpgParser::OP_UPDATE - 84))
        | (1ULL << (RpgParser::OP_WHEN - 84))
        | (1ULL << (RpgParser::OP_WRITE - 84))
        | (1ULL << (RpgParser::OP_XML_INTO - 84))
        | (1ULL << (RpgParser::OP_XML_SAX - 84))
        | (1ULL << (RpgParser::BIF_ABS - 84))
        | (1ULL << (RpgParser::BIF_ADDR - 84))
        | (1ULL << (RpgParser::BIF_ALLOC - 84))
        | (1ULL << (RpgParser::BIF_BITAND - 84))
        | (1ULL << (RpgParser::BIF_BITNOT - 84))
        | (1ULL << (RpgParser::BIF_BITOR - 84))
        | (1ULL << (RpgParser::BIF_BITXOR - 84))
        | (1ULL << (RpgParser::BIF_CHAR - 84))
        | (1ULL << (RpgParser::BIF_CHECK - 84))
        | (1ULL << (RpgParser::BIF_CHECKR - 84))
        | (1ULL << (RpgParser::BIF_DATE - 84))
        | (1ULL << (RpgParser::BIF_DAYS - 84))
        | (1ULL << (RpgParser::BIF_DEC - 84))
        | (1ULL << (RpgParser::BIF_DECH - 84))
        | (1ULL << (RpgParser::BIF_DECPOS - 84))
        | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
        | (1ULL << (RpgParser::BIF_EDITC - 148))
        | (1ULL << (RpgParser::BIF_EDITFLT - 148))
        | (1ULL << (RpgParser::BIF_EDITW - 148))
        | (1ULL << (RpgParser::BIF_ELEM - 148))
        | (1ULL << (RpgParser::BIF_EOF - 148))
        | (1ULL << (RpgParser::BIF_EQUAL - 148))
        | (1ULL << (RpgParser::BIF_ERROR - 148))
        | (1ULL << (RpgParser::BIF_FIELDS - 148))
        | (1ULL << (RpgParser::BIF_FLOAT - 148))
        | (1ULL << (RpgParser::BIF_FOUND - 148))
        | (1ULL << (RpgParser::BIF_GRAPH - 148))
        | (1ULL << (RpgParser::BIF_HANDLER - 148))
        | (1ULL << (RpgParser::BIF_HOURS - 148))
        | (1ULL << (RpgParser::BIF_INT - 148))
        | (1ULL << (RpgParser::BIF_INTH - 148))
        | (1ULL << (RpgParser::BIF_KDS - 148))
        | (1ULL << (RpgParser::BIF_LEN - 148))
        | (1ULL << (RpgParser::BIF_LOOKUP - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_MINUTES - 148))
        | (1ULL << (RpgParser::BIF_MONTHS - 148))
        | (1ULL << (RpgParser::BIF_MSECONDS - 148))
        | (1ULL << (RpgParser::BIF_NULLIND - 148))
        | (1ULL << (RpgParser::BIF_OCCUR - 148))
        | (1ULL << (RpgParser::BIF_OPEN - 148))
        | (1ULL << (RpgParser::BIF_PADDR - 148))
        | (1ULL << (RpgParser::BIF_PARMS - 148))
        | (1ULL << (RpgParser::BIF_PARMNUM - 148))
        | (1ULL << (RpgParser::BIF_REALLOC - 148))
        | (1ULL << (RpgParser::BIF_REM - 148))
        | (1ULL << (RpgParser::BIF_REPLACE - 148))
        | (1ULL << (RpgParser::BIF_SCAN - 148))
        | (1ULL << (RpgParser::BIF_SCANRPL - 148))
        | (1ULL << (RpgParser::BIF_SECONDS - 148))
        | (1ULL << (RpgParser::BIF_SHTDN - 148))
        | (1ULL << (RpgParser::BIF_SIZE - 148))
        | (1ULL << (RpgParser::BIF_SQRT - 148))
        | (1ULL << (RpgParser::BIF_STATUS - 148))
        | (1ULL << (RpgParser::BIF_STR - 148))
        | (1ULL << (RpgParser::BIF_SUBARR - 148))
        | (1ULL << (RpgParser::BIF_SUBDT - 148))
        | (1ULL << (RpgParser::BIF_SUBST - 148))
        | (1ULL << (RpgParser::BIF_THIS - 148))
        | (1ULL << (RpgParser::BIF_TIME - 148))
        | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_TRIM - 148))
        | (1ULL << (RpgParser::BIF_TRIML - 148))
        | (1ULL << (RpgParser::BIF_TRIMR - 148))
        | (1ULL << (RpgParser::BIF_UCS2 - 148))
        | (1ULL << (RpgParser::BIF_UNS - 148))
        | (1ULL << (RpgParser::BIF_UNSH - 148))
        | (1ULL << (RpgParser::BIF_XFOOT - 148))
        | (1ULL << (RpgParser::BIF_XLATE - 148))
        | (1ULL << (RpgParser::BIF_XML - 148))
        | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::PLUS - 404))
        | (1ULL << (RpgParser::MINUS - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404))
        | (1ULL << (RpgParser::HexLiteralStart - 404))
        | (1ULL << (RpgParser::DateLiteralStart - 404))
        | (1ULL << (RpgParser::TimeLiteralStart - 404))
        | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
        | (1ULL << (RpgParser::GraphicLiteralStart - 404))
        | (1ULL << (RpgParser::UCS2LiteralStart - 404))
        | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
        setState(4528);
        expression(0);
        setState(4530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 20) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
          | (1ULL << (RpgParser::NUMBER - 20))
          | (1ULL << (RpgParser::ID - 20))
          | (1ULL << (RpgParser::OP_ACQ - 20))
          | (1ULL << (RpgParser::OP_BEGSR - 20))
          | (1ULL << (RpgParser::OP_CALLP - 20))
          | (1ULL << (RpgParser::OP_CHAIN - 20))
          | (1ULL << (RpgParser::OP_CLEAR - 20))
          | (1ULL << (RpgParser::OP_CLOSE - 20))
          | (1ULL << (RpgParser::OP_COMMIT - 20))
          | (1ULL << (RpgParser::OP_DEALLOC - 20))
          | (1ULL << (RpgParser::OP_DELETE - 20))
          | (1ULL << (RpgParser::OP_DSPLY - 20))
          | (1ULL << (RpgParser::OP_DUMP - 20))
          | (1ULL << (RpgParser::OP_ENDSR - 20))
          | (1ULL << (RpgParser::OP_EVAL - 20))
          | (1ULL << (RpgParser::OP_EVALR - 20))
          | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
          | (1ULL << (RpgParser::OP_EXCEPT - 20))
          | (1ULL << (RpgParser::OP_EXFMT - 20))
          | (1ULL << (RpgParser::OP_EXSR - 20))
          | (1ULL << (RpgParser::OP_FEOD - 20))
          | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
          | (1ULL << (RpgParser::OP_ITER - 84))
          | (1ULL << (RpgParser::OP_LEAVE - 84))
          | (1ULL << (RpgParser::OP_LEAVESR - 84))
          | (1ULL << (RpgParser::OP_NEXT - 84))
          | (1ULL << (RpgParser::OP_OPEN - 84))
          | (1ULL << (RpgParser::OP_OTHER - 84))
          | (1ULL << (RpgParser::OP_OUT - 84))
          | (1ULL << (RpgParser::OP_POST - 84))
          | (1ULL << (RpgParser::OP_READ - 84))
          | (1ULL << (RpgParser::OP_READC - 84))
          | (1ULL << (RpgParser::OP_READE - 84))
          | (1ULL << (RpgParser::OP_READP - 84))
          | (1ULL << (RpgParser::OP_READPE - 84))
          | (1ULL << (RpgParser::OP_REL - 84))
          | (1ULL << (RpgParser::OP_RESET - 84))
          | (1ULL << (RpgParser::OP_RETURN - 84))
          | (1ULL << (RpgParser::OP_ROLBK - 84))
          | (1ULL << (RpgParser::OP_SELECT - 84))
          | (1ULL << (RpgParser::OP_SETGT - 84))
          | (1ULL << (RpgParser::OP_SETLL - 84))
          | (1ULL << (RpgParser::OP_SORTA - 84))
          | (1ULL << (RpgParser::OP_TEST - 84))
          | (1ULL << (RpgParser::OP_UNLOCK - 84))
          | (1ULL << (RpgParser::OP_UPDATE - 84))
          | (1ULL << (RpgParser::OP_WHEN - 84))
          | (1ULL << (RpgParser::OP_WRITE - 84))
          | (1ULL << (RpgParser::OP_XML_INTO - 84))
          | (1ULL << (RpgParser::OP_XML_SAX - 84))
          | (1ULL << (RpgParser::BIF_ABS - 84))
          | (1ULL << (RpgParser::BIF_ADDR - 84))
          | (1ULL << (RpgParser::BIF_ALLOC - 84))
          | (1ULL << (RpgParser::BIF_BITAND - 84))
          | (1ULL << (RpgParser::BIF_BITNOT - 84))
          | (1ULL << (RpgParser::BIF_BITOR - 84))
          | (1ULL << (RpgParser::BIF_BITXOR - 84))
          | (1ULL << (RpgParser::BIF_CHAR - 84))
          | (1ULL << (RpgParser::BIF_CHECK - 84))
          | (1ULL << (RpgParser::BIF_CHECKR - 84))
          | (1ULL << (RpgParser::BIF_DATE - 84))
          | (1ULL << (RpgParser::BIF_DAYS - 84))
          | (1ULL << (RpgParser::BIF_DEC - 84))
          | (1ULL << (RpgParser::BIF_DECH - 84))
          | (1ULL << (RpgParser::BIF_DECPOS - 84))
          | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
          | (1ULL << (RpgParser::BIF_EDITC - 148))
          | (1ULL << (RpgParser::BIF_EDITFLT - 148))
          | (1ULL << (RpgParser::BIF_EDITW - 148))
          | (1ULL << (RpgParser::BIF_ELEM - 148))
          | (1ULL << (RpgParser::BIF_EOF - 148))
          | (1ULL << (RpgParser::BIF_EQUAL - 148))
          | (1ULL << (RpgParser::BIF_ERROR - 148))
          | (1ULL << (RpgParser::BIF_FIELDS - 148))
          | (1ULL << (RpgParser::BIF_FLOAT - 148))
          | (1ULL << (RpgParser::BIF_FOUND - 148))
          | (1ULL << (RpgParser::BIF_GRAPH - 148))
          | (1ULL << (RpgParser::BIF_HANDLER - 148))
          | (1ULL << (RpgParser::BIF_HOURS - 148))
          | (1ULL << (RpgParser::BIF_INT - 148))
          | (1ULL << (RpgParser::BIF_INTH - 148))
          | (1ULL << (RpgParser::BIF_KDS - 148))
          | (1ULL << (RpgParser::BIF_LEN - 148))
          | (1ULL << (RpgParser::BIF_LOOKUP - 148))
          | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
          | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
          | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
          | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
          | (1ULL << (RpgParser::BIF_MINUTES - 148))
          | (1ULL << (RpgParser::BIF_MONTHS - 148))
          | (1ULL << (RpgParser::BIF_MSECONDS - 148))
          | (1ULL << (RpgParser::BIF_NULLIND - 148))
          | (1ULL << (RpgParser::BIF_OCCUR - 148))
          | (1ULL << (RpgParser::BIF_OPEN - 148))
          | (1ULL << (RpgParser::BIF_PADDR - 148))
          | (1ULL << (RpgParser::BIF_PARMS - 148))
          | (1ULL << (RpgParser::BIF_PARMNUM - 148))
          | (1ULL << (RpgParser::BIF_REALLOC - 148))
          | (1ULL << (RpgParser::BIF_REM - 148))
          | (1ULL << (RpgParser::BIF_REPLACE - 148))
          | (1ULL << (RpgParser::BIF_SCAN - 148))
          | (1ULL << (RpgParser::BIF_SCANRPL - 148))
          | (1ULL << (RpgParser::BIF_SECONDS - 148))
          | (1ULL << (RpgParser::BIF_SHTDN - 148))
          | (1ULL << (RpgParser::BIF_SIZE - 148))
          | (1ULL << (RpgParser::BIF_SQRT - 148))
          | (1ULL << (RpgParser::BIF_STATUS - 148))
          | (1ULL << (RpgParser::BIF_STR - 148))
          | (1ULL << (RpgParser::BIF_SUBARR - 148))
          | (1ULL << (RpgParser::BIF_SUBDT - 148))
          | (1ULL << (RpgParser::BIF_SUBST - 148))
          | (1ULL << (RpgParser::BIF_THIS - 148))
          | (1ULL << (RpgParser::BIF_TIME - 148))
          | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
          | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
          | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
          | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
          | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
          | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
          | (1ULL << (RpgParser::BIF_TRIM - 148))
          | (1ULL << (RpgParser::BIF_TRIML - 148))
          | (1ULL << (RpgParser::BIF_TRIMR - 148))
          | (1ULL << (RpgParser::BIF_UCS2 - 148))
          | (1ULL << (RpgParser::BIF_UNS - 148))
          | (1ULL << (RpgParser::BIF_UNSH - 148))
          | (1ULL << (RpgParser::BIF_XFOOT - 148))
          | (1ULL << (RpgParser::BIF_XLATE - 148))
          | (1ULL << (RpgParser::BIF_XML - 148))
          | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
          | (1ULL << (RpgParser::SPLAT_NONE - 212))
          | (1ULL << (RpgParser::SPLAT_YES - 212))
          | (1ULL << (RpgParser::SPLAT_NO - 212))
          | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
          | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
          | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
          | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
          | (1ULL << (RpgParser::SPLAT_VRM - 212))
          | (1ULL << (RpgParser::SPLAT_ALLG - 212))
          | (1ULL << (RpgParser::SPLAT_ALLU - 212))
          | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
          | (1ULL << (RpgParser::SPLAT_ALLX - 212))
          | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
          | (1ULL << (RpgParser::SPLAT_CANCL - 212))
          | (1ULL << (RpgParser::SPLAT_CYMD - 212))
          | (1ULL << (RpgParser::SPLAT_CMDY - 212))
          | (1ULL << (RpgParser::SPLAT_CDMY - 212))
          | (1ULL << (RpgParser::SPLAT_MDY - 212))
          | (1ULL << (RpgParser::SPLAT_DMY - 212))
          | (1ULL << (RpgParser::SPLAT_DFT - 212))
          | (1ULL << (RpgParser::SPLAT_YMD - 212))
          | (1ULL << (RpgParser::SPLAT_JUL - 212))
          | (1ULL << (RpgParser::SPLAT_JAVA - 212))
          | (1ULL << (RpgParser::SPLAT_ISO - 212))
          | (1ULL << (RpgParser::SPLAT_USA - 212))
          | (1ULL << (RpgParser::SPLAT_EUR - 212))
          | (1ULL << (RpgParser::SPLAT_JIS - 212))
          | (1ULL << (RpgParser::SPLAT_DATE - 212))
          | (1ULL << (RpgParser::SPLAT_DAY - 212))
          | (1ULL << (RpgParser::SPlAT_DETC - 212))
          | (1ULL << (RpgParser::SPLAT_DETL - 212))
          | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
          | (1ULL << (RpgParser::SPLAT_END - 212))
          | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
          | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
          | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
          | (1ULL << (RpgParser::SPLAT_EXT - 212))
          | (1ULL << (RpgParser::SPLAT_FILE - 212))
          | (1ULL << (RpgParser::SPLAT_GETIN - 212))
          | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
          | (1ULL << (RpgParser::SPLAT_INIT - 212))
          | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
          | (1ULL << (RpgParser::SPLAT_INZSR - 212))
          | (1ULL << (RpgParser::SPLAT_IN - 212))
          | (1ULL << (RpgParser::SPLAT_INPUT - 212))
          | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
          | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
          | (1ULL << (RpgParser::SPLAT_JOB - 212))
          | (1ULL << (RpgParser::SPLAT_LDA - 212))
          | (1ULL << (RpgParser::SPLAT_LIKE - 212))
          | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
          | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
          | (1ULL << (RpgParser::SPLAT_KEY - 212))
          | (1ULL << (RpgParser::SPLAT_MONTH - 212))
          | (1ULL << (RpgParser::SPLAT_NEXT - 212))
          | (1ULL << (RpgParser::SPLAT_NOIND - 212))
          | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
          | (1ULL << (RpgParser::SPLAT_NULL - 212))
          | (1ULL << (RpgParser::SPLAT_OFL - 212))
          | (1ULL << (RpgParser::SPLAT_ON - 212))
          | (1ULL << (RpgParser::SPLAT_ONLY - 212))
          | (1ULL << (RpgParser::SPLAT_OFF - 212))
          | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
          | (1ULL << (RpgParser::SPLAT_PSSR - 276))
          | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
          | (1ULL << (RpgParser::SPLAT_START - 276))
          | (1ULL << (RpgParser::SPLAT_SYS - 276))
          | (1ULL << (RpgParser::SPLAT_TERM - 276))
          | (1ULL << (RpgParser::SPLAT_TOTC - 276))
          | (1ULL << (RpgParser::SPLAT_TOTL - 276))
          | (1ULL << (RpgParser::SPLAT_USER - 276))
          | (1ULL << (RpgParser::SPLAT_VAR - 276))
          | (1ULL << (RpgParser::SPLAT_YEAR - 276))
          | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
          | (1ULL << (RpgParser::SPLAT_HMS - 276))
          | (1ULL << (RpgParser::SPLAT_INLR - 276))
          | (1ULL << (RpgParser::SPLAT_INOF - 276))
          | (1ULL << (RpgParser::SPLAT_DATA - 276))
          | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
          | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
          | (1ULL << (RpgParser::SPLAT_MAX - 276))
          | (1ULL << (RpgParser::SPLAT_LOCK - 276))
          | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
          | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
          | (1ULL << (RpgParser::SPLAT_D - 276))
          | (1ULL << (RpgParser::SPLAT_H - 276))
          | (1ULL << (RpgParser::SPLAT_HOURS - 276))
          | (1ULL << (RpgParser::SPLAT_DAYS - 276))
          | (1ULL << (RpgParser::SPLAT_M - 276))
          | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
          | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
          | (1ULL << (RpgParser::SPLAT_MN - 276))
          | (1ULL << (RpgParser::SPLAT_MS - 276))
          | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
          | (1ULL << (RpgParser::SPLAT_S - 276))
          | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
          | (1ULL << (RpgParser::SPLAT_Y - 276))
          | (1ULL << (RpgParser::SPLAT_YEARS - 276))
          | (1ULL << (RpgParser::UDATE - 276))
          | (1ULL << (RpgParser::UMONTH - 276))
          | (1ULL << (RpgParser::UYEAR - 276))
          | (1ULL << (RpgParser::UDAY - 276))
          | (1ULL << (RpgParser::CHAR - 276))
          | (1ULL << (RpgParser::VARCHAR - 276))
          | (1ULL << (RpgParser::UCS2 - 276))
          | (1ULL << (RpgParser::DATE_ - 276))
          | (1ULL << (RpgParser::VARUCS2 - 276))
          | (1ULL << (RpgParser::GRAPH - 276))
          | (1ULL << (RpgParser::VARGRAPH - 276))
          | (1ULL << (RpgParser::IND - 276))
          | (1ULL << (RpgParser::PACKED - 276))
          | (1ULL << (RpgParser::ZONED - 276))
          | (1ULL << (RpgParser::BINDEC - 276))
          | (1ULL << (RpgParser::INT - 276))
          | (1ULL << (RpgParser::UNS - 276))
          | (1ULL << (RpgParser::FLOAT - 276))
          | (1ULL << (RpgParser::TIME - 276))
          | (1ULL << (RpgParser::TIMESTAMP - 276))
          | (1ULL << (RpgParser::POINTER - 276))
          | (1ULL << (RpgParser::OBJECT - 276))
          | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
          | (1ULL << (RpgParser::KEYWORD_ALT - 340))
          | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
          | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
          | (1ULL << (RpgParser::KEYWORD_BASED - 340))
          | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
          | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
          | (1ULL << (RpgParser::KEYWORD_CONST - 340))
          | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
          | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
          | (1ULL << (RpgParser::KEYWORD_DIM - 340))
          | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
          | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
          | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
          | (1ULL << (RpgParser::KEYWORD_INZ - 340))
          | (1ULL << (RpgParser::KEYWORD_LEN - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
          | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
          | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
          | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
          | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
          | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
          | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
          | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
          | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
          | (1ULL << (RpgParser::KEYWORD_POS - 340))
          | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
          | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
          | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
          | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
          | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
          | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
          | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
          | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
          | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
          | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
          | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
          | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
          | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
          | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
          | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
          | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
          | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
          | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
          | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
          | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
          | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
          | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
          | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
          | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
          | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
          | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
          | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
          | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
          | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
          | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
          | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
          | (1ULL << (RpgParser::KEYWORD_SLN - 404))
          | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
          | (1ULL << (RpgParser::KEYWORD_DISK - 404))
          | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
          | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
          | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
          | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
          | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
          | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
          | (1ULL << (RpgParser::NOT - 404))
          | (1ULL << (RpgParser::PLUS - 404))
          | (1ULL << (RpgParser::MINUS - 404))
          | (1ULL << (RpgParser::MULT_NOSPACE - 404))
          | (1ULL << (RpgParser::FREE_BY - 404))
          | (1ULL << (RpgParser::FREE_TO - 404))
          | (1ULL << (RpgParser::FREE_DOWNTO - 404))
          | (1ULL << (RpgParser::HexLiteralStart - 404))
          | (1ULL << (RpgParser::DateLiteralStart - 404))
          | (1ULL << (RpgParser::TimeLiteralStart - 404))
          | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
          | (1ULL << (RpgParser::GraphicLiteralStart - 404))
          | (1ULL << (RpgParser::UCS2LiteralStart - 404))
          | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
          setState(4529);
          expression(0);
        }
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_dumpContext ------------------------------------------------------------------

RpgParser::Op_dumpContext::Op_dumpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_dumpContext::OP_DUMP() {
  return getToken(RpgParser::OP_DUMP, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_dumpContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::IdentifierContext* RpgParser::Op_dumpContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Op_dumpContext::getRuleIndex() const {
  return RpgParser::RuleOp_dump;
}

void RpgParser::Op_dumpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_dump(this);
}

void RpgParser::Op_dumpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_dump(this);
}


antlrcpp::Any RpgParser::Op_dumpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_dump(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_dumpContext* RpgParser::op_dump() {
  Op_dumpContext *_localctx = _tracker.createInstance<Op_dumpContext>(_ctx, getState());
  enterRule(_localctx, 824, RpgParser::RuleOp_dump);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4536);
    match(RpgParser::OP_DUMP);
    setState(4538);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4537);
      cs_operationExtender();
    }
    setState(4541);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4540);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_elseContext ------------------------------------------------------------------

RpgParser::Op_elseContext::Op_elseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_elseContext::OP_ELSE() {
  return getToken(RpgParser::OP_ELSE, 0);
}


size_t RpgParser::Op_elseContext::getRuleIndex() const {
  return RpgParser::RuleOp_else;
}

void RpgParser::Op_elseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_else(this);
}

void RpgParser::Op_elseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_else(this);
}


antlrcpp::Any RpgParser::Op_elseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_else(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_elseContext* RpgParser::op_else() {
  Op_elseContext *_localctx = _tracker.createInstance<Op_elseContext>(_ctx, getState());
  enterRule(_localctx, 826, RpgParser::RuleOp_else);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4543);
    match(RpgParser::OP_ELSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_elseifContext ------------------------------------------------------------------

RpgParser::Op_elseifContext::Op_elseifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_elseifContext::OP_ELSEIF() {
  return getToken(RpgParser::OP_ELSEIF, 0);
}

RpgParser::Indicator_exprContext* RpgParser::Op_elseifContext::indicator_expr() {
  return getRuleContext<RpgParser::Indicator_exprContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_elseifContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_elseifContext::getRuleIndex() const {
  return RpgParser::RuleOp_elseif;
}

void RpgParser::Op_elseifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_elseif(this);
}

void RpgParser::Op_elseifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_elseif(this);
}


antlrcpp::Any RpgParser::Op_elseifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_elseif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_elseifContext* RpgParser::op_elseif() {
  Op_elseifContext *_localctx = _tracker.createInstance<Op_elseifContext>(_ctx, getState());
  enterRule(_localctx, 828, RpgParser::RuleOp_elseif);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4545);
    match(RpgParser::OP_ELSEIF);
    setState(4547);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 376, _ctx)) {
    case 1: {
      setState(4546);
      cs_operationExtender();
      break;
    }

    }
    setState(4549);
    indicator_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_enddoContext ------------------------------------------------------------------

RpgParser::Op_enddoContext::Op_enddoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_enddoContext::OP_ENDDO() {
  return getToken(RpgParser::OP_ENDDO, 0);
}


size_t RpgParser::Op_enddoContext::getRuleIndex() const {
  return RpgParser::RuleOp_enddo;
}

void RpgParser::Op_enddoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_enddo(this);
}

void RpgParser::Op_enddoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_enddo(this);
}


antlrcpp::Any RpgParser::Op_enddoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_enddo(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_enddoContext* RpgParser::op_enddo() {
  Op_enddoContext *_localctx = _tracker.createInstance<Op_enddoContext>(_ctx, getState());
  enterRule(_localctx, 830, RpgParser::RuleOp_enddo);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4551);
    match(RpgParser::OP_ENDDO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_endforContext ------------------------------------------------------------------

RpgParser::Op_endforContext::Op_endforContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_endforContext::OP_ENDFOR() {
  return getToken(RpgParser::OP_ENDFOR, 0);
}


size_t RpgParser::Op_endforContext::getRuleIndex() const {
  return RpgParser::RuleOp_endfor;
}

void RpgParser::Op_endforContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_endfor(this);
}

void RpgParser::Op_endforContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_endfor(this);
}


antlrcpp::Any RpgParser::Op_endforContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_endfor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_endforContext* RpgParser::op_endfor() {
  Op_endforContext *_localctx = _tracker.createInstance<Op_endforContext>(_ctx, getState());
  enterRule(_localctx, 832, RpgParser::RuleOp_endfor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4553);
    match(RpgParser::OP_ENDFOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_endifContext ------------------------------------------------------------------

RpgParser::Op_endifContext::Op_endifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_endifContext::OP_ENDIF() {
  return getToken(RpgParser::OP_ENDIF, 0);
}


size_t RpgParser::Op_endifContext::getRuleIndex() const {
  return RpgParser::RuleOp_endif;
}

void RpgParser::Op_endifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_endif(this);
}

void RpgParser::Op_endifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_endif(this);
}


antlrcpp::Any RpgParser::Op_endifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_endif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_endifContext* RpgParser::op_endif() {
  Op_endifContext *_localctx = _tracker.createInstance<Op_endifContext>(_ctx, getState());
  enterRule(_localctx, 834, RpgParser::RuleOp_endif);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4555);
    match(RpgParser::OP_ENDIF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_endmonContext ------------------------------------------------------------------

RpgParser::Op_endmonContext::Op_endmonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_endmonContext::OP_ENDMON() {
  return getToken(RpgParser::OP_ENDMON, 0);
}


size_t RpgParser::Op_endmonContext::getRuleIndex() const {
  return RpgParser::RuleOp_endmon;
}

void RpgParser::Op_endmonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_endmon(this);
}

void RpgParser::Op_endmonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_endmon(this);
}


antlrcpp::Any RpgParser::Op_endmonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_endmon(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_endmonContext* RpgParser::op_endmon() {
  Op_endmonContext *_localctx = _tracker.createInstance<Op_endmonContext>(_ctx, getState());
  enterRule(_localctx, 836, RpgParser::RuleOp_endmon);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4557);
    match(RpgParser::OP_ENDMON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_endslContext ------------------------------------------------------------------

RpgParser::Op_endslContext::Op_endslContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_endslContext::OP_ENDSL() {
  return getToken(RpgParser::OP_ENDSL, 0);
}


size_t RpgParser::Op_endslContext::getRuleIndex() const {
  return RpgParser::RuleOp_endsl;
}

void RpgParser::Op_endslContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_endsl(this);
}

void RpgParser::Op_endslContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_endsl(this);
}


antlrcpp::Any RpgParser::Op_endslContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_endsl(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_endslContext* RpgParser::op_endsl() {
  Op_endslContext *_localctx = _tracker.createInstance<Op_endslContext>(_ctx, getState());
  enterRule(_localctx, 838, RpgParser::RuleOp_endsl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4559);
    match(RpgParser::OP_ENDSL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_evalContext ------------------------------------------------------------------

RpgParser::Op_evalContext::Op_evalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::EvalExpressionContext* RpgParser::Op_evalContext::evalExpression() {
  return getRuleContext<RpgParser::EvalExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Op_evalContext::OP_EVAL() {
  return getToken(RpgParser::OP_EVAL, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_evalContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_evalContext::getRuleIndex() const {
  return RpgParser::RuleOp_eval;
}

void RpgParser::Op_evalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_eval(this);
}

void RpgParser::Op_evalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_eval(this);
}


antlrcpp::Any RpgParser::Op_evalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_eval(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_evalContext* RpgParser::op_eval() {
  Op_evalContext *_localctx = _tracker.createInstance<Op_evalContext>(_ctx, getState());
  enterRule(_localctx, 840, RpgParser::RuleOp_eval);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4565);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
    case 1: {
      setState(4561);
      match(RpgParser::OP_EVAL);
      setState(4563);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
      case 1: {
        setState(4562);
        cs_operationExtender();
        break;
      }

      }
      break;
    }

    }
    setState(4567);
    evalExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_evalrContext ------------------------------------------------------------------

RpgParser::Op_evalrContext::Op_evalrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_evalrContext::OP_EVALR() {
  return getToken(RpgParser::OP_EVALR, 0);
}

RpgParser::AssignmentExpressionContext* RpgParser::Op_evalrContext::assignmentExpression() {
  return getRuleContext<RpgParser::AssignmentExpressionContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_evalrContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_evalrContext::getRuleIndex() const {
  return RpgParser::RuleOp_evalr;
}

void RpgParser::Op_evalrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_evalr(this);
}

void RpgParser::Op_evalrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_evalr(this);
}


antlrcpp::Any RpgParser::Op_evalrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_evalr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_evalrContext* RpgParser::op_evalr() {
  Op_evalrContext *_localctx = _tracker.createInstance<Op_evalrContext>(_ctx, getState());
  enterRule(_localctx, 842, RpgParser::RuleOp_evalr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4569);
    match(RpgParser::OP_EVALR);
    setState(4571);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx)) {
    case 1: {
      setState(4570);
      cs_operationExtender();
      break;
    }

    }
    setState(4573);
    assignmentExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_eval_corrContext ------------------------------------------------------------------

RpgParser::Op_eval_corrContext::Op_eval_corrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_eval_corrContext::OP_EVAL_CORR() {
  return getToken(RpgParser::OP_EVAL_CORR, 0);
}

RpgParser::AssignmentExpressionContext* RpgParser::Op_eval_corrContext::assignmentExpression() {
  return getRuleContext<RpgParser::AssignmentExpressionContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_eval_corrContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_eval_corrContext::getRuleIndex() const {
  return RpgParser::RuleOp_eval_corr;
}

void RpgParser::Op_eval_corrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_eval_corr(this);
}

void RpgParser::Op_eval_corrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_eval_corr(this);
}


antlrcpp::Any RpgParser::Op_eval_corrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_eval_corr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_eval_corrContext* RpgParser::op_eval_corr() {
  Op_eval_corrContext *_localctx = _tracker.createInstance<Op_eval_corrContext>(_ctx, getState());
  enterRule(_localctx, 844, RpgParser::RuleOp_eval_corr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4575);
    match(RpgParser::OP_EVAL_CORR);
    setState(4577);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
    case 1: {
      setState(4576);
      cs_operationExtender();
      break;
    }

    }
    setState(4579);
    assignmentExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_exceptContext ------------------------------------------------------------------

RpgParser::Op_exceptContext::Op_exceptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_exceptContext::OP_EXCEPT() {
  return getToken(RpgParser::OP_EXCEPT, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_exceptContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Op_exceptContext::getRuleIndex() const {
  return RpgParser::RuleOp_except;
}

void RpgParser::Op_exceptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_except(this);
}

void RpgParser::Op_exceptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_except(this);
}


antlrcpp::Any RpgParser::Op_exceptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_except(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_exceptContext* RpgParser::op_except() {
  Op_exceptContext *_localctx = _tracker.createInstance<Op_exceptContext>(_ctx, getState());
  enterRule(_localctx, 846, RpgParser::RuleOp_except);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4581);
    match(RpgParser::OP_EXCEPT);
    setState(4583);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4582);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_exfmtContext ------------------------------------------------------------------

RpgParser::Op_exfmtContext::Op_exfmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_exfmtContext::OP_EXFMT() {
  return getToken(RpgParser::OP_EXFMT, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_exfmtContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_exfmtContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_exfmtContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_exfmtContext::getRuleIndex() const {
  return RpgParser::RuleOp_exfmt;
}

void RpgParser::Op_exfmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_exfmt(this);
}

void RpgParser::Op_exfmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_exfmt(this);
}


antlrcpp::Any RpgParser::Op_exfmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_exfmt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_exfmtContext* RpgParser::op_exfmt() {
  Op_exfmtContext *_localctx = _tracker.createInstance<Op_exfmtContext>(_ctx, getState());
  enterRule(_localctx, 848, RpgParser::RuleOp_exfmt);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4585);
    match(RpgParser::OP_EXFMT);
    setState(4587);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4586);
      cs_operationExtender();
    }
    setState(4589);
    identifier();
    setState(4591);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4590);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_exsrContext ------------------------------------------------------------------

RpgParser::Op_exsrContext::Op_exsrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_exsrContext::OP_EXSR() {
  return getToken(RpgParser::OP_EXSR, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_exsrContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Op_exsrContext::getRuleIndex() const {
  return RpgParser::RuleOp_exsr;
}

void RpgParser::Op_exsrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_exsr(this);
}

void RpgParser::Op_exsrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_exsr(this);
}


antlrcpp::Any RpgParser::Op_exsrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_exsr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_exsrContext* RpgParser::op_exsr() {
  Op_exsrContext *_localctx = _tracker.createInstance<Op_exsrContext>(_ctx, getState());
  enterRule(_localctx, 850, RpgParser::RuleOp_exsr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4593);
    match(RpgParser::OP_EXSR);
    setState(4594);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_feodContext ------------------------------------------------------------------

RpgParser::Op_feodContext::Op_feodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_feodContext::OP_FEOD() {
  return getToken(RpgParser::OP_FEOD, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_feodContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_feodContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_feodContext::getRuleIndex() const {
  return RpgParser::RuleOp_feod;
}

void RpgParser::Op_feodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_feod(this);
}

void RpgParser::Op_feodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_feod(this);
}


antlrcpp::Any RpgParser::Op_feodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_feod(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_feodContext* RpgParser::op_feod() {
  Op_feodContext *_localctx = _tracker.createInstance<Op_feodContext>(_ctx, getState());
  enterRule(_localctx, 852, RpgParser::RuleOp_feod);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4596);
    match(RpgParser::OP_FEOD);
    setState(4598);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4597);
      cs_operationExtender();
    }
    setState(4600);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_forContext ------------------------------------------------------------------

RpgParser::Op_forContext::Op_forContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_forContext::OP_FOR() {
  return getToken(RpgParser::OP_FOR, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Op_forContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Op_forContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_forContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

tree::TerminalNode* RpgParser::Op_forContext::EQUAL() {
  return getToken(RpgParser::EQUAL, 0);
}

tree::TerminalNode* RpgParser::Op_forContext::FREE_BY() {
  return getToken(RpgParser::FREE_BY, 0);
}

tree::TerminalNode* RpgParser::Op_forContext::FREE_TO() {
  return getToken(RpgParser::FREE_TO, 0);
}

tree::TerminalNode* RpgParser::Op_forContext::FREE_DOWNTO() {
  return getToken(RpgParser::FREE_DOWNTO, 0);
}


size_t RpgParser::Op_forContext::getRuleIndex() const {
  return RpgParser::RuleOp_for;
}

void RpgParser::Op_forContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_for(this);
}

void RpgParser::Op_forContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_for(this);
}


antlrcpp::Any RpgParser::Op_forContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_for(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_forContext* RpgParser::op_for() {
  Op_forContext *_localctx = _tracker.createInstance<Op_forContext>(_ctx, getState());
  enterRule(_localctx, 854, RpgParser::RuleOp_for);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4602);
    match(RpgParser::OP_FOR);
    setState(4604);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
    case 1: {
      setState(4603);
      cs_operationExtender();
      break;
    }

    }
    setState(4606);
    dynamic_cast<Op_forContext *>(_localctx)->indexname = expression(0);
    setState(4609);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::EQUAL) {
      setState(4607);
      match(RpgParser::EQUAL);
      setState(4608);
      dynamic_cast<Op_forContext *>(_localctx)->startvalue = expression(0);
    }
    setState(4613);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::FREE_BY) {
      setState(4611);
      match(RpgParser::FREE_BY);
      setState(4612);
      dynamic_cast<Op_forContext *>(_localctx)->increment = expression(0);
    }
    setState(4617);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::FREE_TO

    || _la == RpgParser::FREE_DOWNTO) {
      setState(4615);
      _la = _input->LA(1);
      if (!(_la == RpgParser::FREE_TO

      || _la == RpgParser::FREE_DOWNTO)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4616);
      dynamic_cast<Op_forContext *>(_localctx)->limit = expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_forceContext ------------------------------------------------------------------

RpgParser::Op_forceContext::Op_forceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_forceContext::OP_FORCE() {
  return getToken(RpgParser::OP_FORCE, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_forceContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Op_forceContext::getRuleIndex() const {
  return RpgParser::RuleOp_force;
}

void RpgParser::Op_forceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_force(this);
}

void RpgParser::Op_forceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_force(this);
}


antlrcpp::Any RpgParser::Op_forceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_force(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_forceContext* RpgParser::op_force() {
  Op_forceContext *_localctx = _tracker.createInstance<Op_forceContext>(_ctx, getState());
  enterRule(_localctx, 856, RpgParser::RuleOp_force);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4619);
    match(RpgParser::OP_FORCE);
    setState(4620);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_ifContext ------------------------------------------------------------------

RpgParser::Op_ifContext::Op_ifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_ifContext::OP_IF() {
  return getToken(RpgParser::OP_IF, 0);
}

RpgParser::ExpressionContext* RpgParser::Op_ifContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_ifContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_ifContext::getRuleIndex() const {
  return RpgParser::RuleOp_if;
}

void RpgParser::Op_ifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_if(this);
}

void RpgParser::Op_ifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_if(this);
}


antlrcpp::Any RpgParser::Op_ifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_if(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_ifContext* RpgParser::op_if() {
  Op_ifContext *_localctx = _tracker.createInstance<Op_ifContext>(_ctx, getState());
  enterRule(_localctx, 858, RpgParser::RuleOp_if);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4622);
    match(RpgParser::OP_IF);
    setState(4624);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
    case 1: {
      setState(4623);
      cs_operationExtender();
      break;
    }

    }
    setState(4626);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_inContext ------------------------------------------------------------------

RpgParser::Op_inContext::Op_inContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_inContext::OP_IN() {
  return getToken(RpgParser::OP_IN, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_inContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_inContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_inContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_inContext::getRuleIndex() const {
  return RpgParser::RuleOp_in;
}

void RpgParser::Op_inContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_in(this);
}

void RpgParser::Op_inContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_in(this);
}


antlrcpp::Any RpgParser::Op_inContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_in(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_inContext* RpgParser::op_in() {
  Op_inContext *_localctx = _tracker.createInstance<Op_inContext>(_ctx, getState());
  enterRule(_localctx, 860, RpgParser::RuleOp_in);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4628);
    match(RpgParser::OP_IN);
    setState(4630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4629);
      cs_operationExtender();
    }
    setState(4633);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx)) {
    case 1: {
      setState(4632);
      identifier();
      break;
    }

    }
    setState(4635);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_iterContext ------------------------------------------------------------------

RpgParser::Op_iterContext::Op_iterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_iterContext::OP_ITER() {
  return getToken(RpgParser::OP_ITER, 0);
}


size_t RpgParser::Op_iterContext::getRuleIndex() const {
  return RpgParser::RuleOp_iter;
}

void RpgParser::Op_iterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_iter(this);
}

void RpgParser::Op_iterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_iter(this);
}


antlrcpp::Any RpgParser::Op_iterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_iter(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_iterContext* RpgParser::op_iter() {
  Op_iterContext *_localctx = _tracker.createInstance<Op_iterContext>(_ctx, getState());
  enterRule(_localctx, 862, RpgParser::RuleOp_iter);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4637);
    match(RpgParser::OP_ITER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_leaveContext ------------------------------------------------------------------

RpgParser::Op_leaveContext::Op_leaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_leaveContext::OP_LEAVE() {
  return getToken(RpgParser::OP_LEAVE, 0);
}


size_t RpgParser::Op_leaveContext::getRuleIndex() const {
  return RpgParser::RuleOp_leave;
}

void RpgParser::Op_leaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_leave(this);
}

void RpgParser::Op_leaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_leave(this);
}


antlrcpp::Any RpgParser::Op_leaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_leave(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_leaveContext* RpgParser::op_leave() {
  Op_leaveContext *_localctx = _tracker.createInstance<Op_leaveContext>(_ctx, getState());
  enterRule(_localctx, 864, RpgParser::RuleOp_leave);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4639);
    match(RpgParser::OP_LEAVE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_leavesrContext ------------------------------------------------------------------

RpgParser::Op_leavesrContext::Op_leavesrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_leavesrContext::OP_LEAVESR() {
  return getToken(RpgParser::OP_LEAVESR, 0);
}


size_t RpgParser::Op_leavesrContext::getRuleIndex() const {
  return RpgParser::RuleOp_leavesr;
}

void RpgParser::Op_leavesrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_leavesr(this);
}

void RpgParser::Op_leavesrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_leavesr(this);
}


antlrcpp::Any RpgParser::Op_leavesrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_leavesr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_leavesrContext* RpgParser::op_leavesr() {
  Op_leavesrContext *_localctx = _tracker.createInstance<Op_leavesrContext>(_ctx, getState());
  enterRule(_localctx, 866, RpgParser::RuleOp_leavesr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4641);
    match(RpgParser::OP_LEAVESR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_monitorContext ------------------------------------------------------------------

RpgParser::Op_monitorContext::Op_monitorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_monitorContext::OP_MONITOR() {
  return getToken(RpgParser::OP_MONITOR, 0);
}


size_t RpgParser::Op_monitorContext::getRuleIndex() const {
  return RpgParser::RuleOp_monitor;
}

void RpgParser::Op_monitorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_monitor(this);
}

void RpgParser::Op_monitorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_monitor(this);
}


antlrcpp::Any RpgParser::Op_monitorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_monitor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_monitorContext* RpgParser::op_monitor() {
  Op_monitorContext *_localctx = _tracker.createInstance<Op_monitorContext>(_ctx, getState());
  enterRule(_localctx, 868, RpgParser::RuleOp_monitor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4643);
    match(RpgParser::OP_MONITOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_nextContext ------------------------------------------------------------------

RpgParser::Op_nextContext::Op_nextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_nextContext::OP_NEXT() {
  return getToken(RpgParser::OP_NEXT, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_nextContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_nextContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::LiteralContext* RpgParser::Op_nextContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_nextContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_nextContext::getRuleIndex() const {
  return RpgParser::RuleOp_next;
}

void RpgParser::Op_nextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_next(this);
}

void RpgParser::Op_nextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_next(this);
}


antlrcpp::Any RpgParser::Op_nextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_next(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_nextContext* RpgParser::op_next() {
  Op_nextContext *_localctx = _tracker.createInstance<Op_nextContext>(_ctx, getState());
  enterRule(_localctx, 870, RpgParser::RuleOp_next);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4645);
    match(RpgParser::OP_NEXT);
    setState(4647);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4646);
      cs_operationExtender();
    }
    setState(4651);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        setState(4649);
        literal();
        break;
      }

      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO: {
        setState(4650);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4653);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_on_errorContext ------------------------------------------------------------------

RpgParser::Op_on_errorContext::Op_on_errorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_on_errorContext::OP_ON_ERROR() {
  return getToken(RpgParser::OP_ON_ERROR, 0);
}

std::vector<RpgParser::OnErrorCodeContext *> RpgParser::Op_on_errorContext::onErrorCode() {
  return getRuleContexts<RpgParser::OnErrorCodeContext>();
}

RpgParser::OnErrorCodeContext* RpgParser::Op_on_errorContext::onErrorCode(size_t i) {
  return getRuleContext<RpgParser::OnErrorCodeContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Op_on_errorContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Op_on_errorContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Op_on_errorContext::getRuleIndex() const {
  return RpgParser::RuleOp_on_error;
}

void RpgParser::Op_on_errorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_on_error(this);
}

void RpgParser::Op_on_errorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_on_error(this);
}


antlrcpp::Any RpgParser::Op_on_errorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_on_error(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_on_errorContext* RpgParser::op_on_error() {
  Op_on_errorContext *_localctx = _tracker.createInstance<Op_on_errorContext>(_ctx, getState());
  enterRule(_localctx, 872, RpgParser::RuleOp_on_error);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4655);
    match(RpgParser::OP_ON_ERROR);
    setState(4664);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::NUMBER)
      | (1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4656);
      onErrorCode();
      setState(4661);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == RpgParser::COLON) {
        setState(4657);
        match(RpgParser::COLON);
        setState(4658);
        onErrorCode();
        setState(4663);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_openContext ------------------------------------------------------------------

RpgParser::Op_openContext::Op_openContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_openContext::OP_OPEN() {
  return getToken(RpgParser::OP_OPEN, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_openContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_openContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_openContext::getRuleIndex() const {
  return RpgParser::RuleOp_open;
}

void RpgParser::Op_openContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_open(this);
}

void RpgParser::Op_openContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_open(this);
}


antlrcpp::Any RpgParser::Op_openContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_open(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_openContext* RpgParser::op_open() {
  Op_openContext *_localctx = _tracker.createInstance<Op_openContext>(_ctx, getState());
  enterRule(_localctx, 874, RpgParser::RuleOp_open);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4666);
    match(RpgParser::OP_OPEN);
    setState(4668);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4667);
      cs_operationExtender();
    }
    setState(4670);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_otherContext ------------------------------------------------------------------

RpgParser::Op_otherContext::Op_otherContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_otherContext::OP_OTHER() {
  return getToken(RpgParser::OP_OTHER, 0);
}


size_t RpgParser::Op_otherContext::getRuleIndex() const {
  return RpgParser::RuleOp_other;
}

void RpgParser::Op_otherContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_other(this);
}

void RpgParser::Op_otherContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_other(this);
}


antlrcpp::Any RpgParser::Op_otherContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_other(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_otherContext* RpgParser::op_other() {
  Op_otherContext *_localctx = _tracker.createInstance<Op_otherContext>(_ctx, getState());
  enterRule(_localctx, 876, RpgParser::RuleOp_other);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4672);
    match(RpgParser::OP_OTHER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_outContext ------------------------------------------------------------------

RpgParser::Op_outContext::Op_outContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_outContext::OP_OUT() {
  return getToken(RpgParser::OP_OUT, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_outContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_outContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_outContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_outContext::getRuleIndex() const {
  return RpgParser::RuleOp_out;
}

void RpgParser::Op_outContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_out(this);
}

void RpgParser::Op_outContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_out(this);
}


antlrcpp::Any RpgParser::Op_outContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_out(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_outContext* RpgParser::op_out() {
  Op_outContext *_localctx = _tracker.createInstance<Op_outContext>(_ctx, getState());
  enterRule(_localctx, 878, RpgParser::RuleOp_out);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4674);
    match(RpgParser::OP_OUT);
    setState(4676);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4675);
      cs_operationExtender();
    }
    setState(4679);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
    case 1: {
      setState(4678);
      identifier();
      break;
    }

    }
    setState(4681);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_postContext ------------------------------------------------------------------

RpgParser::Op_postContext::Op_postContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_postContext::OP_POST() {
  return getToken(RpgParser::OP_POST, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_postContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_postContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_postContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::LiteralContext* RpgParser::Op_postContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}


size_t RpgParser::Op_postContext::getRuleIndex() const {
  return RpgParser::RuleOp_post;
}

void RpgParser::Op_postContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_post(this);
}

void RpgParser::Op_postContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_post(this);
}


antlrcpp::Any RpgParser::Op_postContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_post(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_postContext* RpgParser::op_post() {
  Op_postContext *_localctx = _tracker.createInstance<Op_postContext>(_ctx, getState());
  enterRule(_localctx, 880, RpgParser::RuleOp_post);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4683);
    match(RpgParser::OP_POST);
    setState(4685);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4684);
      cs_operationExtender();
    }
    setState(4689);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx)) {
    case 1: {
      setState(4687);
      literal();
      break;
    }

    case 2: {
      setState(4688);
      identifier();
      break;
    }

    }
    setState(4691);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_readContext ------------------------------------------------------------------

RpgParser::Op_readContext::Op_readContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_readContext::OP_READ() {
  return getToken(RpgParser::OP_READ, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_readContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_readContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_readContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_readContext::getRuleIndex() const {
  return RpgParser::RuleOp_read;
}

void RpgParser::Op_readContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_read(this);
}

void RpgParser::Op_readContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_read(this);
}


antlrcpp::Any RpgParser::Op_readContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_read(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_readContext* RpgParser::op_read() {
  Op_readContext *_localctx = _tracker.createInstance<Op_readContext>(_ctx, getState());
  enterRule(_localctx, 882, RpgParser::RuleOp_read);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4693);
    match(RpgParser::OP_READ);
    setState(4695);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4694);
      cs_operationExtender();
    }
    setState(4697);
    identifier();
    setState(4699);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4698);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_readcContext ------------------------------------------------------------------

RpgParser::Op_readcContext::Op_readcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_readcContext::OP_READC() {
  return getToken(RpgParser::OP_READC, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_readcContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_readcContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_readcContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_readcContext::getRuleIndex() const {
  return RpgParser::RuleOp_readc;
}

void RpgParser::Op_readcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_readc(this);
}

void RpgParser::Op_readcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_readc(this);
}


antlrcpp::Any RpgParser::Op_readcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_readc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_readcContext* RpgParser::op_readc() {
  Op_readcContext *_localctx = _tracker.createInstance<Op_readcContext>(_ctx, getState());
  enterRule(_localctx, 884, RpgParser::RuleOp_readc);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4701);
    match(RpgParser::OP_READC);
    setState(4703);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4702);
      cs_operationExtender();
    }
    setState(4705);
    identifier();
    setState(4707);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4706);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_readeContext ------------------------------------------------------------------

RpgParser::Op_readeContext::Op_readeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_readeContext::OP_READE() {
  return getToken(RpgParser::OP_READE, 0);
}

RpgParser::Search_argContext* RpgParser::Op_readeContext::search_arg() {
  return getRuleContext<RpgParser::Search_argContext>(0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_readeContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_readeContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_readeContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_readeContext::getRuleIndex() const {
  return RpgParser::RuleOp_reade;
}

void RpgParser::Op_readeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_reade(this);
}

void RpgParser::Op_readeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_reade(this);
}


antlrcpp::Any RpgParser::Op_readeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_reade(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_readeContext* RpgParser::op_reade() {
  Op_readeContext *_localctx = _tracker.createInstance<Op_readeContext>(_ctx, getState());
  enterRule(_localctx, 886, RpgParser::RuleOp_reade);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4709);
    match(RpgParser::OP_READE);
    setState(4711);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx)) {
    case 1: {
      setState(4710);
      cs_operationExtender();
      break;
    }

    }
    setState(4713);
    search_arg();
    setState(4714);
    identifier();
    setState(4716);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4715);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_readpContext ------------------------------------------------------------------

RpgParser::Op_readpContext::Op_readpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_readpContext::OP_READP() {
  return getToken(RpgParser::OP_READP, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_readpContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_readpContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_readpContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_readpContext::getRuleIndex() const {
  return RpgParser::RuleOp_readp;
}

void RpgParser::Op_readpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_readp(this);
}

void RpgParser::Op_readpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_readp(this);
}


antlrcpp::Any RpgParser::Op_readpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_readp(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_readpContext* RpgParser::op_readp() {
  Op_readpContext *_localctx = _tracker.createInstance<Op_readpContext>(_ctx, getState());
  enterRule(_localctx, 888, RpgParser::RuleOp_readp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4718);
    match(RpgParser::OP_READP);
    setState(4720);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4719);
      cs_operationExtender();
    }
    setState(4722);
    identifier();
    setState(4724);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4723);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_readpeContext ------------------------------------------------------------------

RpgParser::Op_readpeContext::Op_readpeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_readpeContext::OP_READPE() {
  return getToken(RpgParser::OP_READPE, 0);
}

RpgParser::Search_argContext* RpgParser::Op_readpeContext::search_arg() {
  return getRuleContext<RpgParser::Search_argContext>(0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_readpeContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_readpeContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_readpeContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_readpeContext::getRuleIndex() const {
  return RpgParser::RuleOp_readpe;
}

void RpgParser::Op_readpeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_readpe(this);
}

void RpgParser::Op_readpeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_readpe(this);
}


antlrcpp::Any RpgParser::Op_readpeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_readpe(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_readpeContext* RpgParser::op_readpe() {
  Op_readpeContext *_localctx = _tracker.createInstance<Op_readpeContext>(_ctx, getState());
  enterRule(_localctx, 890, RpgParser::RuleOp_readpe);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4726);
    match(RpgParser::OP_READPE);
    setState(4728);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx)) {
    case 1: {
      setState(4727);
      cs_operationExtender();
      break;
    }

    }
    setState(4730);
    search_arg();
    setState(4731);
    identifier();
    setState(4733);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4732);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_relContext ------------------------------------------------------------------

RpgParser::Op_relContext::Op_relContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_relContext::OP_REL() {
  return getToken(RpgParser::OP_REL, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_relContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_relContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::LiteralContext* RpgParser::Op_relContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_relContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_relContext::getRuleIndex() const {
  return RpgParser::RuleOp_rel;
}

void RpgParser::Op_relContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_rel(this);
}

void RpgParser::Op_relContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_rel(this);
}


antlrcpp::Any RpgParser::Op_relContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_rel(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_relContext* RpgParser::op_rel() {
  Op_relContext *_localctx = _tracker.createInstance<Op_relContext>(_ctx, getState());
  enterRule(_localctx, 892, RpgParser::RuleOp_rel);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4735);
    match(RpgParser::OP_REL);
    setState(4737);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4736);
      cs_operationExtender();
    }
    setState(4741);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        setState(4739);
        literal();
        break;
      }

      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO: {
        setState(4740);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4743);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_reset2Context ------------------------------------------------------------------

RpgParser::Op_reset2Context::Op_reset2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_reset2Context::OP_RESET() {
  return getToken(RpgParser::OP_RESET, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_reset2Context::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::Op_reset2Context::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Op_reset2Context::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_reset2Context::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

tree::TerminalNode* RpgParser::Op_reset2Context::MULT_NOSPACE() {
  return getToken(RpgParser::MULT_NOSPACE, 0);
}


size_t RpgParser::Op_reset2Context::getRuleIndex() const {
  return RpgParser::RuleOp_reset2;
}

void RpgParser::Op_reset2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_reset2(this);
}

void RpgParser::Op_reset2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_reset2(this);
}


antlrcpp::Any RpgParser::Op_reset2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_reset2(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_reset2Context* RpgParser::op_reset2() {
  Op_reset2Context *_localctx = _tracker.createInstance<Op_reset2Context>(_ctx, getState());
  enterRule(_localctx, 894, RpgParser::RuleOp_reset2);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4745);
    match(RpgParser::OP_RESET);
    setState(4747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4746);
      cs_operationExtender();
    }
    setState(4749);
    identifier();
    setState(4750);
    match(RpgParser::OPEN_PAREN);
    setState(4752);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::MULT_NOSPACE) {
      setState(4751);
      match(RpgParser::MULT_NOSPACE);
    }
    setState(4754);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_resetContext ------------------------------------------------------------------

RpgParser::Op_resetContext::Op_resetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_resetContext::OP_RESET() {
  return getToken(RpgParser::OP_RESET, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_resetContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_resetContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_resetContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_resetContext::getRuleIndex() const {
  return RpgParser::RuleOp_reset;
}

void RpgParser::Op_resetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_reset(this);
}

void RpgParser::Op_resetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_reset(this);
}


antlrcpp::Any RpgParser::Op_resetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_reset(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_resetContext* RpgParser::op_reset() {
  Op_resetContext *_localctx = _tracker.createInstance<Op_resetContext>(_ctx, getState());
  enterRule(_localctx, 896, RpgParser::RuleOp_reset);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4756);
    match(RpgParser::OP_RESET);
    setState(4758);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4757);
      cs_operationExtender();
    }
    setState(4761);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
    case 1: {
      setState(4760);
      identifier();
      break;
    }

    }
    setState(4764);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
    case 1: {
      setState(4763);
      identifier();
      break;
    }

    }
    setState(4766);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_returnContext ------------------------------------------------------------------

RpgParser::Op_returnContext::Op_returnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_returnContext::OP_RETURN() {
  return getToken(RpgParser::OP_RETURN, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_returnContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::ExpressionContext* RpgParser::Op_returnContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Op_returnContext::getRuleIndex() const {
  return RpgParser::RuleOp_return;
}

void RpgParser::Op_returnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_return(this);
}

void RpgParser::Op_returnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_return(this);
}


antlrcpp::Any RpgParser::Op_returnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_return(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_returnContext* RpgParser::op_return() {
  Op_returnContext *_localctx = _tracker.createInstance<Op_returnContext>(_ctx, getState());
  enterRule(_localctx, 898, RpgParser::RuleOp_return);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4768);
    match(RpgParser::OP_RETURN);
    setState(4770);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx)) {
    case 1: {
      setState(4769);
      cs_operationExtender();
      break;
    }

    }
    setState(4773);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::PLUS - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(4772);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_rolbkContext ------------------------------------------------------------------

RpgParser::Op_rolbkContext::Op_rolbkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_rolbkContext::OP_ROLBK() {
  return getToken(RpgParser::OP_ROLBK, 0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_rolbkContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_rolbkContext::getRuleIndex() const {
  return RpgParser::RuleOp_rolbk;
}

void RpgParser::Op_rolbkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_rolbk(this);
}

void RpgParser::Op_rolbkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_rolbk(this);
}


antlrcpp::Any RpgParser::Op_rolbkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_rolbk(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_rolbkContext* RpgParser::op_rolbk() {
  Op_rolbkContext *_localctx = _tracker.createInstance<Op_rolbkContext>(_ctx, getState());
  enterRule(_localctx, 900, RpgParser::RuleOp_rolbk);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4775);
    match(RpgParser::OP_ROLBK);
    setState(4777);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4776);
      cs_operationExtender();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_selectContext ------------------------------------------------------------------

RpgParser::Op_selectContext::Op_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_selectContext::OP_SELECT() {
  return getToken(RpgParser::OP_SELECT, 0);
}


size_t RpgParser::Op_selectContext::getRuleIndex() const {
  return RpgParser::RuleOp_select;
}

void RpgParser::Op_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_select(this);
}

void RpgParser::Op_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_select(this);
}


antlrcpp::Any RpgParser::Op_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_select(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_selectContext* RpgParser::op_select() {
  Op_selectContext *_localctx = _tracker.createInstance<Op_selectContext>(_ctx, getState());
  enterRule(_localctx, 902, RpgParser::RuleOp_select);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4779);
    match(RpgParser::OP_SELECT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_setgtContext ------------------------------------------------------------------

RpgParser::Op_setgtContext::Op_setgtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_setgtContext::OP_SETGT() {
  return getToken(RpgParser::OP_SETGT, 0);
}

RpgParser::Search_argContext* RpgParser::Op_setgtContext::search_arg() {
  return getRuleContext<RpgParser::Search_argContext>(0);
}

RpgParser::IdentifierContext* RpgParser::Op_setgtContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_setgtContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_setgtContext::getRuleIndex() const {
  return RpgParser::RuleOp_setgt;
}

void RpgParser::Op_setgtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_setgt(this);
}

void RpgParser::Op_setgtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_setgt(this);
}


antlrcpp::Any RpgParser::Op_setgtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_setgt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_setgtContext* RpgParser::op_setgt() {
  Op_setgtContext *_localctx = _tracker.createInstance<Op_setgtContext>(_ctx, getState());
  enterRule(_localctx, 904, RpgParser::RuleOp_setgt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4781);
    match(RpgParser::OP_SETGT);
    setState(4783);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
    case 1: {
      setState(4782);
      cs_operationExtender();
      break;
    }

    }
    setState(4785);
    search_arg();
    setState(4786);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_setllContext ------------------------------------------------------------------

RpgParser::Op_setllContext::Op_setllContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_setllContext::OP_SETLL() {
  return getToken(RpgParser::OP_SETLL, 0);
}

RpgParser::Search_argContext* RpgParser::Op_setllContext::search_arg() {
  return getRuleContext<RpgParser::Search_argContext>(0);
}

RpgParser::IdentifierContext* RpgParser::Op_setllContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_setllContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_setllContext::getRuleIndex() const {
  return RpgParser::RuleOp_setll;
}

void RpgParser::Op_setllContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_setll(this);
}

void RpgParser::Op_setllContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_setll(this);
}


antlrcpp::Any RpgParser::Op_setllContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_setll(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_setllContext* RpgParser::op_setll() {
  Op_setllContext *_localctx = _tracker.createInstance<Op_setllContext>(_ctx, getState());
  enterRule(_localctx, 906, RpgParser::RuleOp_setll);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4788);
    match(RpgParser::OP_SETLL);
    setState(4790);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx)) {
    case 1: {
      setState(4789);
      cs_operationExtender();
      break;
    }

    }
    setState(4792);
    search_arg();
    setState(4793);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_sortaContext ------------------------------------------------------------------

RpgParser::Op_sortaContext::Op_sortaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_sortaContext::OP_SORTA() {
  return getToken(RpgParser::OP_SORTA, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_sortaContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Bif_subarrContext* RpgParser::Op_sortaContext::bif_subarr() {
  return getRuleContext<RpgParser::Bif_subarrContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_sortaContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_sortaContext::getRuleIndex() const {
  return RpgParser::RuleOp_sorta;
}

void RpgParser::Op_sortaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_sorta(this);
}

void RpgParser::Op_sortaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_sorta(this);
}


antlrcpp::Any RpgParser::Op_sortaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_sorta(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_sortaContext* RpgParser::op_sorta() {
  Op_sortaContext *_localctx = _tracker.createInstance<Op_sortaContext>(_ctx, getState());
  enterRule(_localctx, 908, RpgParser::RuleOp_sorta);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4795);
    match(RpgParser::OP_SORTA);
    setState(4797);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4796);
      cs_operationExtender();
    }
    setState(4801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO: {
        setState(4799);
        identifier();
        break;
      }

      case RpgParser::BIF_SUBARR: {
        setState(4800);
        bif_subarr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_testContext ------------------------------------------------------------------

RpgParser::Op_testContext::Op_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_testContext::OP_TEST() {
  return getToken(RpgParser::OP_TEST, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_testContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_testContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_testContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_testContext::getRuleIndex() const {
  return RpgParser::RuleOp_test;
}

void RpgParser::Op_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_test(this);
}

void RpgParser::Op_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_test(this);
}


antlrcpp::Any RpgParser::Op_testContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_test(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_testContext* RpgParser::op_test() {
  Op_testContext *_localctx = _tracker.createInstance<Op_testContext>(_ctx, getState());
  enterRule(_localctx, 910, RpgParser::RuleOp_test);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4803);
    match(RpgParser::OP_TEST);
    setState(4805);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4804);
      cs_operationExtender();
    }
    setState(4808);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx)) {
    case 1: {
      setState(4807);
      identifier();
      break;
    }

    }
    setState(4810);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_unlockContext ------------------------------------------------------------------

RpgParser::Op_unlockContext::Op_unlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_unlockContext::OP_UNLOCK() {
  return getToken(RpgParser::OP_UNLOCK, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_unlockContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_unlockContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_unlockContext::getRuleIndex() const {
  return RpgParser::RuleOp_unlock;
}

void RpgParser::Op_unlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_unlock(this);
}

void RpgParser::Op_unlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_unlock(this);
}


antlrcpp::Any RpgParser::Op_unlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_unlock(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_unlockContext* RpgParser::op_unlock() {
  Op_unlockContext *_localctx = _tracker.createInstance<Op_unlockContext>(_ctx, getState());
  enterRule(_localctx, 912, RpgParser::RuleOp_unlock);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4812);
    match(RpgParser::OP_UNLOCK);
    setState(4814);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4813);
      cs_operationExtender();
    }
    setState(4816);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_updateContext ------------------------------------------------------------------

RpgParser::Op_updateContext::Op_updateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_updateContext::OP_UPDATE() {
  return getToken(RpgParser::OP_UPDATE, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_updateContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_updateContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_updateContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}

RpgParser::Bif_fieldsContext* RpgParser::Op_updateContext::bif_fields() {
  return getRuleContext<RpgParser::Bif_fieldsContext>(0);
}


size_t RpgParser::Op_updateContext::getRuleIndex() const {
  return RpgParser::RuleOp_update;
}

void RpgParser::Op_updateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_update(this);
}

void RpgParser::Op_updateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_update(this);
}


antlrcpp::Any RpgParser::Op_updateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_update(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_updateContext* RpgParser::op_update() {
  Op_updateContext *_localctx = _tracker.createInstance<Op_updateContext>(_ctx, getState());
  enterRule(_localctx, 914, RpgParser::RuleOp_update);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4818);
    match(RpgParser::OP_UPDATE);
    setState(4820);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4819);
      cs_operationExtender();
    }
    setState(4822);
    identifier();
    setState(4825);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO: {
        setState(4823);
        identifier();
        break;
      }

      case RpgParser::BIF_FIELDS: {
        setState(4824);
        bif_fields();
        break;
      }

      case RpgParser::CLOSE_PAREN:
      case RpgParser::FREE_SEMI: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_whenContext ------------------------------------------------------------------

RpgParser::Op_whenContext::Op_whenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_whenContext::OP_WHEN() {
  return getToken(RpgParser::OP_WHEN, 0);
}

RpgParser::Indicator_exprContext* RpgParser::Op_whenContext::indicator_expr() {
  return getRuleContext<RpgParser::Indicator_exprContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_whenContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_whenContext::getRuleIndex() const {
  return RpgParser::RuleOp_when;
}

void RpgParser::Op_whenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_when(this);
}

void RpgParser::Op_whenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_when(this);
}


antlrcpp::Any RpgParser::Op_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_when(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_whenContext* RpgParser::op_when() {
  Op_whenContext *_localctx = _tracker.createInstance<Op_whenContext>(_ctx, getState());
  enterRule(_localctx, 916, RpgParser::RuleOp_when);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4827);
    match(RpgParser::OP_WHEN);
    setState(4829);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
    case 1: {
      setState(4828);
      cs_operationExtender();
      break;
    }

    }
    setState(4831);
    indicator_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_writeContext ------------------------------------------------------------------

RpgParser::Op_writeContext::Op_writeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_writeContext::OP_WRITE() {
  return getToken(RpgParser::OP_WRITE, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Op_writeContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Op_writeContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_writeContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_writeContext::getRuleIndex() const {
  return RpgParser::RuleOp_write;
}

void RpgParser::Op_writeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_write(this);
}

void RpgParser::Op_writeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_write(this);
}


antlrcpp::Any RpgParser::Op_writeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_write(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_writeContext* RpgParser::op_write() {
  Op_writeContext *_localctx = _tracker.createInstance<Op_writeContext>(_ctx, getState());
  enterRule(_localctx, 918, RpgParser::RuleOp_write);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4833);
    match(RpgParser::OP_WRITE);
    setState(4835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4834);
      cs_operationExtender();
    }
    setState(4837);
    identifier();
    setState(4839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << RpgParser::ID)
      | (1ULL << RpgParser::OP_ACQ)
      | (1ULL << RpgParser::OP_BEGSR)
      | (1ULL << RpgParser::OP_CALLP)
      | (1ULL << RpgParser::OP_CHAIN)
      | (1ULL << RpgParser::OP_CLEAR)
      | (1ULL << RpgParser::OP_CLOSE)
      | (1ULL << RpgParser::OP_COMMIT)
      | (1ULL << RpgParser::OP_DEALLOC)
      | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
      | (1ULL << (RpgParser::OP_DUMP - 64))
      | (1ULL << (RpgParser::OP_ENDSR - 64))
      | (1ULL << (RpgParser::OP_EVAL - 64))
      | (1ULL << (RpgParser::OP_EVALR - 64))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
      | (1ULL << (RpgParser::OP_EXCEPT - 64))
      | (1ULL << (RpgParser::OP_EXFMT - 64))
      | (1ULL << (RpgParser::OP_EXSR - 64))
      | (1ULL << (RpgParser::OP_FEOD - 64))
      | (1ULL << (RpgParser::OP_FORCE - 64))
      | (1ULL << (RpgParser::OP_IN - 64))
      | (1ULL << (RpgParser::OP_ITER - 64))
      | (1ULL << (RpgParser::OP_LEAVE - 64))
      | (1ULL << (RpgParser::OP_LEAVESR - 64))
      | (1ULL << (RpgParser::OP_NEXT - 64))
      | (1ULL << (RpgParser::OP_OPEN - 64))
      | (1ULL << (RpgParser::OP_OTHER - 64))
      | (1ULL << (RpgParser::OP_OUT - 64))
      | (1ULL << (RpgParser::OP_POST - 64))
      | (1ULL << (RpgParser::OP_READ - 64))
      | (1ULL << (RpgParser::OP_READC - 64))
      | (1ULL << (RpgParser::OP_READE - 64))
      | (1ULL << (RpgParser::OP_READP - 64))
      | (1ULL << (RpgParser::OP_READPE - 64))
      | (1ULL << (RpgParser::OP_REL - 64))
      | (1ULL << (RpgParser::OP_RESET - 64))
      | (1ULL << (RpgParser::OP_RETURN - 64))
      | (1ULL << (RpgParser::OP_ROLBK - 64))
      | (1ULL << (RpgParser::OP_SELECT - 64))
      | (1ULL << (RpgParser::OP_SETGT - 64))
      | (1ULL << (RpgParser::OP_SETLL - 64))
      | (1ULL << (RpgParser::OP_SORTA - 64))
      | (1ULL << (RpgParser::OP_TEST - 64))
      | (1ULL << (RpgParser::OP_UNLOCK - 64))
      | (1ULL << (RpgParser::OP_UPDATE - 64))
      | (1ULL << (RpgParser::OP_WHEN - 64))
      | (1ULL << (RpgParser::OP_WRITE - 64))
      | (1ULL << (RpgParser::OP_XML_INTO - 64))
      | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
      setState(4838);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_xml_intoContext ------------------------------------------------------------------

RpgParser::Op_xml_intoContext::Op_xml_intoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_xml_intoContext::OP_XML_INTO() {
  return getToken(RpgParser::OP_XML_INTO, 0);
}

RpgParser::IdentifierContext* RpgParser::Op_xml_intoContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::ExpressionContext* RpgParser::Op_xml_intoContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_xml_intoContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_xml_intoContext::getRuleIndex() const {
  return RpgParser::RuleOp_xml_into;
}

void RpgParser::Op_xml_intoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_xml_into(this);
}

void RpgParser::Op_xml_intoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_xml_into(this);
}


antlrcpp::Any RpgParser::Op_xml_intoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_xml_into(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_xml_intoContext* RpgParser::op_xml_into() {
  Op_xml_intoContext *_localctx = _tracker.createInstance<Op_xml_intoContext>(_ctx, getState());
  enterRule(_localctx, 920, RpgParser::RuleOp_xml_into);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4841);
    match(RpgParser::OP_XML_INTO);
    setState(4843);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4842);
      cs_operationExtender();
    }
    setState(4845);
    identifier();
    setState(4846);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_xml_saxContext ------------------------------------------------------------------

RpgParser::Op_xml_saxContext::Op_xml_saxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_xml_saxContext::OP_XML_SAX() {
  return getToken(RpgParser::OP_XML_SAX, 0);
}

RpgParser::Bif_handlerContext* RpgParser::Op_xml_saxContext::bif_handler() {
  return getRuleContext<RpgParser::Bif_handlerContext>(0);
}

RpgParser::Bif_xmlContext* RpgParser::Op_xml_saxContext::bif_xml() {
  return getRuleContext<RpgParser::Bif_xmlContext>(0);
}

RpgParser::Cs_operationExtenderContext* RpgParser::Op_xml_saxContext::cs_operationExtender() {
  return getRuleContext<RpgParser::Cs_operationExtenderContext>(0);
}


size_t RpgParser::Op_xml_saxContext::getRuleIndex() const {
  return RpgParser::RuleOp_xml_sax;
}

void RpgParser::Op_xml_saxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_xml_sax(this);
}

void RpgParser::Op_xml_saxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_xml_sax(this);
}


antlrcpp::Any RpgParser::Op_xml_saxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_xml_sax(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_xml_saxContext* RpgParser::op_xml_sax() {
  Op_xml_saxContext *_localctx = _tracker.createInstance<Op_xml_saxContext>(_ctx, getState());
  enterRule(_localctx, 922, RpgParser::RuleOp_xml_sax);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4848);
    match(RpgParser::OP_XML_SAX);
    setState(4850);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4849);
      cs_operationExtender();
    }
    setState(4852);
    bif_handler();
    setState(4853);
    bif_xml();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Search_argContext ------------------------------------------------------------------

RpgParser::Search_argContext::Search_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ExpressionContext* RpgParser::Search_argContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::ArgsContext* RpgParser::Search_argContext::args() {
  return getRuleContext<RpgParser::ArgsContext>(0);
}


size_t RpgParser::Search_argContext::getRuleIndex() const {
  return RpgParser::RuleSearch_arg;
}

void RpgParser::Search_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSearch_arg(this);
}

void RpgParser::Search_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSearch_arg(this);
}


antlrcpp::Any RpgParser::Search_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSearch_arg(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Search_argContext* RpgParser::search_arg() {
  Search_argContext *_localctx = _tracker.createInstance<Search_argContext>(_ctx, getState());
  enterRule(_localctx, 924, RpgParser::RuleSearch_arg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4857);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4855);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4856);
      args();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_codeContext ------------------------------------------------------------------

RpgParser::Op_codeContext::Op_codeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_ACQ() {
  return getToken(RpgParser::OP_ACQ, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_BEGSR() {
  return getToken(RpgParser::OP_BEGSR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_CALLP() {
  return getToken(RpgParser::OP_CALLP, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_CHAIN() {
  return getToken(RpgParser::OP_CHAIN, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_CLEAR() {
  return getToken(RpgParser::OP_CLEAR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_CLOSE() {
  return getToken(RpgParser::OP_CLOSE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_COMMIT() {
  return getToken(RpgParser::OP_COMMIT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_DEALLOC() {
  return getToken(RpgParser::OP_DEALLOC, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_DELETE() {
  return getToken(RpgParser::OP_DELETE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_DSPLY() {
  return getToken(RpgParser::OP_DSPLY, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_DUMP() {
  return getToken(RpgParser::OP_DUMP, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_ENDSR() {
  return getToken(RpgParser::OP_ENDSR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_EVAL() {
  return getToken(RpgParser::OP_EVAL, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_EVALR() {
  return getToken(RpgParser::OP_EVALR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_EVAL_CORR() {
  return getToken(RpgParser::OP_EVAL_CORR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_EXCEPT() {
  return getToken(RpgParser::OP_EXCEPT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_EXFMT() {
  return getToken(RpgParser::OP_EXFMT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_EXSR() {
  return getToken(RpgParser::OP_EXSR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_FEOD() {
  return getToken(RpgParser::OP_FEOD, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_FORCE() {
  return getToken(RpgParser::OP_FORCE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_IN() {
  return getToken(RpgParser::OP_IN, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_ITER() {
  return getToken(RpgParser::OP_ITER, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_LEAVE() {
  return getToken(RpgParser::OP_LEAVE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_LEAVESR() {
  return getToken(RpgParser::OP_LEAVESR, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_NEXT() {
  return getToken(RpgParser::OP_NEXT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_OPEN() {
  return getToken(RpgParser::OP_OPEN, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_OTHER() {
  return getToken(RpgParser::OP_OTHER, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_OUT() {
  return getToken(RpgParser::OP_OUT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_POST() {
  return getToken(RpgParser::OP_POST, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_READ() {
  return getToken(RpgParser::OP_READ, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_READC() {
  return getToken(RpgParser::OP_READC, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_READE() {
  return getToken(RpgParser::OP_READE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_READP() {
  return getToken(RpgParser::OP_READP, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_READPE() {
  return getToken(RpgParser::OP_READPE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_REL() {
  return getToken(RpgParser::OP_REL, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_RESET() {
  return getToken(RpgParser::OP_RESET, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_RETURN() {
  return getToken(RpgParser::OP_RETURN, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_ROLBK() {
  return getToken(RpgParser::OP_ROLBK, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_SELECT() {
  return getToken(RpgParser::OP_SELECT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_SETGT() {
  return getToken(RpgParser::OP_SETGT, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_SETLL() {
  return getToken(RpgParser::OP_SETLL, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_SORTA() {
  return getToken(RpgParser::OP_SORTA, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_TEST() {
  return getToken(RpgParser::OP_TEST, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_UNLOCK() {
  return getToken(RpgParser::OP_UNLOCK, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_UPDATE() {
  return getToken(RpgParser::OP_UPDATE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_WHEN() {
  return getToken(RpgParser::OP_WHEN, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_WRITE() {
  return getToken(RpgParser::OP_WRITE, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_XML_INTO() {
  return getToken(RpgParser::OP_XML_INTO, 0);
}

tree::TerminalNode* RpgParser::Op_codeContext::OP_XML_SAX() {
  return getToken(RpgParser::OP_XML_SAX, 0);
}


size_t RpgParser::Op_codeContext::getRuleIndex() const {
  return RpgParser::RuleOp_code;
}

void RpgParser::Op_codeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_code(this);
}

void RpgParser::Op_codeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_code(this);
}


antlrcpp::Any RpgParser::Op_codeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOp_code(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Op_codeContext* RpgParser::op_code() {
  Op_codeContext *_localctx = _tracker.createInstance<Op_codeContext>(_ctx, getState());
  enterRule(_localctx, 926, RpgParser::RuleOp_code);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4859);
    _la = _input->LA(1);
    if (!(((((_la - 53) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 53)) & ((1ULL << (RpgParser::OP_ACQ - 53))
      | (1ULL << (RpgParser::OP_BEGSR - 53))
      | (1ULL << (RpgParser::OP_CALLP - 53))
      | (1ULL << (RpgParser::OP_CHAIN - 53))
      | (1ULL << (RpgParser::OP_CLEAR - 53))
      | (1ULL << (RpgParser::OP_CLOSE - 53))
      | (1ULL << (RpgParser::OP_COMMIT - 53))
      | (1ULL << (RpgParser::OP_DEALLOC - 53))
      | (1ULL << (RpgParser::OP_DELETE - 53))
      | (1ULL << (RpgParser::OP_DSPLY - 53))
      | (1ULL << (RpgParser::OP_DUMP - 53))
      | (1ULL << (RpgParser::OP_ENDSR - 53))
      | (1ULL << (RpgParser::OP_EVAL - 53))
      | (1ULL << (RpgParser::OP_EVALR - 53))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 53))
      | (1ULL << (RpgParser::OP_EXCEPT - 53))
      | (1ULL << (RpgParser::OP_EXFMT - 53))
      | (1ULL << (RpgParser::OP_EXSR - 53))
      | (1ULL << (RpgParser::OP_FEOD - 53))
      | (1ULL << (RpgParser::OP_FORCE - 53))
      | (1ULL << (RpgParser::OP_IN - 53))
      | (1ULL << (RpgParser::OP_ITER - 53))
      | (1ULL << (RpgParser::OP_LEAVE - 53))
      | (1ULL << (RpgParser::OP_LEAVESR - 53))
      | (1ULL << (RpgParser::OP_NEXT - 53))
      | (1ULL << (RpgParser::OP_OPEN - 53))
      | (1ULL << (RpgParser::OP_OTHER - 53))
      | (1ULL << (RpgParser::OP_OUT - 53))
      | (1ULL << (RpgParser::OP_POST - 53))
      | (1ULL << (RpgParser::OP_READ - 53))
      | (1ULL << (RpgParser::OP_READC - 53))
      | (1ULL << (RpgParser::OP_READE - 53))
      | (1ULL << (RpgParser::OP_READP - 53))
      | (1ULL << (RpgParser::OP_READPE - 53))
      | (1ULL << (RpgParser::OP_REL - 53))
      | (1ULL << (RpgParser::OP_RESET - 53))
      | (1ULL << (RpgParser::OP_RETURN - 53))
      | (1ULL << (RpgParser::OP_ROLBK - 53))
      | (1ULL << (RpgParser::OP_SELECT - 53))
      | (1ULL << (RpgParser::OP_SETGT - 53))
      | (1ULL << (RpgParser::OP_SETLL - 53))
      | (1ULL << (RpgParser::OP_SORTA - 53))
      | (1ULL << (RpgParser::OP_TEST - 53))
      | (1ULL << (RpgParser::OP_UNLOCK - 53))
      | (1ULL << (RpgParser::OP_UPDATE - 53))
      | (1ULL << (RpgParser::OP_WHEN - 53))
      | (1ULL << (RpgParser::OP_WRITE - 53))
      | (1ULL << (RpgParser::OP_XML_INTO - 53))
      | (1ULL << (RpgParser::OP_XML_SAX - 53)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BifContext ------------------------------------------------------------------

RpgParser::BifContext::BifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Bif_absContext* RpgParser::BifContext::bif_abs() {
  return getRuleContext<RpgParser::Bif_absContext>(0);
}

RpgParser::Bif_addrContext* RpgParser::BifContext::bif_addr() {
  return getRuleContext<RpgParser::Bif_addrContext>(0);
}

RpgParser::Bif_allocContext* RpgParser::BifContext::bif_alloc() {
  return getRuleContext<RpgParser::Bif_allocContext>(0);
}

RpgParser::Bif_bitandContext* RpgParser::BifContext::bif_bitand() {
  return getRuleContext<RpgParser::Bif_bitandContext>(0);
}

RpgParser::Bif_bitnotContext* RpgParser::BifContext::bif_bitnot() {
  return getRuleContext<RpgParser::Bif_bitnotContext>(0);
}

RpgParser::Bif_bitorContext* RpgParser::BifContext::bif_bitor() {
  return getRuleContext<RpgParser::Bif_bitorContext>(0);
}

RpgParser::Bif_bitxorContext* RpgParser::BifContext::bif_bitxor() {
  return getRuleContext<RpgParser::Bif_bitxorContext>(0);
}

RpgParser::Bif_charContext* RpgParser::BifContext::bif_char() {
  return getRuleContext<RpgParser::Bif_charContext>(0);
}

RpgParser::Bif_checkContext* RpgParser::BifContext::bif_check() {
  return getRuleContext<RpgParser::Bif_checkContext>(0);
}

RpgParser::Bif_checkrContext* RpgParser::BifContext::bif_checkr() {
  return getRuleContext<RpgParser::Bif_checkrContext>(0);
}

RpgParser::Bif_dateContext* RpgParser::BifContext::bif_date() {
  return getRuleContext<RpgParser::Bif_dateContext>(0);
}

RpgParser::Bif_daysContext* RpgParser::BifContext::bif_days() {
  return getRuleContext<RpgParser::Bif_daysContext>(0);
}

RpgParser::Bif_decContext* RpgParser::BifContext::bif_dec() {
  return getRuleContext<RpgParser::Bif_decContext>(0);
}

RpgParser::Bif_dechContext* RpgParser::BifContext::bif_dech() {
  return getRuleContext<RpgParser::Bif_dechContext>(0);
}

RpgParser::Bif_decposContext* RpgParser::BifContext::bif_decpos() {
  return getRuleContext<RpgParser::Bif_decposContext>(0);
}

RpgParser::Bif_diffContext* RpgParser::BifContext::bif_diff() {
  return getRuleContext<RpgParser::Bif_diffContext>(0);
}

RpgParser::Bif_divContext* RpgParser::BifContext::bif_div() {
  return getRuleContext<RpgParser::Bif_divContext>(0);
}

RpgParser::Bif_editcContext* RpgParser::BifContext::bif_editc() {
  return getRuleContext<RpgParser::Bif_editcContext>(0);
}

RpgParser::Bif_editfltContext* RpgParser::BifContext::bif_editflt() {
  return getRuleContext<RpgParser::Bif_editfltContext>(0);
}

RpgParser::Bif_editwContext* RpgParser::BifContext::bif_editw() {
  return getRuleContext<RpgParser::Bif_editwContext>(0);
}

RpgParser::Bif_elemContext* RpgParser::BifContext::bif_elem() {
  return getRuleContext<RpgParser::Bif_elemContext>(0);
}

RpgParser::Bif_eofContext* RpgParser::BifContext::bif_eof() {
  return getRuleContext<RpgParser::Bif_eofContext>(0);
}

RpgParser::Bif_equalContext* RpgParser::BifContext::bif_equal() {
  return getRuleContext<RpgParser::Bif_equalContext>(0);
}

RpgParser::Bif_errorContext* RpgParser::BifContext::bif_error() {
  return getRuleContext<RpgParser::Bif_errorContext>(0);
}

RpgParser::Bif_fieldsContext* RpgParser::BifContext::bif_fields() {
  return getRuleContext<RpgParser::Bif_fieldsContext>(0);
}

RpgParser::Bif_floatContext* RpgParser::BifContext::bif_float() {
  return getRuleContext<RpgParser::Bif_floatContext>(0);
}

RpgParser::Bif_foundContext* RpgParser::BifContext::bif_found() {
  return getRuleContext<RpgParser::Bif_foundContext>(0);
}

RpgParser::Bif_graphContext* RpgParser::BifContext::bif_graph() {
  return getRuleContext<RpgParser::Bif_graphContext>(0);
}

RpgParser::Bif_handlerContext* RpgParser::BifContext::bif_handler() {
  return getRuleContext<RpgParser::Bif_handlerContext>(0);
}

RpgParser::Bif_hoursContext* RpgParser::BifContext::bif_hours() {
  return getRuleContext<RpgParser::Bif_hoursContext>(0);
}

RpgParser::Bif_intContext* RpgParser::BifContext::bif_int() {
  return getRuleContext<RpgParser::Bif_intContext>(0);
}

RpgParser::Bif_inthContext* RpgParser::BifContext::bif_inth() {
  return getRuleContext<RpgParser::Bif_inthContext>(0);
}

RpgParser::Bif_kdsContext* RpgParser::BifContext::bif_kds() {
  return getRuleContext<RpgParser::Bif_kdsContext>(0);
}

RpgParser::Bif_lenContext* RpgParser::BifContext::bif_len() {
  return getRuleContext<RpgParser::Bif_lenContext>(0);
}

RpgParser::Bif_lookupContext* RpgParser::BifContext::bif_lookup() {
  return getRuleContext<RpgParser::Bif_lookupContext>(0);
}

RpgParser::Bif_lookupltContext* RpgParser::BifContext::bif_lookuplt() {
  return getRuleContext<RpgParser::Bif_lookupltContext>(0);
}

RpgParser::Bif_lookupleContext* RpgParser::BifContext::bif_lookuple() {
  return getRuleContext<RpgParser::Bif_lookupleContext>(0);
}

RpgParser::Bif_lookupgtContext* RpgParser::BifContext::bif_lookupgt() {
  return getRuleContext<RpgParser::Bif_lookupgtContext>(0);
}

RpgParser::Bif_lookupgeContext* RpgParser::BifContext::bif_lookupge() {
  return getRuleContext<RpgParser::Bif_lookupgeContext>(0);
}

RpgParser::Bif_minutesContext* RpgParser::BifContext::bif_minutes() {
  return getRuleContext<RpgParser::Bif_minutesContext>(0);
}

RpgParser::Bif_monthsContext* RpgParser::BifContext::bif_months() {
  return getRuleContext<RpgParser::Bif_monthsContext>(0);
}

RpgParser::Bif_msecondsContext* RpgParser::BifContext::bif_mseconds() {
  return getRuleContext<RpgParser::Bif_msecondsContext>(0);
}

RpgParser::Bif_nullindContext* RpgParser::BifContext::bif_nullind() {
  return getRuleContext<RpgParser::Bif_nullindContext>(0);
}

RpgParser::Bif_occurContext* RpgParser::BifContext::bif_occur() {
  return getRuleContext<RpgParser::Bif_occurContext>(0);
}

RpgParser::Bif_openContext* RpgParser::BifContext::bif_open() {
  return getRuleContext<RpgParser::Bif_openContext>(0);
}

RpgParser::Bif_paddrContext* RpgParser::BifContext::bif_paddr() {
  return getRuleContext<RpgParser::Bif_paddrContext>(0);
}

RpgParser::Bif_parmsContext* RpgParser::BifContext::bif_parms() {
  return getRuleContext<RpgParser::Bif_parmsContext>(0);
}

RpgParser::Bif_parmnumContext* RpgParser::BifContext::bif_parmnum() {
  return getRuleContext<RpgParser::Bif_parmnumContext>(0);
}

RpgParser::Bif_reallocContext* RpgParser::BifContext::bif_realloc() {
  return getRuleContext<RpgParser::Bif_reallocContext>(0);
}

RpgParser::Bif_remContext* RpgParser::BifContext::bif_rem() {
  return getRuleContext<RpgParser::Bif_remContext>(0);
}

RpgParser::Bif_replaceContext* RpgParser::BifContext::bif_replace() {
  return getRuleContext<RpgParser::Bif_replaceContext>(0);
}

RpgParser::Bif_scanContext* RpgParser::BifContext::bif_scan() {
  return getRuleContext<RpgParser::Bif_scanContext>(0);
}

RpgParser::Bif_scanrplContext* RpgParser::BifContext::bif_scanrpl() {
  return getRuleContext<RpgParser::Bif_scanrplContext>(0);
}

RpgParser::Bif_secondsContext* RpgParser::BifContext::bif_seconds() {
  return getRuleContext<RpgParser::Bif_secondsContext>(0);
}

RpgParser::Bif_shtdnContext* RpgParser::BifContext::bif_shtdn() {
  return getRuleContext<RpgParser::Bif_shtdnContext>(0);
}

RpgParser::Bif_sizeContext* RpgParser::BifContext::bif_size() {
  return getRuleContext<RpgParser::Bif_sizeContext>(0);
}

RpgParser::Bif_sqrtContext* RpgParser::BifContext::bif_sqrt() {
  return getRuleContext<RpgParser::Bif_sqrtContext>(0);
}

RpgParser::Bif_statusContext* RpgParser::BifContext::bif_status() {
  return getRuleContext<RpgParser::Bif_statusContext>(0);
}

RpgParser::Bif_strContext* RpgParser::BifContext::bif_str() {
  return getRuleContext<RpgParser::Bif_strContext>(0);
}

RpgParser::Bif_subarrContext* RpgParser::BifContext::bif_subarr() {
  return getRuleContext<RpgParser::Bif_subarrContext>(0);
}

RpgParser::Bif_subdtContext* RpgParser::BifContext::bif_subdt() {
  return getRuleContext<RpgParser::Bif_subdtContext>(0);
}

RpgParser::Bif_substContext* RpgParser::BifContext::bif_subst() {
  return getRuleContext<RpgParser::Bif_substContext>(0);
}

RpgParser::Bif_thisContext* RpgParser::BifContext::bif_this() {
  return getRuleContext<RpgParser::Bif_thisContext>(0);
}

RpgParser::Bif_timeContext* RpgParser::BifContext::bif_time() {
  return getRuleContext<RpgParser::Bif_timeContext>(0);
}

RpgParser::Bif_timestampContext* RpgParser::BifContext::bif_timestamp() {
  return getRuleContext<RpgParser::Bif_timestampContext>(0);
}

RpgParser::Bif_tlookupContext* RpgParser::BifContext::bif_tlookup() {
  return getRuleContext<RpgParser::Bif_tlookupContext>(0);
}

RpgParser::Bif_tlookupltContext* RpgParser::BifContext::bif_tlookuplt() {
  return getRuleContext<RpgParser::Bif_tlookupltContext>(0);
}

RpgParser::Bif_tlookupleContext* RpgParser::BifContext::bif_tlookuple() {
  return getRuleContext<RpgParser::Bif_tlookupleContext>(0);
}

RpgParser::Bif_tlookupgtContext* RpgParser::BifContext::bif_tlookupgt() {
  return getRuleContext<RpgParser::Bif_tlookupgtContext>(0);
}

RpgParser::Bif_tlookupgeContext* RpgParser::BifContext::bif_tlookupge() {
  return getRuleContext<RpgParser::Bif_tlookupgeContext>(0);
}

RpgParser::Bif_trimContext* RpgParser::BifContext::bif_trim() {
  return getRuleContext<RpgParser::Bif_trimContext>(0);
}

RpgParser::Bif_trimlContext* RpgParser::BifContext::bif_triml() {
  return getRuleContext<RpgParser::Bif_trimlContext>(0);
}

RpgParser::Bif_trimrContext* RpgParser::BifContext::bif_trimr() {
  return getRuleContext<RpgParser::Bif_trimrContext>(0);
}

RpgParser::Bif_ucs2Context* RpgParser::BifContext::bif_ucs2() {
  return getRuleContext<RpgParser::Bif_ucs2Context>(0);
}

RpgParser::Bif_unsContext* RpgParser::BifContext::bif_uns() {
  return getRuleContext<RpgParser::Bif_unsContext>(0);
}

RpgParser::Bif_unshContext* RpgParser::BifContext::bif_unsh() {
  return getRuleContext<RpgParser::Bif_unshContext>(0);
}

RpgParser::Bif_xfootContext* RpgParser::BifContext::bif_xfoot() {
  return getRuleContext<RpgParser::Bif_xfootContext>(0);
}

RpgParser::Bif_xlateContext* RpgParser::BifContext::bif_xlate() {
  return getRuleContext<RpgParser::Bif_xlateContext>(0);
}

RpgParser::Bif_xmlContext* RpgParser::BifContext::bif_xml() {
  return getRuleContext<RpgParser::Bif_xmlContext>(0);
}

RpgParser::Bif_yearsContext* RpgParser::BifContext::bif_years() {
  return getRuleContext<RpgParser::Bif_yearsContext>(0);
}


size_t RpgParser::BifContext::getRuleIndex() const {
  return RpgParser::RuleBif;
}

void RpgParser::BifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif(this);
}

void RpgParser::BifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif(this);
}


antlrcpp::Any RpgParser::BifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BifContext* RpgParser::bif() {
  BifContext *_localctx = _tracker.createInstance<BifContext>(_ctx, getState());
  enterRule(_localctx, 928, RpgParser::RuleBif);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4941);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::BIF_ABS: {
        enterOuterAlt(_localctx, 1);
        setState(4861);
        bif_abs();
        break;
      }

      case RpgParser::BIF_ADDR: {
        enterOuterAlt(_localctx, 2);
        setState(4862);
        bif_addr();
        break;
      }

      case RpgParser::BIF_ALLOC: {
        enterOuterAlt(_localctx, 3);
        setState(4863);
        bif_alloc();
        break;
      }

      case RpgParser::BIF_BITAND: {
        enterOuterAlt(_localctx, 4);
        setState(4864);
        bif_bitand();
        break;
      }

      case RpgParser::BIF_BITNOT: {
        enterOuterAlt(_localctx, 5);
        setState(4865);
        bif_bitnot();
        break;
      }

      case RpgParser::BIF_BITOR: {
        enterOuterAlt(_localctx, 6);
        setState(4866);
        bif_bitor();
        break;
      }

      case RpgParser::BIF_BITXOR: {
        enterOuterAlt(_localctx, 7);
        setState(4867);
        bif_bitxor();
        break;
      }

      case RpgParser::BIF_CHAR: {
        enterOuterAlt(_localctx, 8);
        setState(4868);
        bif_char();
        break;
      }

      case RpgParser::BIF_CHECK: {
        enterOuterAlt(_localctx, 9);
        setState(4869);
        bif_check();
        break;
      }

      case RpgParser::BIF_CHECKR: {
        enterOuterAlt(_localctx, 10);
        setState(4870);
        bif_checkr();
        break;
      }

      case RpgParser::BIF_DATE: {
        enterOuterAlt(_localctx, 11);
        setState(4871);
        bif_date();
        break;
      }

      case RpgParser::BIF_DAYS: {
        enterOuterAlt(_localctx, 12);
        setState(4872);
        bif_days();
        break;
      }

      case RpgParser::BIF_DEC: {
        enterOuterAlt(_localctx, 13);
        setState(4873);
        bif_dec();
        break;
      }

      case RpgParser::BIF_DECH: {
        enterOuterAlt(_localctx, 14);
        setState(4874);
        bif_dech();
        break;
      }

      case RpgParser::BIF_DECPOS: {
        enterOuterAlt(_localctx, 15);
        setState(4875);
        bif_decpos();
        break;
      }

      case RpgParser::BIF_DIFF: {
        enterOuterAlt(_localctx, 16);
        setState(4876);
        bif_diff();
        break;
      }

      case RpgParser::BIF_DIV: {
        enterOuterAlt(_localctx, 17);
        setState(4877);
        bif_div();
        break;
      }

      case RpgParser::BIF_EDITC: {
        enterOuterAlt(_localctx, 18);
        setState(4878);
        bif_editc();
        break;
      }

      case RpgParser::BIF_EDITFLT: {
        enterOuterAlt(_localctx, 19);
        setState(4879);
        bif_editflt();
        break;
      }

      case RpgParser::BIF_EDITW: {
        enterOuterAlt(_localctx, 20);
        setState(4880);
        bif_editw();
        break;
      }

      case RpgParser::BIF_ELEM: {
        enterOuterAlt(_localctx, 21);
        setState(4881);
        bif_elem();
        break;
      }

      case RpgParser::BIF_EOF: {
        enterOuterAlt(_localctx, 22);
        setState(4882);
        bif_eof();
        break;
      }

      case RpgParser::BIF_EQUAL: {
        enterOuterAlt(_localctx, 23);
        setState(4883);
        bif_equal();
        break;
      }

      case RpgParser::BIF_ERROR: {
        enterOuterAlt(_localctx, 24);
        setState(4884);
        bif_error();
        break;
      }

      case RpgParser::BIF_FIELDS: {
        enterOuterAlt(_localctx, 25);
        setState(4885);
        bif_fields();
        break;
      }

      case RpgParser::BIF_FLOAT: {
        enterOuterAlt(_localctx, 26);
        setState(4886);
        bif_float();
        break;
      }

      case RpgParser::BIF_FOUND: {
        enterOuterAlt(_localctx, 27);
        setState(4887);
        bif_found();
        break;
      }

      case RpgParser::BIF_GRAPH: {
        enterOuterAlt(_localctx, 28);
        setState(4888);
        bif_graph();
        break;
      }

      case RpgParser::BIF_HANDLER: {
        enterOuterAlt(_localctx, 29);
        setState(4889);
        bif_handler();
        break;
      }

      case RpgParser::BIF_HOURS: {
        enterOuterAlt(_localctx, 30);
        setState(4890);
        bif_hours();
        break;
      }

      case RpgParser::BIF_INT: {
        enterOuterAlt(_localctx, 31);
        setState(4891);
        bif_int();
        break;
      }

      case RpgParser::BIF_INTH: {
        enterOuterAlt(_localctx, 32);
        setState(4892);
        bif_inth();
        break;
      }

      case RpgParser::BIF_KDS: {
        enterOuterAlt(_localctx, 33);
        setState(4893);
        bif_kds();
        break;
      }

      case RpgParser::BIF_LEN: {
        enterOuterAlt(_localctx, 34);
        setState(4894);
        bif_len();
        break;
      }

      case RpgParser::BIF_LOOKUP: {
        enterOuterAlt(_localctx, 35);
        setState(4895);
        bif_lookup();
        break;
      }

      case RpgParser::BIF_LOOKUPLT: {
        enterOuterAlt(_localctx, 36);
        setState(4896);
        bif_lookuplt();
        break;
      }

      case RpgParser::BIF_LOOKUPLE: {
        enterOuterAlt(_localctx, 37);
        setState(4897);
        bif_lookuple();
        break;
      }

      case RpgParser::BIF_LOOKUPGT: {
        enterOuterAlt(_localctx, 38);
        setState(4898);
        bif_lookupgt();
        break;
      }

      case RpgParser::BIF_LOOKUPGE: {
        enterOuterAlt(_localctx, 39);
        setState(4899);
        bif_lookupge();
        break;
      }

      case RpgParser::BIF_MINUTES: {
        enterOuterAlt(_localctx, 40);
        setState(4900);
        bif_minutes();
        break;
      }

      case RpgParser::BIF_MONTHS: {
        enterOuterAlt(_localctx, 41);
        setState(4901);
        bif_months();
        break;
      }

      case RpgParser::BIF_MSECONDS: {
        enterOuterAlt(_localctx, 42);
        setState(4902);
        bif_mseconds();
        break;
      }

      case RpgParser::BIF_NULLIND: {
        enterOuterAlt(_localctx, 43);
        setState(4903);
        bif_nullind();
        break;
      }

      case RpgParser::BIF_OCCUR: {
        enterOuterAlt(_localctx, 44);
        setState(4904);
        bif_occur();
        break;
      }

      case RpgParser::BIF_OPEN: {
        enterOuterAlt(_localctx, 45);
        setState(4905);
        bif_open();
        break;
      }

      case RpgParser::BIF_PADDR: {
        enterOuterAlt(_localctx, 46);
        setState(4906);
        bif_paddr();
        break;
      }

      case RpgParser::BIF_PARMS: {
        enterOuterAlt(_localctx, 47);
        setState(4907);
        bif_parms();
        break;
      }

      case RpgParser::BIF_PARMNUM: {
        enterOuterAlt(_localctx, 48);
        setState(4908);
        bif_parmnum();
        break;
      }

      case RpgParser::BIF_REALLOC: {
        enterOuterAlt(_localctx, 49);
        setState(4909);
        bif_realloc();
        break;
      }

      case RpgParser::BIF_REM: {
        enterOuterAlt(_localctx, 50);
        setState(4910);
        bif_rem();
        break;
      }

      case RpgParser::BIF_REPLACE: {
        enterOuterAlt(_localctx, 51);
        setState(4911);
        bif_replace();
        break;
      }

      case RpgParser::BIF_SCAN: {
        enterOuterAlt(_localctx, 52);
        setState(4912);
        bif_scan();
        break;
      }

      case RpgParser::BIF_SCANRPL: {
        enterOuterAlt(_localctx, 53);
        setState(4913);
        bif_scanrpl();
        break;
      }

      case RpgParser::BIF_SECONDS: {
        enterOuterAlt(_localctx, 54);
        setState(4914);
        bif_seconds();
        break;
      }

      case RpgParser::BIF_SHTDN: {
        enterOuterAlt(_localctx, 55);
        setState(4915);
        bif_shtdn();
        break;
      }

      case RpgParser::BIF_SIZE: {
        enterOuterAlt(_localctx, 56);
        setState(4916);
        bif_size();
        break;
      }

      case RpgParser::BIF_SQRT: {
        enterOuterAlt(_localctx, 57);
        setState(4917);
        bif_sqrt();
        break;
      }

      case RpgParser::BIF_STATUS: {
        enterOuterAlt(_localctx, 58);
        setState(4918);
        bif_status();
        break;
      }

      case RpgParser::BIF_STR: {
        enterOuterAlt(_localctx, 59);
        setState(4919);
        bif_str();
        break;
      }

      case RpgParser::BIF_SUBARR: {
        enterOuterAlt(_localctx, 60);
        setState(4920);
        bif_subarr();
        break;
      }

      case RpgParser::BIF_SUBDT: {
        enterOuterAlt(_localctx, 61);
        setState(4921);
        bif_subdt();
        break;
      }

      case RpgParser::BIF_SUBST: {
        enterOuterAlt(_localctx, 62);
        setState(4922);
        bif_subst();
        break;
      }

      case RpgParser::BIF_THIS: {
        enterOuterAlt(_localctx, 63);
        setState(4923);
        bif_this();
        break;
      }

      case RpgParser::BIF_TIME: {
        enterOuterAlt(_localctx, 64);
        setState(4924);
        bif_time();
        break;
      }

      case RpgParser::BIF_TIMESTAMP: {
        enterOuterAlt(_localctx, 65);
        setState(4925);
        bif_timestamp();
        break;
      }

      case RpgParser::BIF_TLOOKUP: {
        enterOuterAlt(_localctx, 66);
        setState(4926);
        bif_tlookup();
        break;
      }

      case RpgParser::BIF_TLOOKUPLT: {
        enterOuterAlt(_localctx, 67);
        setState(4927);
        bif_tlookuplt();
        break;
      }

      case RpgParser::BIF_TLOOKUPLE: {
        enterOuterAlt(_localctx, 68);
        setState(4928);
        bif_tlookuple();
        break;
      }

      case RpgParser::BIF_TLOOKUPGT: {
        enterOuterAlt(_localctx, 69);
        setState(4929);
        bif_tlookupgt();
        break;
      }

      case RpgParser::BIF_TLOOKUPGE: {
        enterOuterAlt(_localctx, 70);
        setState(4930);
        bif_tlookupge();
        break;
      }

      case RpgParser::BIF_TRIM: {
        enterOuterAlt(_localctx, 71);
        setState(4931);
        bif_trim();
        break;
      }

      case RpgParser::BIF_TRIML: {
        enterOuterAlt(_localctx, 72);
        setState(4932);
        bif_triml();
        break;
      }

      case RpgParser::BIF_TRIMR: {
        enterOuterAlt(_localctx, 73);
        setState(4933);
        bif_trimr();
        break;
      }

      case RpgParser::BIF_UCS2: {
        enterOuterAlt(_localctx, 74);
        setState(4934);
        bif_ucs2();
        break;
      }

      case RpgParser::BIF_UNS: {
        enterOuterAlt(_localctx, 75);
        setState(4935);
        bif_uns();
        break;
      }

      case RpgParser::BIF_UNSH: {
        enterOuterAlt(_localctx, 76);
        setState(4936);
        bif_unsh();
        break;
      }

      case RpgParser::BIF_XFOOT: {
        enterOuterAlt(_localctx, 77);
        setState(4937);
        bif_xfoot();
        break;
      }

      case RpgParser::BIF_XLATE: {
        enterOuterAlt(_localctx, 78);
        setState(4938);
        bif_xlate();
        break;
      }

      case RpgParser::BIF_XML: {
        enterOuterAlt(_localctx, 79);
        setState(4939);
        bif_xml();
        break;
      }

      case RpgParser::BIF_YEARS: {
        enterOuterAlt(_localctx, 80);
        setState(4940);
        bif_years();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptargsContext ------------------------------------------------------------------

RpgParser::OptargsContext::OptargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::OptargsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::OptargsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::OptargsContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::OptargsContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::OptargsContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::OptargsContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::OptargsContext::getRuleIndex() const {
  return RpgParser::RuleOptargs;
}

void RpgParser::OptargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptargs(this);
}

void RpgParser::OptargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptargs(this);
}


antlrcpp::Any RpgParser::OptargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOptargs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OptargsContext* RpgParser::optargs() {
  OptargsContext *_localctx = _tracker.createInstance<OptargsContext>(_ctx, getState());
  enterRule(_localctx, 930, RpgParser::RuleOptargs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4955);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::OPEN_PAREN) {
      setState(4943);
      match(RpgParser::OPEN_PAREN);
      setState(4952);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
        | (1ULL << (RpgParser::NUMBER - 20))
        | (1ULL << (RpgParser::ID - 20))
        | (1ULL << (RpgParser::OP_ACQ - 20))
        | (1ULL << (RpgParser::OP_BEGSR - 20))
        | (1ULL << (RpgParser::OP_CALLP - 20))
        | (1ULL << (RpgParser::OP_CHAIN - 20))
        | (1ULL << (RpgParser::OP_CLEAR - 20))
        | (1ULL << (RpgParser::OP_CLOSE - 20))
        | (1ULL << (RpgParser::OP_COMMIT - 20))
        | (1ULL << (RpgParser::OP_DEALLOC - 20))
        | (1ULL << (RpgParser::OP_DELETE - 20))
        | (1ULL << (RpgParser::OP_DSPLY - 20))
        | (1ULL << (RpgParser::OP_DUMP - 20))
        | (1ULL << (RpgParser::OP_ENDSR - 20))
        | (1ULL << (RpgParser::OP_EVAL - 20))
        | (1ULL << (RpgParser::OP_EVALR - 20))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
        | (1ULL << (RpgParser::OP_EXCEPT - 20))
        | (1ULL << (RpgParser::OP_EXFMT - 20))
        | (1ULL << (RpgParser::OP_EXSR - 20))
        | (1ULL << (RpgParser::OP_FEOD - 20))
        | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
        | (1ULL << (RpgParser::OP_ITER - 84))
        | (1ULL << (RpgParser::OP_LEAVE - 84))
        | (1ULL << (RpgParser::OP_LEAVESR - 84))
        | (1ULL << (RpgParser::OP_NEXT - 84))
        | (1ULL << (RpgParser::OP_OPEN - 84))
        | (1ULL << (RpgParser::OP_OTHER - 84))
        | (1ULL << (RpgParser::OP_OUT - 84))
        | (1ULL << (RpgParser::OP_POST - 84))
        | (1ULL << (RpgParser::OP_READ - 84))
        | (1ULL << (RpgParser::OP_READC - 84))
        | (1ULL << (RpgParser::OP_READE - 84))
        | (1ULL << (RpgParser::OP_READP - 84))
        | (1ULL << (RpgParser::OP_READPE - 84))
        | (1ULL << (RpgParser::OP_REL - 84))
        | (1ULL << (RpgParser::OP_RESET - 84))
        | (1ULL << (RpgParser::OP_RETURN - 84))
        | (1ULL << (RpgParser::OP_ROLBK - 84))
        | (1ULL << (RpgParser::OP_SELECT - 84))
        | (1ULL << (RpgParser::OP_SETGT - 84))
        | (1ULL << (RpgParser::OP_SETLL - 84))
        | (1ULL << (RpgParser::OP_SORTA - 84))
        | (1ULL << (RpgParser::OP_TEST - 84))
        | (1ULL << (RpgParser::OP_UNLOCK - 84))
        | (1ULL << (RpgParser::OP_UPDATE - 84))
        | (1ULL << (RpgParser::OP_WHEN - 84))
        | (1ULL << (RpgParser::OP_WRITE - 84))
        | (1ULL << (RpgParser::OP_XML_INTO - 84))
        | (1ULL << (RpgParser::OP_XML_SAX - 84))
        | (1ULL << (RpgParser::BIF_ABS - 84))
        | (1ULL << (RpgParser::BIF_ADDR - 84))
        | (1ULL << (RpgParser::BIF_ALLOC - 84))
        | (1ULL << (RpgParser::BIF_BITAND - 84))
        | (1ULL << (RpgParser::BIF_BITNOT - 84))
        | (1ULL << (RpgParser::BIF_BITOR - 84))
        | (1ULL << (RpgParser::BIF_BITXOR - 84))
        | (1ULL << (RpgParser::BIF_CHAR - 84))
        | (1ULL << (RpgParser::BIF_CHECK - 84))
        | (1ULL << (RpgParser::BIF_CHECKR - 84))
        | (1ULL << (RpgParser::BIF_DATE - 84))
        | (1ULL << (RpgParser::BIF_DAYS - 84))
        | (1ULL << (RpgParser::BIF_DEC - 84))
        | (1ULL << (RpgParser::BIF_DECH - 84))
        | (1ULL << (RpgParser::BIF_DECPOS - 84))
        | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
        | (1ULL << (RpgParser::BIF_EDITC - 148))
        | (1ULL << (RpgParser::BIF_EDITFLT - 148))
        | (1ULL << (RpgParser::BIF_EDITW - 148))
        | (1ULL << (RpgParser::BIF_ELEM - 148))
        | (1ULL << (RpgParser::BIF_EOF - 148))
        | (1ULL << (RpgParser::BIF_EQUAL - 148))
        | (1ULL << (RpgParser::BIF_ERROR - 148))
        | (1ULL << (RpgParser::BIF_FIELDS - 148))
        | (1ULL << (RpgParser::BIF_FLOAT - 148))
        | (1ULL << (RpgParser::BIF_FOUND - 148))
        | (1ULL << (RpgParser::BIF_GRAPH - 148))
        | (1ULL << (RpgParser::BIF_HANDLER - 148))
        | (1ULL << (RpgParser::BIF_HOURS - 148))
        | (1ULL << (RpgParser::BIF_INT - 148))
        | (1ULL << (RpgParser::BIF_INTH - 148))
        | (1ULL << (RpgParser::BIF_KDS - 148))
        | (1ULL << (RpgParser::BIF_LEN - 148))
        | (1ULL << (RpgParser::BIF_LOOKUP - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_MINUTES - 148))
        | (1ULL << (RpgParser::BIF_MONTHS - 148))
        | (1ULL << (RpgParser::BIF_MSECONDS - 148))
        | (1ULL << (RpgParser::BIF_NULLIND - 148))
        | (1ULL << (RpgParser::BIF_OCCUR - 148))
        | (1ULL << (RpgParser::BIF_OPEN - 148))
        | (1ULL << (RpgParser::BIF_PADDR - 148))
        | (1ULL << (RpgParser::BIF_PARMS - 148))
        | (1ULL << (RpgParser::BIF_PARMNUM - 148))
        | (1ULL << (RpgParser::BIF_REALLOC - 148))
        | (1ULL << (RpgParser::BIF_REM - 148))
        | (1ULL << (RpgParser::BIF_REPLACE - 148))
        | (1ULL << (RpgParser::BIF_SCAN - 148))
        | (1ULL << (RpgParser::BIF_SCANRPL - 148))
        | (1ULL << (RpgParser::BIF_SECONDS - 148))
        | (1ULL << (RpgParser::BIF_SHTDN - 148))
        | (1ULL << (RpgParser::BIF_SIZE - 148))
        | (1ULL << (RpgParser::BIF_SQRT - 148))
        | (1ULL << (RpgParser::BIF_STATUS - 148))
        | (1ULL << (RpgParser::BIF_STR - 148))
        | (1ULL << (RpgParser::BIF_SUBARR - 148))
        | (1ULL << (RpgParser::BIF_SUBDT - 148))
        | (1ULL << (RpgParser::BIF_SUBST - 148))
        | (1ULL << (RpgParser::BIF_THIS - 148))
        | (1ULL << (RpgParser::BIF_TIME - 148))
        | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_TRIM - 148))
        | (1ULL << (RpgParser::BIF_TRIML - 148))
        | (1ULL << (RpgParser::BIF_TRIMR - 148))
        | (1ULL << (RpgParser::BIF_UCS2 - 148))
        | (1ULL << (RpgParser::BIF_UNS - 148))
        | (1ULL << (RpgParser::BIF_UNSH - 148))
        | (1ULL << (RpgParser::BIF_XFOOT - 148))
        | (1ULL << (RpgParser::BIF_XLATE - 148))
        | (1ULL << (RpgParser::BIF_XML - 148))
        | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::PLUS - 404))
        | (1ULL << (RpgParser::MINUS - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404))
        | (1ULL << (RpgParser::HexLiteralStart - 404))
        | (1ULL << (RpgParser::DateLiteralStart - 404))
        | (1ULL << (RpgParser::TimeLiteralStart - 404))
        | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
        | (1ULL << (RpgParser::GraphicLiteralStart - 404))
        | (1ULL << (RpgParser::UCS2LiteralStart - 404))
        | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
        setState(4944);
        expression(0);
        setState(4949);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == RpgParser::COLON) {
          setState(4945);
          match(RpgParser::COLON);
          setState(4946);
          expression(0);
          setState(4951);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(4954);
      match(RpgParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_charformatContext ------------------------------------------------------------------

RpgParser::Bif_charformatContext::Bif_charformatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SymbolicConstantsContext* RpgParser::Bif_charformatContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}


size_t RpgParser::Bif_charformatContext::getRuleIndex() const {
  return RpgParser::RuleBif_charformat;
}

void RpgParser::Bif_charformatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_charformat(this);
}

void RpgParser::Bif_charformatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_charformat(this);
}


antlrcpp::Any RpgParser::Bif_charformatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_charformat(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_charformatContext* RpgParser::bif_charformat() {
  Bif_charformatContext *_localctx = _tracker.createInstance<Bif_charformatContext>(_ctx, getState());
  enterRule(_localctx, 932, RpgParser::RuleBif_charformat);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4957);
    symbolicConstants();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_dateformatContext ------------------------------------------------------------------

RpgParser::Bif_dateformatContext::Bif_dateformatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SymbolicConstantsContext* RpgParser::Bif_dateformatContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}


size_t RpgParser::Bif_dateformatContext::getRuleIndex() const {
  return RpgParser::RuleBif_dateformat;
}

void RpgParser::Bif_dateformatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_dateformat(this);
}

void RpgParser::Bif_dateformatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_dateformat(this);
}


antlrcpp::Any RpgParser::Bif_dateformatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_dateformat(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_dateformatContext* RpgParser::bif_dateformat() {
  Bif_dateformatContext *_localctx = _tracker.createInstance<Bif_dateformatContext>(_ctx, getState());
  enterRule(_localctx, 934, RpgParser::RuleBif_dateformat);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4959);
    symbolicConstants();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_timeformatContext ------------------------------------------------------------------

RpgParser::Bif_timeformatContext::Bif_timeformatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SymbolicConstantsContext* RpgParser::Bif_timeformatContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}


size_t RpgParser::Bif_timeformatContext::getRuleIndex() const {
  return RpgParser::RuleBif_timeformat;
}

void RpgParser::Bif_timeformatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_timeformat(this);
}

void RpgParser::Bif_timeformatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_timeformat(this);
}


antlrcpp::Any RpgParser::Bif_timeformatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_timeformat(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_timeformatContext* RpgParser::bif_timeformat() {
  Bif_timeformatContext *_localctx = _tracker.createInstance<Bif_timeformatContext>(_ctx, getState());
  enterRule(_localctx, 936, RpgParser::RuleBif_timeformat);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4961);
    symbolicConstants();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_editccurrencyContext ------------------------------------------------------------------

RpgParser::Bif_editccurrencyContext::Bif_editccurrencyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_editccurrencyContext::SPLAT_ASTFILL() {
  return getToken(RpgParser::SPLAT_ASTFILL, 0);
}

tree::TerminalNode* RpgParser::Bif_editccurrencyContext::SPLAT_CURSYM() {
  return getToken(RpgParser::SPLAT_CURSYM, 0);
}

RpgParser::LiteralContext* RpgParser::Bif_editccurrencyContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}


size_t RpgParser::Bif_editccurrencyContext::getRuleIndex() const {
  return RpgParser::RuleBif_editccurrency;
}

void RpgParser::Bif_editccurrencyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_editccurrency(this);
}

void RpgParser::Bif_editccurrencyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_editccurrency(this);
}


antlrcpp::Any RpgParser::Bif_editccurrencyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_editccurrency(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_editccurrencyContext* RpgParser::bif_editccurrency() {
  Bif_editccurrencyContext *_localctx = _tracker.createInstance<Bif_editccurrencyContext>(_ctx, getState());
  enterRule(_localctx, 938, RpgParser::RuleBif_editccurrency);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4966);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::SPLAT_ASTFILL: {
        enterOuterAlt(_localctx, 1);
        setState(4963);
        match(RpgParser::SPLAT_ASTFILL);
        break;
      }

      case RpgParser::SPLAT_CURSYM: {
        enterOuterAlt(_localctx, 2);
        setState(4964);
        match(RpgParser::SPLAT_CURSYM);
        break;
      }

      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        enterOuterAlt(_localctx, 3);
        setState(4965);
        literal();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lookupargsContext ------------------------------------------------------------------

RpgParser::Bif_lookupargsContext::Bif_lookupargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lookupargsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_lookupargsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_lookupargsContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_lookupargsContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_lookupargsContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_lookupargsContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Bif_lookupargsContext::getRuleIndex() const {
  return RpgParser::RuleBif_lookupargs;
}

void RpgParser::Bif_lookupargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_lookupargs(this);
}

void RpgParser::Bif_lookupargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_lookupargs(this);
}


antlrcpp::Any RpgParser::Bif_lookupargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_lookupargs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lookupargsContext* RpgParser::bif_lookupargs() {
  Bif_lookupargsContext *_localctx = _tracker.createInstance<Bif_lookupargsContext>(_ctx, getState());
  enterRule(_localctx, 940, RpgParser::RuleBif_lookupargs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4968);
    match(RpgParser::OPEN_PAREN);
    setState(4969);
    dynamic_cast<Bif_lookupargsContext *>(_localctx)->arg = expression(0);
    setState(4972);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx)) {
    case 1: {
      setState(4970);
      match(RpgParser::COLON);
      setState(4971);
      dynamic_cast<Bif_lookupargsContext *>(_localctx)->array = expression(0);
      break;
    }

    }
    setState(4976);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      setState(4974);
      match(RpgParser::COLON);
      setState(4975);
      dynamic_cast<Bif_lookupargsContext *>(_localctx)->startindex = expression(0);
      break;
    }

    }
    setState(4980);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(4978);
      match(RpgParser::COLON);
      setState(4979);
      dynamic_cast<Bif_lookupargsContext *>(_localctx)->numberelements = expression(0);
    }
    setState(4982);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DurationCodeContext ------------------------------------------------------------------

RpgParser::DurationCodeContext::DurationCodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_D() {
  return getToken(RpgParser::SPLAT_D, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_H() {
  return getToken(RpgParser::SPLAT_H, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_HOURS() {
  return getToken(RpgParser::SPLAT_HOURS, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_DAYS() {
  return getToken(RpgParser::SPLAT_DAYS, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_M() {
  return getToken(RpgParser::SPLAT_M, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_MINUTES() {
  return getToken(RpgParser::SPLAT_MINUTES, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_MONTHS() {
  return getToken(RpgParser::SPLAT_MONTHS, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_MN() {
  return getToken(RpgParser::SPLAT_MN, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_MS() {
  return getToken(RpgParser::SPLAT_MS, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_MSECONDS() {
  return getToken(RpgParser::SPLAT_MSECONDS, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_S() {
  return getToken(RpgParser::SPLAT_S, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_SECONDS() {
  return getToken(RpgParser::SPLAT_SECONDS, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_Y() {
  return getToken(RpgParser::SPLAT_Y, 0);
}

tree::TerminalNode* RpgParser::DurationCodeContext::SPLAT_YEARS() {
  return getToken(RpgParser::SPLAT_YEARS, 0);
}


size_t RpgParser::DurationCodeContext::getRuleIndex() const {
  return RpgParser::RuleDurationCode;
}

void RpgParser::DurationCodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDurationCode(this);
}

void RpgParser::DurationCodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDurationCode(this);
}


antlrcpp::Any RpgParser::DurationCodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitDurationCode(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::DurationCodeContext* RpgParser::durationCode() {
  DurationCodeContext *_localctx = _tracker.createInstance<DurationCodeContext>(_ctx, getState());
  enterRule(_localctx, 942, RpgParser::RuleDurationCode);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4984);
    _la = _input->LA(1);
    if (!(((((_la - 298) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 298)) & ((1ULL << (RpgParser::SPLAT_D - 298))
      | (1ULL << (RpgParser::SPLAT_H - 298))
      | (1ULL << (RpgParser::SPLAT_HOURS - 298))
      | (1ULL << (RpgParser::SPLAT_DAYS - 298))
      | (1ULL << (RpgParser::SPLAT_M - 298))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 298))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 298))
      | (1ULL << (RpgParser::SPLAT_MN - 298))
      | (1ULL << (RpgParser::SPLAT_MS - 298))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 298))
      | (1ULL << (RpgParser::SPLAT_S - 298))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 298))
      | (1ULL << (RpgParser::SPLAT_Y - 298))
      | (1ULL << (RpgParser::SPLAT_YEARS - 298)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_timestampargsContext ------------------------------------------------------------------

RpgParser::Bif_timestampargsContext::Bif_timestampargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_timestampargsContext::SPLAT_ISO() {
  return getToken(RpgParser::SPLAT_ISO, 0);
}


size_t RpgParser::Bif_timestampargsContext::getRuleIndex() const {
  return RpgParser::RuleBif_timestampargs;
}

void RpgParser::Bif_timestampargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_timestampargs(this);
}

void RpgParser::Bif_timestampargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_timestampargs(this);
}


antlrcpp::Any RpgParser::Bif_timestampargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_timestampargs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_timestampargsContext* RpgParser::bif_timestampargs() {
  Bif_timestampargsContext *_localctx = _tracker.createInstance<Bif_timestampargsContext>(_ctx, getState());
  enterRule(_localctx, 944, RpgParser::RuleBif_timestampargs);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4986);
    match(RpgParser::SPLAT_ISO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_tlookupargsContext ------------------------------------------------------------------

RpgParser::Bif_tlookupargsContext::Bif_tlookupargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_tlookupargsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_tlookupargsContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_tlookupargsContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_tlookupargsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_tlookupargsContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_tlookupargsContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_tlookupargsContext::getRuleIndex() const {
  return RpgParser::RuleBif_tlookupargs;
}

void RpgParser::Bif_tlookupargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_tlookupargs(this);
}

void RpgParser::Bif_tlookupargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_tlookupargs(this);
}


antlrcpp::Any RpgParser::Bif_tlookupargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_tlookupargs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_tlookupargsContext* RpgParser::bif_tlookupargs() {
  Bif_tlookupargsContext *_localctx = _tracker.createInstance<Bif_tlookupargsContext>(_ctx, getState());
  enterRule(_localctx, 946, RpgParser::RuleBif_tlookupargs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4988);
    match(RpgParser::OPEN_PAREN);
    setState(4989);
    dynamic_cast<Bif_tlookupargsContext *>(_localctx)->arg = expression(0);
    setState(4990);
    match(RpgParser::COLON);
    setState(4991);
    dynamic_cast<Bif_tlookupargsContext *>(_localctx)->searchtable = expression(0);
    setState(4994);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(4992);
      match(RpgParser::COLON);
      setState(4993);
      dynamic_cast<Bif_tlookupargsContext *>(_localctx)->alttable = expression(0);
    }
    setState(4996);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_absContext ------------------------------------------------------------------

RpgParser::Bif_absContext::Bif_absContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_absContext::BIF_ABS() {
  return getToken(RpgParser::BIF_ABS, 0);
}

tree::TerminalNode* RpgParser::Bif_absContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_absContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_absContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_absContext::getRuleIndex() const {
  return RpgParser::RuleBif_abs;
}

void RpgParser::Bif_absContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_abs(this);
}

void RpgParser::Bif_absContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_abs(this);
}


antlrcpp::Any RpgParser::Bif_absContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_abs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_absContext* RpgParser::bif_abs() {
  Bif_absContext *_localctx = _tracker.createInstance<Bif_absContext>(_ctx, getState());
  enterRule(_localctx, 948, RpgParser::RuleBif_abs);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4998);
    match(RpgParser::BIF_ABS);
    setState(4999);
    match(RpgParser::OPEN_PAREN);
    setState(5000);
    dynamic_cast<Bif_absContext *>(_localctx)->numericexpression = expression(0);
    setState(5001);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_addrContext ------------------------------------------------------------------

RpgParser::Bif_addrContext::Bif_addrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_addrContext::BIF_ADDR() {
  return getToken(RpgParser::BIF_ADDR, 0);
}

tree::TerminalNode* RpgParser::Bif_addrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_addrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_addrContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_addrContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_addrContext::SPLAT_DATA() {
  return getToken(RpgParser::SPLAT_DATA, 0);
}


size_t RpgParser::Bif_addrContext::getRuleIndex() const {
  return RpgParser::RuleBif_addr;
}

void RpgParser::Bif_addrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_addr(this);
}

void RpgParser::Bif_addrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_addr(this);
}


antlrcpp::Any RpgParser::Bif_addrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_addr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_addrContext* RpgParser::bif_addr() {
  Bif_addrContext *_localctx = _tracker.createInstance<Bif_addrContext>(_ctx, getState());
  enterRule(_localctx, 950, RpgParser::RuleBif_addr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5003);
    match(RpgParser::BIF_ADDR);
    setState(5004);
    match(RpgParser::OPEN_PAREN);
    setState(5005);
    dynamic_cast<Bif_addrContext *>(_localctx)->variable = expression(0);
    setState(5008);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5006);
      match(RpgParser::COLON);
      setState(5007);
      dynamic_cast<Bif_addrContext *>(_localctx)->stardata = match(RpgParser::SPLAT_DATA);
    }
    setState(5010);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_allocContext ------------------------------------------------------------------

RpgParser::Bif_allocContext::Bif_allocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_allocContext::BIF_ALLOC() {
  return getToken(RpgParser::BIF_ALLOC, 0);
}

tree::TerminalNode* RpgParser::Bif_allocContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_allocContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_allocContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_allocContext::getRuleIndex() const {
  return RpgParser::RuleBif_alloc;
}

void RpgParser::Bif_allocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_alloc(this);
}

void RpgParser::Bif_allocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_alloc(this);
}


antlrcpp::Any RpgParser::Bif_allocContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_alloc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_allocContext* RpgParser::bif_alloc() {
  Bif_allocContext *_localctx = _tracker.createInstance<Bif_allocContext>(_ctx, getState());
  enterRule(_localctx, 952, RpgParser::RuleBif_alloc);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5012);
    match(RpgParser::BIF_ALLOC);
    setState(5013);
    match(RpgParser::OPEN_PAREN);
    setState(5014);
    dynamic_cast<Bif_allocContext *>(_localctx)->num = expression(0);
    setState(5015);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_bitandContext ------------------------------------------------------------------

RpgParser::Bif_bitandContext::Bif_bitandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_bitandContext::BIF_BITAND() {
  return getToken(RpgParser::BIF_BITAND, 0);
}

tree::TerminalNode* RpgParser::Bif_bitandContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_bitandContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_bitandContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_bitandContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_bitandContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_bitandContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_bitandContext::getRuleIndex() const {
  return RpgParser::RuleBif_bitand;
}

void RpgParser::Bif_bitandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_bitand(this);
}

void RpgParser::Bif_bitandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_bitand(this);
}


antlrcpp::Any RpgParser::Bif_bitandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_bitand(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_bitandContext* RpgParser::bif_bitand() {
  Bif_bitandContext *_localctx = _tracker.createInstance<Bif_bitandContext>(_ctx, getState());
  enterRule(_localctx, 954, RpgParser::RuleBif_bitand);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5017);
    match(RpgParser::BIF_BITAND);
    setState(5018);
    match(RpgParser::OPEN_PAREN);
    setState(5019);
    expression(0);
    setState(5020);
    match(RpgParser::COLON);
    setState(5021);
    expression(0);
    setState(5026);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(5022);
      match(RpgParser::COLON);
      setState(5023);
      expression(0);
      setState(5028);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5029);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_bitnotContext ------------------------------------------------------------------

RpgParser::Bif_bitnotContext::Bif_bitnotContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_bitnotContext::BIF_BITNOT() {
  return getToken(RpgParser::BIF_BITNOT, 0);
}

tree::TerminalNode* RpgParser::Bif_bitnotContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_bitnotContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_bitnotContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_bitnotContext::getRuleIndex() const {
  return RpgParser::RuleBif_bitnot;
}

void RpgParser::Bif_bitnotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_bitnot(this);
}

void RpgParser::Bif_bitnotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_bitnot(this);
}


antlrcpp::Any RpgParser::Bif_bitnotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_bitnot(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_bitnotContext* RpgParser::bif_bitnot() {
  Bif_bitnotContext *_localctx = _tracker.createInstance<Bif_bitnotContext>(_ctx, getState());
  enterRule(_localctx, 956, RpgParser::RuleBif_bitnot);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5031);
    match(RpgParser::BIF_BITNOT);
    setState(5032);
    match(RpgParser::OPEN_PAREN);
    setState(5033);
    expression(0);
    setState(5034);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_bitorContext ------------------------------------------------------------------

RpgParser::Bif_bitorContext::Bif_bitorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_bitorContext::BIF_BITOR() {
  return getToken(RpgParser::BIF_BITOR, 0);
}

tree::TerminalNode* RpgParser::Bif_bitorContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_bitorContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_bitorContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_bitorContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_bitorContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_bitorContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_bitorContext::getRuleIndex() const {
  return RpgParser::RuleBif_bitor;
}

void RpgParser::Bif_bitorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_bitor(this);
}

void RpgParser::Bif_bitorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_bitor(this);
}


antlrcpp::Any RpgParser::Bif_bitorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_bitor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_bitorContext* RpgParser::bif_bitor() {
  Bif_bitorContext *_localctx = _tracker.createInstance<Bif_bitorContext>(_ctx, getState());
  enterRule(_localctx, 958, RpgParser::RuleBif_bitor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5036);
    match(RpgParser::BIF_BITOR);
    setState(5037);
    match(RpgParser::OPEN_PAREN);
    setState(5038);
    expression(0);
    setState(5039);
    match(RpgParser::COLON);
    setState(5040);
    expression(0);
    setState(5045);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(5041);
      match(RpgParser::COLON);
      setState(5042);
      expression(0);
      setState(5047);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5048);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_bitxorContext ------------------------------------------------------------------

RpgParser::Bif_bitxorContext::Bif_bitxorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_bitxorContext::BIF_BITXOR() {
  return getToken(RpgParser::BIF_BITXOR, 0);
}

tree::TerminalNode* RpgParser::Bif_bitxorContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_bitxorContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_bitxorContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_bitxorContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_bitxorContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_bitxorContext::getRuleIndex() const {
  return RpgParser::RuleBif_bitxor;
}

void RpgParser::Bif_bitxorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_bitxor(this);
}

void RpgParser::Bif_bitxorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_bitxor(this);
}


antlrcpp::Any RpgParser::Bif_bitxorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_bitxor(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_bitxorContext* RpgParser::bif_bitxor() {
  Bif_bitxorContext *_localctx = _tracker.createInstance<Bif_bitxorContext>(_ctx, getState());
  enterRule(_localctx, 960, RpgParser::RuleBif_bitxor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5050);
    match(RpgParser::BIF_BITXOR);
    setState(5051);
    match(RpgParser::OPEN_PAREN);
    setState(5052);
    expression(0);
    setState(5053);
    match(RpgParser::COLON);
    setState(5054);
    expression(0);
    setState(5055);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_charContext ------------------------------------------------------------------

RpgParser::Bif_charContext::Bif_charContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_charContext::BIF_CHAR() {
  return getToken(RpgParser::BIF_CHAR, 0);
}

tree::TerminalNode* RpgParser::Bif_charContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_charContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_charContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_charContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::Bif_charformatContext* RpgParser::Bif_charContext::bif_charformat() {
  return getRuleContext<RpgParser::Bif_charformatContext>(0);
}


size_t RpgParser::Bif_charContext::getRuleIndex() const {
  return RpgParser::RuleBif_char;
}

void RpgParser::Bif_charContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_char(this);
}

void RpgParser::Bif_charContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_char(this);
}


antlrcpp::Any RpgParser::Bif_charContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_char(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_charContext* RpgParser::bif_char() {
  Bif_charContext *_localctx = _tracker.createInstance<Bif_charContext>(_ctx, getState());
  enterRule(_localctx, 962, RpgParser::RuleBif_char);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5057);
    match(RpgParser::BIF_CHAR);
    setState(5058);
    match(RpgParser::OPEN_PAREN);
    setState(5059);
    expression(0);
    setState(5062);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5060);
      match(RpgParser::COLON);
      setState(5061);
      dynamic_cast<Bif_charContext *>(_localctx)->format = bif_charformat();
    }
    setState(5064);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_checkContext ------------------------------------------------------------------

RpgParser::Bif_checkContext::Bif_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_checkContext::BIF_CHECK() {
  return getToken(RpgParser::BIF_CHECK, 0);
}

tree::TerminalNode* RpgParser::Bif_checkContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_checkContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_checkContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_checkContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_checkContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_checkContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_checkContext::getRuleIndex() const {
  return RpgParser::RuleBif_check;
}

void RpgParser::Bif_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_check(this);
}

void RpgParser::Bif_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_check(this);
}


antlrcpp::Any RpgParser::Bif_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_check(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_checkContext* RpgParser::bif_check() {
  Bif_checkContext *_localctx = _tracker.createInstance<Bif_checkContext>(_ctx, getState());
  enterRule(_localctx, 964, RpgParser::RuleBif_check);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5066);
    match(RpgParser::BIF_CHECK);
    setState(5067);
    match(RpgParser::OPEN_PAREN);
    setState(5068);
    dynamic_cast<Bif_checkContext *>(_localctx)->comparator = expression(0);
    setState(5069);
    match(RpgParser::COLON);
    setState(5070);
    dynamic_cast<Bif_checkContext *>(_localctx)->base = expression(0);
    setState(5073);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5071);
      match(RpgParser::COLON);
      setState(5072);
      dynamic_cast<Bif_checkContext *>(_localctx)->start = expression(0);
    }
    setState(5075);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_checkrContext ------------------------------------------------------------------

RpgParser::Bif_checkrContext::Bif_checkrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_checkrContext::BIF_CHECKR() {
  return getToken(RpgParser::BIF_CHECKR, 0);
}

tree::TerminalNode* RpgParser::Bif_checkrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_checkrContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_checkrContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_checkrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_checkrContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_checkrContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_checkrContext::getRuleIndex() const {
  return RpgParser::RuleBif_checkr;
}

void RpgParser::Bif_checkrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_checkr(this);
}

void RpgParser::Bif_checkrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_checkr(this);
}


antlrcpp::Any RpgParser::Bif_checkrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_checkr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_checkrContext* RpgParser::bif_checkr() {
  Bif_checkrContext *_localctx = _tracker.createInstance<Bif_checkrContext>(_ctx, getState());
  enterRule(_localctx, 966, RpgParser::RuleBif_checkr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5077);
    match(RpgParser::BIF_CHECKR);
    setState(5078);
    match(RpgParser::OPEN_PAREN);
    setState(5079);
    dynamic_cast<Bif_checkrContext *>(_localctx)->comparator = expression(0);
    setState(5080);
    match(RpgParser::COLON);
    setState(5081);
    dynamic_cast<Bif_checkrContext *>(_localctx)->base = expression(0);
    setState(5084);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5082);
      match(RpgParser::COLON);
      setState(5083);
      dynamic_cast<Bif_checkrContext *>(_localctx)->start = expression(0);
    }
    setState(5086);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_dateContext ------------------------------------------------------------------

RpgParser::Bif_dateContext::Bif_dateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_dateContext::BIF_DATE() {
  return getToken(RpgParser::BIF_DATE, 0);
}

tree::TerminalNode* RpgParser::Bif_dateContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_dateContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_dateContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_dateContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::Bif_dateformatContext* RpgParser::Bif_dateContext::bif_dateformat() {
  return getRuleContext<RpgParser::Bif_dateformatContext>(0);
}


size_t RpgParser::Bif_dateContext::getRuleIndex() const {
  return RpgParser::RuleBif_date;
}

void RpgParser::Bif_dateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_date(this);
}

void RpgParser::Bif_dateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_date(this);
}


antlrcpp::Any RpgParser::Bif_dateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_date(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_dateContext* RpgParser::bif_date() {
  Bif_dateContext *_localctx = _tracker.createInstance<Bif_dateContext>(_ctx, getState());
  enterRule(_localctx, 968, RpgParser::RuleBif_date);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5088);
    match(RpgParser::BIF_DATE);
    setState(5098);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 453, _ctx)) {
    case 1: {
      setState(5089);
      match(RpgParser::OPEN_PAREN);
      setState(5091);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
        | (1ULL << (RpgParser::NUMBER - 20))
        | (1ULL << (RpgParser::ID - 20))
        | (1ULL << (RpgParser::OP_ACQ - 20))
        | (1ULL << (RpgParser::OP_BEGSR - 20))
        | (1ULL << (RpgParser::OP_CALLP - 20))
        | (1ULL << (RpgParser::OP_CHAIN - 20))
        | (1ULL << (RpgParser::OP_CLEAR - 20))
        | (1ULL << (RpgParser::OP_CLOSE - 20))
        | (1ULL << (RpgParser::OP_COMMIT - 20))
        | (1ULL << (RpgParser::OP_DEALLOC - 20))
        | (1ULL << (RpgParser::OP_DELETE - 20))
        | (1ULL << (RpgParser::OP_DSPLY - 20))
        | (1ULL << (RpgParser::OP_DUMP - 20))
        | (1ULL << (RpgParser::OP_ENDSR - 20))
        | (1ULL << (RpgParser::OP_EVAL - 20))
        | (1ULL << (RpgParser::OP_EVALR - 20))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
        | (1ULL << (RpgParser::OP_EXCEPT - 20))
        | (1ULL << (RpgParser::OP_EXFMT - 20))
        | (1ULL << (RpgParser::OP_EXSR - 20))
        | (1ULL << (RpgParser::OP_FEOD - 20))
        | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
        | (1ULL << (RpgParser::OP_ITER - 84))
        | (1ULL << (RpgParser::OP_LEAVE - 84))
        | (1ULL << (RpgParser::OP_LEAVESR - 84))
        | (1ULL << (RpgParser::OP_NEXT - 84))
        | (1ULL << (RpgParser::OP_OPEN - 84))
        | (1ULL << (RpgParser::OP_OTHER - 84))
        | (1ULL << (RpgParser::OP_OUT - 84))
        | (1ULL << (RpgParser::OP_POST - 84))
        | (1ULL << (RpgParser::OP_READ - 84))
        | (1ULL << (RpgParser::OP_READC - 84))
        | (1ULL << (RpgParser::OP_READE - 84))
        | (1ULL << (RpgParser::OP_READP - 84))
        | (1ULL << (RpgParser::OP_READPE - 84))
        | (1ULL << (RpgParser::OP_REL - 84))
        | (1ULL << (RpgParser::OP_RESET - 84))
        | (1ULL << (RpgParser::OP_RETURN - 84))
        | (1ULL << (RpgParser::OP_ROLBK - 84))
        | (1ULL << (RpgParser::OP_SELECT - 84))
        | (1ULL << (RpgParser::OP_SETGT - 84))
        | (1ULL << (RpgParser::OP_SETLL - 84))
        | (1ULL << (RpgParser::OP_SORTA - 84))
        | (1ULL << (RpgParser::OP_TEST - 84))
        | (1ULL << (RpgParser::OP_UNLOCK - 84))
        | (1ULL << (RpgParser::OP_UPDATE - 84))
        | (1ULL << (RpgParser::OP_WHEN - 84))
        | (1ULL << (RpgParser::OP_WRITE - 84))
        | (1ULL << (RpgParser::OP_XML_INTO - 84))
        | (1ULL << (RpgParser::OP_XML_SAX - 84))
        | (1ULL << (RpgParser::BIF_ABS - 84))
        | (1ULL << (RpgParser::BIF_ADDR - 84))
        | (1ULL << (RpgParser::BIF_ALLOC - 84))
        | (1ULL << (RpgParser::BIF_BITAND - 84))
        | (1ULL << (RpgParser::BIF_BITNOT - 84))
        | (1ULL << (RpgParser::BIF_BITOR - 84))
        | (1ULL << (RpgParser::BIF_BITXOR - 84))
        | (1ULL << (RpgParser::BIF_CHAR - 84))
        | (1ULL << (RpgParser::BIF_CHECK - 84))
        | (1ULL << (RpgParser::BIF_CHECKR - 84))
        | (1ULL << (RpgParser::BIF_DATE - 84))
        | (1ULL << (RpgParser::BIF_DAYS - 84))
        | (1ULL << (RpgParser::BIF_DEC - 84))
        | (1ULL << (RpgParser::BIF_DECH - 84))
        | (1ULL << (RpgParser::BIF_DECPOS - 84))
        | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
        | (1ULL << (RpgParser::BIF_EDITC - 148))
        | (1ULL << (RpgParser::BIF_EDITFLT - 148))
        | (1ULL << (RpgParser::BIF_EDITW - 148))
        | (1ULL << (RpgParser::BIF_ELEM - 148))
        | (1ULL << (RpgParser::BIF_EOF - 148))
        | (1ULL << (RpgParser::BIF_EQUAL - 148))
        | (1ULL << (RpgParser::BIF_ERROR - 148))
        | (1ULL << (RpgParser::BIF_FIELDS - 148))
        | (1ULL << (RpgParser::BIF_FLOAT - 148))
        | (1ULL << (RpgParser::BIF_FOUND - 148))
        | (1ULL << (RpgParser::BIF_GRAPH - 148))
        | (1ULL << (RpgParser::BIF_HANDLER - 148))
        | (1ULL << (RpgParser::BIF_HOURS - 148))
        | (1ULL << (RpgParser::BIF_INT - 148))
        | (1ULL << (RpgParser::BIF_INTH - 148))
        | (1ULL << (RpgParser::BIF_KDS - 148))
        | (1ULL << (RpgParser::BIF_LEN - 148))
        | (1ULL << (RpgParser::BIF_LOOKUP - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_MINUTES - 148))
        | (1ULL << (RpgParser::BIF_MONTHS - 148))
        | (1ULL << (RpgParser::BIF_MSECONDS - 148))
        | (1ULL << (RpgParser::BIF_NULLIND - 148))
        | (1ULL << (RpgParser::BIF_OCCUR - 148))
        | (1ULL << (RpgParser::BIF_OPEN - 148))
        | (1ULL << (RpgParser::BIF_PADDR - 148))
        | (1ULL << (RpgParser::BIF_PARMS - 148))
        | (1ULL << (RpgParser::BIF_PARMNUM - 148))
        | (1ULL << (RpgParser::BIF_REALLOC - 148))
        | (1ULL << (RpgParser::BIF_REM - 148))
        | (1ULL << (RpgParser::BIF_REPLACE - 148))
        | (1ULL << (RpgParser::BIF_SCAN - 148))
        | (1ULL << (RpgParser::BIF_SCANRPL - 148))
        | (1ULL << (RpgParser::BIF_SECONDS - 148))
        | (1ULL << (RpgParser::BIF_SHTDN - 148))
        | (1ULL << (RpgParser::BIF_SIZE - 148))
        | (1ULL << (RpgParser::BIF_SQRT - 148))
        | (1ULL << (RpgParser::BIF_STATUS - 148))
        | (1ULL << (RpgParser::BIF_STR - 148))
        | (1ULL << (RpgParser::BIF_SUBARR - 148))
        | (1ULL << (RpgParser::BIF_SUBDT - 148))
        | (1ULL << (RpgParser::BIF_SUBST - 148))
        | (1ULL << (RpgParser::BIF_THIS - 148))
        | (1ULL << (RpgParser::BIF_TIME - 148))
        | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_TRIM - 148))
        | (1ULL << (RpgParser::BIF_TRIML - 148))
        | (1ULL << (RpgParser::BIF_TRIMR - 148))
        | (1ULL << (RpgParser::BIF_UCS2 - 148))
        | (1ULL << (RpgParser::BIF_UNS - 148))
        | (1ULL << (RpgParser::BIF_UNSH - 148))
        | (1ULL << (RpgParser::BIF_XFOOT - 148))
        | (1ULL << (RpgParser::BIF_XLATE - 148))
        | (1ULL << (RpgParser::BIF_XML - 148))
        | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::PLUS - 404))
        | (1ULL << (RpgParser::MINUS - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404))
        | (1ULL << (RpgParser::HexLiteralStart - 404))
        | (1ULL << (RpgParser::DateLiteralStart - 404))
        | (1ULL << (RpgParser::TimeLiteralStart - 404))
        | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
        | (1ULL << (RpgParser::GraphicLiteralStart - 404))
        | (1ULL << (RpgParser::UCS2LiteralStart - 404))
        | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
        setState(5090);
        expression(0);
      }
      setState(5095);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::COLON) {
        setState(5093);
        match(RpgParser::COLON);
        setState(5094);
        dynamic_cast<Bif_dateContext *>(_localctx)->dateformat = bif_dateformat();
      }
      setState(5097);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_daysContext ------------------------------------------------------------------

RpgParser::Bif_daysContext::Bif_daysContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_daysContext::BIF_DAYS() {
  return getToken(RpgParser::BIF_DAYS, 0);
}

tree::TerminalNode* RpgParser::Bif_daysContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_daysContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_daysContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_daysContext::getRuleIndex() const {
  return RpgParser::RuleBif_days;
}

void RpgParser::Bif_daysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_days(this);
}

void RpgParser::Bif_daysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_days(this);
}


antlrcpp::Any RpgParser::Bif_daysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_days(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_daysContext* RpgParser::bif_days() {
  Bif_daysContext *_localctx = _tracker.createInstance<Bif_daysContext>(_ctx, getState());
  enterRule(_localctx, 970, RpgParser::RuleBif_days);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5100);
    match(RpgParser::BIF_DAYS);
    setState(5101);
    match(RpgParser::OPEN_PAREN);
    setState(5102);
    dynamic_cast<Bif_daysContext *>(_localctx)->numberexpression = expression(0);
    setState(5103);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_decContext ------------------------------------------------------------------

RpgParser::Bif_decContext::Bif_decContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_decContext::BIF_DEC() {
  return getToken(RpgParser::BIF_DEC, 0);
}

tree::TerminalNode* RpgParser::Bif_decContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_decContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_decContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_decContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_decContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_decContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Bif_decContext::getRuleIndex() const {
  return RpgParser::RuleBif_dec;
}

void RpgParser::Bif_decContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_dec(this);
}

void RpgParser::Bif_decContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_dec(this);
}


antlrcpp::Any RpgParser::Bif_decContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_dec(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_decContext* RpgParser::bif_dec() {
  Bif_decContext *_localctx = _tracker.createInstance<Bif_decContext>(_ctx, getState());
  enterRule(_localctx, 972, RpgParser::RuleBif_dec);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5105);
    match(RpgParser::BIF_DEC);
    setState(5106);
    match(RpgParser::OPEN_PAREN);
    setState(5107);
    expression(0);
    setState(5110);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx)) {
    case 1: {
      setState(5108);
      match(RpgParser::COLON);
      setState(5109);
      expression(0);
      break;
    }

    }
    setState(5114);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5112);
      match(RpgParser::COLON);
      setState(5113);
      expression(0);
    }
    setState(5116);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_dechContext ------------------------------------------------------------------

RpgParser::Bif_dechContext::Bif_dechContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_dechContext::BIF_DECH() {
  return getToken(RpgParser::BIF_DECH, 0);
}

tree::TerminalNode* RpgParser::Bif_dechContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_dechContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_dechContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_dechContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_dechContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_dechContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_dechContext::getRuleIndex() const {
  return RpgParser::RuleBif_dech;
}

void RpgParser::Bif_dechContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_dech(this);
}

void RpgParser::Bif_dechContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_dech(this);
}


antlrcpp::Any RpgParser::Bif_dechContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_dech(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_dechContext* RpgParser::bif_dech() {
  Bif_dechContext *_localctx = _tracker.createInstance<Bif_dechContext>(_ctx, getState());
  enterRule(_localctx, 974, RpgParser::RuleBif_dech);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5118);
    match(RpgParser::BIF_DECH);
    setState(5119);
    match(RpgParser::OPEN_PAREN);
    setState(5120);
    expression(0);
    setState(5121);
    match(RpgParser::COLON);
    setState(5122);
    expression(0);
    setState(5123);
    match(RpgParser::COLON);
    setState(5124);
    expression(0);
    setState(5125);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_decposContext ------------------------------------------------------------------

RpgParser::Bif_decposContext::Bif_decposContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_decposContext::BIF_DECPOS() {
  return getToken(RpgParser::BIF_DECPOS, 0);
}

tree::TerminalNode* RpgParser::Bif_decposContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_decposContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_decposContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_decposContext::getRuleIndex() const {
  return RpgParser::RuleBif_decpos;
}

void RpgParser::Bif_decposContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_decpos(this);
}

void RpgParser::Bif_decposContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_decpos(this);
}


antlrcpp::Any RpgParser::Bif_decposContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_decpos(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_decposContext* RpgParser::bif_decpos() {
  Bif_decposContext *_localctx = _tracker.createInstance<Bif_decposContext>(_ctx, getState());
  enterRule(_localctx, 976, RpgParser::RuleBif_decpos);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5127);
    match(RpgParser::BIF_DECPOS);
    setState(5128);
    match(RpgParser::OPEN_PAREN);
    setState(5129);
    dynamic_cast<Bif_decposContext *>(_localctx)->numericexpression = expression(0);
    setState(5130);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_diffContext ------------------------------------------------------------------

RpgParser::Bif_diffContext::Bif_diffContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_diffContext::BIF_DIFF() {
  return getToken(RpgParser::BIF_DIFF, 0);
}

tree::TerminalNode* RpgParser::Bif_diffContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_diffContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_diffContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_diffContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_diffContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_diffContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

RpgParser::DurationCodeContext* RpgParser::Bif_diffContext::durationCode() {
  return getRuleContext<RpgParser::DurationCodeContext>(0);
}


size_t RpgParser::Bif_diffContext::getRuleIndex() const {
  return RpgParser::RuleBif_diff;
}

void RpgParser::Bif_diffContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_diff(this);
}

void RpgParser::Bif_diffContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_diff(this);
}


antlrcpp::Any RpgParser::Bif_diffContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_diff(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_diffContext* RpgParser::bif_diff() {
  Bif_diffContext *_localctx = _tracker.createInstance<Bif_diffContext>(_ctx, getState());
  enterRule(_localctx, 978, RpgParser::RuleBif_diff);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5132);
    match(RpgParser::BIF_DIFF);
    setState(5133);
    match(RpgParser::OPEN_PAREN);
    setState(5134);
    dynamic_cast<Bif_diffContext *>(_localctx)->op1 = expression(0);
    setState(5135);
    match(RpgParser::COLON);
    setState(5136);
    dynamic_cast<Bif_diffContext *>(_localctx)->op2 = expression(0);
    setState(5137);
    match(RpgParser::COLON);
    setState(5138);
    dynamic_cast<Bif_diffContext *>(_localctx)->format = durationCode();
    setState(5139);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_divContext ------------------------------------------------------------------

RpgParser::Bif_divContext::Bif_divContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_divContext::BIF_DIV() {
  return getToken(RpgParser::BIF_DIV, 0);
}

tree::TerminalNode* RpgParser::Bif_divContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_divContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_divContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_divContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_divContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_divContext::getRuleIndex() const {
  return RpgParser::RuleBif_div;
}

void RpgParser::Bif_divContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_div(this);
}

void RpgParser::Bif_divContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_div(this);
}


antlrcpp::Any RpgParser::Bif_divContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_div(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_divContext* RpgParser::bif_div() {
  Bif_divContext *_localctx = _tracker.createInstance<Bif_divContext>(_ctx, getState());
  enterRule(_localctx, 980, RpgParser::RuleBif_div);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5141);
    match(RpgParser::BIF_DIV);
    setState(5142);
    match(RpgParser::OPEN_PAREN);
    setState(5143);
    dynamic_cast<Bif_divContext *>(_localctx)->numerator = expression(0);
    setState(5144);
    match(RpgParser::COLON);
    setState(5145);
    dynamic_cast<Bif_divContext *>(_localctx)->denominator = expression(0);
    setState(5146);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_editcContext ------------------------------------------------------------------

RpgParser::Bif_editcContext::Bif_editcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_editcContext::BIF_EDITC() {
  return getToken(RpgParser::BIF_EDITC, 0);
}

tree::TerminalNode* RpgParser::Bif_editcContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_editcContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_editcContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_editcContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_editcContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_editcContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

RpgParser::Bif_editccurrencyContext* RpgParser::Bif_editcContext::bif_editccurrency() {
  return getRuleContext<RpgParser::Bif_editccurrencyContext>(0);
}


size_t RpgParser::Bif_editcContext::getRuleIndex() const {
  return RpgParser::RuleBif_editc;
}

void RpgParser::Bif_editcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_editc(this);
}

void RpgParser::Bif_editcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_editc(this);
}


antlrcpp::Any RpgParser::Bif_editcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_editc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_editcContext* RpgParser::bif_editc() {
  Bif_editcContext *_localctx = _tracker.createInstance<Bif_editcContext>(_ctx, getState());
  enterRule(_localctx, 982, RpgParser::RuleBif_editc);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5148);
    match(RpgParser::BIF_EDITC);
    setState(5149);
    match(RpgParser::OPEN_PAREN);
    setState(5150);
    dynamic_cast<Bif_editcContext *>(_localctx)->numeric = expression(0);
    setState(5151);
    match(RpgParser::COLON);
    setState(5152);
    dynamic_cast<Bif_editcContext *>(_localctx)->editcode = expression(0);
    setState(5155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5153);
      match(RpgParser::COLON);
      setState(5154);
      dynamic_cast<Bif_editcContext *>(_localctx)->currency = bif_editccurrency();
    }
    setState(5157);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_editfltContext ------------------------------------------------------------------

RpgParser::Bif_editfltContext::Bif_editfltContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_editfltContext::BIF_EDITFLT() {
  return getToken(RpgParser::BIF_EDITFLT, 0);
}

tree::TerminalNode* RpgParser::Bif_editfltContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_editfltContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_editfltContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_editfltContext::getRuleIndex() const {
  return RpgParser::RuleBif_editflt;
}

void RpgParser::Bif_editfltContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_editflt(this);
}

void RpgParser::Bif_editfltContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_editflt(this);
}


antlrcpp::Any RpgParser::Bif_editfltContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_editflt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_editfltContext* RpgParser::bif_editflt() {
  Bif_editfltContext *_localctx = _tracker.createInstance<Bif_editfltContext>(_ctx, getState());
  enterRule(_localctx, 984, RpgParser::RuleBif_editflt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5159);
    match(RpgParser::BIF_EDITFLT);
    setState(5160);
    match(RpgParser::OPEN_PAREN);
    setState(5161);
    dynamic_cast<Bif_editfltContext *>(_localctx)->numericexpression = expression(0);
    setState(5162);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_editwContext ------------------------------------------------------------------

RpgParser::Bif_editwContext::Bif_editwContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_editwContext::BIF_EDITW() {
  return getToken(RpgParser::BIF_EDITW, 0);
}

tree::TerminalNode* RpgParser::Bif_editwContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_editwContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_editwContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_editwContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_editwContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_editwContext::getRuleIndex() const {
  return RpgParser::RuleBif_editw;
}

void RpgParser::Bif_editwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_editw(this);
}

void RpgParser::Bif_editwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_editw(this);
}


antlrcpp::Any RpgParser::Bif_editwContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_editw(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_editwContext* RpgParser::bif_editw() {
  Bif_editwContext *_localctx = _tracker.createInstance<Bif_editwContext>(_ctx, getState());
  enterRule(_localctx, 986, RpgParser::RuleBif_editw);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5164);
    match(RpgParser::BIF_EDITW);
    setState(5165);
    match(RpgParser::OPEN_PAREN);
    setState(5166);
    dynamic_cast<Bif_editwContext *>(_localctx)->numeric = expression(0);
    setState(5167);
    match(RpgParser::COLON);
    setState(5168);
    dynamic_cast<Bif_editwContext *>(_localctx)->editword = expression(0);
    setState(5169);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_elemContext ------------------------------------------------------------------

RpgParser::Bif_elemContext::Bif_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_elemContext::BIF_ELEM() {
  return getToken(RpgParser::BIF_ELEM, 0);
}

tree::TerminalNode* RpgParser::Bif_elemContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_elemContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_elemContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_elemContext::getRuleIndex() const {
  return RpgParser::RuleBif_elem;
}

void RpgParser::Bif_elemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_elem(this);
}

void RpgParser::Bif_elemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_elem(this);
}


antlrcpp::Any RpgParser::Bif_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_elem(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_elemContext* RpgParser::bif_elem() {
  Bif_elemContext *_localctx = _tracker.createInstance<Bif_elemContext>(_ctx, getState());
  enterRule(_localctx, 988, RpgParser::RuleBif_elem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5171);
    match(RpgParser::BIF_ELEM);
    setState(5172);
    match(RpgParser::OPEN_PAREN);
    setState(5173);
    expression(0);
    setState(5174);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_eofContext ------------------------------------------------------------------

RpgParser::Bif_eofContext::Bif_eofContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_eofContext::BIF_EOF() {
  return getToken(RpgParser::BIF_EOF, 0);
}

tree::TerminalNode* RpgParser::Bif_eofContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_eofContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_eofContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_eofContext::getRuleIndex() const {
  return RpgParser::RuleBif_eof;
}

void RpgParser::Bif_eofContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_eof(this);
}

void RpgParser::Bif_eofContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_eof(this);
}


antlrcpp::Any RpgParser::Bif_eofContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_eof(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_eofContext* RpgParser::bif_eof() {
  Bif_eofContext *_localctx = _tracker.createInstance<Bif_eofContext>(_ctx, getState());
  enterRule(_localctx, 990, RpgParser::RuleBif_eof);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5176);
    match(RpgParser::BIF_EOF);
    setState(5182);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx)) {
    case 1: {
      setState(5177);
      match(RpgParser::OPEN_PAREN);
      setState(5179);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << RpgParser::ID)
        | (1ULL << RpgParser::OP_ACQ)
        | (1ULL << RpgParser::OP_BEGSR)
        | (1ULL << RpgParser::OP_CALLP)
        | (1ULL << RpgParser::OP_CHAIN)
        | (1ULL << RpgParser::OP_CLEAR)
        | (1ULL << RpgParser::OP_CLOSE)
        | (1ULL << RpgParser::OP_COMMIT)
        | (1ULL << RpgParser::OP_DEALLOC)
        | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
        | (1ULL << (RpgParser::OP_DUMP - 64))
        | (1ULL << (RpgParser::OP_ENDSR - 64))
        | (1ULL << (RpgParser::OP_EVAL - 64))
        | (1ULL << (RpgParser::OP_EVALR - 64))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
        | (1ULL << (RpgParser::OP_EXCEPT - 64))
        | (1ULL << (RpgParser::OP_EXFMT - 64))
        | (1ULL << (RpgParser::OP_EXSR - 64))
        | (1ULL << (RpgParser::OP_FEOD - 64))
        | (1ULL << (RpgParser::OP_FORCE - 64))
        | (1ULL << (RpgParser::OP_IN - 64))
        | (1ULL << (RpgParser::OP_ITER - 64))
        | (1ULL << (RpgParser::OP_LEAVE - 64))
        | (1ULL << (RpgParser::OP_LEAVESR - 64))
        | (1ULL << (RpgParser::OP_NEXT - 64))
        | (1ULL << (RpgParser::OP_OPEN - 64))
        | (1ULL << (RpgParser::OP_OTHER - 64))
        | (1ULL << (RpgParser::OP_OUT - 64))
        | (1ULL << (RpgParser::OP_POST - 64))
        | (1ULL << (RpgParser::OP_READ - 64))
        | (1ULL << (RpgParser::OP_READC - 64))
        | (1ULL << (RpgParser::OP_READE - 64))
        | (1ULL << (RpgParser::OP_READP - 64))
        | (1ULL << (RpgParser::OP_READPE - 64))
        | (1ULL << (RpgParser::OP_REL - 64))
        | (1ULL << (RpgParser::OP_RESET - 64))
        | (1ULL << (RpgParser::OP_RETURN - 64))
        | (1ULL << (RpgParser::OP_ROLBK - 64))
        | (1ULL << (RpgParser::OP_SELECT - 64))
        | (1ULL << (RpgParser::OP_SETGT - 64))
        | (1ULL << (RpgParser::OP_SETLL - 64))
        | (1ULL << (RpgParser::OP_SORTA - 64))
        | (1ULL << (RpgParser::OP_TEST - 64))
        | (1ULL << (RpgParser::OP_UNLOCK - 64))
        | (1ULL << (RpgParser::OP_UPDATE - 64))
        | (1ULL << (RpgParser::OP_WHEN - 64))
        | (1ULL << (RpgParser::OP_WRITE - 64))
        | (1ULL << (RpgParser::OP_XML_INTO - 64))
        | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
        setState(5178);
        dynamic_cast<Bif_eofContext *>(_localctx)->filenameident = identifier();
      }
      setState(5181);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_equalContext ------------------------------------------------------------------

RpgParser::Bif_equalContext::Bif_equalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_equalContext::BIF_EQUAL() {
  return getToken(RpgParser::BIF_EQUAL, 0);
}

tree::TerminalNode* RpgParser::Bif_equalContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_equalContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_equalContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_equalContext::getRuleIndex() const {
  return RpgParser::RuleBif_equal;
}

void RpgParser::Bif_equalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_equal(this);
}

void RpgParser::Bif_equalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_equal(this);
}


antlrcpp::Any RpgParser::Bif_equalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_equal(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_equalContext* RpgParser::bif_equal() {
  Bif_equalContext *_localctx = _tracker.createInstance<Bif_equalContext>(_ctx, getState());
  enterRule(_localctx, 992, RpgParser::RuleBif_equal);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5184);
    match(RpgParser::BIF_EQUAL);
    setState(5189);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 459, _ctx)) {
    case 1: {
      setState(5185);
      match(RpgParser::OPEN_PAREN);
      setState(5186);
      dynamic_cast<Bif_equalContext *>(_localctx)->filenameident = identifier();
      setState(5187);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_errorContext ------------------------------------------------------------------

RpgParser::Bif_errorContext::Bif_errorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_errorContext::BIF_ERROR() {
  return getToken(RpgParser::BIF_ERROR, 0);
}

tree::TerminalNode* RpgParser::Bif_errorContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_errorContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_errorContext::getRuleIndex() const {
  return RpgParser::RuleBif_error;
}

void RpgParser::Bif_errorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_error(this);
}

void RpgParser::Bif_errorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_error(this);
}


antlrcpp::Any RpgParser::Bif_errorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_error(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_errorContext* RpgParser::bif_error() {
  Bif_errorContext *_localctx = _tracker.createInstance<Bif_errorContext>(_ctx, getState());
  enterRule(_localctx, 994, RpgParser::RuleBif_error);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5191);
    match(RpgParser::BIF_ERROR);
    setState(5194);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 460, _ctx)) {
    case 1: {
      setState(5192);
      match(RpgParser::OPEN_PAREN);
      setState(5193);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_fieldsContext ------------------------------------------------------------------

RpgParser::Bif_fieldsContext::Bif_fieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_fieldsContext::BIF_FIELDS() {
  return getToken(RpgParser::BIF_FIELDS, 0);
}

tree::TerminalNode* RpgParser::Bif_fieldsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<RpgParser::IdentifierContext *> RpgParser::Bif_fieldsContext::identifier() {
  return getRuleContexts<RpgParser::IdentifierContext>();
}

RpgParser::IdentifierContext* RpgParser::Bif_fieldsContext::identifier(size_t i) {
  return getRuleContext<RpgParser::IdentifierContext>(i);
}

tree::TerminalNode* RpgParser::Bif_fieldsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_fieldsContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_fieldsContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::Bif_fieldsContext::getRuleIndex() const {
  return RpgParser::RuleBif_fields;
}

void RpgParser::Bif_fieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_fields(this);
}

void RpgParser::Bif_fieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_fields(this);
}


antlrcpp::Any RpgParser::Bif_fieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_fields(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_fieldsContext* RpgParser::bif_fields() {
  Bif_fieldsContext *_localctx = _tracker.createInstance<Bif_fieldsContext>(_ctx, getState());
  enterRule(_localctx, 996, RpgParser::RuleBif_fields);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5196);
    match(RpgParser::BIF_FIELDS);
    setState(5197);
    match(RpgParser::OPEN_PAREN);
    setState(5198);
    identifier();
    setState(5203);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == RpgParser::COLON) {
      setState(5199);
      match(RpgParser::COLON);
      setState(5200);
      identifier();
      setState(5205);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5206);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_floatContext ------------------------------------------------------------------

RpgParser::Bif_floatContext::Bif_floatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_floatContext::BIF_FLOAT() {
  return getToken(RpgParser::BIF_FLOAT, 0);
}

tree::TerminalNode* RpgParser::Bif_floatContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_floatContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_floatContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_floatContext::getRuleIndex() const {
  return RpgParser::RuleBif_float;
}

void RpgParser::Bif_floatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_float(this);
}

void RpgParser::Bif_floatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_float(this);
}


antlrcpp::Any RpgParser::Bif_floatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_float(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_floatContext* RpgParser::bif_float() {
  Bif_floatContext *_localctx = _tracker.createInstance<Bif_floatContext>(_ctx, getState());
  enterRule(_localctx, 998, RpgParser::RuleBif_float);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5208);
    match(RpgParser::BIF_FLOAT);
    setState(5209);
    match(RpgParser::OPEN_PAREN);
    setState(5210);
    expression(0);
    setState(5211);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_foundContext ------------------------------------------------------------------

RpgParser::Bif_foundContext::Bif_foundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_foundContext::BIF_FOUND() {
  return getToken(RpgParser::BIF_FOUND, 0);
}

tree::TerminalNode* RpgParser::Bif_foundContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_foundContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_foundContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_foundContext::getRuleIndex() const {
  return RpgParser::RuleBif_found;
}

void RpgParser::Bif_foundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_found(this);
}

void RpgParser::Bif_foundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_found(this);
}


antlrcpp::Any RpgParser::Bif_foundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_found(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_foundContext* RpgParser::bif_found() {
  Bif_foundContext *_localctx = _tracker.createInstance<Bif_foundContext>(_ctx, getState());
  enterRule(_localctx, 1000, RpgParser::RuleBif_found);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5213);
    match(RpgParser::BIF_FOUND);
    setState(5219);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
    case 1: {
      setState(5214);
      match(RpgParser::OPEN_PAREN);
      setState(5216);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << RpgParser::ID)
        | (1ULL << RpgParser::OP_ACQ)
        | (1ULL << RpgParser::OP_BEGSR)
        | (1ULL << RpgParser::OP_CALLP)
        | (1ULL << RpgParser::OP_CHAIN)
        | (1ULL << RpgParser::OP_CLEAR)
        | (1ULL << RpgParser::OP_CLOSE)
        | (1ULL << RpgParser::OP_COMMIT)
        | (1ULL << RpgParser::OP_DEALLOC)
        | (1ULL << RpgParser::OP_DELETE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (RpgParser::OP_DSPLY - 64))
        | (1ULL << (RpgParser::OP_DUMP - 64))
        | (1ULL << (RpgParser::OP_ENDSR - 64))
        | (1ULL << (RpgParser::OP_EVAL - 64))
        | (1ULL << (RpgParser::OP_EVALR - 64))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 64))
        | (1ULL << (RpgParser::OP_EXCEPT - 64))
        | (1ULL << (RpgParser::OP_EXFMT - 64))
        | (1ULL << (RpgParser::OP_EXSR - 64))
        | (1ULL << (RpgParser::OP_FEOD - 64))
        | (1ULL << (RpgParser::OP_FORCE - 64))
        | (1ULL << (RpgParser::OP_IN - 64))
        | (1ULL << (RpgParser::OP_ITER - 64))
        | (1ULL << (RpgParser::OP_LEAVE - 64))
        | (1ULL << (RpgParser::OP_LEAVESR - 64))
        | (1ULL << (RpgParser::OP_NEXT - 64))
        | (1ULL << (RpgParser::OP_OPEN - 64))
        | (1ULL << (RpgParser::OP_OTHER - 64))
        | (1ULL << (RpgParser::OP_OUT - 64))
        | (1ULL << (RpgParser::OP_POST - 64))
        | (1ULL << (RpgParser::OP_READ - 64))
        | (1ULL << (RpgParser::OP_READC - 64))
        | (1ULL << (RpgParser::OP_READE - 64))
        | (1ULL << (RpgParser::OP_READP - 64))
        | (1ULL << (RpgParser::OP_READPE - 64))
        | (1ULL << (RpgParser::OP_REL - 64))
        | (1ULL << (RpgParser::OP_RESET - 64))
        | (1ULL << (RpgParser::OP_RETURN - 64))
        | (1ULL << (RpgParser::OP_ROLBK - 64))
        | (1ULL << (RpgParser::OP_SELECT - 64))
        | (1ULL << (RpgParser::OP_SETGT - 64))
        | (1ULL << (RpgParser::OP_SETLL - 64))
        | (1ULL << (RpgParser::OP_SORTA - 64))
        | (1ULL << (RpgParser::OP_TEST - 64))
        | (1ULL << (RpgParser::OP_UNLOCK - 64))
        | (1ULL << (RpgParser::OP_UPDATE - 64))
        | (1ULL << (RpgParser::OP_WHEN - 64))
        | (1ULL << (RpgParser::OP_WRITE - 64))
        | (1ULL << (RpgParser::OP_XML_INTO - 64))
        | (1ULL << (RpgParser::OP_XML_SAX - 64)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404)))) != 0)) {
        setState(5215);
        dynamic_cast<Bif_foundContext *>(_localctx)->filenameident = identifier();
      }
      setState(5218);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_graphContext ------------------------------------------------------------------

RpgParser::Bif_graphContext::Bif_graphContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_graphContext::BIF_GRAPH() {
  return getToken(RpgParser::BIF_GRAPH, 0);
}

tree::TerminalNode* RpgParser::Bif_graphContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_graphContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_graphContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_graphContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_graphContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_graphContext::getRuleIndex() const {
  return RpgParser::RuleBif_graph;
}

void RpgParser::Bif_graphContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_graph(this);
}

void RpgParser::Bif_graphContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_graph(this);
}


antlrcpp::Any RpgParser::Bif_graphContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_graph(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_graphContext* RpgParser::bif_graph() {
  Bif_graphContext *_localctx = _tracker.createInstance<Bif_graphContext>(_ctx, getState());
  enterRule(_localctx, 1002, RpgParser::RuleBif_graph);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5221);
    match(RpgParser::BIF_GRAPH);
    setState(5222);
    match(RpgParser::OPEN_PAREN);
    setState(5223);
    expression(0);
    setState(5226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5224);
      match(RpgParser::COLON);
      setState(5225);
      identifier();
    }
    setState(5228);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_handlerContext ------------------------------------------------------------------

RpgParser::Bif_handlerContext::Bif_handlerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_handlerContext::BIF_HANDLER() {
  return getToken(RpgParser::BIF_HANDLER, 0);
}

tree::TerminalNode* RpgParser::Bif_handlerContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_handlerContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_handlerContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_handlerContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_handlerContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_handlerContext::getRuleIndex() const {
  return RpgParser::RuleBif_handler;
}

void RpgParser::Bif_handlerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_handler(this);
}

void RpgParser::Bif_handlerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_handler(this);
}


antlrcpp::Any RpgParser::Bif_handlerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_handler(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_handlerContext* RpgParser::bif_handler() {
  Bif_handlerContext *_localctx = _tracker.createInstance<Bif_handlerContext>(_ctx, getState());
  enterRule(_localctx, 1004, RpgParser::RuleBif_handler);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5230);
    match(RpgParser::BIF_HANDLER);
    setState(5231);
    match(RpgParser::OPEN_PAREN);
    setState(5232);
    dynamic_cast<Bif_handlerContext *>(_localctx)->handlingprocedure = expression(0);
    setState(5233);
    match(RpgParser::COLON);
    setState(5234);
    dynamic_cast<Bif_handlerContext *>(_localctx)->communicationarea = expression(0);
    setState(5235);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_hoursContext ------------------------------------------------------------------

RpgParser::Bif_hoursContext::Bif_hoursContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_hoursContext::BIF_HOURS() {
  return getToken(RpgParser::BIF_HOURS, 0);
}

tree::TerminalNode* RpgParser::Bif_hoursContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_hoursContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_hoursContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_hoursContext::getRuleIndex() const {
  return RpgParser::RuleBif_hours;
}

void RpgParser::Bif_hoursContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_hours(this);
}

void RpgParser::Bif_hoursContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_hours(this);
}


antlrcpp::Any RpgParser::Bif_hoursContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_hours(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_hoursContext* RpgParser::bif_hours() {
  Bif_hoursContext *_localctx = _tracker.createInstance<Bif_hoursContext>(_ctx, getState());
  enterRule(_localctx, 1006, RpgParser::RuleBif_hours);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5237);
    match(RpgParser::BIF_HOURS);
    setState(5238);
    match(RpgParser::OPEN_PAREN);
    setState(5239);
    dynamic_cast<Bif_hoursContext *>(_localctx)->numberexpression = expression(0);
    setState(5240);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_intContext ------------------------------------------------------------------

RpgParser::Bif_intContext::Bif_intContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_intContext::BIF_INT() {
  return getToken(RpgParser::BIF_INT, 0);
}

tree::TerminalNode* RpgParser::Bif_intContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_intContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_intContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_intContext::getRuleIndex() const {
  return RpgParser::RuleBif_int;
}

void RpgParser::Bif_intContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_int(this);
}

void RpgParser::Bif_intContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_int(this);
}


antlrcpp::Any RpgParser::Bif_intContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_int(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_intContext* RpgParser::bif_int() {
  Bif_intContext *_localctx = _tracker.createInstance<Bif_intContext>(_ctx, getState());
  enterRule(_localctx, 1008, RpgParser::RuleBif_int);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5242);
    match(RpgParser::BIF_INT);
    setState(5243);
    match(RpgParser::OPEN_PAREN);
    setState(5244);
    expression(0);
    setState(5245);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_inthContext ------------------------------------------------------------------

RpgParser::Bif_inthContext::Bif_inthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_inthContext::BIF_INTH() {
  return getToken(RpgParser::BIF_INTH, 0);
}

tree::TerminalNode* RpgParser::Bif_inthContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_inthContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_inthContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_inthContext::getRuleIndex() const {
  return RpgParser::RuleBif_inth;
}

void RpgParser::Bif_inthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_inth(this);
}

void RpgParser::Bif_inthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_inth(this);
}


antlrcpp::Any RpgParser::Bif_inthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_inth(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_inthContext* RpgParser::bif_inth() {
  Bif_inthContext *_localctx = _tracker.createInstance<Bif_inthContext>(_ctx, getState());
  enterRule(_localctx, 1010, RpgParser::RuleBif_inth);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5247);
    match(RpgParser::BIF_INTH);
    setState(5248);
    match(RpgParser::OPEN_PAREN);
    setState(5249);
    expression(0);
    setState(5250);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_kdsContext ------------------------------------------------------------------

RpgParser::Bif_kdsContext::Bif_kdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_kdsContext::BIF_KDS() {
  return getToken(RpgParser::BIF_KDS, 0);
}

tree::TerminalNode* RpgParser::Bif_kdsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_kdsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_kdsContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_kdsContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_kdsContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Bif_kdsContext::getRuleIndex() const {
  return RpgParser::RuleBif_kds;
}

void RpgParser::Bif_kdsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_kds(this);
}

void RpgParser::Bif_kdsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_kds(this);
}


antlrcpp::Any RpgParser::Bif_kdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_kds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_kdsContext* RpgParser::bif_kds() {
  Bif_kdsContext *_localctx = _tracker.createInstance<Bif_kdsContext>(_ctx, getState());
  enterRule(_localctx, 1012, RpgParser::RuleBif_kds);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5252);
    match(RpgParser::BIF_KDS);
    setState(5253);
    match(RpgParser::OPEN_PAREN);
    setState(5254);
    dynamic_cast<Bif_kdsContext *>(_localctx)->datastructure = expression(0);
    setState(5257);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5255);
      match(RpgParser::COLON);
      setState(5256);
      dynamic_cast<Bif_kdsContext *>(_localctx)->numkeys = expression(0);
    }
    setState(5259);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lenContext ------------------------------------------------------------------

RpgParser::Bif_lenContext::Bif_lenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lenContext::BIF_LEN() {
  return getToken(RpgParser::BIF_LEN, 0);
}

tree::TerminalNode* RpgParser::Bif_lenContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_lenContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_lenContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_lenContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_lenContext::SPLAT_MAX() {
  return getToken(RpgParser::SPLAT_MAX, 0);
}


size_t RpgParser::Bif_lenContext::getRuleIndex() const {
  return RpgParser::RuleBif_len;
}

void RpgParser::Bif_lenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_len(this);
}

void RpgParser::Bif_lenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_len(this);
}


antlrcpp::Any RpgParser::Bif_lenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_len(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lenContext* RpgParser::bif_len() {
  Bif_lenContext *_localctx = _tracker.createInstance<Bif_lenContext>(_ctx, getState());
  enterRule(_localctx, 1014, RpgParser::RuleBif_len);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5261);
    match(RpgParser::BIF_LEN);
    setState(5262);
    match(RpgParser::OPEN_PAREN);
    setState(5263);
    expression(0);
    setState(5266);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5264);
      match(RpgParser::COLON);
      setState(5265);
      dynamic_cast<Bif_lenContext *>(_localctx)->starmax = match(RpgParser::SPLAT_MAX);
    }
    setState(5268);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lookupContext ------------------------------------------------------------------

RpgParser::Bif_lookupContext::Bif_lookupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lookupContext::BIF_LOOKUP() {
  return getToken(RpgParser::BIF_LOOKUP, 0);
}

RpgParser::Bif_lookupargsContext* RpgParser::Bif_lookupContext::bif_lookupargs() {
  return getRuleContext<RpgParser::Bif_lookupargsContext>(0);
}


size_t RpgParser::Bif_lookupContext::getRuleIndex() const {
  return RpgParser::RuleBif_lookup;
}

void RpgParser::Bif_lookupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_lookup(this);
}

void RpgParser::Bif_lookupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_lookup(this);
}


antlrcpp::Any RpgParser::Bif_lookupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_lookup(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lookupContext* RpgParser::bif_lookup() {
  Bif_lookupContext *_localctx = _tracker.createInstance<Bif_lookupContext>(_ctx, getState());
  enterRule(_localctx, 1016, RpgParser::RuleBif_lookup);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5270);
    match(RpgParser::BIF_LOOKUP);
    setState(5271);
    bif_lookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lookupltContext ------------------------------------------------------------------

RpgParser::Bif_lookupltContext::Bif_lookupltContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lookupltContext::BIF_LOOKUPLT() {
  return getToken(RpgParser::BIF_LOOKUPLT, 0);
}

RpgParser::Bif_lookupargsContext* RpgParser::Bif_lookupltContext::bif_lookupargs() {
  return getRuleContext<RpgParser::Bif_lookupargsContext>(0);
}


size_t RpgParser::Bif_lookupltContext::getRuleIndex() const {
  return RpgParser::RuleBif_lookuplt;
}

void RpgParser::Bif_lookupltContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_lookuplt(this);
}

void RpgParser::Bif_lookupltContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_lookuplt(this);
}


antlrcpp::Any RpgParser::Bif_lookupltContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_lookuplt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lookupltContext* RpgParser::bif_lookuplt() {
  Bif_lookupltContext *_localctx = _tracker.createInstance<Bif_lookupltContext>(_ctx, getState());
  enterRule(_localctx, 1018, RpgParser::RuleBif_lookuplt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5273);
    match(RpgParser::BIF_LOOKUPLT);
    setState(5274);
    bif_lookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lookupleContext ------------------------------------------------------------------

RpgParser::Bif_lookupleContext::Bif_lookupleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lookupleContext::BIF_LOOKUPLE() {
  return getToken(RpgParser::BIF_LOOKUPLE, 0);
}

RpgParser::Bif_lookupargsContext* RpgParser::Bif_lookupleContext::bif_lookupargs() {
  return getRuleContext<RpgParser::Bif_lookupargsContext>(0);
}


size_t RpgParser::Bif_lookupleContext::getRuleIndex() const {
  return RpgParser::RuleBif_lookuple;
}

void RpgParser::Bif_lookupleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_lookuple(this);
}

void RpgParser::Bif_lookupleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_lookuple(this);
}


antlrcpp::Any RpgParser::Bif_lookupleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_lookuple(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lookupleContext* RpgParser::bif_lookuple() {
  Bif_lookupleContext *_localctx = _tracker.createInstance<Bif_lookupleContext>(_ctx, getState());
  enterRule(_localctx, 1020, RpgParser::RuleBif_lookuple);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5276);
    match(RpgParser::BIF_LOOKUPLE);
    setState(5277);
    bif_lookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lookupgtContext ------------------------------------------------------------------

RpgParser::Bif_lookupgtContext::Bif_lookupgtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lookupgtContext::BIF_LOOKUPGT() {
  return getToken(RpgParser::BIF_LOOKUPGT, 0);
}

RpgParser::Bif_lookupargsContext* RpgParser::Bif_lookupgtContext::bif_lookupargs() {
  return getRuleContext<RpgParser::Bif_lookupargsContext>(0);
}


size_t RpgParser::Bif_lookupgtContext::getRuleIndex() const {
  return RpgParser::RuleBif_lookupgt;
}

void RpgParser::Bif_lookupgtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_lookupgt(this);
}

void RpgParser::Bif_lookupgtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_lookupgt(this);
}


antlrcpp::Any RpgParser::Bif_lookupgtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_lookupgt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lookupgtContext* RpgParser::bif_lookupgt() {
  Bif_lookupgtContext *_localctx = _tracker.createInstance<Bif_lookupgtContext>(_ctx, getState());
  enterRule(_localctx, 1022, RpgParser::RuleBif_lookupgt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5279);
    match(RpgParser::BIF_LOOKUPGT);
    setState(5280);
    bif_lookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_lookupgeContext ------------------------------------------------------------------

RpgParser::Bif_lookupgeContext::Bif_lookupgeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_lookupgeContext::BIF_LOOKUPGE() {
  return getToken(RpgParser::BIF_LOOKUPGE, 0);
}

RpgParser::Bif_lookupargsContext* RpgParser::Bif_lookupgeContext::bif_lookupargs() {
  return getRuleContext<RpgParser::Bif_lookupargsContext>(0);
}


size_t RpgParser::Bif_lookupgeContext::getRuleIndex() const {
  return RpgParser::RuleBif_lookupge;
}

void RpgParser::Bif_lookupgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_lookupge(this);
}

void RpgParser::Bif_lookupgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_lookupge(this);
}


antlrcpp::Any RpgParser::Bif_lookupgeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_lookupge(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_lookupgeContext* RpgParser::bif_lookupge() {
  Bif_lookupgeContext *_localctx = _tracker.createInstance<Bif_lookupgeContext>(_ctx, getState());
  enterRule(_localctx, 1024, RpgParser::RuleBif_lookupge);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5282);
    match(RpgParser::BIF_LOOKUPGE);
    setState(5283);
    bif_lookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_minutesContext ------------------------------------------------------------------

RpgParser::Bif_minutesContext::Bif_minutesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_minutesContext::BIF_MINUTES() {
  return getToken(RpgParser::BIF_MINUTES, 0);
}

tree::TerminalNode* RpgParser::Bif_minutesContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_minutesContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_minutesContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_minutesContext::getRuleIndex() const {
  return RpgParser::RuleBif_minutes;
}

void RpgParser::Bif_minutesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_minutes(this);
}

void RpgParser::Bif_minutesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_minutes(this);
}


antlrcpp::Any RpgParser::Bif_minutesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_minutes(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_minutesContext* RpgParser::bif_minutes() {
  Bif_minutesContext *_localctx = _tracker.createInstance<Bif_minutesContext>(_ctx, getState());
  enterRule(_localctx, 1026, RpgParser::RuleBif_minutes);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5285);
    match(RpgParser::BIF_MINUTES);
    setState(5286);
    match(RpgParser::OPEN_PAREN);
    setState(5287);
    dynamic_cast<Bif_minutesContext *>(_localctx)->minutes = expression(0);
    setState(5288);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_monthsContext ------------------------------------------------------------------

RpgParser::Bif_monthsContext::Bif_monthsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_monthsContext::BIF_MONTHS() {
  return getToken(RpgParser::BIF_MONTHS, 0);
}

tree::TerminalNode* RpgParser::Bif_monthsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_monthsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_monthsContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_monthsContext::getRuleIndex() const {
  return RpgParser::RuleBif_months;
}

void RpgParser::Bif_monthsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_months(this);
}

void RpgParser::Bif_monthsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_months(this);
}


antlrcpp::Any RpgParser::Bif_monthsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_months(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_monthsContext* RpgParser::bif_months() {
  Bif_monthsContext *_localctx = _tracker.createInstance<Bif_monthsContext>(_ctx, getState());
  enterRule(_localctx, 1028, RpgParser::RuleBif_months);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5290);
    match(RpgParser::BIF_MONTHS);
    setState(5291);
    match(RpgParser::OPEN_PAREN);
    setState(5292);
    dynamic_cast<Bif_monthsContext *>(_localctx)->numberexpression = expression(0);
    setState(5293);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_msecondsContext ------------------------------------------------------------------

RpgParser::Bif_msecondsContext::Bif_msecondsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_msecondsContext::BIF_MSECONDS() {
  return getToken(RpgParser::BIF_MSECONDS, 0);
}

tree::TerminalNode* RpgParser::Bif_msecondsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_msecondsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_msecondsContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_msecondsContext::getRuleIndex() const {
  return RpgParser::RuleBif_mseconds;
}

void RpgParser::Bif_msecondsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_mseconds(this);
}

void RpgParser::Bif_msecondsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_mseconds(this);
}


antlrcpp::Any RpgParser::Bif_msecondsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_mseconds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_msecondsContext* RpgParser::bif_mseconds() {
  Bif_msecondsContext *_localctx = _tracker.createInstance<Bif_msecondsContext>(_ctx, getState());
  enterRule(_localctx, 1030, RpgParser::RuleBif_mseconds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5295);
    match(RpgParser::BIF_MSECONDS);
    setState(5296);
    match(RpgParser::OPEN_PAREN);
    setState(5297);
    dynamic_cast<Bif_msecondsContext *>(_localctx)->numberexpression = expression(0);
    setState(5298);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_nullindContext ------------------------------------------------------------------

RpgParser::Bif_nullindContext::Bif_nullindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_nullindContext::BIF_NULLIND() {
  return getToken(RpgParser::BIF_NULLIND, 0);
}

tree::TerminalNode* RpgParser::Bif_nullindContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_nullindContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_nullindContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_nullindContext::getRuleIndex() const {
  return RpgParser::RuleBif_nullind;
}

void RpgParser::Bif_nullindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_nullind(this);
}

void RpgParser::Bif_nullindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_nullind(this);
}


antlrcpp::Any RpgParser::Bif_nullindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_nullind(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_nullindContext* RpgParser::bif_nullind() {
  Bif_nullindContext *_localctx = _tracker.createInstance<Bif_nullindContext>(_ctx, getState());
  enterRule(_localctx, 1032, RpgParser::RuleBif_nullind);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5300);
    match(RpgParser::BIF_NULLIND);
    setState(5301);
    match(RpgParser::OPEN_PAREN);
    setState(5302);
    dynamic_cast<Bif_nullindContext *>(_localctx)->fieldname = identifier();
    setState(5303);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_occurContext ------------------------------------------------------------------

RpgParser::Bif_occurContext::Bif_occurContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_occurContext::BIF_OCCUR() {
  return getToken(RpgParser::BIF_OCCUR, 0);
}

tree::TerminalNode* RpgParser::Bif_occurContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_occurContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_occurContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_occurContext::getRuleIndex() const {
  return RpgParser::RuleBif_occur;
}

void RpgParser::Bif_occurContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_occur(this);
}

void RpgParser::Bif_occurContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_occur(this);
}


antlrcpp::Any RpgParser::Bif_occurContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_occur(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_occurContext* RpgParser::bif_occur() {
  Bif_occurContext *_localctx = _tracker.createInstance<Bif_occurContext>(_ctx, getState());
  enterRule(_localctx, 1034, RpgParser::RuleBif_occur);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5305);
    match(RpgParser::BIF_OCCUR);
    setState(5306);
    match(RpgParser::OPEN_PAREN);
    setState(5307);
    dynamic_cast<Bif_occurContext *>(_localctx)->dsnname = identifier();
    setState(5308);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_openContext ------------------------------------------------------------------

RpgParser::Bif_openContext::Bif_openContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_openContext::BIF_OPEN() {
  return getToken(RpgParser::BIF_OPEN, 0);
}

tree::TerminalNode* RpgParser::Bif_openContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_openContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_openContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_openContext::getRuleIndex() const {
  return RpgParser::RuleBif_open;
}

void RpgParser::Bif_openContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_open(this);
}

void RpgParser::Bif_openContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_open(this);
}


antlrcpp::Any RpgParser::Bif_openContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_open(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_openContext* RpgParser::bif_open() {
  Bif_openContext *_localctx = _tracker.createInstance<Bif_openContext>(_ctx, getState());
  enterRule(_localctx, 1036, RpgParser::RuleBif_open);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5310);
    match(RpgParser::BIF_OPEN);
    setState(5311);
    match(RpgParser::OPEN_PAREN);
    setState(5312);
    dynamic_cast<Bif_openContext *>(_localctx)->filenameident = identifier();
    setState(5313);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_paddrContext ------------------------------------------------------------------

RpgParser::Bif_paddrContext::Bif_paddrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_paddrContext::BIF_PADDR() {
  return getToken(RpgParser::BIF_PADDR, 0);
}

tree::TerminalNode* RpgParser::Bif_paddrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_paddrContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::Bif_paddrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_paddrContext::getRuleIndex() const {
  return RpgParser::RuleBif_paddr;
}

void RpgParser::Bif_paddrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_paddr(this);
}

void RpgParser::Bif_paddrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_paddr(this);
}


antlrcpp::Any RpgParser::Bif_paddrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_paddr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_paddrContext* RpgParser::bif_paddr() {
  Bif_paddrContext *_localctx = _tracker.createInstance<Bif_paddrContext>(_ctx, getState());
  enterRule(_localctx, 1038, RpgParser::RuleBif_paddr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5315);
    match(RpgParser::BIF_PADDR);
    setState(5316);
    match(RpgParser::OPEN_PAREN);
    setState(5317);
    identifier();
    setState(5318);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_parmsContext ------------------------------------------------------------------

RpgParser::Bif_parmsContext::Bif_parmsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_parmsContext::BIF_PARMS() {
  return getToken(RpgParser::BIF_PARMS, 0);
}

tree::TerminalNode* RpgParser::Bif_parmsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_parmsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_parmsContext::getRuleIndex() const {
  return RpgParser::RuleBif_parms;
}

void RpgParser::Bif_parmsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_parms(this);
}

void RpgParser::Bif_parmsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_parms(this);
}


antlrcpp::Any RpgParser::Bif_parmsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_parms(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_parmsContext* RpgParser::bif_parms() {
  Bif_parmsContext *_localctx = _tracker.createInstance<Bif_parmsContext>(_ctx, getState());
  enterRule(_localctx, 1040, RpgParser::RuleBif_parms);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5320);
    match(RpgParser::BIF_PARMS);
    setState(5323);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 467, _ctx)) {
    case 1: {
      setState(5321);
      match(RpgParser::OPEN_PAREN);
      setState(5322);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_parmnumContext ------------------------------------------------------------------

RpgParser::Bif_parmnumContext::Bif_parmnumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_parmnumContext::BIF_PARMNUM() {
  return getToken(RpgParser::BIF_PARMNUM, 0);
}

tree::TerminalNode* RpgParser::Bif_parmnumContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_parmnumContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

tree::TerminalNode* RpgParser::Bif_parmnumContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_parmnumContext::getRuleIndex() const {
  return RpgParser::RuleBif_parmnum;
}

void RpgParser::Bif_parmnumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_parmnum(this);
}

void RpgParser::Bif_parmnumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_parmnum(this);
}


antlrcpp::Any RpgParser::Bif_parmnumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_parmnum(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_parmnumContext* RpgParser::bif_parmnum() {
  Bif_parmnumContext *_localctx = _tracker.createInstance<Bif_parmnumContext>(_ctx, getState());
  enterRule(_localctx, 1042, RpgParser::RuleBif_parmnum);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5325);
    match(RpgParser::BIF_PARMNUM);
    setState(5326);
    match(RpgParser::OPEN_PAREN);
    setState(5327);
    identifier();
    setState(5328);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_reallocContext ------------------------------------------------------------------

RpgParser::Bif_reallocContext::Bif_reallocContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_reallocContext::BIF_REALLOC() {
  return getToken(RpgParser::BIF_REALLOC, 0);
}

tree::TerminalNode* RpgParser::Bif_reallocContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_reallocContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_reallocContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_reallocContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::ExpressionContext* RpgParser::Bif_reallocContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_reallocContext::getRuleIndex() const {
  return RpgParser::RuleBif_realloc;
}

void RpgParser::Bif_reallocContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_realloc(this);
}

void RpgParser::Bif_reallocContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_realloc(this);
}


antlrcpp::Any RpgParser::Bif_reallocContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_realloc(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_reallocContext* RpgParser::bif_realloc() {
  Bif_reallocContext *_localctx = _tracker.createInstance<Bif_reallocContext>(_ctx, getState());
  enterRule(_localctx, 1044, RpgParser::RuleBif_realloc);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5330);
    match(RpgParser::BIF_REALLOC);
    setState(5331);
    match(RpgParser::OPEN_PAREN);
    setState(5332);
    dynamic_cast<Bif_reallocContext *>(_localctx)->ptr = identifier();
    setState(5333);
    match(RpgParser::COLON);
    setState(5334);
    dynamic_cast<Bif_reallocContext *>(_localctx)->num = expression(0);
    setState(5335);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_remContext ------------------------------------------------------------------

RpgParser::Bif_remContext::Bif_remContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_remContext::BIF_REM() {
  return getToken(RpgParser::BIF_REM, 0);
}

tree::TerminalNode* RpgParser::Bif_remContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_remContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_remContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_remContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_remContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_remContext::getRuleIndex() const {
  return RpgParser::RuleBif_rem;
}

void RpgParser::Bif_remContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_rem(this);
}

void RpgParser::Bif_remContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_rem(this);
}


antlrcpp::Any RpgParser::Bif_remContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_rem(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_remContext* RpgParser::bif_rem() {
  Bif_remContext *_localctx = _tracker.createInstance<Bif_remContext>(_ctx, getState());
  enterRule(_localctx, 1046, RpgParser::RuleBif_rem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5337);
    match(RpgParser::BIF_REM);
    setState(5338);
    match(RpgParser::OPEN_PAREN);
    setState(5339);
    dynamic_cast<Bif_remContext *>(_localctx)->numerator = expression(0);
    setState(5340);
    match(RpgParser::COLON);
    setState(5341);
    dynamic_cast<Bif_remContext *>(_localctx)->denominator = expression(0);
    setState(5342);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_replaceContext ------------------------------------------------------------------

RpgParser::Bif_replaceContext::Bif_replaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_replaceContext::BIF_REPLACE() {
  return getToken(RpgParser::BIF_REPLACE, 0);
}

tree::TerminalNode* RpgParser::Bif_replaceContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_replaceContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_replaceContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_replaceContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_replaceContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_replaceContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_replaceContext::getRuleIndex() const {
  return RpgParser::RuleBif_replace;
}

void RpgParser::Bif_replaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_replace(this);
}

void RpgParser::Bif_replaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_replace(this);
}


antlrcpp::Any RpgParser::Bif_replaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_replace(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_replaceContext* RpgParser::bif_replace() {
  Bif_replaceContext *_localctx = _tracker.createInstance<Bif_replaceContext>(_ctx, getState());
  enterRule(_localctx, 1048, RpgParser::RuleBif_replace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5344);
    match(RpgParser::BIF_REPLACE);
    setState(5345);
    match(RpgParser::OPEN_PAREN);
    setState(5346);
    dynamic_cast<Bif_replaceContext *>(_localctx)->replacement = expression(0);
    setState(5347);
    match(RpgParser::COLON);
    setState(5348);
    dynamic_cast<Bif_replaceContext *>(_localctx)->source = expression(0);
    setState(5355);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5349);
      match(RpgParser::COLON);
      setState(5350);
      dynamic_cast<Bif_replaceContext *>(_localctx)->start = expression(0);
      setState(5353);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::COLON) {
        setState(5351);
        match(RpgParser::COLON);
        setState(5352);
        dynamic_cast<Bif_replaceContext *>(_localctx)->length = expression(0);
      }
    }
    setState(5357);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_scanContext ------------------------------------------------------------------

RpgParser::Bif_scanContext::Bif_scanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_scanContext::BIF_SCAN() {
  return getToken(RpgParser::BIF_SCAN, 0);
}

tree::TerminalNode* RpgParser::Bif_scanContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_scanContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_scanContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_scanContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_scanContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_scanContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_scanContext::getRuleIndex() const {
  return RpgParser::RuleBif_scan;
}

void RpgParser::Bif_scanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_scan(this);
}

void RpgParser::Bif_scanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_scan(this);
}


antlrcpp::Any RpgParser::Bif_scanContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_scan(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_scanContext* RpgParser::bif_scan() {
  Bif_scanContext *_localctx = _tracker.createInstance<Bif_scanContext>(_ctx, getState());
  enterRule(_localctx, 1050, RpgParser::RuleBif_scan);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5359);
    match(RpgParser::BIF_SCAN);
    setState(5360);
    match(RpgParser::OPEN_PAREN);
    setState(5361);
    dynamic_cast<Bif_scanContext *>(_localctx)->searcharg = expression(0);
    setState(5362);
    match(RpgParser::COLON);
    setState(5363);
    dynamic_cast<Bif_scanContext *>(_localctx)->source = expression(0);
    setState(5366);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5364);
      match(RpgParser::COLON);
      setState(5365);
      dynamic_cast<Bif_scanContext *>(_localctx)->start = expression(0);
    }
    setState(5368);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_scanrplContext ------------------------------------------------------------------

RpgParser::Bif_scanrplContext::Bif_scanrplContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_scanrplContext::BIF_SCANRPL() {
  return getToken(RpgParser::BIF_SCANRPL, 0);
}

tree::TerminalNode* RpgParser::Bif_scanrplContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_scanrplContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_scanrplContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_scanrplContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_scanrplContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_scanrplContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_scanrplContext::getRuleIndex() const {
  return RpgParser::RuleBif_scanrpl;
}

void RpgParser::Bif_scanrplContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_scanrpl(this);
}

void RpgParser::Bif_scanrplContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_scanrpl(this);
}


antlrcpp::Any RpgParser::Bif_scanrplContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_scanrpl(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_scanrplContext* RpgParser::bif_scanrpl() {
  Bif_scanrplContext *_localctx = _tracker.createInstance<Bif_scanrplContext>(_ctx, getState());
  enterRule(_localctx, 1052, RpgParser::RuleBif_scanrpl);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5370);
    match(RpgParser::BIF_SCANRPL);
    setState(5371);
    match(RpgParser::OPEN_PAREN);
    setState(5372);
    dynamic_cast<Bif_scanrplContext *>(_localctx)->scanstring = expression(0);
    setState(5373);
    match(RpgParser::COLON);
    setState(5374);
    dynamic_cast<Bif_scanrplContext *>(_localctx)->replacement = expression(0);
    setState(5375);
    match(RpgParser::COLON);
    setState(5376);
    dynamic_cast<Bif_scanrplContext *>(_localctx)->source = expression(0);
    setState(5383);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5377);
      match(RpgParser::COLON);
      setState(5378);
      dynamic_cast<Bif_scanrplContext *>(_localctx)->start = expression(0);
      setState(5381);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::COLON) {
        setState(5379);
        match(RpgParser::COLON);
        setState(5380);
        dynamic_cast<Bif_scanrplContext *>(_localctx)->length = expression(0);
      }
    }
    setState(5385);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_secondsContext ------------------------------------------------------------------

RpgParser::Bif_secondsContext::Bif_secondsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_secondsContext::BIF_SECONDS() {
  return getToken(RpgParser::BIF_SECONDS, 0);
}

tree::TerminalNode* RpgParser::Bif_secondsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_secondsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_secondsContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_secondsContext::getRuleIndex() const {
  return RpgParser::RuleBif_seconds;
}

void RpgParser::Bif_secondsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_seconds(this);
}

void RpgParser::Bif_secondsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_seconds(this);
}


antlrcpp::Any RpgParser::Bif_secondsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_seconds(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_secondsContext* RpgParser::bif_seconds() {
  Bif_secondsContext *_localctx = _tracker.createInstance<Bif_secondsContext>(_ctx, getState());
  enterRule(_localctx, 1054, RpgParser::RuleBif_seconds);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5387);
    match(RpgParser::BIF_SECONDS);
    setState(5388);
    match(RpgParser::OPEN_PAREN);
    setState(5389);
    dynamic_cast<Bif_secondsContext *>(_localctx)->numberexpression = expression(0);
    setState(5390);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_shtdnContext ------------------------------------------------------------------

RpgParser::Bif_shtdnContext::Bif_shtdnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_shtdnContext::BIF_SHTDN() {
  return getToken(RpgParser::BIF_SHTDN, 0);
}


size_t RpgParser::Bif_shtdnContext::getRuleIndex() const {
  return RpgParser::RuleBif_shtdn;
}

void RpgParser::Bif_shtdnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_shtdn(this);
}

void RpgParser::Bif_shtdnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_shtdn(this);
}


antlrcpp::Any RpgParser::Bif_shtdnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_shtdn(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_shtdnContext* RpgParser::bif_shtdn() {
  Bif_shtdnContext *_localctx = _tracker.createInstance<Bif_shtdnContext>(_ctx, getState());
  enterRule(_localctx, 1056, RpgParser::RuleBif_shtdn);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5392);
    match(RpgParser::BIF_SHTDN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_sizeContext ------------------------------------------------------------------

RpgParser::Bif_sizeContext::Bif_sizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_sizeContext::BIF_SIZE() {
  return getToken(RpgParser::BIF_SIZE, 0);
}

tree::TerminalNode* RpgParser::Bif_sizeContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_sizeContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_sizeContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_sizeContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_sizeContext::SPLAT_ALL() {
  return getToken(RpgParser::SPLAT_ALL, 0);
}


size_t RpgParser::Bif_sizeContext::getRuleIndex() const {
  return RpgParser::RuleBif_size;
}

void RpgParser::Bif_sizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_size(this);
}

void RpgParser::Bif_sizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_size(this);
}


antlrcpp::Any RpgParser::Bif_sizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_size(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_sizeContext* RpgParser::bif_size() {
  Bif_sizeContext *_localctx = _tracker.createInstance<Bif_sizeContext>(_ctx, getState());
  enterRule(_localctx, 1058, RpgParser::RuleBif_size);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5394);
    match(RpgParser::BIF_SIZE);
    setState(5395);
    match(RpgParser::OPEN_PAREN);
    setState(5396);
    expression(0);
    setState(5399);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5397);
      match(RpgParser::COLON);
      setState(5398);
      match(RpgParser::SPLAT_ALL);
    }
    setState(5401);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_sqrtContext ------------------------------------------------------------------

RpgParser::Bif_sqrtContext::Bif_sqrtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_sqrtContext::BIF_SQRT() {
  return getToken(RpgParser::BIF_SQRT, 0);
}

tree::TerminalNode* RpgParser::Bif_sqrtContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_sqrtContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_sqrtContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_sqrtContext::getRuleIndex() const {
  return RpgParser::RuleBif_sqrt;
}

void RpgParser::Bif_sqrtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_sqrt(this);
}

void RpgParser::Bif_sqrtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_sqrt(this);
}


antlrcpp::Any RpgParser::Bif_sqrtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_sqrt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_sqrtContext* RpgParser::bif_sqrt() {
  Bif_sqrtContext *_localctx = _tracker.createInstance<Bif_sqrtContext>(_ctx, getState());
  enterRule(_localctx, 1060, RpgParser::RuleBif_sqrt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5403);
    match(RpgParser::BIF_SQRT);
    setState(5404);
    match(RpgParser::OPEN_PAREN);
    setState(5405);
    dynamic_cast<Bif_sqrtContext *>(_localctx)->numeric = expression(0);
    setState(5406);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_statusContext ------------------------------------------------------------------

RpgParser::Bif_statusContext::Bif_statusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_statusContext::BIF_STATUS() {
  return getToken(RpgParser::BIF_STATUS, 0);
}

tree::TerminalNode* RpgParser::Bif_statusContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_statusContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::IdentifierContext* RpgParser::Bif_statusContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}


size_t RpgParser::Bif_statusContext::getRuleIndex() const {
  return RpgParser::RuleBif_status;
}

void RpgParser::Bif_statusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_status(this);
}

void RpgParser::Bif_statusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_status(this);
}


antlrcpp::Any RpgParser::Bif_statusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_status(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_statusContext* RpgParser::bif_status() {
  Bif_statusContext *_localctx = _tracker.createInstance<Bif_statusContext>(_ctx, getState());
  enterRule(_localctx, 1062, RpgParser::RuleBif_status);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5408);
    match(RpgParser::BIF_STATUS);
    setState(5413);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 474, _ctx)) {
    case 1: {
      setState(5409);
      match(RpgParser::OPEN_PAREN);
      setState(5410);
      dynamic_cast<Bif_statusContext *>(_localctx)->filenameident = identifier();
      setState(5411);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_strContext ------------------------------------------------------------------

RpgParser::Bif_strContext::Bif_strContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_strContext::BIF_STR() {
  return getToken(RpgParser::BIF_STR, 0);
}

tree::TerminalNode* RpgParser::Bif_strContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_strContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_strContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_strContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_strContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Bif_strContext::getRuleIndex() const {
  return RpgParser::RuleBif_str;
}

void RpgParser::Bif_strContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_str(this);
}

void RpgParser::Bif_strContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_str(this);
}


antlrcpp::Any RpgParser::Bif_strContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_str(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_strContext* RpgParser::bif_str() {
  Bif_strContext *_localctx = _tracker.createInstance<Bif_strContext>(_ctx, getState());
  enterRule(_localctx, 1064, RpgParser::RuleBif_str);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5415);
    match(RpgParser::BIF_STR);
    setState(5416);
    match(RpgParser::OPEN_PAREN);
    setState(5417);
    dynamic_cast<Bif_strContext *>(_localctx)->basingpointer = expression(0);
    setState(5420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5418);
      match(RpgParser::COLON);
      setState(5419);
      dynamic_cast<Bif_strContext *>(_localctx)->maxlength = expression(0);
    }
    setState(5422);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_subarrContext ------------------------------------------------------------------

RpgParser::Bif_subarrContext::Bif_subarrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_subarrContext::BIF_SUBARR() {
  return getToken(RpgParser::BIF_SUBARR, 0);
}

tree::TerminalNode* RpgParser::Bif_subarrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_subarrContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_subarrContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_subarrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_subarrContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_subarrContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_subarrContext::getRuleIndex() const {
  return RpgParser::RuleBif_subarr;
}

void RpgParser::Bif_subarrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_subarr(this);
}

void RpgParser::Bif_subarrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_subarr(this);
}


antlrcpp::Any RpgParser::Bif_subarrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_subarr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_subarrContext* RpgParser::bif_subarr() {
  Bif_subarrContext *_localctx = _tracker.createInstance<Bif_subarrContext>(_ctx, getState());
  enterRule(_localctx, 1066, RpgParser::RuleBif_subarr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5424);
    match(RpgParser::BIF_SUBARR);
    setState(5425);
    match(RpgParser::OPEN_PAREN);
    setState(5426);
    dynamic_cast<Bif_subarrContext *>(_localctx)->array = expression(0);
    setState(5427);
    match(RpgParser::COLON);
    setState(5428);
    dynamic_cast<Bif_subarrContext *>(_localctx)->start = expression(0);
    setState(5431);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5429);
      match(RpgParser::COLON);
      setState(5430);
      dynamic_cast<Bif_subarrContext *>(_localctx)->numberelements = expression(0);
    }
    setState(5433);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_subdtContext ------------------------------------------------------------------

RpgParser::Bif_subdtContext::Bif_subdtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_subdtContext::BIF_SUBDT() {
  return getToken(RpgParser::BIF_SUBDT, 0);
}

tree::TerminalNode* RpgParser::Bif_subdtContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_subdtContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

tree::TerminalNode* RpgParser::Bif_subdtContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_subdtContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::DurationCodeContext* RpgParser::Bif_subdtContext::durationCode() {
  return getRuleContext<RpgParser::DurationCodeContext>(0);
}


size_t RpgParser::Bif_subdtContext::getRuleIndex() const {
  return RpgParser::RuleBif_subdt;
}

void RpgParser::Bif_subdtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_subdt(this);
}

void RpgParser::Bif_subdtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_subdt(this);
}


antlrcpp::Any RpgParser::Bif_subdtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_subdt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_subdtContext* RpgParser::bif_subdt() {
  Bif_subdtContext *_localctx = _tracker.createInstance<Bif_subdtContext>(_ctx, getState());
  enterRule(_localctx, 1068, RpgParser::RuleBif_subdt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5435);
    match(RpgParser::BIF_SUBDT);
    setState(5436);
    match(RpgParser::OPEN_PAREN);
    setState(5437);
    dynamic_cast<Bif_subdtContext *>(_localctx)->value = expression(0);
    setState(5438);
    match(RpgParser::COLON);
    setState(5439);
    dynamic_cast<Bif_subdtContext *>(_localctx)->format = durationCode();
    setState(5440);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_substContext ------------------------------------------------------------------

RpgParser::Bif_substContext::Bif_substContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_substContext::BIF_SUBST() {
  return getToken(RpgParser::BIF_SUBST, 0);
}

tree::TerminalNode* RpgParser::Bif_substContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_substContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_substContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_substContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_substContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_substContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_substContext::getRuleIndex() const {
  return RpgParser::RuleBif_subst;
}

void RpgParser::Bif_substContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_subst(this);
}

void RpgParser::Bif_substContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_subst(this);
}


antlrcpp::Any RpgParser::Bif_substContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_subst(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_substContext* RpgParser::bif_subst() {
  Bif_substContext *_localctx = _tracker.createInstance<Bif_substContext>(_ctx, getState());
  enterRule(_localctx, 1070, RpgParser::RuleBif_subst);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5442);
    match(RpgParser::BIF_SUBST);
    setState(5443);
    match(RpgParser::OPEN_PAREN);
    setState(5444);
    dynamic_cast<Bif_substContext *>(_localctx)->string = expression(0);
    setState(5445);
    match(RpgParser::COLON);
    setState(5446);
    dynamic_cast<Bif_substContext *>(_localctx)->start = expression(0);
    setState(5449);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5447);
      match(RpgParser::COLON);
      setState(5448);
      dynamic_cast<Bif_substContext *>(_localctx)->length = expression(0);
    }
    setState(5451);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_thisContext ------------------------------------------------------------------

RpgParser::Bif_thisContext::Bif_thisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_thisContext::BIF_THIS() {
  return getToken(RpgParser::BIF_THIS, 0);
}


size_t RpgParser::Bif_thisContext::getRuleIndex() const {
  return RpgParser::RuleBif_this;
}

void RpgParser::Bif_thisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_this(this);
}

void RpgParser::Bif_thisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_this(this);
}


antlrcpp::Any RpgParser::Bif_thisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_this(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_thisContext* RpgParser::bif_this() {
  Bif_thisContext *_localctx = _tracker.createInstance<Bif_thisContext>(_ctx, getState());
  enterRule(_localctx, 1072, RpgParser::RuleBif_this);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5453);
    match(RpgParser::BIF_THIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_timeContext ------------------------------------------------------------------

RpgParser::Bif_timeContext::Bif_timeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_timeContext::BIF_TIME() {
  return getToken(RpgParser::BIF_TIME, 0);
}

tree::TerminalNode* RpgParser::Bif_timeContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_timeContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_timeContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_timeContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::Bif_timeformatContext* RpgParser::Bif_timeContext::bif_timeformat() {
  return getRuleContext<RpgParser::Bif_timeformatContext>(0);
}


size_t RpgParser::Bif_timeContext::getRuleIndex() const {
  return RpgParser::RuleBif_time;
}

void RpgParser::Bif_timeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_time(this);
}

void RpgParser::Bif_timeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_time(this);
}


antlrcpp::Any RpgParser::Bif_timeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_time(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_timeContext* RpgParser::bif_time() {
  Bif_timeContext *_localctx = _tracker.createInstance<Bif_timeContext>(_ctx, getState());
  enterRule(_localctx, 1074, RpgParser::RuleBif_time);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5455);
    match(RpgParser::BIF_TIME);
    setState(5465);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx)) {
    case 1: {
      setState(5456);
      match(RpgParser::OPEN_PAREN);
      setState(5458);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
        | (1ULL << (RpgParser::NUMBER - 20))
        | (1ULL << (RpgParser::ID - 20))
        | (1ULL << (RpgParser::OP_ACQ - 20))
        | (1ULL << (RpgParser::OP_BEGSR - 20))
        | (1ULL << (RpgParser::OP_CALLP - 20))
        | (1ULL << (RpgParser::OP_CHAIN - 20))
        | (1ULL << (RpgParser::OP_CLEAR - 20))
        | (1ULL << (RpgParser::OP_CLOSE - 20))
        | (1ULL << (RpgParser::OP_COMMIT - 20))
        | (1ULL << (RpgParser::OP_DEALLOC - 20))
        | (1ULL << (RpgParser::OP_DELETE - 20))
        | (1ULL << (RpgParser::OP_DSPLY - 20))
        | (1ULL << (RpgParser::OP_DUMP - 20))
        | (1ULL << (RpgParser::OP_ENDSR - 20))
        | (1ULL << (RpgParser::OP_EVAL - 20))
        | (1ULL << (RpgParser::OP_EVALR - 20))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
        | (1ULL << (RpgParser::OP_EXCEPT - 20))
        | (1ULL << (RpgParser::OP_EXFMT - 20))
        | (1ULL << (RpgParser::OP_EXSR - 20))
        | (1ULL << (RpgParser::OP_FEOD - 20))
        | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
        | (1ULL << (RpgParser::OP_ITER - 84))
        | (1ULL << (RpgParser::OP_LEAVE - 84))
        | (1ULL << (RpgParser::OP_LEAVESR - 84))
        | (1ULL << (RpgParser::OP_NEXT - 84))
        | (1ULL << (RpgParser::OP_OPEN - 84))
        | (1ULL << (RpgParser::OP_OTHER - 84))
        | (1ULL << (RpgParser::OP_OUT - 84))
        | (1ULL << (RpgParser::OP_POST - 84))
        | (1ULL << (RpgParser::OP_READ - 84))
        | (1ULL << (RpgParser::OP_READC - 84))
        | (1ULL << (RpgParser::OP_READE - 84))
        | (1ULL << (RpgParser::OP_READP - 84))
        | (1ULL << (RpgParser::OP_READPE - 84))
        | (1ULL << (RpgParser::OP_REL - 84))
        | (1ULL << (RpgParser::OP_RESET - 84))
        | (1ULL << (RpgParser::OP_RETURN - 84))
        | (1ULL << (RpgParser::OP_ROLBK - 84))
        | (1ULL << (RpgParser::OP_SELECT - 84))
        | (1ULL << (RpgParser::OP_SETGT - 84))
        | (1ULL << (RpgParser::OP_SETLL - 84))
        | (1ULL << (RpgParser::OP_SORTA - 84))
        | (1ULL << (RpgParser::OP_TEST - 84))
        | (1ULL << (RpgParser::OP_UNLOCK - 84))
        | (1ULL << (RpgParser::OP_UPDATE - 84))
        | (1ULL << (RpgParser::OP_WHEN - 84))
        | (1ULL << (RpgParser::OP_WRITE - 84))
        | (1ULL << (RpgParser::OP_XML_INTO - 84))
        | (1ULL << (RpgParser::OP_XML_SAX - 84))
        | (1ULL << (RpgParser::BIF_ABS - 84))
        | (1ULL << (RpgParser::BIF_ADDR - 84))
        | (1ULL << (RpgParser::BIF_ALLOC - 84))
        | (1ULL << (RpgParser::BIF_BITAND - 84))
        | (1ULL << (RpgParser::BIF_BITNOT - 84))
        | (1ULL << (RpgParser::BIF_BITOR - 84))
        | (1ULL << (RpgParser::BIF_BITXOR - 84))
        | (1ULL << (RpgParser::BIF_CHAR - 84))
        | (1ULL << (RpgParser::BIF_CHECK - 84))
        | (1ULL << (RpgParser::BIF_CHECKR - 84))
        | (1ULL << (RpgParser::BIF_DATE - 84))
        | (1ULL << (RpgParser::BIF_DAYS - 84))
        | (1ULL << (RpgParser::BIF_DEC - 84))
        | (1ULL << (RpgParser::BIF_DECH - 84))
        | (1ULL << (RpgParser::BIF_DECPOS - 84))
        | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
        | (1ULL << (RpgParser::BIF_EDITC - 148))
        | (1ULL << (RpgParser::BIF_EDITFLT - 148))
        | (1ULL << (RpgParser::BIF_EDITW - 148))
        | (1ULL << (RpgParser::BIF_ELEM - 148))
        | (1ULL << (RpgParser::BIF_EOF - 148))
        | (1ULL << (RpgParser::BIF_EQUAL - 148))
        | (1ULL << (RpgParser::BIF_ERROR - 148))
        | (1ULL << (RpgParser::BIF_FIELDS - 148))
        | (1ULL << (RpgParser::BIF_FLOAT - 148))
        | (1ULL << (RpgParser::BIF_FOUND - 148))
        | (1ULL << (RpgParser::BIF_GRAPH - 148))
        | (1ULL << (RpgParser::BIF_HANDLER - 148))
        | (1ULL << (RpgParser::BIF_HOURS - 148))
        | (1ULL << (RpgParser::BIF_INT - 148))
        | (1ULL << (RpgParser::BIF_INTH - 148))
        | (1ULL << (RpgParser::BIF_KDS - 148))
        | (1ULL << (RpgParser::BIF_LEN - 148))
        | (1ULL << (RpgParser::BIF_LOOKUP - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_MINUTES - 148))
        | (1ULL << (RpgParser::BIF_MONTHS - 148))
        | (1ULL << (RpgParser::BIF_MSECONDS - 148))
        | (1ULL << (RpgParser::BIF_NULLIND - 148))
        | (1ULL << (RpgParser::BIF_OCCUR - 148))
        | (1ULL << (RpgParser::BIF_OPEN - 148))
        | (1ULL << (RpgParser::BIF_PADDR - 148))
        | (1ULL << (RpgParser::BIF_PARMS - 148))
        | (1ULL << (RpgParser::BIF_PARMNUM - 148))
        | (1ULL << (RpgParser::BIF_REALLOC - 148))
        | (1ULL << (RpgParser::BIF_REM - 148))
        | (1ULL << (RpgParser::BIF_REPLACE - 148))
        | (1ULL << (RpgParser::BIF_SCAN - 148))
        | (1ULL << (RpgParser::BIF_SCANRPL - 148))
        | (1ULL << (RpgParser::BIF_SECONDS - 148))
        | (1ULL << (RpgParser::BIF_SHTDN - 148))
        | (1ULL << (RpgParser::BIF_SIZE - 148))
        | (1ULL << (RpgParser::BIF_SQRT - 148))
        | (1ULL << (RpgParser::BIF_STATUS - 148))
        | (1ULL << (RpgParser::BIF_STR - 148))
        | (1ULL << (RpgParser::BIF_SUBARR - 148))
        | (1ULL << (RpgParser::BIF_SUBDT - 148))
        | (1ULL << (RpgParser::BIF_SUBST - 148))
        | (1ULL << (RpgParser::BIF_THIS - 148))
        | (1ULL << (RpgParser::BIF_TIME - 148))
        | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_TRIM - 148))
        | (1ULL << (RpgParser::BIF_TRIML - 148))
        | (1ULL << (RpgParser::BIF_TRIMR - 148))
        | (1ULL << (RpgParser::BIF_UCS2 - 148))
        | (1ULL << (RpgParser::BIF_UNS - 148))
        | (1ULL << (RpgParser::BIF_UNSH - 148))
        | (1ULL << (RpgParser::BIF_XFOOT - 148))
        | (1ULL << (RpgParser::BIF_XLATE - 148))
        | (1ULL << (RpgParser::BIF_XML - 148))
        | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::PLUS - 404))
        | (1ULL << (RpgParser::MINUS - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404))
        | (1ULL << (RpgParser::HexLiteralStart - 404))
        | (1ULL << (RpgParser::DateLiteralStart - 404))
        | (1ULL << (RpgParser::TimeLiteralStart - 404))
        | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
        | (1ULL << (RpgParser::GraphicLiteralStart - 404))
        | (1ULL << (RpgParser::UCS2LiteralStart - 404))
        | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
        setState(5457);
        expression(0);
      }
      setState(5462);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::COLON) {
        setState(5460);
        match(RpgParser::COLON);
        setState(5461);
        dynamic_cast<Bif_timeContext *>(_localctx)->timeformat = bif_timeformat();
      }
      setState(5464);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_timestampContext ------------------------------------------------------------------

RpgParser::Bif_timestampContext::Bif_timestampContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_timestampContext::BIF_TIMESTAMP() {
  return getToken(RpgParser::BIF_TIMESTAMP, 0);
}

tree::TerminalNode* RpgParser::Bif_timestampContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_timestampContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_timestampContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_timestampContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}

RpgParser::Bif_timestampargsContext* RpgParser::Bif_timestampContext::bif_timestampargs() {
  return getRuleContext<RpgParser::Bif_timestampargsContext>(0);
}


size_t RpgParser::Bif_timestampContext::getRuleIndex() const {
  return RpgParser::RuleBif_timestamp;
}

void RpgParser::Bif_timestampContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_timestamp(this);
}

void RpgParser::Bif_timestampContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_timestamp(this);
}


antlrcpp::Any RpgParser::Bif_timestampContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_timestamp(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_timestampContext* RpgParser::bif_timestamp() {
  Bif_timestampContext *_localctx = _tracker.createInstance<Bif_timestampContext>(_ctx, getState());
  enterRule(_localctx, 1076, RpgParser::RuleBif_timestamp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5467);
    match(RpgParser::BIF_TIMESTAMP);
    setState(5477);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 483, _ctx)) {
    case 1: {
      setState(5468);
      match(RpgParser::OPEN_PAREN);
      setState(5470);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 20) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
        | (1ULL << (RpgParser::NUMBER - 20))
        | (1ULL << (RpgParser::ID - 20))
        | (1ULL << (RpgParser::OP_ACQ - 20))
        | (1ULL << (RpgParser::OP_BEGSR - 20))
        | (1ULL << (RpgParser::OP_CALLP - 20))
        | (1ULL << (RpgParser::OP_CHAIN - 20))
        | (1ULL << (RpgParser::OP_CLEAR - 20))
        | (1ULL << (RpgParser::OP_CLOSE - 20))
        | (1ULL << (RpgParser::OP_COMMIT - 20))
        | (1ULL << (RpgParser::OP_DEALLOC - 20))
        | (1ULL << (RpgParser::OP_DELETE - 20))
        | (1ULL << (RpgParser::OP_DSPLY - 20))
        | (1ULL << (RpgParser::OP_DUMP - 20))
        | (1ULL << (RpgParser::OP_ENDSR - 20))
        | (1ULL << (RpgParser::OP_EVAL - 20))
        | (1ULL << (RpgParser::OP_EVALR - 20))
        | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
        | (1ULL << (RpgParser::OP_EXCEPT - 20))
        | (1ULL << (RpgParser::OP_EXFMT - 20))
        | (1ULL << (RpgParser::OP_EXSR - 20))
        | (1ULL << (RpgParser::OP_FEOD - 20))
        | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
        | (1ULL << (RpgParser::OP_ITER - 84))
        | (1ULL << (RpgParser::OP_LEAVE - 84))
        | (1ULL << (RpgParser::OP_LEAVESR - 84))
        | (1ULL << (RpgParser::OP_NEXT - 84))
        | (1ULL << (RpgParser::OP_OPEN - 84))
        | (1ULL << (RpgParser::OP_OTHER - 84))
        | (1ULL << (RpgParser::OP_OUT - 84))
        | (1ULL << (RpgParser::OP_POST - 84))
        | (1ULL << (RpgParser::OP_READ - 84))
        | (1ULL << (RpgParser::OP_READC - 84))
        | (1ULL << (RpgParser::OP_READE - 84))
        | (1ULL << (RpgParser::OP_READP - 84))
        | (1ULL << (RpgParser::OP_READPE - 84))
        | (1ULL << (RpgParser::OP_REL - 84))
        | (1ULL << (RpgParser::OP_RESET - 84))
        | (1ULL << (RpgParser::OP_RETURN - 84))
        | (1ULL << (RpgParser::OP_ROLBK - 84))
        | (1ULL << (RpgParser::OP_SELECT - 84))
        | (1ULL << (RpgParser::OP_SETGT - 84))
        | (1ULL << (RpgParser::OP_SETLL - 84))
        | (1ULL << (RpgParser::OP_SORTA - 84))
        | (1ULL << (RpgParser::OP_TEST - 84))
        | (1ULL << (RpgParser::OP_UNLOCK - 84))
        | (1ULL << (RpgParser::OP_UPDATE - 84))
        | (1ULL << (RpgParser::OP_WHEN - 84))
        | (1ULL << (RpgParser::OP_WRITE - 84))
        | (1ULL << (RpgParser::OP_XML_INTO - 84))
        | (1ULL << (RpgParser::OP_XML_SAX - 84))
        | (1ULL << (RpgParser::BIF_ABS - 84))
        | (1ULL << (RpgParser::BIF_ADDR - 84))
        | (1ULL << (RpgParser::BIF_ALLOC - 84))
        | (1ULL << (RpgParser::BIF_BITAND - 84))
        | (1ULL << (RpgParser::BIF_BITNOT - 84))
        | (1ULL << (RpgParser::BIF_BITOR - 84))
        | (1ULL << (RpgParser::BIF_BITXOR - 84))
        | (1ULL << (RpgParser::BIF_CHAR - 84))
        | (1ULL << (RpgParser::BIF_CHECK - 84))
        | (1ULL << (RpgParser::BIF_CHECKR - 84))
        | (1ULL << (RpgParser::BIF_DATE - 84))
        | (1ULL << (RpgParser::BIF_DAYS - 84))
        | (1ULL << (RpgParser::BIF_DEC - 84))
        | (1ULL << (RpgParser::BIF_DECH - 84))
        | (1ULL << (RpgParser::BIF_DECPOS - 84))
        | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
        | (1ULL << (RpgParser::BIF_EDITC - 148))
        | (1ULL << (RpgParser::BIF_EDITFLT - 148))
        | (1ULL << (RpgParser::BIF_EDITW - 148))
        | (1ULL << (RpgParser::BIF_ELEM - 148))
        | (1ULL << (RpgParser::BIF_EOF - 148))
        | (1ULL << (RpgParser::BIF_EQUAL - 148))
        | (1ULL << (RpgParser::BIF_ERROR - 148))
        | (1ULL << (RpgParser::BIF_FIELDS - 148))
        | (1ULL << (RpgParser::BIF_FLOAT - 148))
        | (1ULL << (RpgParser::BIF_FOUND - 148))
        | (1ULL << (RpgParser::BIF_GRAPH - 148))
        | (1ULL << (RpgParser::BIF_HANDLER - 148))
        | (1ULL << (RpgParser::BIF_HOURS - 148))
        | (1ULL << (RpgParser::BIF_INT - 148))
        | (1ULL << (RpgParser::BIF_INTH - 148))
        | (1ULL << (RpgParser::BIF_KDS - 148))
        | (1ULL << (RpgParser::BIF_LEN - 148))
        | (1ULL << (RpgParser::BIF_LOOKUP - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_MINUTES - 148))
        | (1ULL << (RpgParser::BIF_MONTHS - 148))
        | (1ULL << (RpgParser::BIF_MSECONDS - 148))
        | (1ULL << (RpgParser::BIF_NULLIND - 148))
        | (1ULL << (RpgParser::BIF_OCCUR - 148))
        | (1ULL << (RpgParser::BIF_OPEN - 148))
        | (1ULL << (RpgParser::BIF_PADDR - 148))
        | (1ULL << (RpgParser::BIF_PARMS - 148))
        | (1ULL << (RpgParser::BIF_PARMNUM - 148))
        | (1ULL << (RpgParser::BIF_REALLOC - 148))
        | (1ULL << (RpgParser::BIF_REM - 148))
        | (1ULL << (RpgParser::BIF_REPLACE - 148))
        | (1ULL << (RpgParser::BIF_SCAN - 148))
        | (1ULL << (RpgParser::BIF_SCANRPL - 148))
        | (1ULL << (RpgParser::BIF_SECONDS - 148))
        | (1ULL << (RpgParser::BIF_SHTDN - 148))
        | (1ULL << (RpgParser::BIF_SIZE - 148))
        | (1ULL << (RpgParser::BIF_SQRT - 148))
        | (1ULL << (RpgParser::BIF_STATUS - 148))
        | (1ULL << (RpgParser::BIF_STR - 148))
        | (1ULL << (RpgParser::BIF_SUBARR - 148))
        | (1ULL << (RpgParser::BIF_SUBDT - 148))
        | (1ULL << (RpgParser::BIF_SUBST - 148))
        | (1ULL << (RpgParser::BIF_THIS - 148))
        | (1ULL << (RpgParser::BIF_TIME - 148))
        | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
        | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
        | (1ULL << (RpgParser::BIF_TRIM - 148))
        | (1ULL << (RpgParser::BIF_TRIML - 148))
        | (1ULL << (RpgParser::BIF_TRIMR - 148))
        | (1ULL << (RpgParser::BIF_UCS2 - 148))
        | (1ULL << (RpgParser::BIF_UNS - 148))
        | (1ULL << (RpgParser::BIF_UNSH - 148))
        | (1ULL << (RpgParser::BIF_XFOOT - 148))
        | (1ULL << (RpgParser::BIF_XLATE - 148))
        | (1ULL << (RpgParser::BIF_XML - 148))
        | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
        | (1ULL << (RpgParser::SPLAT_NONE - 212))
        | (1ULL << (RpgParser::SPLAT_YES - 212))
        | (1ULL << (RpgParser::SPLAT_NO - 212))
        | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
        | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
        | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
        | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
        | (1ULL << (RpgParser::SPLAT_VRM - 212))
        | (1ULL << (RpgParser::SPLAT_ALLG - 212))
        | (1ULL << (RpgParser::SPLAT_ALLU - 212))
        | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
        | (1ULL << (RpgParser::SPLAT_ALLX - 212))
        | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
        | (1ULL << (RpgParser::SPLAT_CANCL - 212))
        | (1ULL << (RpgParser::SPLAT_CYMD - 212))
        | (1ULL << (RpgParser::SPLAT_CMDY - 212))
        | (1ULL << (RpgParser::SPLAT_CDMY - 212))
        | (1ULL << (RpgParser::SPLAT_MDY - 212))
        | (1ULL << (RpgParser::SPLAT_DMY - 212))
        | (1ULL << (RpgParser::SPLAT_DFT - 212))
        | (1ULL << (RpgParser::SPLAT_YMD - 212))
        | (1ULL << (RpgParser::SPLAT_JUL - 212))
        | (1ULL << (RpgParser::SPLAT_JAVA - 212))
        | (1ULL << (RpgParser::SPLAT_ISO - 212))
        | (1ULL << (RpgParser::SPLAT_USA - 212))
        | (1ULL << (RpgParser::SPLAT_EUR - 212))
        | (1ULL << (RpgParser::SPLAT_JIS - 212))
        | (1ULL << (RpgParser::SPLAT_DATE - 212))
        | (1ULL << (RpgParser::SPLAT_DAY - 212))
        | (1ULL << (RpgParser::SPlAT_DETC - 212))
        | (1ULL << (RpgParser::SPLAT_DETL - 212))
        | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
        | (1ULL << (RpgParser::SPLAT_END - 212))
        | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
        | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
        | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
        | (1ULL << (RpgParser::SPLAT_EXT - 212))
        | (1ULL << (RpgParser::SPLAT_FILE - 212))
        | (1ULL << (RpgParser::SPLAT_GETIN - 212))
        | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
        | (1ULL << (RpgParser::SPLAT_INIT - 212))
        | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
        | (1ULL << (RpgParser::SPLAT_INZSR - 212))
        | (1ULL << (RpgParser::SPLAT_IN - 212))
        | (1ULL << (RpgParser::SPLAT_INPUT - 212))
        | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
        | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
        | (1ULL << (RpgParser::SPLAT_JOB - 212))
        | (1ULL << (RpgParser::SPLAT_LDA - 212))
        | (1ULL << (RpgParser::SPLAT_LIKE - 212))
        | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
        | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
        | (1ULL << (RpgParser::SPLAT_KEY - 212))
        | (1ULL << (RpgParser::SPLAT_MONTH - 212))
        | (1ULL << (RpgParser::SPLAT_NEXT - 212))
        | (1ULL << (RpgParser::SPLAT_NOIND - 212))
        | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
        | (1ULL << (RpgParser::SPLAT_NULL - 212))
        | (1ULL << (RpgParser::SPLAT_OFL - 212))
        | (1ULL << (RpgParser::SPLAT_ON - 212))
        | (1ULL << (RpgParser::SPLAT_ONLY - 212))
        | (1ULL << (RpgParser::SPLAT_OFF - 212))
        | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
        | (1ULL << (RpgParser::SPLAT_PSSR - 276))
        | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
        | (1ULL << (RpgParser::SPLAT_START - 276))
        | (1ULL << (RpgParser::SPLAT_SYS - 276))
        | (1ULL << (RpgParser::SPLAT_TERM - 276))
        | (1ULL << (RpgParser::SPLAT_TOTC - 276))
        | (1ULL << (RpgParser::SPLAT_TOTL - 276))
        | (1ULL << (RpgParser::SPLAT_USER - 276))
        | (1ULL << (RpgParser::SPLAT_VAR - 276))
        | (1ULL << (RpgParser::SPLAT_YEAR - 276))
        | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
        | (1ULL << (RpgParser::SPLAT_HMS - 276))
        | (1ULL << (RpgParser::SPLAT_INLR - 276))
        | (1ULL << (RpgParser::SPLAT_INOF - 276))
        | (1ULL << (RpgParser::SPLAT_DATA - 276))
        | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
        | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
        | (1ULL << (RpgParser::SPLAT_MAX - 276))
        | (1ULL << (RpgParser::SPLAT_LOCK - 276))
        | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
        | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
        | (1ULL << (RpgParser::SPLAT_D - 276))
        | (1ULL << (RpgParser::SPLAT_H - 276))
        | (1ULL << (RpgParser::SPLAT_HOURS - 276))
        | (1ULL << (RpgParser::SPLAT_DAYS - 276))
        | (1ULL << (RpgParser::SPLAT_M - 276))
        | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
        | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
        | (1ULL << (RpgParser::SPLAT_MN - 276))
        | (1ULL << (RpgParser::SPLAT_MS - 276))
        | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_S - 276))
        | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
        | (1ULL << (RpgParser::SPLAT_Y - 276))
        | (1ULL << (RpgParser::SPLAT_YEARS - 276))
        | (1ULL << (RpgParser::UDATE - 276))
        | (1ULL << (RpgParser::UMONTH - 276))
        | (1ULL << (RpgParser::UYEAR - 276))
        | (1ULL << (RpgParser::UDAY - 276))
        | (1ULL << (RpgParser::CHAR - 276))
        | (1ULL << (RpgParser::VARCHAR - 276))
        | (1ULL << (RpgParser::UCS2 - 276))
        | (1ULL << (RpgParser::DATE_ - 276))
        | (1ULL << (RpgParser::VARUCS2 - 276))
        | (1ULL << (RpgParser::GRAPH - 276))
        | (1ULL << (RpgParser::VARGRAPH - 276))
        | (1ULL << (RpgParser::IND - 276))
        | (1ULL << (RpgParser::PACKED - 276))
        | (1ULL << (RpgParser::ZONED - 276))
        | (1ULL << (RpgParser::BINDEC - 276))
        | (1ULL << (RpgParser::INT - 276))
        | (1ULL << (RpgParser::UNS - 276))
        | (1ULL << (RpgParser::FLOAT - 276))
        | (1ULL << (RpgParser::TIME - 276))
        | (1ULL << (RpgParser::TIMESTAMP - 276))
        | (1ULL << (RpgParser::POINTER - 276))
        | (1ULL << (RpgParser::OBJECT - 276))
        | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
        | (1ULL << (RpgParser::KEYWORD_ALT - 340))
        | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
        | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_BASED - 340))
        | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
        | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
        | (1ULL << (RpgParser::KEYWORD_CONST - 340))
        | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
        | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
        | (1ULL << (RpgParser::KEYWORD_DIM - 340))
        | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
        | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
        | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
        | (1ULL << (RpgParser::KEYWORD_INZ - 340))
        | (1ULL << (RpgParser::KEYWORD_LEN - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
        | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
        | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
        | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
        | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
        | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
        | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
        | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
        | (1ULL << (RpgParser::KEYWORD_POS - 340))
        | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
        | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
        | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
        | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
        | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
        | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
        | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
        | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
        | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
        | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
        | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
        | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
        | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
        | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
        | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
        | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
        | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
        | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
        | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
        | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
        | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
        | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
        | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
        | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
        | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
        | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
        | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
        | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
        | (1ULL << (RpgParser::KEYWORD_SLN - 404))
        | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
        | (1ULL << (RpgParser::KEYWORD_DISK - 404))
        | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
        | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
        | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
        | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
        | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
        | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
        | (1ULL << (RpgParser::NOT - 404))
        | (1ULL << (RpgParser::PLUS - 404))
        | (1ULL << (RpgParser::MINUS - 404))
        | (1ULL << (RpgParser::MULT_NOSPACE - 404))
        | (1ULL << (RpgParser::FREE_BY - 404))
        | (1ULL << (RpgParser::FREE_TO - 404))
        | (1ULL << (RpgParser::FREE_DOWNTO - 404))
        | (1ULL << (RpgParser::HexLiteralStart - 404))
        | (1ULL << (RpgParser::DateLiteralStart - 404))
        | (1ULL << (RpgParser::TimeLiteralStart - 404))
        | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
        | (1ULL << (RpgParser::GraphicLiteralStart - 404))
        | (1ULL << (RpgParser::UCS2LiteralStart - 404))
        | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
        setState(5469);
        expression(0);
      }
      setState(5474);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::COLON) {
        setState(5472);
        match(RpgParser::COLON);
        setState(5473);
        dynamic_cast<Bif_timestampContext *>(_localctx)->format = bif_timestampargs();
      }
      setState(5476);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_tlookupContext ------------------------------------------------------------------

RpgParser::Bif_tlookupContext::Bif_tlookupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_tlookupContext::BIF_TLOOKUP() {
  return getToken(RpgParser::BIF_TLOOKUP, 0);
}

RpgParser::Bif_tlookupargsContext* RpgParser::Bif_tlookupContext::bif_tlookupargs() {
  return getRuleContext<RpgParser::Bif_tlookupargsContext>(0);
}


size_t RpgParser::Bif_tlookupContext::getRuleIndex() const {
  return RpgParser::RuleBif_tlookup;
}

void RpgParser::Bif_tlookupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_tlookup(this);
}

void RpgParser::Bif_tlookupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_tlookup(this);
}


antlrcpp::Any RpgParser::Bif_tlookupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_tlookup(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_tlookupContext* RpgParser::bif_tlookup() {
  Bif_tlookupContext *_localctx = _tracker.createInstance<Bif_tlookupContext>(_ctx, getState());
  enterRule(_localctx, 1078, RpgParser::RuleBif_tlookup);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5479);
    match(RpgParser::BIF_TLOOKUP);
    setState(5480);
    bif_tlookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_tlookupltContext ------------------------------------------------------------------

RpgParser::Bif_tlookupltContext::Bif_tlookupltContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_tlookupltContext::BIF_TLOOKUPLT() {
  return getToken(RpgParser::BIF_TLOOKUPLT, 0);
}

RpgParser::Bif_tlookupargsContext* RpgParser::Bif_tlookupltContext::bif_tlookupargs() {
  return getRuleContext<RpgParser::Bif_tlookupargsContext>(0);
}


size_t RpgParser::Bif_tlookupltContext::getRuleIndex() const {
  return RpgParser::RuleBif_tlookuplt;
}

void RpgParser::Bif_tlookupltContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_tlookuplt(this);
}

void RpgParser::Bif_tlookupltContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_tlookuplt(this);
}


antlrcpp::Any RpgParser::Bif_tlookupltContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_tlookuplt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_tlookupltContext* RpgParser::bif_tlookuplt() {
  Bif_tlookupltContext *_localctx = _tracker.createInstance<Bif_tlookupltContext>(_ctx, getState());
  enterRule(_localctx, 1080, RpgParser::RuleBif_tlookuplt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5482);
    match(RpgParser::BIF_TLOOKUPLT);
    setState(5483);
    bif_tlookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_tlookupleContext ------------------------------------------------------------------

RpgParser::Bif_tlookupleContext::Bif_tlookupleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_tlookupleContext::BIF_TLOOKUPLE() {
  return getToken(RpgParser::BIF_TLOOKUPLE, 0);
}

RpgParser::Bif_tlookupargsContext* RpgParser::Bif_tlookupleContext::bif_tlookupargs() {
  return getRuleContext<RpgParser::Bif_tlookupargsContext>(0);
}


size_t RpgParser::Bif_tlookupleContext::getRuleIndex() const {
  return RpgParser::RuleBif_tlookuple;
}

void RpgParser::Bif_tlookupleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_tlookuple(this);
}

void RpgParser::Bif_tlookupleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_tlookuple(this);
}


antlrcpp::Any RpgParser::Bif_tlookupleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_tlookuple(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_tlookupleContext* RpgParser::bif_tlookuple() {
  Bif_tlookupleContext *_localctx = _tracker.createInstance<Bif_tlookupleContext>(_ctx, getState());
  enterRule(_localctx, 1082, RpgParser::RuleBif_tlookuple);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5485);
    match(RpgParser::BIF_TLOOKUPLE);
    setState(5486);
    bif_tlookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_tlookupgtContext ------------------------------------------------------------------

RpgParser::Bif_tlookupgtContext::Bif_tlookupgtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_tlookupgtContext::BIF_TLOOKUPGT() {
  return getToken(RpgParser::BIF_TLOOKUPGT, 0);
}

RpgParser::Bif_tlookupargsContext* RpgParser::Bif_tlookupgtContext::bif_tlookupargs() {
  return getRuleContext<RpgParser::Bif_tlookupargsContext>(0);
}


size_t RpgParser::Bif_tlookupgtContext::getRuleIndex() const {
  return RpgParser::RuleBif_tlookupgt;
}

void RpgParser::Bif_tlookupgtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_tlookupgt(this);
}

void RpgParser::Bif_tlookupgtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_tlookupgt(this);
}


antlrcpp::Any RpgParser::Bif_tlookupgtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_tlookupgt(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_tlookupgtContext* RpgParser::bif_tlookupgt() {
  Bif_tlookupgtContext *_localctx = _tracker.createInstance<Bif_tlookupgtContext>(_ctx, getState());
  enterRule(_localctx, 1084, RpgParser::RuleBif_tlookupgt);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5488);
    match(RpgParser::BIF_TLOOKUPGT);
    setState(5489);
    bif_tlookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_tlookupgeContext ------------------------------------------------------------------

RpgParser::Bif_tlookupgeContext::Bif_tlookupgeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_tlookupgeContext::BIF_TLOOKUPGE() {
  return getToken(RpgParser::BIF_TLOOKUPGE, 0);
}

RpgParser::Bif_tlookupargsContext* RpgParser::Bif_tlookupgeContext::bif_tlookupargs() {
  return getRuleContext<RpgParser::Bif_tlookupargsContext>(0);
}


size_t RpgParser::Bif_tlookupgeContext::getRuleIndex() const {
  return RpgParser::RuleBif_tlookupge;
}

void RpgParser::Bif_tlookupgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_tlookupge(this);
}

void RpgParser::Bif_tlookupgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_tlookupge(this);
}


antlrcpp::Any RpgParser::Bif_tlookupgeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_tlookupge(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_tlookupgeContext* RpgParser::bif_tlookupge() {
  Bif_tlookupgeContext *_localctx = _tracker.createInstance<Bif_tlookupgeContext>(_ctx, getState());
  enterRule(_localctx, 1086, RpgParser::RuleBif_tlookupge);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5491);
    match(RpgParser::BIF_TLOOKUPGE);
    setState(5492);
    bif_tlookupargs();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_trimContext ------------------------------------------------------------------

RpgParser::Bif_trimContext::Bif_trimContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_trimContext::BIF_TRIM() {
  return getToken(RpgParser::BIF_TRIM, 0);
}

tree::TerminalNode* RpgParser::Bif_trimContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_trimContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_trimContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_trimContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_trimContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Bif_trimContext::getRuleIndex() const {
  return RpgParser::RuleBif_trim;
}

void RpgParser::Bif_trimContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_trim(this);
}

void RpgParser::Bif_trimContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_trim(this);
}


antlrcpp::Any RpgParser::Bif_trimContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_trim(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_trimContext* RpgParser::bif_trim() {
  Bif_trimContext *_localctx = _tracker.createInstance<Bif_trimContext>(_ctx, getState());
  enterRule(_localctx, 1088, RpgParser::RuleBif_trim);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5494);
    match(RpgParser::BIF_TRIM);
    setState(5495);
    match(RpgParser::OPEN_PAREN);
    setState(5496);
    dynamic_cast<Bif_trimContext *>(_localctx)->string = expression(0);
    setState(5499);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5497);
      match(RpgParser::COLON);
      setState(5498);
      dynamic_cast<Bif_trimContext *>(_localctx)->trimcharacters = expression(0);
    }
    setState(5501);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_trimlContext ------------------------------------------------------------------

RpgParser::Bif_trimlContext::Bif_trimlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_trimlContext::BIF_TRIML() {
  return getToken(RpgParser::BIF_TRIML, 0);
}

tree::TerminalNode* RpgParser::Bif_trimlContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_trimlContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_trimlContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_trimlContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_trimlContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Bif_trimlContext::getRuleIndex() const {
  return RpgParser::RuleBif_triml;
}

void RpgParser::Bif_trimlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_triml(this);
}

void RpgParser::Bif_trimlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_triml(this);
}


antlrcpp::Any RpgParser::Bif_trimlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_triml(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_trimlContext* RpgParser::bif_triml() {
  Bif_trimlContext *_localctx = _tracker.createInstance<Bif_trimlContext>(_ctx, getState());
  enterRule(_localctx, 1090, RpgParser::RuleBif_triml);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5503);
    match(RpgParser::BIF_TRIML);
    setState(5504);
    match(RpgParser::OPEN_PAREN);
    setState(5505);
    dynamic_cast<Bif_trimlContext *>(_localctx)->string = expression(0);
    setState(5508);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5506);
      match(RpgParser::COLON);
      setState(5507);
      dynamic_cast<Bif_trimlContext *>(_localctx)->trimcharacters = expression(0);
    }
    setState(5510);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_trimrContext ------------------------------------------------------------------

RpgParser::Bif_trimrContext::Bif_trimrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_trimrContext::BIF_TRIMR() {
  return getToken(RpgParser::BIF_TRIMR, 0);
}

tree::TerminalNode* RpgParser::Bif_trimrContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_trimrContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_trimrContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_trimrContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_trimrContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Bif_trimrContext::getRuleIndex() const {
  return RpgParser::RuleBif_trimr;
}

void RpgParser::Bif_trimrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_trimr(this);
}

void RpgParser::Bif_trimrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_trimr(this);
}


antlrcpp::Any RpgParser::Bif_trimrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_trimr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_trimrContext* RpgParser::bif_trimr() {
  Bif_trimrContext *_localctx = _tracker.createInstance<Bif_trimrContext>(_ctx, getState());
  enterRule(_localctx, 1092, RpgParser::RuleBif_trimr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5512);
    match(RpgParser::BIF_TRIMR);
    setState(5513);
    match(RpgParser::OPEN_PAREN);
    setState(5514);
    dynamic_cast<Bif_trimrContext *>(_localctx)->string = expression(0);
    setState(5517);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5515);
      match(RpgParser::COLON);
      setState(5516);
      dynamic_cast<Bif_trimrContext *>(_localctx)->trimcharacters = expression(0);
    }
    setState(5519);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_ucs2Context ------------------------------------------------------------------

RpgParser::Bif_ucs2Context::Bif_ucs2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_ucs2Context::BIF_UCS2() {
  return getToken(RpgParser::BIF_UCS2, 0);
}

tree::TerminalNode* RpgParser::Bif_ucs2Context::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_ucs2Context::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_ucs2Context::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_ucs2Context::getRuleIndex() const {
  return RpgParser::RuleBif_ucs2;
}

void RpgParser::Bif_ucs2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_ucs2(this);
}

void RpgParser::Bif_ucs2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_ucs2(this);
}


antlrcpp::Any RpgParser::Bif_ucs2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_ucs2(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_ucs2Context* RpgParser::bif_ucs2() {
  Bif_ucs2Context *_localctx = _tracker.createInstance<Bif_ucs2Context>(_ctx, getState());
  enterRule(_localctx, 1094, RpgParser::RuleBif_ucs2);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5521);
    match(RpgParser::BIF_UCS2);
    setState(5522);
    match(RpgParser::OPEN_PAREN);
    setState(5523);
    expression(0);
    setState(5524);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_unsContext ------------------------------------------------------------------

RpgParser::Bif_unsContext::Bif_unsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_unsContext::BIF_UNS() {
  return getToken(RpgParser::BIF_UNS, 0);
}

tree::TerminalNode* RpgParser::Bif_unsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_unsContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_unsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_unsContext::getRuleIndex() const {
  return RpgParser::RuleBif_uns;
}

void RpgParser::Bif_unsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_uns(this);
}

void RpgParser::Bif_unsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_uns(this);
}


antlrcpp::Any RpgParser::Bif_unsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_uns(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_unsContext* RpgParser::bif_uns() {
  Bif_unsContext *_localctx = _tracker.createInstance<Bif_unsContext>(_ctx, getState());
  enterRule(_localctx, 1096, RpgParser::RuleBif_uns);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5526);
    match(RpgParser::BIF_UNS);
    setState(5527);
    match(RpgParser::OPEN_PAREN);
    setState(5528);
    expression(0);
    setState(5529);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_unshContext ------------------------------------------------------------------

RpgParser::Bif_unshContext::Bif_unshContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_unshContext::BIF_UNSH() {
  return getToken(RpgParser::BIF_UNSH, 0);
}

tree::TerminalNode* RpgParser::Bif_unshContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_unshContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Bif_unshContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::Bif_unshContext::getRuleIndex() const {
  return RpgParser::RuleBif_unsh;
}

void RpgParser::Bif_unshContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_unsh(this);
}

void RpgParser::Bif_unshContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_unsh(this);
}


antlrcpp::Any RpgParser::Bif_unshContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_unsh(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_unshContext* RpgParser::bif_unsh() {
  Bif_unshContext *_localctx = _tracker.createInstance<Bif_unshContext>(_ctx, getState());
  enterRule(_localctx, 1098, RpgParser::RuleBif_unsh);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5531);
    match(RpgParser::BIF_UNSH);
    setState(5532);
    match(RpgParser::OPEN_PAREN);
    setState(5533);
    expression(0);
    setState(5534);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_xfootContext ------------------------------------------------------------------

RpgParser::Bif_xfootContext::Bif_xfootContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_xfootContext::BIF_XFOOT() {
  return getToken(RpgParser::BIF_XFOOT, 0);
}

tree::TerminalNode* RpgParser::Bif_xfootContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_xfootContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_xfootContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_xfootContext::getRuleIndex() const {
  return RpgParser::RuleBif_xfoot;
}

void RpgParser::Bif_xfootContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_xfoot(this);
}

void RpgParser::Bif_xfootContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_xfoot(this);
}


antlrcpp::Any RpgParser::Bif_xfootContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_xfoot(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_xfootContext* RpgParser::bif_xfoot() {
  Bif_xfootContext *_localctx = _tracker.createInstance<Bif_xfootContext>(_ctx, getState());
  enterRule(_localctx, 1100, RpgParser::RuleBif_xfoot);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5536);
    match(RpgParser::BIF_XFOOT);
    setState(5537);
    match(RpgParser::OPEN_PAREN);
    setState(5538);
    dynamic_cast<Bif_xfootContext *>(_localctx)->arrayexpression = expression(0);
    setState(5539);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_xlateContext ------------------------------------------------------------------

RpgParser::Bif_xlateContext::Bif_xlateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_xlateContext::BIF_XLATE() {
  return getToken(RpgParser::BIF_XLATE, 0);
}

tree::TerminalNode* RpgParser::Bif_xlateContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Bif_xlateContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::Bif_xlateContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}

tree::TerminalNode* RpgParser::Bif_xlateContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_xlateContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_xlateContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}


size_t RpgParser::Bif_xlateContext::getRuleIndex() const {
  return RpgParser::RuleBif_xlate;
}

void RpgParser::Bif_xlateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_xlate(this);
}

void RpgParser::Bif_xlateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_xlate(this);
}


antlrcpp::Any RpgParser::Bif_xlateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_xlate(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_xlateContext* RpgParser::bif_xlate() {
  Bif_xlateContext *_localctx = _tracker.createInstance<Bif_xlateContext>(_ctx, getState());
  enterRule(_localctx, 1102, RpgParser::RuleBif_xlate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5541);
    match(RpgParser::BIF_XLATE);
    setState(5542);
    match(RpgParser::OPEN_PAREN);
    setState(5543);
    dynamic_cast<Bif_xlateContext *>(_localctx)->from = expression(0);
    setState(5544);
    match(RpgParser::COLON);
    setState(5545);
    dynamic_cast<Bif_xlateContext *>(_localctx)->to = expression(0);
    setState(5546);
    match(RpgParser::COLON);
    setState(5547);
    dynamic_cast<Bif_xlateContext *>(_localctx)->string = expression(0);
    setState(5550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5548);
      match(RpgParser::COLON);
      setState(5549);
      dynamic_cast<Bif_xlateContext *>(_localctx)->startpos = expression(0);
    }
    setState(5552);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_xmlContext ------------------------------------------------------------------

RpgParser::Bif_xmlContext::Bif_xmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_xmlContext::BIF_XML() {
  return getToken(RpgParser::BIF_XML, 0);
}

tree::TerminalNode* RpgParser::Bif_xmlContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_xmlContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::Bif_xmlContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::Bif_xmlContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

tree::TerminalNode* RpgParser::Bif_xmlContext::COLON() {
  return getToken(RpgParser::COLON, 0);
}


size_t RpgParser::Bif_xmlContext::getRuleIndex() const {
  return RpgParser::RuleBif_xml;
}

void RpgParser::Bif_xmlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_xml(this);
}

void RpgParser::Bif_xmlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_xml(this);
}


antlrcpp::Any RpgParser::Bif_xmlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_xml(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_xmlContext* RpgParser::bif_xml() {
  Bif_xmlContext *_localctx = _tracker.createInstance<Bif_xmlContext>(_ctx, getState());
  enterRule(_localctx, 1104, RpgParser::RuleBif_xml);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5554);
    match(RpgParser::BIF_XML);
    setState(5555);
    match(RpgParser::OPEN_PAREN);
    setState(5556);
    dynamic_cast<Bif_xmlContext *>(_localctx)->xmldocument = expression(0);
    setState(5559);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::COLON) {
      setState(5557);
      match(RpgParser::COLON);
      setState(5558);
      dynamic_cast<Bif_xmlContext *>(_localctx)->options = expression(0);
    }
    setState(5561);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_yearsContext ------------------------------------------------------------------

RpgParser::Bif_yearsContext::Bif_yearsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_yearsContext::BIF_YEARS() {
  return getToken(RpgParser::BIF_YEARS, 0);
}

tree::TerminalNode* RpgParser::Bif_yearsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Bif_yearsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Bif_yearsContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Bif_yearsContext::getRuleIndex() const {
  return RpgParser::RuleBif_years;
}

void RpgParser::Bif_yearsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_years(this);
}

void RpgParser::Bif_yearsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_years(this);
}


antlrcpp::Any RpgParser::Bif_yearsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_years(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_yearsContext* RpgParser::bif_years() {
  Bif_yearsContext *_localctx = _tracker.createInstance<Bif_yearsContext>(_ctx, getState());
  enterRule(_localctx, 1106, RpgParser::RuleBif_years);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5563);
    match(RpgParser::BIF_YEARS);
    setState(5564);
    match(RpgParser::OPEN_PAREN);
    setState(5565);
    dynamic_cast<Bif_yearsContext *>(_localctx)->numberexpression = expression(0);
    setState(5566);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bif_codeContext ------------------------------------------------------------------

RpgParser::Bif_codeContext::Bif_codeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_ABS() {
  return getToken(RpgParser::BIF_ABS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_ADDR() {
  return getToken(RpgParser::BIF_ADDR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_ALLOC() {
  return getToken(RpgParser::BIF_ALLOC, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_BITAND() {
  return getToken(RpgParser::BIF_BITAND, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_BITNOT() {
  return getToken(RpgParser::BIF_BITNOT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_BITOR() {
  return getToken(RpgParser::BIF_BITOR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_BITXOR() {
  return getToken(RpgParser::BIF_BITXOR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_CHAR() {
  return getToken(RpgParser::BIF_CHAR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_CHECK() {
  return getToken(RpgParser::BIF_CHECK, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_CHECKR() {
  return getToken(RpgParser::BIF_CHECKR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DATE() {
  return getToken(RpgParser::BIF_DATE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DAYS() {
  return getToken(RpgParser::BIF_DAYS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DEC() {
  return getToken(RpgParser::BIF_DEC, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DECH() {
  return getToken(RpgParser::BIF_DECH, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DECPOS() {
  return getToken(RpgParser::BIF_DECPOS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DIFF() {
  return getToken(RpgParser::BIF_DIFF, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_DIV() {
  return getToken(RpgParser::BIF_DIV, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_EDITC() {
  return getToken(RpgParser::BIF_EDITC, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_EDITFLT() {
  return getToken(RpgParser::BIF_EDITFLT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_EDITW() {
  return getToken(RpgParser::BIF_EDITW, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_ELEM() {
  return getToken(RpgParser::BIF_ELEM, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_EOF() {
  return getToken(RpgParser::BIF_EOF, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_EQUAL() {
  return getToken(RpgParser::BIF_EQUAL, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_ERROR() {
  return getToken(RpgParser::BIF_ERROR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_FIELDS() {
  return getToken(RpgParser::BIF_FIELDS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_FLOAT() {
  return getToken(RpgParser::BIF_FLOAT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_FOUND() {
  return getToken(RpgParser::BIF_FOUND, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_GRAPH() {
  return getToken(RpgParser::BIF_GRAPH, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_HANDLER() {
  return getToken(RpgParser::BIF_HANDLER, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_HOURS() {
  return getToken(RpgParser::BIF_HOURS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_INT() {
  return getToken(RpgParser::BIF_INT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_INTH() {
  return getToken(RpgParser::BIF_INTH, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_KDS() {
  return getToken(RpgParser::BIF_KDS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_LEN() {
  return getToken(RpgParser::BIF_LEN, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_LOOKUP() {
  return getToken(RpgParser::BIF_LOOKUP, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_LOOKUPLT() {
  return getToken(RpgParser::BIF_LOOKUPLT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_LOOKUPLE() {
  return getToken(RpgParser::BIF_LOOKUPLE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_LOOKUPGT() {
  return getToken(RpgParser::BIF_LOOKUPGT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_LOOKUPGE() {
  return getToken(RpgParser::BIF_LOOKUPGE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_MINUTES() {
  return getToken(RpgParser::BIF_MINUTES, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_MONTHS() {
  return getToken(RpgParser::BIF_MONTHS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_MSECONDS() {
  return getToken(RpgParser::BIF_MSECONDS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_NULLIND() {
  return getToken(RpgParser::BIF_NULLIND, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_OCCUR() {
  return getToken(RpgParser::BIF_OCCUR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_OPEN() {
  return getToken(RpgParser::BIF_OPEN, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_PADDR() {
  return getToken(RpgParser::BIF_PADDR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_PARMS() {
  return getToken(RpgParser::BIF_PARMS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_PARMNUM() {
  return getToken(RpgParser::BIF_PARMNUM, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_REALLOC() {
  return getToken(RpgParser::BIF_REALLOC, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_REM() {
  return getToken(RpgParser::BIF_REM, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_REPLACE() {
  return getToken(RpgParser::BIF_REPLACE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SCAN() {
  return getToken(RpgParser::BIF_SCAN, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SCANRPL() {
  return getToken(RpgParser::BIF_SCANRPL, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SECONDS() {
  return getToken(RpgParser::BIF_SECONDS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SHTDN() {
  return getToken(RpgParser::BIF_SHTDN, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SIZE() {
  return getToken(RpgParser::BIF_SIZE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SQRT() {
  return getToken(RpgParser::BIF_SQRT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_STATUS() {
  return getToken(RpgParser::BIF_STATUS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_STR() {
  return getToken(RpgParser::BIF_STR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SUBARR() {
  return getToken(RpgParser::BIF_SUBARR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SUBDT() {
  return getToken(RpgParser::BIF_SUBDT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_SUBST() {
  return getToken(RpgParser::BIF_SUBST, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_THIS() {
  return getToken(RpgParser::BIF_THIS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TIME() {
  return getToken(RpgParser::BIF_TIME, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TIMESTAMP() {
  return getToken(RpgParser::BIF_TIMESTAMP, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TLOOKUP() {
  return getToken(RpgParser::BIF_TLOOKUP, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TLOOKUPLT() {
  return getToken(RpgParser::BIF_TLOOKUPLT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TLOOKUPLE() {
  return getToken(RpgParser::BIF_TLOOKUPLE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TLOOKUPGT() {
  return getToken(RpgParser::BIF_TLOOKUPGT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TLOOKUPGE() {
  return getToken(RpgParser::BIF_TLOOKUPGE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TRIM() {
  return getToken(RpgParser::BIF_TRIM, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TRIML() {
  return getToken(RpgParser::BIF_TRIML, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_TRIMR() {
  return getToken(RpgParser::BIF_TRIMR, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_UCS2() {
  return getToken(RpgParser::BIF_UCS2, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_UNS() {
  return getToken(RpgParser::BIF_UNS, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_UNSH() {
  return getToken(RpgParser::BIF_UNSH, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_XFOOT() {
  return getToken(RpgParser::BIF_XFOOT, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_XLATE() {
  return getToken(RpgParser::BIF_XLATE, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_XML() {
  return getToken(RpgParser::BIF_XML, 0);
}

tree::TerminalNode* RpgParser::Bif_codeContext::BIF_YEARS() {
  return getToken(RpgParser::BIF_YEARS, 0);
}


size_t RpgParser::Bif_codeContext::getRuleIndex() const {
  return RpgParser::RuleBif_code;
}

void RpgParser::Bif_codeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBif_code(this);
}

void RpgParser::Bif_codeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBif_code(this);
}


antlrcpp::Any RpgParser::Bif_codeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBif_code(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Bif_codeContext* RpgParser::bif_code() {
  Bif_codeContext *_localctx = _tracker.createInstance<Bif_codeContext>(_ctx, getState());
  enterRule(_localctx, 1108, RpgParser::RuleBif_code);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5568);
    _la = _input->LA(1);
    if (!(((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & ((1ULL << (RpgParser::BIF_ABS - 132))
      | (1ULL << (RpgParser::BIF_ADDR - 132))
      | (1ULL << (RpgParser::BIF_ALLOC - 132))
      | (1ULL << (RpgParser::BIF_BITAND - 132))
      | (1ULL << (RpgParser::BIF_BITNOT - 132))
      | (1ULL << (RpgParser::BIF_BITOR - 132))
      | (1ULL << (RpgParser::BIF_BITXOR - 132))
      | (1ULL << (RpgParser::BIF_CHAR - 132))
      | (1ULL << (RpgParser::BIF_CHECK - 132))
      | (1ULL << (RpgParser::BIF_CHECKR - 132))
      | (1ULL << (RpgParser::BIF_DATE - 132))
      | (1ULL << (RpgParser::BIF_DAYS - 132))
      | (1ULL << (RpgParser::BIF_DEC - 132))
      | (1ULL << (RpgParser::BIF_DECH - 132))
      | (1ULL << (RpgParser::BIF_DECPOS - 132))
      | (1ULL << (RpgParser::BIF_DIFF - 132))
      | (1ULL << (RpgParser::BIF_DIV - 132))
      | (1ULL << (RpgParser::BIF_EDITC - 132))
      | (1ULL << (RpgParser::BIF_EDITFLT - 132))
      | (1ULL << (RpgParser::BIF_EDITW - 132))
      | (1ULL << (RpgParser::BIF_ELEM - 132))
      | (1ULL << (RpgParser::BIF_EOF - 132))
      | (1ULL << (RpgParser::BIF_EQUAL - 132))
      | (1ULL << (RpgParser::BIF_ERROR - 132))
      | (1ULL << (RpgParser::BIF_FIELDS - 132))
      | (1ULL << (RpgParser::BIF_FLOAT - 132))
      | (1ULL << (RpgParser::BIF_FOUND - 132))
      | (1ULL << (RpgParser::BIF_GRAPH - 132))
      | (1ULL << (RpgParser::BIF_HANDLER - 132))
      | (1ULL << (RpgParser::BIF_HOURS - 132))
      | (1ULL << (RpgParser::BIF_INT - 132))
      | (1ULL << (RpgParser::BIF_INTH - 132))
      | (1ULL << (RpgParser::BIF_KDS - 132))
      | (1ULL << (RpgParser::BIF_LEN - 132))
      | (1ULL << (RpgParser::BIF_LOOKUP - 132))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 132))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 132))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 132))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 132))
      | (1ULL << (RpgParser::BIF_MINUTES - 132))
      | (1ULL << (RpgParser::BIF_MONTHS - 132))
      | (1ULL << (RpgParser::BIF_MSECONDS - 132))
      | (1ULL << (RpgParser::BIF_NULLIND - 132))
      | (1ULL << (RpgParser::BIF_OCCUR - 132))
      | (1ULL << (RpgParser::BIF_OPEN - 132))
      | (1ULL << (RpgParser::BIF_PADDR - 132))
      | (1ULL << (RpgParser::BIF_PARMS - 132))
      | (1ULL << (RpgParser::BIF_PARMNUM - 132))
      | (1ULL << (RpgParser::BIF_REALLOC - 132))
      | (1ULL << (RpgParser::BIF_REM - 132))
      | (1ULL << (RpgParser::BIF_REPLACE - 132))
      | (1ULL << (RpgParser::BIF_SCAN - 132))
      | (1ULL << (RpgParser::BIF_SCANRPL - 132))
      | (1ULL << (RpgParser::BIF_SECONDS - 132))
      | (1ULL << (RpgParser::BIF_SHTDN - 132))
      | (1ULL << (RpgParser::BIF_SIZE - 132))
      | (1ULL << (RpgParser::BIF_SQRT - 132))
      | (1ULL << (RpgParser::BIF_STATUS - 132))
      | (1ULL << (RpgParser::BIF_STR - 132))
      | (1ULL << (RpgParser::BIF_SUBARR - 132))
      | (1ULL << (RpgParser::BIF_SUBDT - 132))
      | (1ULL << (RpgParser::BIF_SUBST - 132))
      | (1ULL << (RpgParser::BIF_THIS - 132))
      | (1ULL << (RpgParser::BIF_TIME - 132)))) != 0) || ((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & ((1ULL << (RpgParser::BIF_TIMESTAMP - 196))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 196))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 196))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 196))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 196))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 196))
      | (1ULL << (RpgParser::BIF_TRIM - 196))
      | (1ULL << (RpgParser::BIF_TRIML - 196))
      | (1ULL << (RpgParser::BIF_TRIMR - 196))
      | (1ULL << (RpgParser::BIF_UCS2 - 196))
      | (1ULL << (RpgParser::BIF_UNS - 196))
      | (1ULL << (RpgParser::BIF_UNSH - 196))
      | (1ULL << (RpgParser::BIF_XFOOT - 196))
      | (1ULL << (RpgParser::BIF_XLATE - 196))
      | (1ULL << (RpgParser::BIF_XML - 196))
      | (1ULL << (RpgParser::BIF_YEARS - 196)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FreeContext ------------------------------------------------------------------

RpgParser::FreeContext::FreeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Exec_sqlContext* RpgParser::FreeContext::exec_sql() {
  return getRuleContext<RpgParser::Exec_sqlContext>(0);
}

RpgParser::BaseExpressionContext* RpgParser::FreeContext::baseExpression() {
  return getRuleContext<RpgParser::BaseExpressionContext>(0);
}

tree::TerminalNode* RpgParser::FreeContext::FREE_SEMI() {
  return getToken(RpgParser::FREE_SEMI, 0);
}

RpgParser::Free_linecommentsContext* RpgParser::FreeContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::FreeContext::getRuleIndex() const {
  return RpgParser::RuleFree;
}

void RpgParser::FreeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFree(this);
}

void RpgParser::FreeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFree(this);
}


antlrcpp::Any RpgParser::FreeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFree(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FreeContext* RpgParser::free() {
  FreeContext *_localctx = _tracker.createInstance<FreeContext>(_ctx, getState());
  enterRule(_localctx, 1110, RpgParser::RuleFree);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5576);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OPEN_PAREN:
      case RpgParser::NUMBER:
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::BIF_ABS:
      case RpgParser::BIF_ADDR:
      case RpgParser::BIF_ALLOC:
      case RpgParser::BIF_BITAND:
      case RpgParser::BIF_BITNOT:
      case RpgParser::BIF_BITOR:
      case RpgParser::BIF_BITXOR:
      case RpgParser::BIF_CHAR:
      case RpgParser::BIF_CHECK:
      case RpgParser::BIF_CHECKR:
      case RpgParser::BIF_DATE:
      case RpgParser::BIF_DAYS:
      case RpgParser::BIF_DEC:
      case RpgParser::BIF_DECH:
      case RpgParser::BIF_DECPOS:
      case RpgParser::BIF_DIFF:
      case RpgParser::BIF_DIV:
      case RpgParser::BIF_EDITC:
      case RpgParser::BIF_EDITFLT:
      case RpgParser::BIF_EDITW:
      case RpgParser::BIF_ELEM:
      case RpgParser::BIF_EOF:
      case RpgParser::BIF_EQUAL:
      case RpgParser::BIF_ERROR:
      case RpgParser::BIF_FIELDS:
      case RpgParser::BIF_FLOAT:
      case RpgParser::BIF_FOUND:
      case RpgParser::BIF_GRAPH:
      case RpgParser::BIF_HANDLER:
      case RpgParser::BIF_HOURS:
      case RpgParser::BIF_INT:
      case RpgParser::BIF_INTH:
      case RpgParser::BIF_KDS:
      case RpgParser::BIF_LEN:
      case RpgParser::BIF_LOOKUP:
      case RpgParser::BIF_LOOKUPLT:
      case RpgParser::BIF_LOOKUPLE:
      case RpgParser::BIF_LOOKUPGT:
      case RpgParser::BIF_LOOKUPGE:
      case RpgParser::BIF_MINUTES:
      case RpgParser::BIF_MONTHS:
      case RpgParser::BIF_MSECONDS:
      case RpgParser::BIF_NULLIND:
      case RpgParser::BIF_OCCUR:
      case RpgParser::BIF_OPEN:
      case RpgParser::BIF_PADDR:
      case RpgParser::BIF_PARMS:
      case RpgParser::BIF_PARMNUM:
      case RpgParser::BIF_REALLOC:
      case RpgParser::BIF_REM:
      case RpgParser::BIF_REPLACE:
      case RpgParser::BIF_SCAN:
      case RpgParser::BIF_SCANRPL:
      case RpgParser::BIF_SECONDS:
      case RpgParser::BIF_SHTDN:
      case RpgParser::BIF_SIZE:
      case RpgParser::BIF_SQRT:
      case RpgParser::BIF_STATUS:
      case RpgParser::BIF_STR:
      case RpgParser::BIF_SUBARR:
      case RpgParser::BIF_SUBDT:
      case RpgParser::BIF_SUBST:
      case RpgParser::BIF_THIS:
      case RpgParser::BIF_TIME:
      case RpgParser::BIF_TIMESTAMP:
      case RpgParser::BIF_TLOOKUP:
      case RpgParser::BIF_TLOOKUPLT:
      case RpgParser::BIF_TLOOKUPLE:
      case RpgParser::BIF_TLOOKUPGT:
      case RpgParser::BIF_TLOOKUPGE:
      case RpgParser::BIF_TRIM:
      case RpgParser::BIF_TRIML:
      case RpgParser::BIF_TRIMR:
      case RpgParser::BIF_UCS2:
      case RpgParser::BIF_UNS:
      case RpgParser::BIF_UNSH:
      case RpgParser::BIF_XFOOT:
      case RpgParser::BIF_XLATE:
      case RpgParser::BIF_XML:
      case RpgParser::BIF_YEARS:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::PLUS:
      case RpgParser::MINUS:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO:
      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        setState(5570);
        baseExpression();
        setState(5571);
        match(RpgParser::FREE_SEMI);
        setState(5573);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 489, _ctx)) {
        case 1: {
          setState(5572);
          free_linecomments();
          break;
        }

        }
        break;
      }

      case RpgParser::EXEC_SQL: {
        setState(5575);
        exec_sql();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- C_freeContext ------------------------------------------------------------------

RpgParser::C_freeContext::C_freeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Exec_sqlContext* RpgParser::C_freeContext::exec_sql() {
  return getRuleContext<RpgParser::Exec_sqlContext>(0);
}

RpgParser::ExpressionContext* RpgParser::C_freeContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::Free_linecommentsContext* RpgParser::C_freeContext::free_linecomments() {
  return getRuleContext<RpgParser::Free_linecommentsContext>(0);
}


size_t RpgParser::C_freeContext::getRuleIndex() const {
  return RpgParser::RuleC_free;
}

void RpgParser::C_freeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterC_free(this);
}

void RpgParser::C_freeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitC_free(this);
}


antlrcpp::Any RpgParser::C_freeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitC_free(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::C_freeContext* RpgParser::c_free() {
  C_freeContext *_localctx = _tracker.createInstance<C_freeContext>(_ctx, getState());
  enterRule(_localctx, 1112, RpgParser::RuleC_free);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5583);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OPEN_PAREN:
      case RpgParser::NUMBER:
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::BIF_ABS:
      case RpgParser::BIF_ADDR:
      case RpgParser::BIF_ALLOC:
      case RpgParser::BIF_BITAND:
      case RpgParser::BIF_BITNOT:
      case RpgParser::BIF_BITOR:
      case RpgParser::BIF_BITXOR:
      case RpgParser::BIF_CHAR:
      case RpgParser::BIF_CHECK:
      case RpgParser::BIF_CHECKR:
      case RpgParser::BIF_DATE:
      case RpgParser::BIF_DAYS:
      case RpgParser::BIF_DEC:
      case RpgParser::BIF_DECH:
      case RpgParser::BIF_DECPOS:
      case RpgParser::BIF_DIFF:
      case RpgParser::BIF_DIV:
      case RpgParser::BIF_EDITC:
      case RpgParser::BIF_EDITFLT:
      case RpgParser::BIF_EDITW:
      case RpgParser::BIF_ELEM:
      case RpgParser::BIF_EOF:
      case RpgParser::BIF_EQUAL:
      case RpgParser::BIF_ERROR:
      case RpgParser::BIF_FIELDS:
      case RpgParser::BIF_FLOAT:
      case RpgParser::BIF_FOUND:
      case RpgParser::BIF_GRAPH:
      case RpgParser::BIF_HANDLER:
      case RpgParser::BIF_HOURS:
      case RpgParser::BIF_INT:
      case RpgParser::BIF_INTH:
      case RpgParser::BIF_KDS:
      case RpgParser::BIF_LEN:
      case RpgParser::BIF_LOOKUP:
      case RpgParser::BIF_LOOKUPLT:
      case RpgParser::BIF_LOOKUPLE:
      case RpgParser::BIF_LOOKUPGT:
      case RpgParser::BIF_LOOKUPGE:
      case RpgParser::BIF_MINUTES:
      case RpgParser::BIF_MONTHS:
      case RpgParser::BIF_MSECONDS:
      case RpgParser::BIF_NULLIND:
      case RpgParser::BIF_OCCUR:
      case RpgParser::BIF_OPEN:
      case RpgParser::BIF_PADDR:
      case RpgParser::BIF_PARMS:
      case RpgParser::BIF_PARMNUM:
      case RpgParser::BIF_REALLOC:
      case RpgParser::BIF_REM:
      case RpgParser::BIF_REPLACE:
      case RpgParser::BIF_SCAN:
      case RpgParser::BIF_SCANRPL:
      case RpgParser::BIF_SECONDS:
      case RpgParser::BIF_SHTDN:
      case RpgParser::BIF_SIZE:
      case RpgParser::BIF_SQRT:
      case RpgParser::BIF_STATUS:
      case RpgParser::BIF_STR:
      case RpgParser::BIF_SUBARR:
      case RpgParser::BIF_SUBDT:
      case RpgParser::BIF_SUBST:
      case RpgParser::BIF_THIS:
      case RpgParser::BIF_TIME:
      case RpgParser::BIF_TIMESTAMP:
      case RpgParser::BIF_TLOOKUP:
      case RpgParser::BIF_TLOOKUPLT:
      case RpgParser::BIF_TLOOKUPLE:
      case RpgParser::BIF_TLOOKUPGT:
      case RpgParser::BIF_TLOOKUPGE:
      case RpgParser::BIF_TRIM:
      case RpgParser::BIF_TRIML:
      case RpgParser::BIF_TRIMR:
      case RpgParser::BIF_UCS2:
      case RpgParser::BIF_UNS:
      case RpgParser::BIF_UNSH:
      case RpgParser::BIF_XFOOT:
      case RpgParser::BIF_XLATE:
      case RpgParser::BIF_XML:
      case RpgParser::BIF_YEARS:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::PLUS:
      case RpgParser::MINUS:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO:
      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        setState(5578);
        expression(0);
        setState(5580);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == RpgParser::COMMENTS) {
          setState(5579);
          free_linecomments();
        }
        break;
      }

      case RpgParser::EXEC_SQL: {
        setState(5582);
        exec_sql();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ControlContext ------------------------------------------------------------------

RpgParser::ControlContext::ControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::OpCodeContext* RpgParser::ControlContext::opCode() {
  return getRuleContext<RpgParser::OpCodeContext>(0);
}

RpgParser::Indicator_exprContext* RpgParser::ControlContext::indicator_expr() {
  return getRuleContext<RpgParser::Indicator_exprContext>(0);
}


size_t RpgParser::ControlContext::getRuleIndex() const {
  return RpgParser::RuleControl;
}

void RpgParser::ControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterControl(this);
}

void RpgParser::ControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitControl(this);
}


antlrcpp::Any RpgParser::ControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitControl(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ControlContext* RpgParser::control() {
  ControlContext *_localctx = _tracker.createInstance<ControlContext>(_ctx, getState());
  enterRule(_localctx, 1114, RpgParser::RuleControl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5585);
    opCode();
    setState(5586);
    indicator_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exec_sqlContext ------------------------------------------------------------------

RpgParser::Exec_sqlContext::Exec_sqlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::Exec_sqlContext::EXEC_SQL() {
  return getToken(RpgParser::EXEC_SQL, 0);
}

tree::TerminalNode* RpgParser::Exec_sqlContext::SEMI() {
  return getToken(RpgParser::SEMI, 0);
}

std::vector<tree::TerminalNode *> RpgParser::Exec_sqlContext::WORDS() {
  return getTokens(RpgParser::WORDS);
}

tree::TerminalNode* RpgParser::Exec_sqlContext::WORDS(size_t i) {
  return getToken(RpgParser::WORDS, i);
}


size_t RpgParser::Exec_sqlContext::getRuleIndex() const {
  return RpgParser::RuleExec_sql;
}

void RpgParser::Exec_sqlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExec_sql(this);
}

void RpgParser::Exec_sqlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExec_sql(this);
}


antlrcpp::Any RpgParser::Exec_sqlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitExec_sql(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Exec_sqlContext* RpgParser::exec_sql() {
  Exec_sqlContext *_localctx = _tracker.createInstance<Exec_sqlContext>(_ctx, getState());
  enterRule(_localctx, 1116, RpgParser::RuleExec_sql);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5588);
    match(RpgParser::EXEC_SQL);
    setState(5590); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(5589);
      match(RpgParser::WORDS);
      setState(5592); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == RpgParser::WORDS);
    setState(5594);
    match(RpgParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseExpressionContext ------------------------------------------------------------------

RpgParser::BaseExpressionContext::BaseExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::OpContext* RpgParser::BaseExpressionContext::op() {
  return getRuleContext<RpgParser::OpContext>(0);
}

RpgParser::ExpressionContext* RpgParser::BaseExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::BaseExpressionContext::getRuleIndex() const {
  return RpgParser::RuleBaseExpression;
}

void RpgParser::BaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseExpression(this);
}

void RpgParser::BaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseExpression(this);
}


antlrcpp::Any RpgParser::BaseExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitBaseExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::BaseExpressionContext* RpgParser::baseExpression() {
  BaseExpressionContext *_localctx = _tracker.createInstance<BaseExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1118, RpgParser::RuleBaseExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5598);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 494, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5596);
      op();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5597);
      expression(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndicatorContext ------------------------------------------------------------------

RpgParser::IndicatorContext::IndicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::IndicatorContext::SPLAT_IN() {
  return getToken(RpgParser::SPLAT_IN, 0);
}

tree::TerminalNode* RpgParser::IndicatorContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::BaseExpressionContext* RpgParser::IndicatorContext::baseExpression() {
  return getRuleContext<RpgParser::BaseExpressionContext>(0);
}

tree::TerminalNode* RpgParser::IndicatorContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::IndicatorContext::getRuleIndex() const {
  return RpgParser::RuleIndicator;
}

void RpgParser::IndicatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndicator(this);
}

void RpgParser::IndicatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndicator(this);
}


antlrcpp::Any RpgParser::IndicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIndicator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::IndicatorContext* RpgParser::indicator() {
  IndicatorContext *_localctx = _tracker.createInstance<IndicatorContext>(_ctx, getState());
  enterRule(_localctx, 1120, RpgParser::RuleIndicator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5600);
    match(RpgParser::SPLAT_IN);
    setState(5601);
    match(RpgParser::OPEN_PAREN);
    setState(5602);
    baseExpression();
    setState(5603);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentExpressionContext ------------------------------------------------------------------

RpgParser::AssignmentExpressionContext::AssignmentExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SimpleExpressionContext* RpgParser::AssignmentExpressionContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

tree::TerminalNode* RpgParser::AssignmentExpressionContext::EQUAL() {
  return getToken(RpgParser::EQUAL, 0);
}

RpgParser::ExpressionContext* RpgParser::AssignmentExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::AssignmentExpressionContext::getRuleIndex() const {
  return RpgParser::RuleAssignmentExpression;
}

void RpgParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}

void RpgParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}


antlrcpp::Any RpgParser::AssignmentExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::AssignmentExpressionContext* RpgParser::assignmentExpression() {
  AssignmentExpressionContext *_localctx = _tracker.createInstance<AssignmentExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1122, RpgParser::RuleAssignmentExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5605);
    simpleExpression();
    setState(5606);
    match(RpgParser::EQUAL);
    setState(5607);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignOperatorExpressionContext ------------------------------------------------------------------

RpgParser::AssignOperatorExpressionContext::AssignOperatorExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SimpleExpressionContext* RpgParser::AssignOperatorExpressionContext::simpleExpression() {
  return getRuleContext<RpgParser::SimpleExpressionContext>(0);
}

RpgParser::AssignmentOperatorContext* RpgParser::AssignOperatorExpressionContext::assignmentOperator() {
  return getRuleContext<RpgParser::AssignmentOperatorContext>(0);
}

RpgParser::ExpressionContext* RpgParser::AssignOperatorExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::AssignOperatorExpressionContext::getRuleIndex() const {
  return RpgParser::RuleAssignOperatorExpression;
}

void RpgParser::AssignOperatorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignOperatorExpression(this);
}

void RpgParser::AssignOperatorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignOperatorExpression(this);
}


antlrcpp::Any RpgParser::AssignOperatorExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitAssignOperatorExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::AssignOperatorExpressionContext* RpgParser::assignOperatorExpression() {
  AssignOperatorExpressionContext *_localctx = _tracker.createInstance<AssignOperatorExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1124, RpgParser::RuleAssignOperatorExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5609);
    simpleExpression();
    setState(5610);
    assignmentOperator();
    setState(5611);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EvalExpressionContext ------------------------------------------------------------------

RpgParser::EvalExpressionContext::EvalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::AssignmentExpressionContext* RpgParser::EvalExpressionContext::assignmentExpression() {
  return getRuleContext<RpgParser::AssignmentExpressionContext>(0);
}

RpgParser::AssignOperatorExpressionContext* RpgParser::EvalExpressionContext::assignOperatorExpression() {
  return getRuleContext<RpgParser::AssignOperatorExpressionContext>(0);
}


size_t RpgParser::EvalExpressionContext::getRuleIndex() const {
  return RpgParser::RuleEvalExpression;
}

void RpgParser::EvalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEvalExpression(this);
}

void RpgParser::EvalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEvalExpression(this);
}


antlrcpp::Any RpgParser::EvalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitEvalExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::EvalExpressionContext* RpgParser::evalExpression() {
  EvalExpressionContext *_localctx = _tracker.createInstance<EvalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1126, RpgParser::RuleEvalExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5615);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5613);
      assignmentExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5614);
      assignOperatorExpression();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleExpressionContext ------------------------------------------------------------------

RpgParser::SimpleExpressionContext::SimpleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::FunctionContext* RpgParser::SimpleExpressionContext::function() {
  return getRuleContext<RpgParser::FunctionContext>(0);
}

RpgParser::BifContext* RpgParser::SimpleExpressionContext::bif() {
  return getRuleContext<RpgParser::BifContext>(0);
}

RpgParser::IdentifierContext* RpgParser::SimpleExpressionContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::NumberContext* RpgParser::SimpleExpressionContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

RpgParser::LiteralContext* RpgParser::SimpleExpressionContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

tree::TerminalNode* RpgParser::SimpleExpressionContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::SimpleExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::SimpleExpressionContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::SimpleExpressionContext::getRuleIndex() const {
  return RpgParser::RuleSimpleExpression;
}

void RpgParser::SimpleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExpression(this);
}

void RpgParser::SimpleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExpression(this);
}


antlrcpp::Any RpgParser::SimpleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSimpleExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::SimpleExpressionContext* RpgParser::simpleExpression() {
  SimpleExpressionContext *_localctx = _tracker.createInstance<SimpleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1128, RpgParser::RuleSimpleExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5626);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 496, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5617);
      function();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5618);
      bif();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5619);
      identifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5620);
      number();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5621);
      literal();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5622);
      match(RpgParser::OPEN_PAREN);
      setState(5623);
      expression(0);
      setState(5624);
      match(RpgParser::CLOSE_PAREN);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryExpressionContext ------------------------------------------------------------------

RpgParser::UnaryExpressionContext::UnaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SignContext* RpgParser::UnaryExpressionContext::sign() {
  return getRuleContext<RpgParser::SignContext>(0);
}

RpgParser::ExpressionContext* RpgParser::UnaryExpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::UnaryExpressionContext::getRuleIndex() const {
  return RpgParser::RuleUnaryExpression;
}

void RpgParser::UnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryExpression(this);
}

void RpgParser::UnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryExpression(this);
}


antlrcpp::Any RpgParser::UnaryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitUnaryExpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::UnaryExpressionContext* RpgParser::unaryExpression() {
  UnaryExpressionContext *_localctx = _tracker.createInstance<UnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1130, RpgParser::RuleUnaryExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5628);
    sign();
    setState(5629);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

RpgParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ExpressionContext::NOT() {
  return getToken(RpgParser::NOT, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::ExpressionContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

RpgParser::NumberContext* RpgParser::ExpressionContext::number() {
  return getRuleContext<RpgParser::NumberContext>(0);
}

RpgParser::PexpressionContext* RpgParser::ExpressionContext::pexpression() {
  return getRuleContext<RpgParser::PexpressionContext>(0);
}

RpgParser::UnaryExpressionContext* RpgParser::ExpressionContext::unaryExpression() {
  return getRuleContext<RpgParser::UnaryExpressionContext>(0);
}

RpgParser::IndicatorContext* RpgParser::ExpressionContext::indicator() {
  return getRuleContext<RpgParser::IndicatorContext>(0);
}

RpgParser::FunctionContext* RpgParser::ExpressionContext::function() {
  return getRuleContext<RpgParser::FunctionContext>(0);
}

RpgParser::IdentifierContext* RpgParser::ExpressionContext::identifier() {
  return getRuleContext<RpgParser::IdentifierContext>(0);
}

RpgParser::LiteralContext* RpgParser::ExpressionContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}

RpgParser::BifContext* RpgParser::ExpressionContext::bif() {
  return getRuleContext<RpgParser::BifContext>(0);
}

tree::TerminalNode* RpgParser::ExpressionContext::EXP() {
  return getToken(RpgParser::EXP, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::MULT() {
  return getToken(RpgParser::MULT, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::MULT_NOSPACE() {
  return getToken(RpgParser::MULT_NOSPACE, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::DIV() {
  return getToken(RpgParser::DIV, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::PLUS() {
  return getToken(RpgParser::PLUS, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::MINUS() {
  return getToken(RpgParser::MINUS, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::EQUAL() {
  return getToken(RpgParser::EQUAL, 0);
}

RpgParser::AssignmentOperatorContext* RpgParser::ExpressionContext::assignmentOperator() {
  return getRuleContext<RpgParser::AssignmentOperatorContext>(0);
}

RpgParser::ComparisonOperatorContext* RpgParser::ExpressionContext::comparisonOperator() {
  return getRuleContext<RpgParser::ComparisonOperatorContext>(0);
}

tree::TerminalNode* RpgParser::ExpressionContext::AND() {
  return getToken(RpgParser::AND, 0);
}

tree::TerminalNode* RpgParser::ExpressionContext::OR() {
  return getToken(RpgParser::OR, 0);
}


size_t RpgParser::ExpressionContext::getRuleIndex() const {
  return RpgParser::RuleExpression;
}

void RpgParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void RpgParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


antlrcpp::Any RpgParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


RpgParser::ExpressionContext* RpgParser::expression() {
   return expression(0);
}

RpgParser::ExpressionContext* RpgParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  RpgParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  RpgParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1132;
  enterRecursionRule(_localctx, 1132, RpgParser::RuleExpression, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5642);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 497, _ctx)) {
    case 1: {
      setState(5632);
      match(RpgParser::NOT);
      setState(5633);
      expression(18);
      break;
    }

    case 2: {
      setState(5634);
      number();
      break;
    }

    case 3: {
      setState(5635);
      pexpression();
      break;
    }

    case 4: {
      setState(5636);
      unaryExpression();
      break;
    }

    case 5: {
      setState(5637);
      indicator();
      break;
    }

    case 6: {
      setState(5638);
      function();
      break;
    }

    case 7: {
      setState(5639);
      identifier();
      break;
    }

    case 8: {
      setState(5640);
      literal();
      break;
    }

    case 9: {
      setState(5641);
      bif();
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5677);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5675);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5644);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(5645);
          match(RpgParser::EXP);
          setState(5646);
          expression(15);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5647);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(5648);
          _la = _input->LA(1);
          if (!(_la == RpgParser::MULT_NOSPACE

          || _la == RpgParser::MULT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5649);
          expression(15);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5650);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(5651);
          match(RpgParser::DIV);
          setState(5652);
          expression(14);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5653);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(5654);
          match(RpgParser::PLUS);
          setState(5655);
          expression(13);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5656);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(5657);
          match(RpgParser::MINUS);
          setState(5658);
          expression(12);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5659);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(5660);
          match(RpgParser::EQUAL);
          setState(5661);
          expression(11);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5662);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(5666);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case RpgParser::CPLUS:
            case RpgParser::CMINUS:
            case RpgParser::CMULT:
            case RpgParser::CDIV:
            case RpgParser::CEXP: {
              setState(5663);
              assignmentOperator();
              break;
            }

            case RpgParser::GT:
            case RpgParser::LT:
            case RpgParser::GE:
            case RpgParser::LE:
            case RpgParser::NE: {
              setState(5664);
              comparisonOperator();
              break;
            }

            case RpgParser::EQUAL: {
              setState(5665);
              match(RpgParser::EQUAL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(5668);
          expression(10);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5669);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(5670);
          match(RpgParser::AND);
          setState(5671);
          expression(9);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(5672);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(5673);
          match(RpgParser::OR);
          setState(5674);
          expression(8);
          break;
        }

        } 
      }
      setState(5679);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PexpressionContext ------------------------------------------------------------------

RpgParser::PexpressionContext::PexpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::PexpressionContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::PexpressionContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::PexpressionContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}


size_t RpgParser::PexpressionContext::getRuleIndex() const {
  return RpgParser::RulePexpression;
}

void RpgParser::PexpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPexpression(this);
}

void RpgParser::PexpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPexpression(this);
}


antlrcpp::Any RpgParser::PexpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitPexpression(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::PexpressionContext* RpgParser::pexpression() {
  PexpressionContext *_localctx = _tracker.createInstance<PexpressionContext>(_ctx, getState());
  enterRule(_localctx, 1134, RpgParser::RulePexpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5680);
    match(RpgParser::OPEN_PAREN);
    setState(5681);
    expression(0);
    setState(5682);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indicator_exprContext ------------------------------------------------------------------

RpgParser::Indicator_exprContext::Indicator_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ExpressionContext* RpgParser::Indicator_exprContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}


size_t RpgParser::Indicator_exprContext::getRuleIndex() const {
  return RpgParser::RuleIndicator_expr;
}

void RpgParser::Indicator_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndicator_expr(this);
}

void RpgParser::Indicator_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndicator_expr(this);
}


antlrcpp::Any RpgParser::Indicator_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIndicator_expr(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Indicator_exprContext* RpgParser::indicator_expr() {
  Indicator_exprContext *_localctx = _tracker.createInstance<Indicator_exprContext>(_ctx, getState());
  enterRule(_localctx, 1136, RpgParser::RuleIndicator_expr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5684);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionContext ------------------------------------------------------------------

RpgParser::FunctionContext::FunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::FunctionNameContext* RpgParser::FunctionContext::functionName() {
  return getRuleContext<RpgParser::FunctionNameContext>(0);
}

RpgParser::ArgsContext* RpgParser::FunctionContext::args() {
  return getRuleContext<RpgParser::ArgsContext>(0);
}


size_t RpgParser::FunctionContext::getRuleIndex() const {
  return RpgParser::RuleFunction;
}

void RpgParser::FunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction(this);
}

void RpgParser::FunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction(this);
}


antlrcpp::Any RpgParser::FunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFunction(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FunctionContext* RpgParser::function() {
  FunctionContext *_localctx = _tracker.createInstance<FunctionContext>(_ctx, getState());
  enterRule(_localctx, 1138, RpgParser::RuleFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5686);
    functionName();
    setState(5687);
    args();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

RpgParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ComparisonOperatorContext::GT() {
  return getToken(RpgParser::GT, 0);
}

tree::TerminalNode* RpgParser::ComparisonOperatorContext::LT() {
  return getToken(RpgParser::LT, 0);
}

tree::TerminalNode* RpgParser::ComparisonOperatorContext::GE() {
  return getToken(RpgParser::GE, 0);
}

tree::TerminalNode* RpgParser::ComparisonOperatorContext::LE() {
  return getToken(RpgParser::LE, 0);
}

tree::TerminalNode* RpgParser::ComparisonOperatorContext::NE() {
  return getToken(RpgParser::NE, 0);
}


size_t RpgParser::ComparisonOperatorContext::getRuleIndex() const {
  return RpgParser::RuleComparisonOperator;
}

void RpgParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void RpgParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}


antlrcpp::Any RpgParser::ComparisonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitComparisonOperator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ComparisonOperatorContext* RpgParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 1140, RpgParser::RuleComparisonOperator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5689);
    _la = _input->LA(1);
    if (!(((((_la - 439) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 439)) & ((1ULL << (RpgParser::GT - 439))
      | (1ULL << (RpgParser::LT - 439))
      | (1ULL << (RpgParser::GE - 439))
      | (1ULL << (RpgParser::LE - 439))
      | (1ULL << (RpgParser::NE - 439)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

RpgParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::AssignmentOperatorContext::CPLUS() {
  return getToken(RpgParser::CPLUS, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorContext::CMINUS() {
  return getToken(RpgParser::CMINUS, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorContext::CMULT() {
  return getToken(RpgParser::CMULT, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorContext::CDIV() {
  return getToken(RpgParser::CDIV, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorContext::CEXP() {
  return getToken(RpgParser::CEXP, 0);
}


size_t RpgParser::AssignmentOperatorContext::getRuleIndex() const {
  return RpgParser::RuleAssignmentOperator;
}

void RpgParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void RpgParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}


antlrcpp::Any RpgParser::AssignmentOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentOperator(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::AssignmentOperatorContext* RpgParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 1142, RpgParser::RuleAssignmentOperator);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5691);
    _la = _input->LA(1);
    if (!(((((_la - 434) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 434)) & ((1ULL << (RpgParser::CPLUS - 434))
      | (1ULL << (RpgParser::CMINUS - 434))
      | (1ULL << (RpgParser::CMULT - 434))
      | (1ULL << (RpgParser::CDIV - 434))
      | (1ULL << (RpgParser::CEXP - 434)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorIncludingEqualContext ------------------------------------------------------------------

RpgParser::AssignmentOperatorIncludingEqualContext::AssignmentOperatorIncludingEqualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::AssignmentOperatorIncludingEqualContext::CPLUS() {
  return getToken(RpgParser::CPLUS, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorIncludingEqualContext::CMINUS() {
  return getToken(RpgParser::CMINUS, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorIncludingEqualContext::CMULT() {
  return getToken(RpgParser::CMULT, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorIncludingEqualContext::CDIV() {
  return getToken(RpgParser::CDIV, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorIncludingEqualContext::CEXP() {
  return getToken(RpgParser::CEXP, 0);
}

tree::TerminalNode* RpgParser::AssignmentOperatorIncludingEqualContext::EQUAL() {
  return getToken(RpgParser::EQUAL, 0);
}


size_t RpgParser::AssignmentOperatorIncludingEqualContext::getRuleIndex() const {
  return RpgParser::RuleAssignmentOperatorIncludingEqual;
}

void RpgParser::AssignmentOperatorIncludingEqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperatorIncludingEqual(this);
}

void RpgParser::AssignmentOperatorIncludingEqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperatorIncludingEqual(this);
}


antlrcpp::Any RpgParser::AssignmentOperatorIncludingEqualContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentOperatorIncludingEqual(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::AssignmentOperatorIncludingEqualContext* RpgParser::assignmentOperatorIncludingEqual() {
  AssignmentOperatorIncludingEqualContext *_localctx = _tracker.createInstance<AssignmentOperatorIncludingEqualContext>(_ctx, getState());
  enterRule(_localctx, 1144, RpgParser::RuleAssignmentOperatorIncludingEqual);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5693);
    _la = _input->LA(1);
    if (!(((((_la - 434) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 434)) & ((1ULL << (RpgParser::CPLUS - 434))
      | (1ULL << (RpgParser::CMINUS - 434))
      | (1ULL << (RpgParser::CMULT - 434))
      | (1ULL << (RpgParser::CDIV - 434))
      | (1ULL << (RpgParser::CEXP - 434))
      | (1ULL << (RpgParser::EQUAL - 434)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgsContext ------------------------------------------------------------------

RpgParser::ArgsContext::ArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ArgsContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::ArgsContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

std::vector<RpgParser::ExpressionContext *> RpgParser::ArgsContext::expression() {
  return getRuleContexts<RpgParser::ExpressionContext>();
}

RpgParser::ExpressionContext* RpgParser::ArgsContext::expression(size_t i) {
  return getRuleContext<RpgParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::ArgsContext::COLON() {
  return getTokens(RpgParser::COLON);
}

tree::TerminalNode* RpgParser::ArgsContext::COLON(size_t i) {
  return getToken(RpgParser::COLON, i);
}


size_t RpgParser::ArgsContext::getRuleIndex() const {
  return RpgParser::RuleArgs;
}

void RpgParser::ArgsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgs(this);
}

void RpgParser::ArgsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgs(this);
}


antlrcpp::Any RpgParser::ArgsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitArgs(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ArgsContext* RpgParser::args() {
  ArgsContext *_localctx = _tracker.createInstance<ArgsContext>(_ctx, getState());
  enterRule(_localctx, 1146, RpgParser::RuleArgs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5695);
    match(RpgParser::OPEN_PAREN);
    setState(5704);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 20) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 20)) & ((1ULL << (RpgParser::OPEN_PAREN - 20))
      | (1ULL << (RpgParser::NUMBER - 20))
      | (1ULL << (RpgParser::ID - 20))
      | (1ULL << (RpgParser::OP_ACQ - 20))
      | (1ULL << (RpgParser::OP_BEGSR - 20))
      | (1ULL << (RpgParser::OP_CALLP - 20))
      | (1ULL << (RpgParser::OP_CHAIN - 20))
      | (1ULL << (RpgParser::OP_CLEAR - 20))
      | (1ULL << (RpgParser::OP_CLOSE - 20))
      | (1ULL << (RpgParser::OP_COMMIT - 20))
      | (1ULL << (RpgParser::OP_DEALLOC - 20))
      | (1ULL << (RpgParser::OP_DELETE - 20))
      | (1ULL << (RpgParser::OP_DSPLY - 20))
      | (1ULL << (RpgParser::OP_DUMP - 20))
      | (1ULL << (RpgParser::OP_ENDSR - 20))
      | (1ULL << (RpgParser::OP_EVAL - 20))
      | (1ULL << (RpgParser::OP_EVALR - 20))
      | (1ULL << (RpgParser::OP_EVAL_CORR - 20))
      | (1ULL << (RpgParser::OP_EXCEPT - 20))
      | (1ULL << (RpgParser::OP_EXFMT - 20))
      | (1ULL << (RpgParser::OP_EXSR - 20))
      | (1ULL << (RpgParser::OP_FEOD - 20))
      | (1ULL << (RpgParser::OP_FORCE - 20)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (RpgParser::OP_IN - 84))
      | (1ULL << (RpgParser::OP_ITER - 84))
      | (1ULL << (RpgParser::OP_LEAVE - 84))
      | (1ULL << (RpgParser::OP_LEAVESR - 84))
      | (1ULL << (RpgParser::OP_NEXT - 84))
      | (1ULL << (RpgParser::OP_OPEN - 84))
      | (1ULL << (RpgParser::OP_OTHER - 84))
      | (1ULL << (RpgParser::OP_OUT - 84))
      | (1ULL << (RpgParser::OP_POST - 84))
      | (1ULL << (RpgParser::OP_READ - 84))
      | (1ULL << (RpgParser::OP_READC - 84))
      | (1ULL << (RpgParser::OP_READE - 84))
      | (1ULL << (RpgParser::OP_READP - 84))
      | (1ULL << (RpgParser::OP_READPE - 84))
      | (1ULL << (RpgParser::OP_REL - 84))
      | (1ULL << (RpgParser::OP_RESET - 84))
      | (1ULL << (RpgParser::OP_RETURN - 84))
      | (1ULL << (RpgParser::OP_ROLBK - 84))
      | (1ULL << (RpgParser::OP_SELECT - 84))
      | (1ULL << (RpgParser::OP_SETGT - 84))
      | (1ULL << (RpgParser::OP_SETLL - 84))
      | (1ULL << (RpgParser::OP_SORTA - 84))
      | (1ULL << (RpgParser::OP_TEST - 84))
      | (1ULL << (RpgParser::OP_UNLOCK - 84))
      | (1ULL << (RpgParser::OP_UPDATE - 84))
      | (1ULL << (RpgParser::OP_WHEN - 84))
      | (1ULL << (RpgParser::OP_WRITE - 84))
      | (1ULL << (RpgParser::OP_XML_INTO - 84))
      | (1ULL << (RpgParser::OP_XML_SAX - 84))
      | (1ULL << (RpgParser::BIF_ABS - 84))
      | (1ULL << (RpgParser::BIF_ADDR - 84))
      | (1ULL << (RpgParser::BIF_ALLOC - 84))
      | (1ULL << (RpgParser::BIF_BITAND - 84))
      | (1ULL << (RpgParser::BIF_BITNOT - 84))
      | (1ULL << (RpgParser::BIF_BITOR - 84))
      | (1ULL << (RpgParser::BIF_BITXOR - 84))
      | (1ULL << (RpgParser::BIF_CHAR - 84))
      | (1ULL << (RpgParser::BIF_CHECK - 84))
      | (1ULL << (RpgParser::BIF_CHECKR - 84))
      | (1ULL << (RpgParser::BIF_DATE - 84))
      | (1ULL << (RpgParser::BIF_DAYS - 84))
      | (1ULL << (RpgParser::BIF_DEC - 84))
      | (1ULL << (RpgParser::BIF_DECH - 84))
      | (1ULL << (RpgParser::BIF_DECPOS - 84))
      | (1ULL << (RpgParser::BIF_DIFF - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (RpgParser::BIF_DIV - 148))
      | (1ULL << (RpgParser::BIF_EDITC - 148))
      | (1ULL << (RpgParser::BIF_EDITFLT - 148))
      | (1ULL << (RpgParser::BIF_EDITW - 148))
      | (1ULL << (RpgParser::BIF_ELEM - 148))
      | (1ULL << (RpgParser::BIF_EOF - 148))
      | (1ULL << (RpgParser::BIF_EQUAL - 148))
      | (1ULL << (RpgParser::BIF_ERROR - 148))
      | (1ULL << (RpgParser::BIF_FIELDS - 148))
      | (1ULL << (RpgParser::BIF_FLOAT - 148))
      | (1ULL << (RpgParser::BIF_FOUND - 148))
      | (1ULL << (RpgParser::BIF_GRAPH - 148))
      | (1ULL << (RpgParser::BIF_HANDLER - 148))
      | (1ULL << (RpgParser::BIF_HOURS - 148))
      | (1ULL << (RpgParser::BIF_INT - 148))
      | (1ULL << (RpgParser::BIF_INTH - 148))
      | (1ULL << (RpgParser::BIF_KDS - 148))
      | (1ULL << (RpgParser::BIF_LEN - 148))
      | (1ULL << (RpgParser::BIF_LOOKUP - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_LOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_MINUTES - 148))
      | (1ULL << (RpgParser::BIF_MONTHS - 148))
      | (1ULL << (RpgParser::BIF_MSECONDS - 148))
      | (1ULL << (RpgParser::BIF_NULLIND - 148))
      | (1ULL << (RpgParser::BIF_OCCUR - 148))
      | (1ULL << (RpgParser::BIF_OPEN - 148))
      | (1ULL << (RpgParser::BIF_PADDR - 148))
      | (1ULL << (RpgParser::BIF_PARMS - 148))
      | (1ULL << (RpgParser::BIF_PARMNUM - 148))
      | (1ULL << (RpgParser::BIF_REALLOC - 148))
      | (1ULL << (RpgParser::BIF_REM - 148))
      | (1ULL << (RpgParser::BIF_REPLACE - 148))
      | (1ULL << (RpgParser::BIF_SCAN - 148))
      | (1ULL << (RpgParser::BIF_SCANRPL - 148))
      | (1ULL << (RpgParser::BIF_SECONDS - 148))
      | (1ULL << (RpgParser::BIF_SHTDN - 148))
      | (1ULL << (RpgParser::BIF_SIZE - 148))
      | (1ULL << (RpgParser::BIF_SQRT - 148))
      | (1ULL << (RpgParser::BIF_STATUS - 148))
      | (1ULL << (RpgParser::BIF_STR - 148))
      | (1ULL << (RpgParser::BIF_SUBARR - 148))
      | (1ULL << (RpgParser::BIF_SUBDT - 148))
      | (1ULL << (RpgParser::BIF_SUBST - 148))
      | (1ULL << (RpgParser::BIF_THIS - 148))
      | (1ULL << (RpgParser::BIF_TIME - 148))
      | (1ULL << (RpgParser::BIF_TIMESTAMP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUP - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPLE - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGT - 148))
      | (1ULL << (RpgParser::BIF_TLOOKUPGE - 148))
      | (1ULL << (RpgParser::BIF_TRIM - 148))
      | (1ULL << (RpgParser::BIF_TRIML - 148))
      | (1ULL << (RpgParser::BIF_TRIMR - 148))
      | (1ULL << (RpgParser::BIF_UCS2 - 148))
      | (1ULL << (RpgParser::BIF_UNS - 148))
      | (1ULL << (RpgParser::BIF_UNSH - 148))
      | (1ULL << (RpgParser::BIF_XFOOT - 148))
      | (1ULL << (RpgParser::BIF_XLATE - 148))
      | (1ULL << (RpgParser::BIF_XML - 148))
      | (1ULL << (RpgParser::BIF_YEARS - 148)))) != 0) || ((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276))
      | (1ULL << (RpgParser::UDATE - 276))
      | (1ULL << (RpgParser::UMONTH - 276))
      | (1ULL << (RpgParser::UYEAR - 276))
      | (1ULL << (RpgParser::UDAY - 276))
      | (1ULL << (RpgParser::CHAR - 276))
      | (1ULL << (RpgParser::VARCHAR - 276))
      | (1ULL << (RpgParser::UCS2 - 276))
      | (1ULL << (RpgParser::DATE_ - 276))
      | (1ULL << (RpgParser::VARUCS2 - 276))
      | (1ULL << (RpgParser::GRAPH - 276))
      | (1ULL << (RpgParser::VARGRAPH - 276))
      | (1ULL << (RpgParser::IND - 276))
      | (1ULL << (RpgParser::PACKED - 276))
      | (1ULL << (RpgParser::ZONED - 276))
      | (1ULL << (RpgParser::BINDEC - 276))
      | (1ULL << (RpgParser::INT - 276))
      | (1ULL << (RpgParser::UNS - 276))
      | (1ULL << (RpgParser::FLOAT - 276))
      | (1ULL << (RpgParser::TIME - 276))
      | (1ULL << (RpgParser::TIMESTAMP - 276))
      | (1ULL << (RpgParser::POINTER - 276))
      | (1ULL << (RpgParser::OBJECT - 276))
      | (1ULL << (RpgParser::KEYWORD_ALIAS - 276)))) != 0) || ((((_la - 340) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 340)) & ((1ULL << (RpgParser::KEYWORD_ALIGN - 340))
      | (1ULL << (RpgParser::KEYWORD_ALT - 340))
      | (1ULL << (RpgParser::KEYWORD_ALTSEQ - 340))
      | (1ULL << (RpgParser::KEYWORD_ASCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_BASED - 340))
      | (1ULL << (RpgParser::KEYWORD_CCSID - 340))
      | (1ULL << (RpgParser::KEYWORD_CLASS - 340))
      | (1ULL << (RpgParser::KEYWORD_CONST - 340))
      | (1ULL << (RpgParser::KEYWORD_CTDATA - 340))
      | (1ULL << (RpgParser::KEYWORD_DATFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_DESCEND - 340))
      | (1ULL << (RpgParser::KEYWORD_DIM - 340))
      | (1ULL << (RpgParser::KEYWORD_DTAARA - 340))
      | (1ULL << (RpgParser::KEYWORD_EXPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFLD - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTNAME - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPGM - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTPROC - 340))
      | (1ULL << (RpgParser::KEYWORD_FROMFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_IMPORT - 340))
      | (1ULL << (RpgParser::KEYWORD_INZ - 340))
      | (1ULL << (RpgParser::KEYWORD_LEN - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEDS - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_LIKEREC - 340))
      | (1ULL << (RpgParser::KEYWORD_NOOPT - 340))
      | (1ULL << (RpgParser::KEYWORD_OCCURS - 340))
      | (1ULL << (RpgParser::KEYWORD_OPDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_OPTIONS - 340))
      | (1ULL << (RpgParser::KEYWORD_OVERLAY - 340))
      | (1ULL << (RpgParser::KEYWORD_PACKEVEN - 340))
      | (1ULL << (RpgParser::KEYWORD_PERRCD - 340))
      | (1ULL << (RpgParser::KEYWORD_PREFIX - 340))
      | (1ULL << (RpgParser::KEYWORD_POS - 340))
      | (1ULL << (RpgParser::KEYWORD_PROCPTR - 340))
      | (1ULL << (RpgParser::KEYWORD_QUALIFIED - 340))
      | (1ULL << (RpgParser::KEYWORD_RTNPARM - 340))
      | (1ULL << (RpgParser::KEYWORD_STATIC - 340))
      | (1ULL << (RpgParser::KEYWORD_TEMPLATE - 340))
      | (1ULL << (RpgParser::KEYWORD_TIMFMT - 340))
      | (1ULL << (RpgParser::KEYWORD_TOFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_VALUE - 340))
      | (1ULL << (RpgParser::KEYWORD_VARYING - 340))
      | (1ULL << (RpgParser::KEYWORD_BLOCK - 340))
      | (1ULL << (RpgParser::KEYWORD_COMMIT - 340))
      | (1ULL << (RpgParser::KEYWORD_DEVID - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTDESC - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTFILE - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTIND - 340))
      | (1ULL << (RpgParser::KEYWORD_EXTMBR - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMLEN - 340))
      | (1ULL << (RpgParser::KEYWORD_FORMOFL - 340))
      | (1ULL << (RpgParser::KEYWORD_IGNORE - 340))
      | (1ULL << (RpgParser::KEYWORD_INCLUDE - 340))
      | (1ULL << (RpgParser::KEYWORD_INDDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFDS - 340))
      | (1ULL << (RpgParser::KEYWORD_INFSR - 340))
      | (1ULL << (RpgParser::KEYWORD_KEYLOC - 340))
      | (1ULL << (RpgParser::KEYWORD_MAXDEV - 340))
      | (1ULL << (RpgParser::KEYWORD_OFLIND - 340))
      | (1ULL << (RpgParser::KEYWORD_PASS - 340)))) != 0) || ((((_la - 404) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 404)) & ((1ULL << (RpgParser::KEYWORD_PGMNAME - 404))
      | (1ULL << (RpgParser::KEYWORD_PLIST - 404))
      | (1ULL << (RpgParser::KEYWORD_PRTCTL - 404))
      | (1ULL << (RpgParser::KEYWORD_RAFDATA - 404))
      | (1ULL << (RpgParser::KEYWORD_RECNO - 404))
      | (1ULL << (RpgParser::KEYWORD_RENAME - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEDS - 404))
      | (1ULL << (RpgParser::KEYWORD_SAVEIND - 404))
      | (1ULL << (RpgParser::KEYWORD_SFILE - 404))
      | (1ULL << (RpgParser::KEYWORD_SLN - 404))
      | (1ULL << (RpgParser::KEYWORD_USROPN - 404))
      | (1ULL << (RpgParser::KEYWORD_DISK - 404))
      | (1ULL << (RpgParser::KEYWORD_WORKSTN - 404))
      | (1ULL << (RpgParser::KEYWORD_PRINTER - 404))
      | (1ULL << (RpgParser::KEYWORD_SPECIAL - 404))
      | (1ULL << (RpgParser::KEYWORD_KEYED - 404))
      | (1ULL << (RpgParser::KEYWORD_USAGE - 404))
      | (1ULL << (RpgParser::KEYWORD_PSDS - 404))
      | (1ULL << (RpgParser::NOT - 404))
      | (1ULL << (RpgParser::PLUS - 404))
      | (1ULL << (RpgParser::MINUS - 404))
      | (1ULL << (RpgParser::MULT_NOSPACE - 404))
      | (1ULL << (RpgParser::FREE_BY - 404))
      | (1ULL << (RpgParser::FREE_TO - 404))
      | (1ULL << (RpgParser::FREE_DOWNTO - 404))
      | (1ULL << (RpgParser::HexLiteralStart - 404))
      | (1ULL << (RpgParser::DateLiteralStart - 404))
      | (1ULL << (RpgParser::TimeLiteralStart - 404))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 404))
      | (1ULL << (RpgParser::GraphicLiteralStart - 404))
      | (1ULL << (RpgParser::UCS2LiteralStart - 404))
      | (1ULL << (RpgParser::StringLiteralStart - 404)))) != 0)) {
      setState(5696);
      expression(0);
      setState(5701);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == RpgParser::COLON) {
        setState(5697);
        match(RpgParser::COLON);
        setState(5698);
        expression(0);
        setState(5703);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(5706);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

RpgParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::LiteralContext::StringLiteralEnd() {
  return getToken(RpgParser::StringLiteralEnd, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::StringLiteralStart() {
  return getToken(RpgParser::StringLiteralStart, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::HexLiteralStart() {
  return getToken(RpgParser::HexLiteralStart, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::DateLiteralStart() {
  return getToken(RpgParser::DateLiteralStart, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::TimeLiteralStart() {
  return getToken(RpgParser::TimeLiteralStart, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::TimeStampLiteralStart() {
  return getToken(RpgParser::TimeStampLiteralStart, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::UCS2LiteralStart() {
  return getToken(RpgParser::UCS2LiteralStart, 0);
}

tree::TerminalNode* RpgParser::LiteralContext::GraphicLiteralStart() {
  return getToken(RpgParser::GraphicLiteralStart, 0);
}

std::vector<tree::TerminalNode *> RpgParser::LiteralContext::StringContent() {
  return getTokens(RpgParser::StringContent);
}

tree::TerminalNode* RpgParser::LiteralContext::StringContent(size_t i) {
  return getToken(RpgParser::StringContent, i);
}

std::vector<tree::TerminalNode *> RpgParser::LiteralContext::StringEscapedQuote() {
  return getTokens(RpgParser::StringEscapedQuote);
}

tree::TerminalNode* RpgParser::LiteralContext::StringEscapedQuote(size_t i) {
  return getToken(RpgParser::StringEscapedQuote, i);
}

std::vector<tree::TerminalNode *> RpgParser::LiteralContext::PlusOrMinus() {
  return getTokens(RpgParser::PlusOrMinus);
}

tree::TerminalNode* RpgParser::LiteralContext::PlusOrMinus(size_t i) {
  return getToken(RpgParser::PlusOrMinus, i);
}


size_t RpgParser::LiteralContext::getRuleIndex() const {
  return RpgParser::RuleLiteral;
}

void RpgParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void RpgParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


antlrcpp::Any RpgParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::LiteralContext* RpgParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 1148, RpgParser::RuleLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5708);
    _la = _input->LA(1);
    if (!(((((_la - 449) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 449)) & ((1ULL << (RpgParser::HexLiteralStart - 449))
      | (1ULL << (RpgParser::DateLiteralStart - 449))
      | (1ULL << (RpgParser::TimeLiteralStart - 449))
      | (1ULL << (RpgParser::TimeStampLiteralStart - 449))
      | (1ULL << (RpgParser::GraphicLiteralStart - 449))
      | (1ULL << (RpgParser::UCS2LiteralStart - 449))
      | (1ULL << (RpgParser::StringLiteralStart - 449)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5712);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 575) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 575)) & ((1ULL << (RpgParser::StringContent - 575))
      | (1ULL << (RpgParser::StringEscapedQuote - 575))
      | (1ULL << (RpgParser::PlusOrMinus - 575)))) != 0)) {
      setState(5709);
      dynamic_cast<LiteralContext *>(_localctx)->content = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 575) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 575)) & ((1ULL << (RpgParser::StringContent - 575))
        | (1ULL << (RpgParser::StringEscapedQuote - 575))
        | (1ULL << (RpgParser::PlusOrMinus - 575)))) != 0))) {
        dynamic_cast<LiteralContext *>(_localctx)->content = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5714);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5715);
    match(RpgParser::StringLiteralEnd);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

RpgParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Free_identifierContext* RpgParser::IdentifierContext::free_identifier() {
  return getRuleContext<RpgParser::Free_identifierContext>(0);
}

RpgParser::Multipart_identifierContext* RpgParser::IdentifierContext::multipart_identifier() {
  return getRuleContext<RpgParser::Multipart_identifierContext>(0);
}

RpgParser::AllContext* RpgParser::IdentifierContext::all() {
  return getRuleContext<RpgParser::AllContext>(0);
}


size_t RpgParser::IdentifierContext::getRuleIndex() const {
  return RpgParser::RuleIdentifier;
}

void RpgParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void RpgParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}


antlrcpp::Any RpgParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::IdentifierContext* RpgParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1150, RpgParser::RuleIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5720);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 504, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5717);
      free_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5718);
      multipart_identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5719);
      all();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllContext ------------------------------------------------------------------

RpgParser::AllContext::AllContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::SymbolicConstantsContext* RpgParser::AllContext::symbolicConstants() {
  return getRuleContext<RpgParser::SymbolicConstantsContext>(0);
}

RpgParser::LiteralContext* RpgParser::AllContext::literal() {
  return getRuleContext<RpgParser::LiteralContext>(0);
}


size_t RpgParser::AllContext::getRuleIndex() const {
  return RpgParser::RuleAll;
}

void RpgParser::AllContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAll(this);
}

void RpgParser::AllContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAll(this);
}


antlrcpp::Any RpgParser::AllContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitAll(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::AllContext* RpgParser::all() {
  AllContext *_localctx = _tracker.createInstance<AllContext>(_ctx, getState());
  enterRule(_localctx, 1152, RpgParser::RuleAll);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5722);
    symbolicConstants();
    setState(5724);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx)) {
    case 1: {
      setState(5723);
      literal();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

RpgParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Free_identifierContext* RpgParser::FunctionNameContext::free_identifier() {
  return getRuleContext<RpgParser::Free_identifierContext>(0);
}


size_t RpgParser::FunctionNameContext::getRuleIndex() const {
  return RpgParser::RuleFunctionName;
}

void RpgParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void RpgParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}


antlrcpp::Any RpgParser::FunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFunctionName(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::FunctionNameContext* RpgParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 1154, RpgParser::RuleFunctionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5726);
    free_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multipart_identifierContext ------------------------------------------------------------------

RpgParser::Multipart_identifierContext::Multipart_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::Multipart_identifier_elementContext *> RpgParser::Multipart_identifierContext::multipart_identifier_element() {
  return getRuleContexts<RpgParser::Multipart_identifier_elementContext>();
}

RpgParser::Multipart_identifier_elementContext* RpgParser::Multipart_identifierContext::multipart_identifier_element(size_t i) {
  return getRuleContext<RpgParser::Multipart_identifier_elementContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::Multipart_identifierContext::FREE_DOT() {
  return getTokens(RpgParser::FREE_DOT);
}

tree::TerminalNode* RpgParser::Multipart_identifierContext::FREE_DOT(size_t i) {
  return getToken(RpgParser::FREE_DOT, i);
}


size_t RpgParser::Multipart_identifierContext::getRuleIndex() const {
  return RpgParser::RuleMultipart_identifier;
}

void RpgParser::Multipart_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipart_identifier(this);
}

void RpgParser::Multipart_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipart_identifier(this);
}


antlrcpp::Any RpgParser::Multipart_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitMultipart_identifier(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Multipart_identifierContext* RpgParser::multipart_identifier() {
  Multipart_identifierContext *_localctx = _tracker.createInstance<Multipart_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1156, RpgParser::RuleMultipart_identifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5728);
    dynamic_cast<Multipart_identifierContext *>(_localctx)->multipart_identifier_elementContext = multipart_identifier_element();
    dynamic_cast<Multipart_identifierContext *>(_localctx)->elements.push_back(dynamic_cast<Multipart_identifierContext *>(_localctx)->multipart_identifier_elementContext);
    setState(5733);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5729);
        match(RpgParser::FREE_DOT);
        setState(5730);
        dynamic_cast<Multipart_identifierContext *>(_localctx)->multipart_identifier_elementContext = multipart_identifier_element();
        dynamic_cast<Multipart_identifierContext *>(_localctx)->elements.push_back(dynamic_cast<Multipart_identifierContext *>(_localctx)->multipart_identifier_elementContext); 
      }
      setState(5735);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multipart_identifier_elementContext ------------------------------------------------------------------

RpgParser::Multipart_identifier_elementContext::Multipart_identifier_elementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Free_identifierContext* RpgParser::Multipart_identifier_elementContext::free_identifier() {
  return getRuleContext<RpgParser::Free_identifierContext>(0);
}

RpgParser::Indexed_identifierContext* RpgParser::Multipart_identifier_elementContext::indexed_identifier() {
  return getRuleContext<RpgParser::Indexed_identifierContext>(0);
}


size_t RpgParser::Multipart_identifier_elementContext::getRuleIndex() const {
  return RpgParser::RuleMultipart_identifier_element;
}

void RpgParser::Multipart_identifier_elementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipart_identifier_element(this);
}

void RpgParser::Multipart_identifier_elementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipart_identifier_element(this);
}


antlrcpp::Any RpgParser::Multipart_identifier_elementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitMultipart_identifier_element(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Multipart_identifier_elementContext* RpgParser::multipart_identifier_element() {
  Multipart_identifier_elementContext *_localctx = _tracker.createInstance<Multipart_identifier_elementContext>(_ctx, getState());
  enterRule(_localctx, 1158, RpgParser::RuleMultipart_identifier_element);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5738);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5736);
      free_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5737);
      indexed_identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indexed_identifierContext ------------------------------------------------------------------

RpgParser::Indexed_identifierContext::Indexed_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Free_identifierContext* RpgParser::Indexed_identifierContext::free_identifier() {
  return getRuleContext<RpgParser::Free_identifierContext>(0);
}

tree::TerminalNode* RpgParser::Indexed_identifierContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::Indexed_identifierContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::ExpressionContext* RpgParser::Indexed_identifierContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

tree::TerminalNode* RpgParser::Indexed_identifierContext::ARRAY_REPEAT() {
  return getToken(RpgParser::ARRAY_REPEAT, 0);
}


size_t RpgParser::Indexed_identifierContext::getRuleIndex() const {
  return RpgParser::RuleIndexed_identifier;
}

void RpgParser::Indexed_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexed_identifier(this);
}

void RpgParser::Indexed_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexed_identifier(this);
}


antlrcpp::Any RpgParser::Indexed_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIndexed_identifier(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Indexed_identifierContext* RpgParser::indexed_identifier() {
  Indexed_identifierContext *_localctx = _tracker.createInstance<Indexed_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1160, RpgParser::RuleIndexed_identifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5740);
    free_identifier();
    setState(5741);
    match(RpgParser::OPEN_PAREN);
    setState(5744);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::OPEN_PAREN:
      case RpgParser::NUMBER:
      case RpgParser::ID:
      case RpgParser::OP_ACQ:
      case RpgParser::OP_BEGSR:
      case RpgParser::OP_CALLP:
      case RpgParser::OP_CHAIN:
      case RpgParser::OP_CLEAR:
      case RpgParser::OP_CLOSE:
      case RpgParser::OP_COMMIT:
      case RpgParser::OP_DEALLOC:
      case RpgParser::OP_DELETE:
      case RpgParser::OP_DSPLY:
      case RpgParser::OP_DUMP:
      case RpgParser::OP_ENDSR:
      case RpgParser::OP_EVAL:
      case RpgParser::OP_EVALR:
      case RpgParser::OP_EVAL_CORR:
      case RpgParser::OP_EXCEPT:
      case RpgParser::OP_EXFMT:
      case RpgParser::OP_EXSR:
      case RpgParser::OP_FEOD:
      case RpgParser::OP_FORCE:
      case RpgParser::OP_IN:
      case RpgParser::OP_ITER:
      case RpgParser::OP_LEAVE:
      case RpgParser::OP_LEAVESR:
      case RpgParser::OP_NEXT:
      case RpgParser::OP_OPEN:
      case RpgParser::OP_OTHER:
      case RpgParser::OP_OUT:
      case RpgParser::OP_POST:
      case RpgParser::OP_READ:
      case RpgParser::OP_READC:
      case RpgParser::OP_READE:
      case RpgParser::OP_READP:
      case RpgParser::OP_READPE:
      case RpgParser::OP_REL:
      case RpgParser::OP_RESET:
      case RpgParser::OP_RETURN:
      case RpgParser::OP_ROLBK:
      case RpgParser::OP_SELECT:
      case RpgParser::OP_SETGT:
      case RpgParser::OP_SETLL:
      case RpgParser::OP_SORTA:
      case RpgParser::OP_TEST:
      case RpgParser::OP_UNLOCK:
      case RpgParser::OP_UPDATE:
      case RpgParser::OP_WHEN:
      case RpgParser::OP_WRITE:
      case RpgParser::OP_XML_INTO:
      case RpgParser::OP_XML_SAX:
      case RpgParser::BIF_ABS:
      case RpgParser::BIF_ADDR:
      case RpgParser::BIF_ALLOC:
      case RpgParser::BIF_BITAND:
      case RpgParser::BIF_BITNOT:
      case RpgParser::BIF_BITOR:
      case RpgParser::BIF_BITXOR:
      case RpgParser::BIF_CHAR:
      case RpgParser::BIF_CHECK:
      case RpgParser::BIF_CHECKR:
      case RpgParser::BIF_DATE:
      case RpgParser::BIF_DAYS:
      case RpgParser::BIF_DEC:
      case RpgParser::BIF_DECH:
      case RpgParser::BIF_DECPOS:
      case RpgParser::BIF_DIFF:
      case RpgParser::BIF_DIV:
      case RpgParser::BIF_EDITC:
      case RpgParser::BIF_EDITFLT:
      case RpgParser::BIF_EDITW:
      case RpgParser::BIF_ELEM:
      case RpgParser::BIF_EOF:
      case RpgParser::BIF_EQUAL:
      case RpgParser::BIF_ERROR:
      case RpgParser::BIF_FIELDS:
      case RpgParser::BIF_FLOAT:
      case RpgParser::BIF_FOUND:
      case RpgParser::BIF_GRAPH:
      case RpgParser::BIF_HANDLER:
      case RpgParser::BIF_HOURS:
      case RpgParser::BIF_INT:
      case RpgParser::BIF_INTH:
      case RpgParser::BIF_KDS:
      case RpgParser::BIF_LEN:
      case RpgParser::BIF_LOOKUP:
      case RpgParser::BIF_LOOKUPLT:
      case RpgParser::BIF_LOOKUPLE:
      case RpgParser::BIF_LOOKUPGT:
      case RpgParser::BIF_LOOKUPGE:
      case RpgParser::BIF_MINUTES:
      case RpgParser::BIF_MONTHS:
      case RpgParser::BIF_MSECONDS:
      case RpgParser::BIF_NULLIND:
      case RpgParser::BIF_OCCUR:
      case RpgParser::BIF_OPEN:
      case RpgParser::BIF_PADDR:
      case RpgParser::BIF_PARMS:
      case RpgParser::BIF_PARMNUM:
      case RpgParser::BIF_REALLOC:
      case RpgParser::BIF_REM:
      case RpgParser::BIF_REPLACE:
      case RpgParser::BIF_SCAN:
      case RpgParser::BIF_SCANRPL:
      case RpgParser::BIF_SECONDS:
      case RpgParser::BIF_SHTDN:
      case RpgParser::BIF_SIZE:
      case RpgParser::BIF_SQRT:
      case RpgParser::BIF_STATUS:
      case RpgParser::BIF_STR:
      case RpgParser::BIF_SUBARR:
      case RpgParser::BIF_SUBDT:
      case RpgParser::BIF_SUBST:
      case RpgParser::BIF_THIS:
      case RpgParser::BIF_TIME:
      case RpgParser::BIF_TIMESTAMP:
      case RpgParser::BIF_TLOOKUP:
      case RpgParser::BIF_TLOOKUPLT:
      case RpgParser::BIF_TLOOKUPLE:
      case RpgParser::BIF_TLOOKUPGT:
      case RpgParser::BIF_TLOOKUPGE:
      case RpgParser::BIF_TRIM:
      case RpgParser::BIF_TRIML:
      case RpgParser::BIF_TRIMR:
      case RpgParser::BIF_UCS2:
      case RpgParser::BIF_UNS:
      case RpgParser::BIF_UNSH:
      case RpgParser::BIF_XFOOT:
      case RpgParser::BIF_XLATE:
      case RpgParser::BIF_XML:
      case RpgParser::BIF_YEARS:
      case RpgParser::SPLAT_ALL:
      case RpgParser::SPLAT_NONE:
      case RpgParser::SPLAT_YES:
      case RpgParser::SPLAT_NO:
      case RpgParser::SPLAT_ILERPG:
      case RpgParser::SPLAT_COMPAT:
      case RpgParser::SPLAT_CRTBNDRPG:
      case RpgParser::SPLAT_CRTRPGMOD:
      case RpgParser::SPLAT_VRM:
      case RpgParser::SPLAT_ALLG:
      case RpgParser::SPLAT_ALLU:
      case RpgParser::SPLAT_ALLTHREAD:
      case RpgParser::SPLAT_ALLX:
      case RpgParser::SPLAT_BLANKS:
      case RpgParser::SPLAT_CANCL:
      case RpgParser::SPLAT_CYMD:
      case RpgParser::SPLAT_CMDY:
      case RpgParser::SPLAT_CDMY:
      case RpgParser::SPLAT_MDY:
      case RpgParser::SPLAT_DMY:
      case RpgParser::SPLAT_DFT:
      case RpgParser::SPLAT_YMD:
      case RpgParser::SPLAT_JUL:
      case RpgParser::SPLAT_JAVA:
      case RpgParser::SPLAT_ISO:
      case RpgParser::SPLAT_USA:
      case RpgParser::SPLAT_EUR:
      case RpgParser::SPLAT_JIS:
      case RpgParser::SPLAT_DATE:
      case RpgParser::SPLAT_DAY:
      case RpgParser::SPlAT_DETC:
      case RpgParser::SPLAT_DETL:
      case RpgParser::SPLAT_DTAARA:
      case RpgParser::SPLAT_END:
      case RpgParser::SPLAT_ENTRY:
      case RpgParser::SPLAT_EQUATE:
      case RpgParser::SPLAT_EXTDFT:
      case RpgParser::SPLAT_EXT:
      case RpgParser::SPLAT_FILE:
      case RpgParser::SPLAT_GETIN:
      case RpgParser::SPLAT_HIVAL:
      case RpgParser::SPLAT_INIT:
      case RpgParser::SPLAT_INDICATOR:
      case RpgParser::SPLAT_INZSR:
      case RpgParser::SPLAT_IN:
      case RpgParser::SPLAT_INPUT:
      case RpgParser::SPLAT_OUTPUT:
      case RpgParser::SPLAT_JOBRUN:
      case RpgParser::SPLAT_JOB:
      case RpgParser::SPLAT_LDA:
      case RpgParser::SPLAT_LIKE:
      case RpgParser::SPLAT_LONGJUL:
      case RpgParser::SPLAT_LOVAL:
      case RpgParser::SPLAT_KEY:
      case RpgParser::SPLAT_MONTH:
      case RpgParser::SPLAT_NEXT:
      case RpgParser::SPLAT_NOIND:
      case RpgParser::SPLAT_NOKEY:
      case RpgParser::SPLAT_NULL:
      case RpgParser::SPLAT_OFL:
      case RpgParser::SPLAT_ON:
      case RpgParser::SPLAT_ONLY:
      case RpgParser::SPLAT_OFF:
      case RpgParser::SPLAT_PDA:
      case RpgParser::SPLAT_PLACE:
      case RpgParser::SPLAT_PSSR:
      case RpgParser::SPLAT_ROUTINE:
      case RpgParser::SPLAT_START:
      case RpgParser::SPLAT_SYS:
      case RpgParser::SPLAT_TERM:
      case RpgParser::SPLAT_TOTC:
      case RpgParser::SPLAT_TOTL:
      case RpgParser::SPLAT_USER:
      case RpgParser::SPLAT_VAR:
      case RpgParser::SPLAT_YEAR:
      case RpgParser::SPLAT_ZEROS:
      case RpgParser::SPLAT_HMS:
      case RpgParser::SPLAT_INLR:
      case RpgParser::SPLAT_INOF:
      case RpgParser::SPLAT_DATA:
      case RpgParser::SPLAT_ASTFILL:
      case RpgParser::SPLAT_CURSYM:
      case RpgParser::SPLAT_MAX:
      case RpgParser::SPLAT_LOCK:
      case RpgParser::SPLAT_PROGRAM:
      case RpgParser::SPLAT_EXTDESC:
      case RpgParser::SPLAT_D:
      case RpgParser::SPLAT_H:
      case RpgParser::SPLAT_HOURS:
      case RpgParser::SPLAT_DAYS:
      case RpgParser::SPLAT_M:
      case RpgParser::SPLAT_MINUTES:
      case RpgParser::SPLAT_MONTHS:
      case RpgParser::SPLAT_MN:
      case RpgParser::SPLAT_MS:
      case RpgParser::SPLAT_MSECONDS:
      case RpgParser::SPLAT_S:
      case RpgParser::SPLAT_SECONDS:
      case RpgParser::SPLAT_Y:
      case RpgParser::SPLAT_YEARS:
      case RpgParser::UDATE:
      case RpgParser::UMONTH:
      case RpgParser::UYEAR:
      case RpgParser::UDAY:
      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT:
      case RpgParser::KEYWORD_ALIAS:
      case RpgParser::KEYWORD_ALIGN:
      case RpgParser::KEYWORD_ALT:
      case RpgParser::KEYWORD_ALTSEQ:
      case RpgParser::KEYWORD_ASCEND:
      case RpgParser::KEYWORD_BASED:
      case RpgParser::KEYWORD_CCSID:
      case RpgParser::KEYWORD_CLASS:
      case RpgParser::KEYWORD_CONST:
      case RpgParser::KEYWORD_CTDATA:
      case RpgParser::KEYWORD_DATFMT:
      case RpgParser::KEYWORD_DESCEND:
      case RpgParser::KEYWORD_DIM:
      case RpgParser::KEYWORD_DTAARA:
      case RpgParser::KEYWORD_EXPORT:
      case RpgParser::KEYWORD_EXT:
      case RpgParser::KEYWORD_EXTFLD:
      case RpgParser::KEYWORD_EXTFMT:
      case RpgParser::KEYWORD_EXTNAME:
      case RpgParser::KEYWORD_EXTPGM:
      case RpgParser::KEYWORD_EXTPROC:
      case RpgParser::KEYWORD_FROMFILE:
      case RpgParser::KEYWORD_IMPORT:
      case RpgParser::KEYWORD_INZ:
      case RpgParser::KEYWORD_LEN:
      case RpgParser::KEYWORD_LIKE:
      case RpgParser::KEYWORD_LIKEDS:
      case RpgParser::KEYWORD_LIKEFILE:
      case RpgParser::KEYWORD_LIKEREC:
      case RpgParser::KEYWORD_NOOPT:
      case RpgParser::KEYWORD_OCCURS:
      case RpgParser::KEYWORD_OPDESC:
      case RpgParser::KEYWORD_OPTIONS:
      case RpgParser::KEYWORD_OVERLAY:
      case RpgParser::KEYWORD_PACKEVEN:
      case RpgParser::KEYWORD_PERRCD:
      case RpgParser::KEYWORD_PREFIX:
      case RpgParser::KEYWORD_POS:
      case RpgParser::KEYWORD_PROCPTR:
      case RpgParser::KEYWORD_QUALIFIED:
      case RpgParser::KEYWORD_RTNPARM:
      case RpgParser::KEYWORD_STATIC:
      case RpgParser::KEYWORD_TEMPLATE:
      case RpgParser::KEYWORD_TIMFMT:
      case RpgParser::KEYWORD_TOFILE:
      case RpgParser::KEYWORD_VALUE:
      case RpgParser::KEYWORD_VARYING:
      case RpgParser::KEYWORD_BLOCK:
      case RpgParser::KEYWORD_COMMIT:
      case RpgParser::KEYWORD_DEVID:
      case RpgParser::KEYWORD_EXTDESC:
      case RpgParser::KEYWORD_EXTFILE:
      case RpgParser::KEYWORD_EXTIND:
      case RpgParser::KEYWORD_EXTMBR:
      case RpgParser::KEYWORD_FORMLEN:
      case RpgParser::KEYWORD_FORMOFL:
      case RpgParser::KEYWORD_IGNORE:
      case RpgParser::KEYWORD_INCLUDE:
      case RpgParser::KEYWORD_INDDS:
      case RpgParser::KEYWORD_INFDS:
      case RpgParser::KEYWORD_INFSR:
      case RpgParser::KEYWORD_KEYLOC:
      case RpgParser::KEYWORD_MAXDEV:
      case RpgParser::KEYWORD_OFLIND:
      case RpgParser::KEYWORD_PASS:
      case RpgParser::KEYWORD_PGMNAME:
      case RpgParser::KEYWORD_PLIST:
      case RpgParser::KEYWORD_PRTCTL:
      case RpgParser::KEYWORD_RAFDATA:
      case RpgParser::KEYWORD_RECNO:
      case RpgParser::KEYWORD_RENAME:
      case RpgParser::KEYWORD_SAVEDS:
      case RpgParser::KEYWORD_SAVEIND:
      case RpgParser::KEYWORD_SFILE:
      case RpgParser::KEYWORD_SLN:
      case RpgParser::KEYWORD_USROPN:
      case RpgParser::KEYWORD_DISK:
      case RpgParser::KEYWORD_WORKSTN:
      case RpgParser::KEYWORD_PRINTER:
      case RpgParser::KEYWORD_SPECIAL:
      case RpgParser::KEYWORD_KEYED:
      case RpgParser::KEYWORD_USAGE:
      case RpgParser::KEYWORD_PSDS:
      case RpgParser::NOT:
      case RpgParser::PLUS:
      case RpgParser::MINUS:
      case RpgParser::MULT_NOSPACE:
      case RpgParser::FREE_BY:
      case RpgParser::FREE_TO:
      case RpgParser::FREE_DOWNTO:
      case RpgParser::HexLiteralStart:
      case RpgParser::DateLiteralStart:
      case RpgParser::TimeLiteralStart:
      case RpgParser::TimeStampLiteralStart:
      case RpgParser::GraphicLiteralStart:
      case RpgParser::UCS2LiteralStart:
      case RpgParser::StringLiteralStart: {
        setState(5742);
        expression(0);
        break;
      }

      case RpgParser::ARRAY_REPEAT: {
        setState(5743);
        match(RpgParser::ARRAY_REPEAT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(5746);
    match(RpgParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpCodeContext ------------------------------------------------------------------

RpgParser::OpCodeContext::OpCodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::Free_identifierContext* RpgParser::OpCodeContext::free_identifier() {
  return getRuleContext<RpgParser::Free_identifierContext>(0);
}


size_t RpgParser::OpCodeContext::getRuleIndex() const {
  return RpgParser::RuleOpCode;
}

void RpgParser::OpCodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpCode(this);
}

void RpgParser::OpCodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpCode(this);
}


antlrcpp::Any RpgParser::OpCodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitOpCode(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::OpCodeContext* RpgParser::opCode() {
  OpCodeContext *_localctx = _tracker.createInstance<OpCodeContext>(_ctx, getState());
  enterRule(_localctx, 1162, RpgParser::RuleOpCode);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5748);
    free_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

RpgParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::NumberContext::NUMBER() {
  return getToken(RpgParser::NUMBER, 0);
}

tree::TerminalNode* RpgParser::NumberContext::MINUS() {
  return getToken(RpgParser::MINUS, 0);
}

std::vector<tree::TerminalNode *> RpgParser::NumberContext::NumberPart() {
  return getTokens(RpgParser::NumberPart);
}

tree::TerminalNode* RpgParser::NumberContext::NumberPart(size_t i) {
  return getToken(RpgParser::NumberPart, i);
}


size_t RpgParser::NumberContext::getRuleIndex() const {
  return RpgParser::RuleNumber;
}

void RpgParser::NumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumber(this);
}

void RpgParser::NumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumber(this);
}


antlrcpp::Any RpgParser::NumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitNumber(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::NumberContext* RpgParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 1164, RpgParser::RuleNumber);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5751);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == RpgParser::MINUS) {
      setState(5750);
      match(RpgParser::MINUS);
    }
    setState(5753);
    match(RpgParser::NUMBER);
    setState(5757);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5754);
        match(RpgParser::NumberPart); 
      }
      setState(5759);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Free_identifierContext ------------------------------------------------------------------

RpgParser::Free_identifierContext::Free_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

RpgParser::ContinuedIdentifierContext* RpgParser::Free_identifierContext::continuedIdentifier() {
  return getRuleContext<RpgParser::ContinuedIdentifierContext>(0);
}

RpgParser::IdOrKeywordContext* RpgParser::Free_identifierContext::idOrKeyword() {
  return getRuleContext<RpgParser::IdOrKeywordContext>(0);
}

tree::TerminalNode* RpgParser::Free_identifierContext::NOT() {
  return getToken(RpgParser::NOT, 0);
}

tree::TerminalNode* RpgParser::Free_identifierContext::FREE_BY() {
  return getToken(RpgParser::FREE_BY, 0);
}

tree::TerminalNode* RpgParser::Free_identifierContext::FREE_TO() {
  return getToken(RpgParser::FREE_TO, 0);
}

tree::TerminalNode* RpgParser::Free_identifierContext::FREE_DOWNTO() {
  return getToken(RpgParser::FREE_DOWNTO, 0);
}

RpgParser::Op_codeContext* RpgParser::Free_identifierContext::op_code() {
  return getRuleContext<RpgParser::Op_codeContext>(0);
}

tree::TerminalNode* RpgParser::Free_identifierContext::MULT_NOSPACE() {
  return getToken(RpgParser::MULT_NOSPACE, 0);
}


size_t RpgParser::Free_identifierContext::getRuleIndex() const {
  return RpgParser::RuleFree_identifier;
}

void RpgParser::Free_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFree_identifier(this);
}

void RpgParser::Free_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFree_identifier(this);
}


antlrcpp::Any RpgParser::Free_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitFree_identifier(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::Free_identifierContext* RpgParser::free_identifier() {
  Free_identifierContext *_localctx = _tracker.createInstance<Free_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1166, RpgParser::RuleFree_identifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5770);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx)) {
    case 1: {
      setState(5760);
      continuedIdentifier();
      break;
    }

    case 2: {
      setState(5762);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == RpgParser::MULT_NOSPACE) {
        setState(5761);
        match(RpgParser::MULT_NOSPACE);
      }
      setState(5764);
      idOrKeyword();
      break;
    }

    case 3: {
      setState(5765);
      match(RpgParser::NOT);
      break;
    }

    case 4: {
      setState(5766);
      match(RpgParser::FREE_BY);
      break;
    }

    case 5: {
      setState(5767);
      match(RpgParser::FREE_TO);
      break;
    }

    case 6: {
      setState(5768);
      match(RpgParser::FREE_DOWNTO);
      break;
    }

    case 7: {
      setState(5769);
      op_code();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinuedIdentifierContext ------------------------------------------------------------------

RpgParser::ContinuedIdentifierContext::ContinuedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<RpgParser::IdOrKeywordContext *> RpgParser::ContinuedIdentifierContext::idOrKeyword() {
  return getRuleContexts<RpgParser::IdOrKeywordContext>();
}

RpgParser::IdOrKeywordContext* RpgParser::ContinuedIdentifierContext::idOrKeyword(size_t i) {
  return getRuleContext<RpgParser::IdOrKeywordContext>(i);
}

std::vector<tree::TerminalNode *> RpgParser::ContinuedIdentifierContext::CONTINUATION() {
  return getTokens(RpgParser::CONTINUATION);
}

tree::TerminalNode* RpgParser::ContinuedIdentifierContext::CONTINUATION(size_t i) {
  return getToken(RpgParser::CONTINUATION, i);
}


size_t RpgParser::ContinuedIdentifierContext::getRuleIndex() const {
  return RpgParser::RuleContinuedIdentifier;
}

void RpgParser::ContinuedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinuedIdentifier(this);
}

void RpgParser::ContinuedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinuedIdentifier(this);
}


antlrcpp::Any RpgParser::ContinuedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitContinuedIdentifier(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ContinuedIdentifierContext* RpgParser::continuedIdentifier() {
  ContinuedIdentifierContext *_localctx = _tracker.createInstance<ContinuedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1168, RpgParser::RuleContinuedIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5775); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(5772);
              idOrKeyword();
              setState(5773);
              match(RpgParser::CONTINUATION);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(5777); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(5779);
    idOrKeyword();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdOrKeywordContext ------------------------------------------------------------------

RpgParser::IdOrKeywordContext::IdOrKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::ID() {
  return getToken(RpgParser::ID, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_ALIAS() {
  return getToken(RpgParser::KEYWORD_ALIAS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_ALIGN() {
  return getToken(RpgParser::KEYWORD_ALIGN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_ALT() {
  return getToken(RpgParser::KEYWORD_ALT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_ALTSEQ() {
  return getToken(RpgParser::KEYWORD_ALTSEQ, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_ASCEND() {
  return getToken(RpgParser::KEYWORD_ASCEND, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_BASED() {
  return getToken(RpgParser::KEYWORD_BASED, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_CCSID() {
  return getToken(RpgParser::KEYWORD_CCSID, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_CLASS() {
  return getToken(RpgParser::KEYWORD_CLASS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_CONST() {
  return getToken(RpgParser::KEYWORD_CONST, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_CTDATA() {
  return getToken(RpgParser::KEYWORD_CTDATA, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_DATFMT() {
  return getToken(RpgParser::KEYWORD_DATFMT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_DESCEND() {
  return getToken(RpgParser::KEYWORD_DESCEND, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_DIM() {
  return getToken(RpgParser::KEYWORD_DIM, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_DTAARA() {
  return getToken(RpgParser::KEYWORD_DTAARA, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXPORT() {
  return getToken(RpgParser::KEYWORD_EXPORT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXT() {
  return getToken(RpgParser::KEYWORD_EXT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTFLD() {
  return getToken(RpgParser::KEYWORD_EXTFLD, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTFMT() {
  return getToken(RpgParser::KEYWORD_EXTFMT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTNAME() {
  return getToken(RpgParser::KEYWORD_EXTNAME, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTPGM() {
  return getToken(RpgParser::KEYWORD_EXTPGM, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTPROC() {
  return getToken(RpgParser::KEYWORD_EXTPROC, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_FROMFILE() {
  return getToken(RpgParser::KEYWORD_FROMFILE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_IMPORT() {
  return getToken(RpgParser::KEYWORD_IMPORT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_INZ() {
  return getToken(RpgParser::KEYWORD_INZ, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_LEN() {
  return getToken(RpgParser::KEYWORD_LEN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_LIKE() {
  return getToken(RpgParser::KEYWORD_LIKE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_LIKEDS() {
  return getToken(RpgParser::KEYWORD_LIKEDS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_LIKEFILE() {
  return getToken(RpgParser::KEYWORD_LIKEFILE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_LIKEREC() {
  return getToken(RpgParser::KEYWORD_LIKEREC, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_NOOPT() {
  return getToken(RpgParser::KEYWORD_NOOPT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_OCCURS() {
  return getToken(RpgParser::KEYWORD_OCCURS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_OPDESC() {
  return getToken(RpgParser::KEYWORD_OPDESC, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_OPTIONS() {
  return getToken(RpgParser::KEYWORD_OPTIONS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_OVERLAY() {
  return getToken(RpgParser::KEYWORD_OVERLAY, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PACKEVEN() {
  return getToken(RpgParser::KEYWORD_PACKEVEN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PERRCD() {
  return getToken(RpgParser::KEYWORD_PERRCD, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PREFIX() {
  return getToken(RpgParser::KEYWORD_PREFIX, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_POS() {
  return getToken(RpgParser::KEYWORD_POS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PROCPTR() {
  return getToken(RpgParser::KEYWORD_PROCPTR, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_QUALIFIED() {
  return getToken(RpgParser::KEYWORD_QUALIFIED, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_RTNPARM() {
  return getToken(RpgParser::KEYWORD_RTNPARM, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_STATIC() {
  return getToken(RpgParser::KEYWORD_STATIC, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_TEMPLATE() {
  return getToken(RpgParser::KEYWORD_TEMPLATE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_TIMFMT() {
  return getToken(RpgParser::KEYWORD_TIMFMT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_TOFILE() {
  return getToken(RpgParser::KEYWORD_TOFILE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_VALUE() {
  return getToken(RpgParser::KEYWORD_VALUE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_VARYING() {
  return getToken(RpgParser::KEYWORD_VARYING, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_BLOCK() {
  return getToken(RpgParser::KEYWORD_BLOCK, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_COMMIT() {
  return getToken(RpgParser::KEYWORD_COMMIT, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_DEVID() {
  return getToken(RpgParser::KEYWORD_DEVID, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTDESC() {
  return getToken(RpgParser::KEYWORD_EXTDESC, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTFILE() {
  return getToken(RpgParser::KEYWORD_EXTFILE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTIND() {
  return getToken(RpgParser::KEYWORD_EXTIND, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_EXTMBR() {
  return getToken(RpgParser::KEYWORD_EXTMBR, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_FORMLEN() {
  return getToken(RpgParser::KEYWORD_FORMLEN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_FORMOFL() {
  return getToken(RpgParser::KEYWORD_FORMOFL, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_IGNORE() {
  return getToken(RpgParser::KEYWORD_IGNORE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_INCLUDE() {
  return getToken(RpgParser::KEYWORD_INCLUDE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_INDDS() {
  return getToken(RpgParser::KEYWORD_INDDS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_INFDS() {
  return getToken(RpgParser::KEYWORD_INFDS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_INFSR() {
  return getToken(RpgParser::KEYWORD_INFSR, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_KEYLOC() {
  return getToken(RpgParser::KEYWORD_KEYLOC, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_MAXDEV() {
  return getToken(RpgParser::KEYWORD_MAXDEV, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_OFLIND() {
  return getToken(RpgParser::KEYWORD_OFLIND, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PASS() {
  return getToken(RpgParser::KEYWORD_PASS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PGMNAME() {
  return getToken(RpgParser::KEYWORD_PGMNAME, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PLIST() {
  return getToken(RpgParser::KEYWORD_PLIST, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PRTCTL() {
  return getToken(RpgParser::KEYWORD_PRTCTL, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_RAFDATA() {
  return getToken(RpgParser::KEYWORD_RAFDATA, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_RECNO() {
  return getToken(RpgParser::KEYWORD_RECNO, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_RENAME() {
  return getToken(RpgParser::KEYWORD_RENAME, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_SAVEDS() {
  return getToken(RpgParser::KEYWORD_SAVEDS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_SAVEIND() {
  return getToken(RpgParser::KEYWORD_SAVEIND, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_SFILE() {
  return getToken(RpgParser::KEYWORD_SFILE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_SLN() {
  return getToken(RpgParser::KEYWORD_SLN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_USROPN() {
  return getToken(RpgParser::KEYWORD_USROPN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_DISK() {
  return getToken(RpgParser::KEYWORD_DISK, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_WORKSTN() {
  return getToken(RpgParser::KEYWORD_WORKSTN, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PRINTER() {
  return getToken(RpgParser::KEYWORD_PRINTER, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_SPECIAL() {
  return getToken(RpgParser::KEYWORD_SPECIAL, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_KEYED() {
  return getToken(RpgParser::KEYWORD_KEYED, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_USAGE() {
  return getToken(RpgParser::KEYWORD_USAGE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::KEYWORD_PSDS() {
  return getToken(RpgParser::KEYWORD_PSDS, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::UDATE() {
  return getToken(RpgParser::UDATE, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::UMONTH() {
  return getToken(RpgParser::UMONTH, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::UYEAR() {
  return getToken(RpgParser::UYEAR, 0);
}

tree::TerminalNode* RpgParser::IdOrKeywordContext::UDAY() {
  return getToken(RpgParser::UDAY, 0);
}

RpgParser::DatatypeNameContext* RpgParser::IdOrKeywordContext::datatypeName() {
  return getRuleContext<RpgParser::DatatypeNameContext>(0);
}


size_t RpgParser::IdOrKeywordContext::getRuleIndex() const {
  return RpgParser::RuleIdOrKeyword;
}

void RpgParser::IdOrKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdOrKeyword(this);
}

void RpgParser::IdOrKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdOrKeyword(this);
}


antlrcpp::Any RpgParser::IdOrKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIdOrKeyword(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::IdOrKeywordContext* RpgParser::idOrKeyword() {
  IdOrKeywordContext *_localctx = _tracker.createInstance<IdOrKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1170, RpgParser::RuleIdOrKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5870);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case RpgParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(5781);
        match(RpgParser::ID);
        break;
      }

      case RpgParser::KEYWORD_ALIAS: {
        enterOuterAlt(_localctx, 2);
        setState(5782);
        match(RpgParser::KEYWORD_ALIAS);
        break;
      }

      case RpgParser::KEYWORD_ALIGN: {
        enterOuterAlt(_localctx, 3);
        setState(5783);
        match(RpgParser::KEYWORD_ALIGN);
        break;
      }

      case RpgParser::KEYWORD_ALT: {
        enterOuterAlt(_localctx, 4);
        setState(5784);
        match(RpgParser::KEYWORD_ALT);
        break;
      }

      case RpgParser::KEYWORD_ALTSEQ: {
        enterOuterAlt(_localctx, 5);
        setState(5785);
        match(RpgParser::KEYWORD_ALTSEQ);
        break;
      }

      case RpgParser::KEYWORD_ASCEND: {
        enterOuterAlt(_localctx, 6);
        setState(5786);
        match(RpgParser::KEYWORD_ASCEND);
        break;
      }

      case RpgParser::KEYWORD_BASED: {
        enterOuterAlt(_localctx, 7);
        setState(5787);
        match(RpgParser::KEYWORD_BASED);
        break;
      }

      case RpgParser::KEYWORD_CCSID: {
        enterOuterAlt(_localctx, 8);
        setState(5788);
        match(RpgParser::KEYWORD_CCSID);
        break;
      }

      case RpgParser::KEYWORD_CLASS: {
        enterOuterAlt(_localctx, 9);
        setState(5789);
        match(RpgParser::KEYWORD_CLASS);
        break;
      }

      case RpgParser::KEYWORD_CONST: {
        enterOuterAlt(_localctx, 10);
        setState(5790);
        match(RpgParser::KEYWORD_CONST);
        break;
      }

      case RpgParser::KEYWORD_CTDATA: {
        enterOuterAlt(_localctx, 11);
        setState(5791);
        match(RpgParser::KEYWORD_CTDATA);
        break;
      }

      case RpgParser::KEYWORD_DATFMT: {
        enterOuterAlt(_localctx, 12);
        setState(5792);
        match(RpgParser::KEYWORD_DATFMT);
        break;
      }

      case RpgParser::KEYWORD_DESCEND: {
        enterOuterAlt(_localctx, 13);
        setState(5793);
        match(RpgParser::KEYWORD_DESCEND);
        break;
      }

      case RpgParser::KEYWORD_DIM: {
        enterOuterAlt(_localctx, 14);
        setState(5794);
        match(RpgParser::KEYWORD_DIM);
        break;
      }

      case RpgParser::KEYWORD_DTAARA: {
        enterOuterAlt(_localctx, 15);
        setState(5795);
        match(RpgParser::KEYWORD_DTAARA);
        break;
      }

      case RpgParser::KEYWORD_EXPORT: {
        enterOuterAlt(_localctx, 16);
        setState(5796);
        match(RpgParser::KEYWORD_EXPORT);
        break;
      }

      case RpgParser::KEYWORD_EXT: {
        enterOuterAlt(_localctx, 17);
        setState(5797);
        match(RpgParser::KEYWORD_EXT);
        break;
      }

      case RpgParser::KEYWORD_EXTFLD: {
        enterOuterAlt(_localctx, 18);
        setState(5798);
        match(RpgParser::KEYWORD_EXTFLD);
        break;
      }

      case RpgParser::KEYWORD_EXTFMT: {
        enterOuterAlt(_localctx, 19);
        setState(5799);
        match(RpgParser::KEYWORD_EXTFMT);
        break;
      }

      case RpgParser::KEYWORD_EXTNAME: {
        enterOuterAlt(_localctx, 20);
        setState(5800);
        match(RpgParser::KEYWORD_EXTNAME);
        break;
      }

      case RpgParser::KEYWORD_EXTPGM: {
        enterOuterAlt(_localctx, 21);
        setState(5801);
        match(RpgParser::KEYWORD_EXTPGM);
        break;
      }

      case RpgParser::KEYWORD_EXTPROC: {
        enterOuterAlt(_localctx, 22);
        setState(5802);
        match(RpgParser::KEYWORD_EXTPROC);
        break;
      }

      case RpgParser::KEYWORD_FROMFILE: {
        enterOuterAlt(_localctx, 23);
        setState(5803);
        match(RpgParser::KEYWORD_FROMFILE);
        break;
      }

      case RpgParser::KEYWORD_IMPORT: {
        enterOuterAlt(_localctx, 24);
        setState(5804);
        match(RpgParser::KEYWORD_IMPORT);
        break;
      }

      case RpgParser::KEYWORD_INZ: {
        enterOuterAlt(_localctx, 25);
        setState(5805);
        match(RpgParser::KEYWORD_INZ);
        break;
      }

      case RpgParser::KEYWORD_LEN: {
        enterOuterAlt(_localctx, 26);
        setState(5806);
        match(RpgParser::KEYWORD_LEN);
        break;
      }

      case RpgParser::KEYWORD_LIKE: {
        enterOuterAlt(_localctx, 27);
        setState(5807);
        match(RpgParser::KEYWORD_LIKE);
        break;
      }

      case RpgParser::KEYWORD_LIKEDS: {
        enterOuterAlt(_localctx, 28);
        setState(5808);
        match(RpgParser::KEYWORD_LIKEDS);
        break;
      }

      case RpgParser::KEYWORD_LIKEFILE: {
        enterOuterAlt(_localctx, 29);
        setState(5809);
        match(RpgParser::KEYWORD_LIKEFILE);
        break;
      }

      case RpgParser::KEYWORD_LIKEREC: {
        enterOuterAlt(_localctx, 30);
        setState(5810);
        match(RpgParser::KEYWORD_LIKEREC);
        break;
      }

      case RpgParser::KEYWORD_NOOPT: {
        enterOuterAlt(_localctx, 31);
        setState(5811);
        match(RpgParser::KEYWORD_NOOPT);
        break;
      }

      case RpgParser::KEYWORD_OCCURS: {
        enterOuterAlt(_localctx, 32);
        setState(5812);
        match(RpgParser::KEYWORD_OCCURS);
        break;
      }

      case RpgParser::KEYWORD_OPDESC: {
        enterOuterAlt(_localctx, 33);
        setState(5813);
        match(RpgParser::KEYWORD_OPDESC);
        break;
      }

      case RpgParser::KEYWORD_OPTIONS: {
        enterOuterAlt(_localctx, 34);
        setState(5814);
        match(RpgParser::KEYWORD_OPTIONS);
        break;
      }

      case RpgParser::KEYWORD_OVERLAY: {
        enterOuterAlt(_localctx, 35);
        setState(5815);
        match(RpgParser::KEYWORD_OVERLAY);
        break;
      }

      case RpgParser::KEYWORD_PACKEVEN: {
        enterOuterAlt(_localctx, 36);
        setState(5816);
        match(RpgParser::KEYWORD_PACKEVEN);
        break;
      }

      case RpgParser::KEYWORD_PERRCD: {
        enterOuterAlt(_localctx, 37);
        setState(5817);
        match(RpgParser::KEYWORD_PERRCD);
        break;
      }

      case RpgParser::KEYWORD_PREFIX: {
        enterOuterAlt(_localctx, 38);
        setState(5818);
        match(RpgParser::KEYWORD_PREFIX);
        break;
      }

      case RpgParser::KEYWORD_POS: {
        enterOuterAlt(_localctx, 39);
        setState(5819);
        match(RpgParser::KEYWORD_POS);
        break;
      }

      case RpgParser::KEYWORD_PROCPTR: {
        enterOuterAlt(_localctx, 40);
        setState(5820);
        match(RpgParser::KEYWORD_PROCPTR);
        break;
      }

      case RpgParser::KEYWORD_QUALIFIED: {
        enterOuterAlt(_localctx, 41);
        setState(5821);
        match(RpgParser::KEYWORD_QUALIFIED);
        break;
      }

      case RpgParser::KEYWORD_RTNPARM: {
        enterOuterAlt(_localctx, 42);
        setState(5822);
        match(RpgParser::KEYWORD_RTNPARM);
        break;
      }

      case RpgParser::KEYWORD_STATIC: {
        enterOuterAlt(_localctx, 43);
        setState(5823);
        match(RpgParser::KEYWORD_STATIC);
        break;
      }

      case RpgParser::KEYWORD_TEMPLATE: {
        enterOuterAlt(_localctx, 44);
        setState(5824);
        match(RpgParser::KEYWORD_TEMPLATE);
        break;
      }

      case RpgParser::KEYWORD_TIMFMT: {
        enterOuterAlt(_localctx, 45);
        setState(5825);
        match(RpgParser::KEYWORD_TIMFMT);
        break;
      }

      case RpgParser::KEYWORD_TOFILE: {
        enterOuterAlt(_localctx, 46);
        setState(5826);
        match(RpgParser::KEYWORD_TOFILE);
        break;
      }

      case RpgParser::KEYWORD_VALUE: {
        enterOuterAlt(_localctx, 47);
        setState(5827);
        match(RpgParser::KEYWORD_VALUE);
        break;
      }

      case RpgParser::KEYWORD_VARYING: {
        enterOuterAlt(_localctx, 48);
        setState(5828);
        match(RpgParser::KEYWORD_VARYING);
        break;
      }

      case RpgParser::KEYWORD_BLOCK: {
        enterOuterAlt(_localctx, 49);
        setState(5829);
        match(RpgParser::KEYWORD_BLOCK);
        break;
      }

      case RpgParser::KEYWORD_COMMIT: {
        enterOuterAlt(_localctx, 50);
        setState(5830);
        match(RpgParser::KEYWORD_COMMIT);
        break;
      }

      case RpgParser::KEYWORD_DEVID: {
        enterOuterAlt(_localctx, 51);
        setState(5831);
        match(RpgParser::KEYWORD_DEVID);
        break;
      }

      case RpgParser::KEYWORD_EXTDESC: {
        enterOuterAlt(_localctx, 52);
        setState(5832);
        match(RpgParser::KEYWORD_EXTDESC);
        break;
      }

      case RpgParser::KEYWORD_EXTFILE: {
        enterOuterAlt(_localctx, 53);
        setState(5833);
        match(RpgParser::KEYWORD_EXTFILE);
        break;
      }

      case RpgParser::KEYWORD_EXTIND: {
        enterOuterAlt(_localctx, 54);
        setState(5834);
        match(RpgParser::KEYWORD_EXTIND);
        break;
      }

      case RpgParser::KEYWORD_EXTMBR: {
        enterOuterAlt(_localctx, 55);
        setState(5835);
        match(RpgParser::KEYWORD_EXTMBR);
        break;
      }

      case RpgParser::KEYWORD_FORMLEN: {
        enterOuterAlt(_localctx, 56);
        setState(5836);
        match(RpgParser::KEYWORD_FORMLEN);
        break;
      }

      case RpgParser::KEYWORD_FORMOFL: {
        enterOuterAlt(_localctx, 57);
        setState(5837);
        match(RpgParser::KEYWORD_FORMOFL);
        break;
      }

      case RpgParser::KEYWORD_IGNORE: {
        enterOuterAlt(_localctx, 58);
        setState(5838);
        match(RpgParser::KEYWORD_IGNORE);
        break;
      }

      case RpgParser::KEYWORD_INCLUDE: {
        enterOuterAlt(_localctx, 59);
        setState(5839);
        match(RpgParser::KEYWORD_INCLUDE);
        break;
      }

      case RpgParser::KEYWORD_INDDS: {
        enterOuterAlt(_localctx, 60);
        setState(5840);
        match(RpgParser::KEYWORD_INDDS);
        break;
      }

      case RpgParser::KEYWORD_INFDS: {
        enterOuterAlt(_localctx, 61);
        setState(5841);
        match(RpgParser::KEYWORD_INFDS);
        break;
      }

      case RpgParser::KEYWORD_INFSR: {
        enterOuterAlt(_localctx, 62);
        setState(5842);
        match(RpgParser::KEYWORD_INFSR);
        break;
      }

      case RpgParser::KEYWORD_KEYLOC: {
        enterOuterAlt(_localctx, 63);
        setState(5843);
        match(RpgParser::KEYWORD_KEYLOC);
        break;
      }

      case RpgParser::KEYWORD_MAXDEV: {
        enterOuterAlt(_localctx, 64);
        setState(5844);
        match(RpgParser::KEYWORD_MAXDEV);
        break;
      }

      case RpgParser::KEYWORD_OFLIND: {
        enterOuterAlt(_localctx, 65);
        setState(5845);
        match(RpgParser::KEYWORD_OFLIND);
        break;
      }

      case RpgParser::KEYWORD_PASS: {
        enterOuterAlt(_localctx, 66);
        setState(5846);
        match(RpgParser::KEYWORD_PASS);
        break;
      }

      case RpgParser::KEYWORD_PGMNAME: {
        enterOuterAlt(_localctx, 67);
        setState(5847);
        match(RpgParser::KEYWORD_PGMNAME);
        break;
      }

      case RpgParser::KEYWORD_PLIST: {
        enterOuterAlt(_localctx, 68);
        setState(5848);
        match(RpgParser::KEYWORD_PLIST);
        break;
      }

      case RpgParser::KEYWORD_PRTCTL: {
        enterOuterAlt(_localctx, 69);
        setState(5849);
        match(RpgParser::KEYWORD_PRTCTL);
        break;
      }

      case RpgParser::KEYWORD_RAFDATA: {
        enterOuterAlt(_localctx, 70);
        setState(5850);
        match(RpgParser::KEYWORD_RAFDATA);
        break;
      }

      case RpgParser::KEYWORD_RECNO: {
        enterOuterAlt(_localctx, 71);
        setState(5851);
        match(RpgParser::KEYWORD_RECNO);
        break;
      }

      case RpgParser::KEYWORD_RENAME: {
        enterOuterAlt(_localctx, 72);
        setState(5852);
        match(RpgParser::KEYWORD_RENAME);
        break;
      }

      case RpgParser::KEYWORD_SAVEDS: {
        enterOuterAlt(_localctx, 73);
        setState(5853);
        match(RpgParser::KEYWORD_SAVEDS);
        break;
      }

      case RpgParser::KEYWORD_SAVEIND: {
        enterOuterAlt(_localctx, 74);
        setState(5854);
        match(RpgParser::KEYWORD_SAVEIND);
        break;
      }

      case RpgParser::KEYWORD_SFILE: {
        enterOuterAlt(_localctx, 75);
        setState(5855);
        match(RpgParser::KEYWORD_SFILE);
        break;
      }

      case RpgParser::KEYWORD_SLN: {
        enterOuterAlt(_localctx, 76);
        setState(5856);
        match(RpgParser::KEYWORD_SLN);
        break;
      }

      case RpgParser::KEYWORD_USROPN: {
        enterOuterAlt(_localctx, 77);
        setState(5857);
        match(RpgParser::KEYWORD_USROPN);
        break;
      }

      case RpgParser::KEYWORD_DISK: {
        enterOuterAlt(_localctx, 78);
        setState(5858);
        match(RpgParser::KEYWORD_DISK);
        break;
      }

      case RpgParser::KEYWORD_WORKSTN: {
        enterOuterAlt(_localctx, 79);
        setState(5859);
        match(RpgParser::KEYWORD_WORKSTN);
        break;
      }

      case RpgParser::KEYWORD_PRINTER: {
        enterOuterAlt(_localctx, 80);
        setState(5860);
        match(RpgParser::KEYWORD_PRINTER);
        break;
      }

      case RpgParser::KEYWORD_SPECIAL: {
        enterOuterAlt(_localctx, 81);
        setState(5861);
        match(RpgParser::KEYWORD_SPECIAL);
        break;
      }

      case RpgParser::KEYWORD_KEYED: {
        enterOuterAlt(_localctx, 82);
        setState(5862);
        match(RpgParser::KEYWORD_KEYED);
        break;
      }

      case RpgParser::KEYWORD_USAGE: {
        enterOuterAlt(_localctx, 83);
        setState(5863);
        match(RpgParser::KEYWORD_USAGE);
        break;
      }

      case RpgParser::KEYWORD_PSDS: {
        enterOuterAlt(_localctx, 84);
        setState(5864);
        match(RpgParser::KEYWORD_PSDS);
        break;
      }

      case RpgParser::UDATE: {
        enterOuterAlt(_localctx, 85);
        setState(5865);
        match(RpgParser::UDATE);
        break;
      }

      case RpgParser::UMONTH: {
        enterOuterAlt(_localctx, 86);
        setState(5866);
        match(RpgParser::UMONTH);
        break;
      }

      case RpgParser::UYEAR: {
        enterOuterAlt(_localctx, 87);
        setState(5867);
        match(RpgParser::UYEAR);
        break;
      }

      case RpgParser::UDAY: {
        enterOuterAlt(_localctx, 88);
        setState(5868);
        match(RpgParser::UDAY);
        break;
      }

      case RpgParser::CHAR:
      case RpgParser::VARCHAR:
      case RpgParser::UCS2:
      case RpgParser::DATE_:
      case RpgParser::VARUCS2:
      case RpgParser::GRAPH:
      case RpgParser::VARGRAPH:
      case RpgParser::IND:
      case RpgParser::PACKED:
      case RpgParser::ZONED:
      case RpgParser::BINDEC:
      case RpgParser::INT:
      case RpgParser::UNS:
      case RpgParser::FLOAT:
      case RpgParser::TIME:
      case RpgParser::TIMESTAMP:
      case RpgParser::POINTER:
      case RpgParser::OBJECT: {
        enterOuterAlt(_localctx, 89);
        setState(5869);
        datatypeName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

RpgParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::ArgumentContext::ID() {
  return getToken(RpgParser::ID, 0);
}


size_t RpgParser::ArgumentContext::getRuleIndex() const {
  return RpgParser::RuleArgument;
}

void RpgParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void RpgParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}


antlrcpp::Any RpgParser::ArgumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitArgument(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::ArgumentContext* RpgParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 1172, RpgParser::RuleArgument);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5872);
    match(RpgParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolicConstantsContext ------------------------------------------------------------------

RpgParser::SymbolicConstantsContext::SymbolicConstantsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ALL() {
  return getToken(RpgParser::SPLAT_ALL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_NONE() {
  return getToken(RpgParser::SPLAT_NONE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_NO() {
  return getToken(RpgParser::SPLAT_NO, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_YES() {
  return getToken(RpgParser::SPLAT_YES, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ILERPG() {
  return getToken(RpgParser::SPLAT_ILERPG, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_COMPAT() {
  return getToken(RpgParser::SPLAT_COMPAT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CRTBNDRPG() {
  return getToken(RpgParser::SPLAT_CRTBNDRPG, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CRTRPGMOD() {
  return getToken(RpgParser::SPLAT_CRTRPGMOD, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_VRM() {
  return getToken(RpgParser::SPLAT_VRM, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ALLG() {
  return getToken(RpgParser::SPLAT_ALLG, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ALLU() {
  return getToken(RpgParser::SPLAT_ALLU, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ALLTHREAD() {
  return getToken(RpgParser::SPLAT_ALLTHREAD, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ALLX() {
  return getToken(RpgParser::SPLAT_ALLX, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_BLANKS() {
  return getToken(RpgParser::SPLAT_BLANKS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CANCL() {
  return getToken(RpgParser::SPLAT_CANCL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CYMD() {
  return getToken(RpgParser::SPLAT_CYMD, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CMDY() {
  return getToken(RpgParser::SPLAT_CMDY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CDMY() {
  return getToken(RpgParser::SPLAT_CDMY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MDY() {
  return getToken(RpgParser::SPLAT_MDY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DMY() {
  return getToken(RpgParser::SPLAT_DMY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DFT() {
  return getToken(RpgParser::SPLAT_DFT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_YMD() {
  return getToken(RpgParser::SPLAT_YMD, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_JUL() {
  return getToken(RpgParser::SPLAT_JUL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_INPUT() {
  return getToken(RpgParser::SPLAT_INPUT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_OUTPUT() {
  return getToken(RpgParser::SPLAT_OUTPUT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ISO() {
  return getToken(RpgParser::SPLAT_ISO, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_KEY() {
  return getToken(RpgParser::SPLAT_KEY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_NEXT() {
  return getToken(RpgParser::SPLAT_NEXT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_USA() {
  return getToken(RpgParser::SPLAT_USA, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_EUR() {
  return getToken(RpgParser::SPLAT_EUR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_JIS() {
  return getToken(RpgParser::SPLAT_JIS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_JAVA() {
  return getToken(RpgParser::SPLAT_JAVA, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DATE() {
  return getToken(RpgParser::SPLAT_DATE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DAY() {
  return getToken(RpgParser::SPLAT_DAY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPlAT_DETC() {
  return getToken(RpgParser::SPlAT_DETC, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DETL() {
  return getToken(RpgParser::SPLAT_DETL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DTAARA() {
  return getToken(RpgParser::SPLAT_DTAARA, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_END() {
  return getToken(RpgParser::SPLAT_END, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ENTRY() {
  return getToken(RpgParser::SPLAT_ENTRY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_EQUATE() {
  return getToken(RpgParser::SPLAT_EQUATE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_EXTDFT() {
  return getToken(RpgParser::SPLAT_EXTDFT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_EXT() {
  return getToken(RpgParser::SPLAT_EXT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_FILE() {
  return getToken(RpgParser::SPLAT_FILE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_GETIN() {
  return getToken(RpgParser::SPLAT_GETIN, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_HIVAL() {
  return getToken(RpgParser::SPLAT_HIVAL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_INIT() {
  return getToken(RpgParser::SPLAT_INIT, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_INDICATOR() {
  return getToken(RpgParser::SPLAT_INDICATOR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_INZSR() {
  return getToken(RpgParser::SPLAT_INZSR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_IN() {
  return getToken(RpgParser::SPLAT_IN, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_JOBRUN() {
  return getToken(RpgParser::SPLAT_JOBRUN, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_JOB() {
  return getToken(RpgParser::SPLAT_JOB, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_LDA() {
  return getToken(RpgParser::SPLAT_LDA, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_LIKE() {
  return getToken(RpgParser::SPLAT_LIKE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_LONGJUL() {
  return getToken(RpgParser::SPLAT_LONGJUL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_LOVAL() {
  return getToken(RpgParser::SPLAT_LOVAL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MONTH() {
  return getToken(RpgParser::SPLAT_MONTH, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_NOIND() {
  return getToken(RpgParser::SPLAT_NOIND, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_NOKEY() {
  return getToken(RpgParser::SPLAT_NOKEY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_NULL() {
  return getToken(RpgParser::SPLAT_NULL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_OFL() {
  return getToken(RpgParser::SPLAT_OFL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ON() {
  return getToken(RpgParser::SPLAT_ON, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ONLY() {
  return getToken(RpgParser::SPLAT_ONLY, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_OFF() {
  return getToken(RpgParser::SPLAT_OFF, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_PDA() {
  return getToken(RpgParser::SPLAT_PDA, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_PLACE() {
  return getToken(RpgParser::SPLAT_PLACE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_PSSR() {
  return getToken(RpgParser::SPLAT_PSSR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ROUTINE() {
  return getToken(RpgParser::SPLAT_ROUTINE, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_START() {
  return getToken(RpgParser::SPLAT_START, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_SYS() {
  return getToken(RpgParser::SPLAT_SYS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_TERM() {
  return getToken(RpgParser::SPLAT_TERM, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_TOTC() {
  return getToken(RpgParser::SPLAT_TOTC, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_TOTL() {
  return getToken(RpgParser::SPLAT_TOTL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_USER() {
  return getToken(RpgParser::SPLAT_USER, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_VAR() {
  return getToken(RpgParser::SPLAT_VAR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_YEAR() {
  return getToken(RpgParser::SPLAT_YEAR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ZEROS() {
  return getToken(RpgParser::SPLAT_ZEROS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_HMS() {
  return getToken(RpgParser::SPLAT_HMS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_INLR() {
  return getToken(RpgParser::SPLAT_INLR, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_INOF() {
  return getToken(RpgParser::SPLAT_INOF, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DATA() {
  return getToken(RpgParser::SPLAT_DATA, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_ASTFILL() {
  return getToken(RpgParser::SPLAT_ASTFILL, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_CURSYM() {
  return getToken(RpgParser::SPLAT_CURSYM, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MAX() {
  return getToken(RpgParser::SPLAT_MAX, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_LOCK() {
  return getToken(RpgParser::SPLAT_LOCK, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_PROGRAM() {
  return getToken(RpgParser::SPLAT_PROGRAM, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_D() {
  return getToken(RpgParser::SPLAT_D, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_DAYS() {
  return getToken(RpgParser::SPLAT_DAYS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_H() {
  return getToken(RpgParser::SPLAT_H, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_HOURS() {
  return getToken(RpgParser::SPLAT_HOURS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_M() {
  return getToken(RpgParser::SPLAT_M, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MINUTES() {
  return getToken(RpgParser::SPLAT_MINUTES, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MONTHS() {
  return getToken(RpgParser::SPLAT_MONTHS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MN() {
  return getToken(RpgParser::SPLAT_MN, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MS() {
  return getToken(RpgParser::SPLAT_MS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_MSECONDS() {
  return getToken(RpgParser::SPLAT_MSECONDS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_S() {
  return getToken(RpgParser::SPLAT_S, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_SECONDS() {
  return getToken(RpgParser::SPLAT_SECONDS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_Y() {
  return getToken(RpgParser::SPLAT_Y, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_YEARS() {
  return getToken(RpgParser::SPLAT_YEARS, 0);
}

tree::TerminalNode* RpgParser::SymbolicConstantsContext::SPLAT_EXTDESC() {
  return getToken(RpgParser::SPLAT_EXTDESC, 0);
}


size_t RpgParser::SymbolicConstantsContext::getRuleIndex() const {
  return RpgParser::RuleSymbolicConstants;
}

void RpgParser::SymbolicConstantsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolicConstants(this);
}

void RpgParser::SymbolicConstantsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolicConstants(this);
}


antlrcpp::Any RpgParser::SymbolicConstantsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSymbolicConstants(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::SymbolicConstantsContext* RpgParser::symbolicConstants() {
  SymbolicConstantsContext *_localctx = _tracker.createInstance<SymbolicConstantsContext>(_ctx, getState());
  enterRule(_localctx, 1174, RpgParser::RuleSymbolicConstants);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5874);
    _la = _input->LA(1);
    if (!(((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & ((1ULL << (RpgParser::SPLAT_ALL - 212))
      | (1ULL << (RpgParser::SPLAT_NONE - 212))
      | (1ULL << (RpgParser::SPLAT_YES - 212))
      | (1ULL << (RpgParser::SPLAT_NO - 212))
      | (1ULL << (RpgParser::SPLAT_ILERPG - 212))
      | (1ULL << (RpgParser::SPLAT_COMPAT - 212))
      | (1ULL << (RpgParser::SPLAT_CRTBNDRPG - 212))
      | (1ULL << (RpgParser::SPLAT_CRTRPGMOD - 212))
      | (1ULL << (RpgParser::SPLAT_VRM - 212))
      | (1ULL << (RpgParser::SPLAT_ALLG - 212))
      | (1ULL << (RpgParser::SPLAT_ALLU - 212))
      | (1ULL << (RpgParser::SPLAT_ALLTHREAD - 212))
      | (1ULL << (RpgParser::SPLAT_ALLX - 212))
      | (1ULL << (RpgParser::SPLAT_BLANKS - 212))
      | (1ULL << (RpgParser::SPLAT_CANCL - 212))
      | (1ULL << (RpgParser::SPLAT_CYMD - 212))
      | (1ULL << (RpgParser::SPLAT_CMDY - 212))
      | (1ULL << (RpgParser::SPLAT_CDMY - 212))
      | (1ULL << (RpgParser::SPLAT_MDY - 212))
      | (1ULL << (RpgParser::SPLAT_DMY - 212))
      | (1ULL << (RpgParser::SPLAT_DFT - 212))
      | (1ULL << (RpgParser::SPLAT_YMD - 212))
      | (1ULL << (RpgParser::SPLAT_JUL - 212))
      | (1ULL << (RpgParser::SPLAT_JAVA - 212))
      | (1ULL << (RpgParser::SPLAT_ISO - 212))
      | (1ULL << (RpgParser::SPLAT_USA - 212))
      | (1ULL << (RpgParser::SPLAT_EUR - 212))
      | (1ULL << (RpgParser::SPLAT_JIS - 212))
      | (1ULL << (RpgParser::SPLAT_DATE - 212))
      | (1ULL << (RpgParser::SPLAT_DAY - 212))
      | (1ULL << (RpgParser::SPlAT_DETC - 212))
      | (1ULL << (RpgParser::SPLAT_DETL - 212))
      | (1ULL << (RpgParser::SPLAT_DTAARA - 212))
      | (1ULL << (RpgParser::SPLAT_END - 212))
      | (1ULL << (RpgParser::SPLAT_ENTRY - 212))
      | (1ULL << (RpgParser::SPLAT_EQUATE - 212))
      | (1ULL << (RpgParser::SPLAT_EXTDFT - 212))
      | (1ULL << (RpgParser::SPLAT_EXT - 212))
      | (1ULL << (RpgParser::SPLAT_FILE - 212))
      | (1ULL << (RpgParser::SPLAT_GETIN - 212))
      | (1ULL << (RpgParser::SPLAT_HIVAL - 212))
      | (1ULL << (RpgParser::SPLAT_INIT - 212))
      | (1ULL << (RpgParser::SPLAT_INDICATOR - 212))
      | (1ULL << (RpgParser::SPLAT_INZSR - 212))
      | (1ULL << (RpgParser::SPLAT_IN - 212))
      | (1ULL << (RpgParser::SPLAT_INPUT - 212))
      | (1ULL << (RpgParser::SPLAT_OUTPUT - 212))
      | (1ULL << (RpgParser::SPLAT_JOBRUN - 212))
      | (1ULL << (RpgParser::SPLAT_JOB - 212))
      | (1ULL << (RpgParser::SPLAT_LDA - 212))
      | (1ULL << (RpgParser::SPLAT_LIKE - 212))
      | (1ULL << (RpgParser::SPLAT_LONGJUL - 212))
      | (1ULL << (RpgParser::SPLAT_LOVAL - 212))
      | (1ULL << (RpgParser::SPLAT_KEY - 212))
      | (1ULL << (RpgParser::SPLAT_MONTH - 212))
      | (1ULL << (RpgParser::SPLAT_NEXT - 212))
      | (1ULL << (RpgParser::SPLAT_NOIND - 212))
      | (1ULL << (RpgParser::SPLAT_NOKEY - 212))
      | (1ULL << (RpgParser::SPLAT_NULL - 212))
      | (1ULL << (RpgParser::SPLAT_OFL - 212))
      | (1ULL << (RpgParser::SPLAT_ON - 212))
      | (1ULL << (RpgParser::SPLAT_ONLY - 212))
      | (1ULL << (RpgParser::SPLAT_OFF - 212))
      | (1ULL << (RpgParser::SPLAT_PDA - 212)))) != 0) || ((((_la - 276) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 276)) & ((1ULL << (RpgParser::SPLAT_PLACE - 276))
      | (1ULL << (RpgParser::SPLAT_PSSR - 276))
      | (1ULL << (RpgParser::SPLAT_ROUTINE - 276))
      | (1ULL << (RpgParser::SPLAT_START - 276))
      | (1ULL << (RpgParser::SPLAT_SYS - 276))
      | (1ULL << (RpgParser::SPLAT_TERM - 276))
      | (1ULL << (RpgParser::SPLAT_TOTC - 276))
      | (1ULL << (RpgParser::SPLAT_TOTL - 276))
      | (1ULL << (RpgParser::SPLAT_USER - 276))
      | (1ULL << (RpgParser::SPLAT_VAR - 276))
      | (1ULL << (RpgParser::SPLAT_YEAR - 276))
      | (1ULL << (RpgParser::SPLAT_ZEROS - 276))
      | (1ULL << (RpgParser::SPLAT_HMS - 276))
      | (1ULL << (RpgParser::SPLAT_INLR - 276))
      | (1ULL << (RpgParser::SPLAT_INOF - 276))
      | (1ULL << (RpgParser::SPLAT_DATA - 276))
      | (1ULL << (RpgParser::SPLAT_ASTFILL - 276))
      | (1ULL << (RpgParser::SPLAT_CURSYM - 276))
      | (1ULL << (RpgParser::SPLAT_MAX - 276))
      | (1ULL << (RpgParser::SPLAT_LOCK - 276))
      | (1ULL << (RpgParser::SPLAT_PROGRAM - 276))
      | (1ULL << (RpgParser::SPLAT_EXTDESC - 276))
      | (1ULL << (RpgParser::SPLAT_D - 276))
      | (1ULL << (RpgParser::SPLAT_H - 276))
      | (1ULL << (RpgParser::SPLAT_HOURS - 276))
      | (1ULL << (RpgParser::SPLAT_DAYS - 276))
      | (1ULL << (RpgParser::SPLAT_M - 276))
      | (1ULL << (RpgParser::SPLAT_MINUTES - 276))
      | (1ULL << (RpgParser::SPLAT_MONTHS - 276))
      | (1ULL << (RpgParser::SPLAT_MN - 276))
      | (1ULL << (RpgParser::SPLAT_MS - 276))
      | (1ULL << (RpgParser::SPLAT_MSECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_S - 276))
      | (1ULL << (RpgParser::SPLAT_SECONDS - 276))
      | (1ULL << (RpgParser::SPLAT_Y - 276))
      | (1ULL << (RpgParser::SPLAT_YEARS - 276)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TargetContext ------------------------------------------------------------------

RpgParser::TargetContext::TargetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t RpgParser::TargetContext::getRuleIndex() const {
  return RpgParser::RuleTarget;
}

void RpgParser::TargetContext::copyFrom(TargetContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- GlobalIndicatorTargetContext ------------------------------------------------------------------

tree::TerminalNode* RpgParser::GlobalIndicatorTargetContext::SPLAT_IN() {
  return getToken(RpgParser::SPLAT_IN, 0);
}

RpgParser::GlobalIndicatorTargetContext::GlobalIndicatorTargetContext(TargetContext *ctx) { copyFrom(ctx); }

void RpgParser::GlobalIndicatorTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalIndicatorTarget(this);
}
void RpgParser::GlobalIndicatorTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalIndicatorTarget(this);
}

antlrcpp::Any RpgParser::GlobalIndicatorTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitGlobalIndicatorTarget(this);
  else
    return visitor->visitChildren(this);
}
//----------------- QualifiedTargetContext ------------------------------------------------------------------

tree::TerminalNode* RpgParser::QualifiedTargetContext::FREE_DOT() {
  return getToken(RpgParser::FREE_DOT, 0);
}

std::vector<RpgParser::IdOrKeywordContext *> RpgParser::QualifiedTargetContext::idOrKeyword() {
  return getRuleContexts<RpgParser::IdOrKeywordContext>();
}

RpgParser::IdOrKeywordContext* RpgParser::QualifiedTargetContext::idOrKeyword(size_t i) {
  return getRuleContext<RpgParser::IdOrKeywordContext>(i);
}

tree::TerminalNode* RpgParser::QualifiedTargetContext::DOT() {
  return getToken(RpgParser::DOT, 0);
}

RpgParser::QualifiedTargetContext::QualifiedTargetContext(TargetContext *ctx) { copyFrom(ctx); }

void RpgParser::QualifiedTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedTarget(this);
}
void RpgParser::QualifiedTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedTarget(this);
}

antlrcpp::Any RpgParser::QualifiedTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedTarget(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IndicatorTargetContext ------------------------------------------------------------------

tree::TerminalNode* RpgParser::IndicatorTargetContext::SPLAT_INDICATOR() {
  return getToken(RpgParser::SPLAT_INDICATOR, 0);
}

RpgParser::IndicatorTargetContext::IndicatorTargetContext(TargetContext *ctx) { copyFrom(ctx); }

void RpgParser::IndicatorTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndicatorTarget(this);
}
void RpgParser::IndicatorTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndicatorTarget(this);
}

antlrcpp::Any RpgParser::IndicatorTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIndicatorTarget(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleTargetContext ------------------------------------------------------------------

RpgParser::IdOrKeywordContext* RpgParser::SimpleTargetContext::idOrKeyword() {
  return getRuleContext<RpgParser::IdOrKeywordContext>(0);
}

RpgParser::SimpleTargetContext::SimpleTargetContext(TargetContext *ctx) { copyFrom(ctx); }

void RpgParser::SimpleTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleTarget(this);
}
void RpgParser::SimpleTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleTarget(this);
}

antlrcpp::Any RpgParser::SimpleTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSimpleTarget(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IndexedTargetContext ------------------------------------------------------------------

tree::TerminalNode* RpgParser::IndexedTargetContext::OPEN_PAREN() {
  return getToken(RpgParser::OPEN_PAREN, 0);
}

tree::TerminalNode* RpgParser::IndexedTargetContext::CLOSE_PAREN() {
  return getToken(RpgParser::CLOSE_PAREN, 0);
}

RpgParser::TargetContext* RpgParser::IndexedTargetContext::target() {
  return getRuleContext<RpgParser::TargetContext>(0);
}

RpgParser::ExpressionContext* RpgParser::IndexedTargetContext::expression() {
  return getRuleContext<RpgParser::ExpressionContext>(0);
}

RpgParser::IndexedTargetContext::IndexedTargetContext(TargetContext *ctx) { copyFrom(ctx); }

void RpgParser::IndexedTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexedTarget(this);
}
void RpgParser::IndexedTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexedTarget(this);
}

antlrcpp::Any RpgParser::IndexedTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitIndexedTarget(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubstTargetContext ------------------------------------------------------------------

RpgParser::Bif_substContext* RpgParser::SubstTargetContext::bif_subst() {
  return getRuleContext<RpgParser::Bif_substContext>(0);
}

RpgParser::SubstTargetContext::SubstTargetContext(TargetContext *ctx) { copyFrom(ctx); }

void RpgParser::SubstTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstTarget(this);
}
void RpgParser::SubstTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<RpgParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstTarget(this);
}

antlrcpp::Any RpgParser::SubstTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<RpgParserVisitor*>(visitor))
    return parserVisitor->visitSubstTarget(this);
  else
    return visitor->visitChildren(this);
}

RpgParser::TargetContext* RpgParser::target() {
   return target(0);
}

RpgParser::TargetContext* RpgParser::target(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  RpgParser::TargetContext *_localctx = _tracker.createInstance<TargetContext>(_ctx, parentState);
  RpgParser::TargetContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1176;
  enterRecursionRule(_localctx, 1176, RpgParser::RuleTarget, precedence);

    

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5889);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 515, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SimpleTargetContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(5877);
      dynamic_cast<SimpleTargetContext *>(_localctx)->name = idOrKeyword();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<QualifiedTargetContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5878);
      dynamic_cast<QualifiedTargetContext *>(_localctx)->container = idOrKeyword();
      setState(5879);
      match(RpgParser::FREE_DOT);
      setState(5880);
      dynamic_cast<QualifiedTargetContext *>(_localctx)->field = idOrKeyword();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SubstTargetContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5882);
      bif_subst();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<QualifiedTargetContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5883);
      dynamic_cast<QualifiedTargetContext *>(_localctx)->container = idOrKeyword();
      setState(5884);
      match(RpgParser::DOT);
      setState(5885);
      dynamic_cast<QualifiedTargetContext *>(_localctx)->fieldName = idOrKeyword();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<IndicatorTargetContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5887);
      dynamic_cast<IndicatorTargetContext *>(_localctx)->indic = match(RpgParser::SPLAT_INDICATOR);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<GlobalIndicatorTargetContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5888);
      match(RpgParser::SPLAT_IN);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5898);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<IndexedTargetContext>(_tracker.createInstance<TargetContext>(parentContext, parentState));
        _localctx = newContext;
        newContext->base = previousContext;
        pushNewRecursionContext(newContext, startState, RuleTarget);
        setState(5891);

        if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
        setState(5892);
        match(RpgParser::OPEN_PAREN);
        setState(5893);
        dynamic_cast<IndexedTargetContext *>(_localctx)->index = expression(0);
        setState(5894);
        match(RpgParser::CLOSE_PAREN); 
      }
      setState(5900);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

bool RpgParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 566: return expressionSempred(dynamic_cast<ExpressionContext *>(context), predicateIndex);
    case 588: return targetSempred(dynamic_cast<TargetContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool RpgParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 15);
    case 1: return precpred(_ctx, 14);
    case 2: return precpred(_ctx, 13);
    case 3: return precpred(_ctx, 12);
    case 4: return precpred(_ctx, 11);
    case 5: return precpred(_ctx, 10);
    case 6: return precpred(_ctx, 9);
    case 7: return precpred(_ctx, 8);
    case 8: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

bool RpgParser::targetSempred(TargetContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return precpred(_ctx, 5);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> RpgParser::_decisionToDFA;
atn::PredictionContextCache RpgParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN RpgParser::_atn;
std::vector<uint16_t> RpgParser::_serializedATN;

std::vector<std::string> RpgParser::_ruleNames = {
  "r", "statement", "endSourceBlock", "endSource", "endSourceHead", "endSourceLine", 
  "endSourceLineText", "star_comments", "free_comments", "free_linecomments", 
  "comments", "dspec", "dspecConstant", "datatype", "keyword", "dspec_bif", 
  "keyword_alias", "keyword_align", "keyword_alt", "keyword_altseq", "keyword_ascend", 
  "keyword_based", "keyword_ccsid", "keyword_class", "keyword_const", "keyword_ctdata", 
  "keyword_datfmt", "dateSeparator", "keyword_descend", "keyword_dim", "keyword_dtaara", 
  "keyword_export", "keyword_ext", "keyword_extfld", "keyword_extfmt", "keyword_extname", 
  "keyword_extpgm", "keyword_extproc", "keyword_fromfile", "keyword_import", 
  "keyword_inz", "keyword_len", "keyword_like", "keyword_likeds", "keyword_likefile", 
  "keyword_likerec", "keyword_noopt", "keyword_occurs", "keyword_opdesc", 
  "keyword_options", "keyword_overlay", "keyword_packeven", "keyword_perrcd", 
  "keyword_prefix", "keyword_pos", "keyword_procptr", "keyword_qualified", 
  "keyword_rtnparm", "keyword_static", "keyword_sqltype", "keyword_template", 
  "keyword_timfmt", "keyword_tofile", "keyword_value", "keyword_varying", 
  "keyword_psds", "keyword_block", "keyword_commit", "keyword_devid", "keyword_extdesc", 
  "keyword_extfile", "keyword_extind", "keyword_extmbr", "keyword_formlen", 
  "keyword_formofl", "keyword_ignore", "keyword_include", "keyword_indds", 
  "keyword_infds", "keyword_infsr", "keyword_keyloc", "keyword_maxdev", 
  "keyword_oflind", "keyword_pass", "keyword_pgmname", "keyword_plist", 
  "keyword_prtctl", "keyword_rafdata", "keyword_recno", "keyword_rename", 
  "keyword_saveds", "keyword_saveind", "keyword_sfile", "keyword_sln", "keyword_usropn", 
  "keyword_disk", "keyword_workstn", "keyword_printer", "keyword_special", 
  "keyword_keyed", "keyword_usage", "like_lengthAdjustment", "sign", "dcl_ds", 
  "dcl_ds_field", "end_dcl_ds", "dcl_pr", "dcl_pr_field", "end_dcl_pr", 
  "dcl_pi", "dcl_pi_field", "end_dcl_pi", "dcl_c", "ctl_opt", "datatypeName", 
  "block", "ifstatement", "elseIfClause", "elseClause", "casestatement", 
  "casestatementend", "monitorstatement", "beginmonitor", "endmonitor", 
  "onError", "selectstatement", "other", "beginselect", "whenstatement", 
  "when", "csWHENxx", "endselect", "beginif", "begindou", "begindow", "begindo", 
  "elseifstmt", "elsestmt", "csIFxx", "csDOUxx", "csDOWxx", "complexCondxx", 
  "csANDxx", "csORxx", "forstatement", "beginfor", "endif", "enddo", "endfor", 
  "dspec_fixed", "ds_name", "ospec_fixed", "os_fixed_pgmdesc1", "outputConditioningOnOffIndicator", 
  "outputConditioningIndicator", "os_fixed_pgmdesc_compound", "os_fixed_pgmdesc2", 
  "os_fixed_pgmfield", "ps_name", "fspec", "filename", "fs_parm", "fs_string", 
  "fs_keyword", "fspec_fixed", "cspec_fixed", "cspec_continuedIndicators", 
  "cspec_blank", "blank_spec", "piBegin", "parm_fixed", "pr_parm_fixed", 
  "pi_parm_fixed", "procedure", "beginProcedure", "endProcedure", "psBegin", 
  "freeBeginProcedure", "psEnd", "freeEndProcedure", "prBegin", "subroutine", 
  "subprocedurestatement", "begsr", "endsr", "csBEGSR", "freeBEGSR", "csENDSR", 
  "freeENDSR", "onOffIndicatorsFlag", "cs_controlLevel", "cs_indicators", 
  "resultIndicator", "cspec_fixed_sql", "cspec_fixed_standard", "cspec_fixed_standard_parts", 
  "csACQ", "csADD", "csADDDUR", "csALLOC", "csANDEQ", "csANDNE", "csANDLE", 
  "csANDLT", "csANDGE", "csANDGT", "csBITOFF", "csBITON", "csCABxx", "csCABEQ", 
  "csCABNE", "csCABLE", "csCABLT", "csCABGE", "csCABGT", "csCALL", "csCALLB", 
  "csCALLP", "csCASEQ", "csCASNE", "csCASLE", "csCASLT", "csCASGE", "csCASGT", 
  "csCAS", "csCAT", "csCHAIN", "csCHECK", "csCHECKR", "csCLEAR", "csCLOSE", 
  "csCOMMIT", "csCOMP", "csDEALLOC", "csDEFINE", "csDELETE", "csDIV", "csDO", 
  "csDOU", "csDOUEQ", "csDOUNE", "csDOULE", "csDOULT", "csDOUGE", "csDOUGT", 
  "csDOW", "csDOWEQ", "csDOWNE", "csDOWLE", "csDOWLT", "csDOWGE", "csDOWGT", 
  "csDSPLY", "csDUMP", "csELSE", "csELSEIF", "csEND", "csENDCS", "csENDDO", 
  "csENDFOR", "csENDIF", "csENDMON", "csENDSL", "csEVAL", "csEVAL_CORR", 
  "csEVALR", "csEXCEPT", "csEXFMT", "csEXSR", "csEXTRCT", "csFEOD", "csFOR", 
  "byExpression", "stopExpression", "csFORCE", "csGOTO", "csIF", "csIFEQ", 
  "csIFNE", "csIFLE", "csIFLT", "csIFGE", "csIFGT", "csIN", "csITER", "csKLIST", 
  "csKFLD", "csLEAVE", "csLEAVESR", "csLOOKUP", "csMHHZO", "csMHLZO", "csMLHZO", 
  "csMLLZO", "csMONITOR", "csMOVE", "csMOVEA", "csMOVEL", "csMULT", "csMVR", 
  "csNEXT", "csOCCUR", "csON_ERROR", "onErrorCode", "csOPEN", "csOREQ", 
  "csORNE", "csORLE", "csORLT", "csORGE", "csORGT", "csOTHER", "csOUT", 
  "csPARM", "csPLIST", "csPOST", "csREAD", "csREADC", "csREADE", "csREADP", 
  "csREADPE", "csREALLOC", "csREL", "csRESET", "csRETURN", "csROLBK", "csSCAN", 
  "csSELECT", "csSETGT", "csSETLL", "csSETOFF", "csSETON", "csSHTDN", "csSORTA", 
  "csSQRT", "csSUB", "csSUBDUR", "csSUBST", "csTAG", "csTEST", "csTESTB", 
  "csTESTN", "csTESTZ", "csTIME", "csUNLOCK", "csUPDATE", "csWHEN", "csWHENEQ", 
  "csWHENNE", "csWHENLE", "csWHENLT", "csWHENGE", "csWHENGT", "csWRITE", 
  "csXFOOT", "csXLATE", "csXML_INTO", "csXML_SAX", "csZ_ADD", "csZ_SUB", 
  "cs_operationExtender", "factor", "factorContent", "resultType", "cs_fixed_comments", 
  "cspec_fixed_x2", "csOperationAndExtendedFactor2", "ispec_fixed", "fieldRecordRelation", 
  "fieldIndicator", "is_external_rec", "is_rec", "recordIdIndicator", "is_external_field", 
  "controlLevelIndicator", "matchingFieldsIndicator", "hspec_fixed", "hspec_content", 
  "hs_decedit_set", "hs_expression", "hs_parm", "hs_string", "blank_line", 
  "directive", "space_directive", "dir_copy", "dir_include", "dir_if", "dir_elseif", 
  "dir_else", "dir_endif", "dir_define", "dir_undefine", "dir_eof", "beginfree_directive", 
  "endfree_directive", "copyText", "trailing_ws", "title_directive", "title_text", 
  "op", "op_acq", "op_callp", "op_chain", "op_clear", "op_close", "op_commit", 
  "op_dealloc", "op_delete", "op_dou", "op_dow", "op_dsply", "op_dump", 
  "op_else", "op_elseif", "op_enddo", "op_endfor", "op_endif", "op_endmon", 
  "op_endsl", "op_eval", "op_evalr", "op_eval_corr", "op_except", "op_exfmt", 
  "op_exsr", "op_feod", "op_for", "op_force", "op_if", "op_in", "op_iter", 
  "op_leave", "op_leavesr", "op_monitor", "op_next", "op_on_error", "op_open", 
  "op_other", "op_out", "op_post", "op_read", "op_readc", "op_reade", "op_readp", 
  "op_readpe", "op_rel", "op_reset2", "op_reset", "op_return", "op_rolbk", 
  "op_select", "op_setgt", "op_setll", "op_sorta", "op_test", "op_unlock", 
  "op_update", "op_when", "op_write", "op_xml_into", "op_xml_sax", "search_arg", 
  "op_code", "bif", "optargs", "bif_charformat", "bif_dateformat", "bif_timeformat", 
  "bif_editccurrency", "bif_lookupargs", "durationCode", "bif_timestampargs", 
  "bif_tlookupargs", "bif_abs", "bif_addr", "bif_alloc", "bif_bitand", "bif_bitnot", 
  "bif_bitor", "bif_bitxor", "bif_char", "bif_check", "bif_checkr", "bif_date", 
  "bif_days", "bif_dec", "bif_dech", "bif_decpos", "bif_diff", "bif_div", 
  "bif_editc", "bif_editflt", "bif_editw", "bif_elem", "bif_eof", "bif_equal", 
  "bif_error", "bif_fields", "bif_float", "bif_found", "bif_graph", "bif_handler", 
  "bif_hours", "bif_int", "bif_inth", "bif_kds", "bif_len", "bif_lookup", 
  "bif_lookuplt", "bif_lookuple", "bif_lookupgt", "bif_lookupge", "bif_minutes", 
  "bif_months", "bif_mseconds", "bif_nullind", "bif_occur", "bif_open", 
  "bif_paddr", "bif_parms", "bif_parmnum", "bif_realloc", "bif_rem", "bif_replace", 
  "bif_scan", "bif_scanrpl", "bif_seconds", "bif_shtdn", "bif_size", "bif_sqrt", 
  "bif_status", "bif_str", "bif_subarr", "bif_subdt", "bif_subst", "bif_this", 
  "bif_time", "bif_timestamp", "bif_tlookup", "bif_tlookuplt", "bif_tlookuple", 
  "bif_tlookupgt", "bif_tlookupge", "bif_trim", "bif_triml", "bif_trimr", 
  "bif_ucs2", "bif_uns", "bif_unsh", "bif_xfoot", "bif_xlate", "bif_xml", 
  "bif_years", "bif_code", "free", "c_free", "control", "exec_sql", "baseExpression", 
  "indicator", "assignmentExpression", "assignOperatorExpression", "evalExpression", 
  "simpleExpression", "unaryExpression", "expression", "pexpression", "indicator_expr", 
  "function", "comparisonOperator", "assignmentOperator", "assignmentOperatorIncludingEqual", 
  "args", "literal", "identifier", "all", "functionName", "multipart_identifier", 
  "multipart_identifier_element", "indexed_identifier", "opCode", "number", 
  "free_identifier", "continuedIdentifier", "idOrKeyword", "argument", "symbolicConstants", 
  "target"
};

std::vector<std::string> RpgParser::_literalNames = {
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "'('", "')'", "", "';'", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "'&'", "", "", "", "'+'", 
  "'-'", "", "", "", "", "'/'", "'+='", "'-='", "'*='", "'/='", "'**='", 
  "'>'", "'<'", "'>='", "'<='", "'<>'", "'.'", "'='", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "'                                                                           '", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'                             '", 
  "", "", "", "", "", "", "", "", "", "'              '", "", "", "", "'          '"
};

std::vector<std::string> RpgParser::_symbolicNames = {
  "", "END_SOURCE", "LEAD_WS5", "LEAD_WS5_Comments", "FREE_SPEC", "COMMENT_SPEC_FIXED", 
  "DS_FIXED", "FS_FIXED", "OS_FIXED", "CS_FIXED", "CS_ExecSQL", "IS_FIXED", 
  "PS_FIXED", "HS_FIXED", "BLANK_LINE", "BLANK_SPEC_LINE1", "BLANK_SPEC_LINE", 
  "COMMENTS", "EMPTY_LINE", "DIRECTIVE", "OPEN_PAREN", "CLOSE_PAREN", "NUMBER", 
  "SEMI", "COLON", "ID", "NEWLINE", "WS", "DIR_NOT", "DIR_DEFINED", "DIR_FREE", 
  "DIR_ENDFREE", "DIR_TITLE", "DIR_EJECT", "DIR_SPACE", "DIR_SET", "DIR_RESTORE", 
  "DIR_COPY", "DIR_INCLUDE", "DIR_EOF", "DIR_DEFINE", "DIR_UNDEFINE", "DIR_IF", 
  "DIR_ELSE", "DIR_ELSEIF", "DIR_ENDIF", "DIR_WhiteSpace", "DIR_OtherText", 
  "DIR_Comma", "DIR_Slash", "DIR_FREE_OTHER_TEXT", "EOS_Text", "OP_WS", 
  "OP_ACQ", "OP_BEGSR", "OP_CALLP", "OP_CHAIN", "OP_CLEAR", "OP_CLOSE", 
  "OP_COMMIT", "OP_DEALLOC", "OP_DELETE", "OP_DOU", "OP_DOW", "OP_DSPLY", 
  "OP_DUMP", "OP_ELSE", "OP_ELSEIF", "OP_ENDDO", "OP_ENDFOR", "OP_ENDIF", 
  "OP_ENDMON", "OP_ENDSL", "OP_ENDSR", "OP_EVAL", "OP_EVALR", "OP_EVAL_CORR", 
  "OP_EXCEPT", "OP_EXFMT", "OP_EXSR", "OP_FEOD", "OP_FOR", "OP_FORCE", "OP_IF", 
  "OP_IN", "OP_ITER", "OP_LEAVE", "OP_LEAVESR", "OP_MONITOR", "OP_NEXT", 
  "OP_ON_ERROR", "OP_OPEN", "OP_OTHER", "OP_OUT", "OP_POST", "OP_READ", 
  "OP_READC", "OP_READE", "OP_READP", "OP_READPE", "OP_REL", "OP_RESET", 
  "OP_RETURN", "OP_ROLBK", "OP_SELECT", "OP_SETGT", "OP_SETLL", "OP_SORTA", 
  "OP_TEST", "OP_UNLOCK", "OP_UPDATE", "OP_WHEN", "OP_WRITE", "OP_XML_INTO", 
  "OP_XML_SAX", "OP_NoSpace", "DS_Standalone", "DS_DataStructureStart", 
  "DS_DataStructureEnd", "DS_PrototypeStart", "DS_PrototypeEnd", "DS_Parm", 
  "DS_SubField", "DS_ProcedureInterfaceStart", "DS_ProcedureInterfaceEnd", 
  "DS_ProcedureStart", "DS_ProcedureEnd", "DS_Constant", "FS_FreeFile", 
  "H_SPEC", "FREE_COMMENTS80", "EXEC_SQL", "BIF_ABS", "BIF_ADDR", "BIF_ALLOC", 
  "BIF_BITAND", "BIF_BITNOT", "BIF_BITOR", "BIF_BITXOR", "BIF_CHAR", "BIF_CHECK", 
  "BIF_CHECKR", "BIF_DATE", "BIF_DAYS", "BIF_DEC", "BIF_DECH", "BIF_DECPOS", 
  "BIF_DIFF", "BIF_DIV", "BIF_EDITC", "BIF_EDITFLT", "BIF_EDITW", "BIF_ELEM", 
  "BIF_EOF", "BIF_EQUAL", "BIF_ERROR", "BIF_FIELDS", "BIF_FLOAT", "BIF_FOUND", 
  "BIF_GRAPH", "BIF_HANDLER", "BIF_HOURS", "BIF_INT", "BIF_INTH", "BIF_KDS", 
  "BIF_LEN", "BIF_LOOKUP", "BIF_LOOKUPLT", "BIF_LOOKUPLE", "BIF_LOOKUPGT", 
  "BIF_LOOKUPGE", "BIF_MINUTES", "BIF_MONTHS", "BIF_MSECONDS", "BIF_NULLIND", 
  "BIF_OCCUR", "BIF_OPEN", "BIF_PADDR", "BIF_PARMS", "BIF_PARMNUM", "BIF_REALLOC", 
  "BIF_REM", "BIF_REPLACE", "BIF_SCAN", "BIF_SCANRPL", "BIF_SECONDS", "BIF_SHTDN", 
  "BIF_SIZE", "BIF_SQRT", "BIF_STATUS", "BIF_STR", "BIF_SUBARR", "BIF_SUBDT", 
  "BIF_SUBST", "BIF_THIS", "BIF_TIME", "BIF_TIMESTAMP", "BIF_TLOOKUP", "BIF_TLOOKUPLT", 
  "BIF_TLOOKUPLE", "BIF_TLOOKUPGT", "BIF_TLOOKUPGE", "BIF_TRIM", "BIF_TRIML", 
  "BIF_TRIMR", "BIF_UCS2", "BIF_UNS", "BIF_UNSH", "BIF_XFOOT", "BIF_XLATE", 
  "BIF_XML", "BIF_YEARS", "SPLAT_ALL", "SPLAT_NONE", "SPLAT_YES", "SPLAT_NO", 
  "SPLAT_ILERPG", "SPLAT_COMPAT", "SPLAT_CRTBNDRPG", "SPLAT_CRTRPGMOD", 
  "SPLAT_VRM", "SPLAT_ALLG", "SPLAT_ALLU", "SPLAT_ALLTHREAD", "SPLAT_ALLX", 
  "SPLAT_BLANKS", "SPLAT_CANCL", "SPLAT_CYMD", "SPLAT_CMDY", "SPLAT_CDMY", 
  "SPLAT_MDY", "SPLAT_DMY", "SPLAT_DFT", "SPLAT_YMD", "SPLAT_JUL", "SPLAT_JAVA", 
  "SPLAT_ISO", "SPLAT_USA", "SPLAT_EUR", "SPLAT_JIS", "SPLAT_DATE", "SPLAT_DAY", 
  "SPlAT_DETC", "SPLAT_DETL", "SPLAT_DTAARA", "SPLAT_END", "SPLAT_ENTRY", 
  "SPLAT_EQUATE", "SPLAT_EXTDFT", "SPLAT_EXT", "SPLAT_FILE", "SPLAT_GETIN", 
  "SPLAT_HIVAL", "SPLAT_INIT", "SPLAT_INDICATOR", "SPLAT_INZSR", "SPLAT_IN", 
  "SPLAT_INPUT", "SPLAT_OUTPUT", "SPLAT_JOBRUN", "SPLAT_JOB", "SPLAT_LDA", 
  "SPLAT_LIKE", "SPLAT_LONGJUL", "SPLAT_LOVAL", "SPLAT_KEY", "SPLAT_MONTH", 
  "SPLAT_NEXT", "SPLAT_NOIND", "SPLAT_NOKEY", "SPLAT_NULL", "SPLAT_OFL", 
  "SPLAT_ON", "SPLAT_ONLY", "SPLAT_OFF", "SPLAT_PDA", "SPLAT_PLACE", "SPLAT_PSSR", 
  "SPLAT_ROUTINE", "SPLAT_START", "SPLAT_SYS", "SPLAT_TERM", "SPLAT_TOTC", 
  "SPLAT_TOTL", "SPLAT_USER", "SPLAT_VAR", "SPLAT_YEAR", "SPLAT_ZEROS", 
  "SPLAT_HMS", "SPLAT_INLR", "SPLAT_INOF", "SPLAT_DATA", "SPLAT_ASTFILL", 
  "SPLAT_CURSYM", "SPLAT_MAX", "SPLAT_LOCK", "SPLAT_PROGRAM", "SPLAT_EXTDESC", 
  "SPLAT_D", "SPLAT_H", "SPLAT_HOURS", "SPLAT_DAYS", "SPLAT_M", "SPLAT_MINUTES", 
  "SPLAT_MONTHS", "SPLAT_MN", "SPLAT_MS", "SPLAT_MSECONDS", "SPLAT_S", "SPLAT_SECONDS", 
  "SPLAT_Y", "SPLAT_YEARS", "UDATE", "DATE", "UMONTH", "MONTH", "UYEAR", 
  "YEAR", "UDAY", "DAY", "PAGE", "CHAR", "VARCHAR", "UCS2", "DATE_", "VARUCS2", 
  "GRAPH", "VARGRAPH", "IND", "PACKED", "ZONED", "BINDEC", "INT", "UNS", 
  "FLOAT", "TIME", "TIMESTAMP", "POINTER", "OBJECT", "KEYWORD_ALIAS", "KEYWORD_ALIGN", 
  "KEYWORD_ALT", "KEYWORD_ALTSEQ", "KEYWORD_ASCEND", "KEYWORD_BASED", "KEYWORD_CCSID", 
  "KEYWORD_CLASS", "KEYWORD_CONST", "KEYWORD_CTDATA", "KEYWORD_DATFMT", 
  "KEYWORD_DESCEND", "KEYWORD_DIM", "KEYWORD_DTAARA", "KEYWORD_EXPORT", 
  "KEYWORD_EXT", "KEYWORD_EXTFLD", "KEYWORD_EXTFMT", "KEYWORD_EXTNAME", 
  "KEYWORD_EXTPGM", "KEYWORD_EXTPROC", "KEYWORD_FROMFILE", "KEYWORD_IMPORT", 
  "KEYWORD_INZ", "KEYWORD_LEN", "KEYWORD_LIKE", "KEYWORD_LIKEDS", "KEYWORD_LIKEFILE", 
  "KEYWORD_LIKEREC", "KEYWORD_NOOPT", "KEYWORD_OCCURS", "KEYWORD_OPDESC", 
  "KEYWORD_OPTIONS", "KEYWORD_OVERLAY", "KEYWORD_PACKEVEN", "KEYWORD_PERRCD", 
  "KEYWORD_PREFIX", "KEYWORD_POS", "KEYWORD_PROCPTR", "KEYWORD_QUALIFIED", 
  "KEYWORD_RTNPARM", "KEYWORD_STATIC", "KEYWORD_TEMPLATE", "KEYWORD_TIMFMT", 
  "KEYWORD_TOFILE", "KEYWORD_VALUE", "KEYWORD_VARYING", "KEYWORD_BLOCK", 
  "KEYWORD_COMMIT", "KEYWORD_DEVID", "KEYWORD_EXTDESC", "KEYWORD_EXTFILE", 
  "KEYWORD_EXTIND", "KEYWORD_EXTMBR", "KEYWORD_FORMLEN", "KEYWORD_FORMOFL", 
  "KEYWORD_IGNORE", "KEYWORD_INCLUDE", "KEYWORD_INDDS", "KEYWORD_INFDS", 
  "KEYWORD_INFSR", "KEYWORD_KEYLOC", "KEYWORD_MAXDEV", "KEYWORD_OFLIND", 
  "KEYWORD_PASS", "KEYWORD_PGMNAME", "KEYWORD_PLIST", "KEYWORD_PRTCTL", 
  "KEYWORD_RAFDATA", "KEYWORD_RECNO", "KEYWORD_RENAME", "KEYWORD_SAVEDS", 
  "KEYWORD_SAVEIND", "KEYWORD_SFILE", "KEYWORD_SLN", "KEYWORD_SQLTYPE", 
  "KEYWORD_USROPN", "KEYWORD_DISK", "KEYWORD_WORKSTN", "KEYWORD_PRINTER", 
  "KEYWORD_SPECIAL", "KEYWORD_KEYED", "KEYWORD_USAGE", "KEYWORD_PSDS", "AMPERSAND", 
  "AND", "OR", "NOT", "PLUS", "MINUS", "EXP", "ARRAY_REPEAT", "MULT_NOSPACE", 
  "MULT", "DIV", "CPLUS", "CMINUS", "CMULT", "CDIV", "CEXP", "GT", "LT", 
  "GE", "LE", "NE", "FREE_DOT", "EQUAL", "FREE_BY", "FREE_TO", "FREE_DOWNTO", 
  "HexLiteralStart", "DateLiteralStart", "TimeLiteralStart", "TimeStampLiteralStart", 
  "GraphicLiteralStart", "UCS2LiteralStart", "StringLiteralStart", "FREE_COMMENTS", 
  "FREE_WS", "C_FREE_CONTINUATION", "D_FREE_CONTINUATION", "F_FREE_CONTINUATION", 
  "FREE_LEAD_WS5", "FREE_LEAD_WS5_Comments", "FREE_FREE_SPEC", "C_FREE_NEWLINE", 
  "FREE_NEWLINE", "FREE_SEMI", "NumberContinuation_CONTINUATION", "NumberPart", 
  "NumberContinuation_ANY", "OP_ADD", "OP_ADDDUR", "OP_ALLOC", "OP_ANDxx", 
  "OP_ANDEQ", "OP_ANDNE", "OP_ANDLE", "OP_ANDLT", "OP_ANDGE", "OP_ANDGT", 
  "OP_BITOFF", "OP_BITON", "OP_CABxx", "OP_CABEQ", "OP_CABNE", "OP_CABLE", 
  "OP_CABLT", "OP_CABGE", "OP_CABGT", "OP_CALL", "OP_CALLB", "OP_CASEQ", 
  "OP_CASNE", "OP_CASLE", "OP_CASLT", "OP_CASGE", "OP_CASGT", "OP_CAS", 
  "OP_CAT", "OP_CHECK", "OP_CHECKR", "OP_COMP", "OP_DEFINE", "OP_DIV", "OP_DO", 
  "OP_DOUEQ", "OP_DOUNE", "OP_DOULE", "OP_DOULT", "OP_DOUGE", "OP_DOUGT", 
  "OP_DOWEQ", "OP_DOWNE", "OP_DOWLE", "OP_DOWLT", "OP_DOWGE", "OP_DOWGT", 
  "OP_END", "OP_ENDCS", "OP_EXTRCT", "OP_GOTO", "OP_IFEQ", "OP_IFNE", "OP_IFLE", 
  "OP_IFLT", "OP_IFGE", "OP_IFGT", "OP_KFLD", "OP_KLIST", "OP_LOOKUP", "OP_MHHZO", 
  "OP_MHLZO", "OP_MLHZO", "OP_MLLZO", "OP_MOVE", "OP_MOVEA", "OP_MOVEL", 
  "OP_MULT", "OP_MVR", "OP_OCCUR", "OP_OREQ", "OP_ORNE", "OP_ORLE", "OP_ORLT", 
  "OP_ORGE", "OP_ORGT", "OP_PARM", "OP_PLIST", "OP_REALLOC", "OP_SCAN", 
  "OP_SETOFF", "OP_SETON", "OP_SHTDN", "OP_SQRT", "OP_SUB", "OP_SUBDUR", 
  "OP_SUBST", "OP_TAG", "OP_TESTB", "OP_TESTN", "OP_TESTZ", "OP_TIME", "OP_WHENEQ", 
  "OP_WHENNE", "OP_WHENLE", "OP_WHENLT", "OP_WHENGE", "OP_WHENGT", "OP_XFOOT", 
  "OP_XLATE", "OP_Z_ADD", "OP_Z_SUB", "FE_BLANKS", "FE_COMMENTS", "FE_NEWLINE", 
  "StringContent", "StringEscapedQuote", "StringLiteralEnd", "FIXED_FREE_STRING_CONTINUATION", 
  "FIXED_FREE_STRING_CONTINUATION_MINUS", "FREE_STRING_CONTINUATION", "FREE_STRING_CONTINUATION_MINUS", 
  "PlusOrMinus", "EatCommentLinesPlus_Any", "EatCommentLines_WhiteSpace", 
  "EatCommentLines_StarComment", "FIXED_FREE_STRING_CONTINUATION_Part2", 
  "EatCommentLines_NothingLeft", "InFactor_EndFactor", "BLANK_COMMENTS_TEXT", 
  "COMMENTS_TEXT", "COMMENTS_EOL", "COMMENTS_TEXT_SKIP", "COMMENTS_TEXT_HIDDEN", 
  "COMMENTS_EOL_HIDDEN", "SQL_WS", "WORDS", "PS_NAME", "PS_CONTINUATION_NAME", 
  "PS_CONTINUATION", "PS_RESERVED1", "PS_BEGIN", "PS_END", "PS_RESERVED2", 
  "PS_KEYWORDS", "PS_WS80", "PS_COMMENTS80", "PS_Any", "BLANK_SPEC", "CONTINUATION_NAME", 
  "CONTINUATION", "NAME", "EXTERNAL_DESCRIPTION", "DATA_STRUCTURE_TYPE", 
  "DEF_TYPE_C", "DEF_TYPE_PI", "DEF_TYPE_PR", "DEF_TYPE_DS", "DEF_TYPE_S", 
  "DEF_TYPE_BLANK", "DEF_TYPE", "FROM_POSITION", "TO_POSITION", "DATA_TYPE", 
  "DECIMAL_POSITIONS", "RESERVED", "D_WS", "D_COMMENTS80", "EOL", "CE_WS", 
  "CE_COMMENTS80", "CE_LEAD_WS5", "CE_LEAD_WS5_Comments", "CE_D_SPEC_FIXED", 
  "CE_P_SPEC_FIXED", "CE_NEWLINE", "FS_RecordName", "FS_Type", "FS_Designation", 
  "FS_EndOfFile", "FS_Addution", "FS_Sequence", "FS_Format", "FS_RecordLength", 
  "FS_Limits", "FS_LengthOfKey", "FS_RecordAddressType", "FS_Organization", 
  "FS_Device", "FS_Reserved", "FS_WhiteSpace", "OS_RecordName", "OS_AndOr", 
  "OS_FieldReserved", "OS_Type", "OS_AddDelete", "OS_FetchOverflow", "OS_ExceptName", 
  "OS_Space3", "OS_RemainingSpace", "OS_Comments", "OS_WS", "OS_FieldName", 
  "OS_EditNames", "OS_BlankAfter", "OS_Reserved1", "OS_EndPosition", "OS_DataFormat", 
  "OS_Any", "CS_BlankFactor", "CS_FactorWs", "CS_FactorWs2", "CS_FactorContent", 
  "CS_OperationAndExtender_Blank", "CS_OperationAndExtender_WS", "CS_OperationAndExtender", 
  "CS_FieldLength", "CS_DecimalPositions", "CS_WhiteSpace", "CS_Comments", 
  "CS_FixedComments", "CS_FixedOperationAndExtender_WS", "CS_FixedOperationExtenderReturn", 
  "CS_FixedOperationAndExtender2_WS", "CS_FixedOperationExtender2Return", 
  "FreeOpExtender_Any", "FreeOpExtender2_WS", "BlankFlag", "NoFlag", "BlankIndicator", 
  "GeneralIndicator", "FunctionKeyIndicator", "ControlLevelIndicator", "ControlLevel0Indicator", 
  "LastRecordIndicator", "MatchingRecordIndicator", "HaltIndicator", "ReturnIndicator", 
  "ExternalIndicator", "OverflowIndicator", "SubroutineIndicator", "AndIndicator", 
  "OrIndicator", "DoubleSplatIndicator", "FirstPageIndicator", "OtherTextIndicator", 
  "NewLineIndicator", "CSQL_EMPTY_TEXT", "CSQL_TEXT", "CSQL_LEADBLANK", 
  "CSQL_LEADWS", "CSQL_END", "CSQL_CONT", "CSQL_CSplat", "CSQL_EOL", "CSQL_Any", 
  "CSQLC_LEADWS", "CSQLC_CSplat", "CSQLC_WS", "CSQLC_Comments", "CSQLC_Any", 
  "C2_FACTOR2_CONT", "C2_FACTOR2", "C2_OTHER", "IS_FileName", "IS_FieldReserved", 
  "IS_ExtFieldReserved", "IS_LogicalRelationship", "IS_ExtRecordReserved", 
  "IS_Sequence", "IS_Number", "IS_Option", "IS_RecordIdCode", "IS_WS", "IS_COMMENTS", 
  "IF_Name", "IF_Reserved", "IF_FieldName", "IF_Reserved2", "IF_WS", "IR_WS", 
  "IFD_DATA_ATTR", "IFD_DATETIME_SEP", "IFD_DATA_FORMAT", "IFD_FIELD_LOCATION", 
  "IFD_DECIMAL_POSITIONS", "IFD_FIELD_NAME", "IFD_CONTROL_LEVEL", "IFD_MATCHING_FIELDS", 
  "IFD_BLANKS", "IFD_COMMENTS", "HS_DECEDIT", "HS_WhiteSpace", "HS_CONTINUATION", 
  "DOT"
};

dfa::Vocabulary RpgParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> RpgParser::_tokenNames;

RpgParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x2f4, 0x1710, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 
       0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 
       0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 
       0xa, 0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 
       0x4, 0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 
       0x11, 0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 
       0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 
       0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 
       0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 
       0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 
       0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 
       0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 
       0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
       0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 
       0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 
       0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 
       0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 
       0x35, 0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 
       0x38, 0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 
       0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 
       0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 
       0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 
       0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 
       0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 
       0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 
       0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
       0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 
       0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 
       0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 
       0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 
       0x5c, 0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 
       0x5f, 0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 
       0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 
       0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 
       0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 
       0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 
       0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 
       0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 
       0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
       0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 
       0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 
       0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 
       0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 
       0x83, 0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 
       0x86, 0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 
       0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 
       0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 
       0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 
       0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 
       0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 
       0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 
       0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
       0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 
       0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 
       0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 
       0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 
       0xaa, 0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 
       0xad, 0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 
       0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 
       0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 
       0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 
       0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 
       0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 
       0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 
       0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
       0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 
       0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 
       0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 
       0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 
       0xd1, 0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 
       0xd4, 0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 
       0xd7, 0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 
       0xda, 0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 
       0xdd, 0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 
       0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 
       0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 
       0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 
       0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 
       0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 
       0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 
       0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 
       0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 
       0xf8, 0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 
       0xfb, 0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 
       0xfe, 0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x4, 0x100, 0x9, 0x100, 0x4, 
       0x101, 0x9, 0x101, 0x4, 0x102, 0x9, 0x102, 0x4, 0x103, 0x9, 0x103, 
       0x4, 0x104, 0x9, 0x104, 0x4, 0x105, 0x9, 0x105, 0x4, 0x106, 0x9, 
       0x106, 0x4, 0x107, 0x9, 0x107, 0x4, 0x108, 0x9, 0x108, 0x4, 0x109, 
       0x9, 0x109, 0x4, 0x10a, 0x9, 0x10a, 0x4, 0x10b, 0x9, 0x10b, 0x4, 
       0x10c, 0x9, 0x10c, 0x4, 0x10d, 0x9, 0x10d, 0x4, 0x10e, 0x9, 0x10e, 
       0x4, 0x10f, 0x9, 0x10f, 0x4, 0x110, 0x9, 0x110, 0x4, 0x111, 0x9, 
       0x111, 0x4, 0x112, 0x9, 0x112, 0x4, 0x113, 0x9, 0x113, 0x4, 0x114, 
       0x9, 0x114, 0x4, 0x115, 0x9, 0x115, 0x4, 0x116, 0x9, 0x116, 0x4, 
       0x117, 0x9, 0x117, 0x4, 0x118, 0x9, 0x118, 0x4, 0x119, 0x9, 0x119, 
       0x4, 0x11a, 0x9, 0x11a, 0x4, 0x11b, 0x9, 0x11b, 0x4, 0x11c, 0x9, 
       0x11c, 0x4, 0x11d, 0x9, 0x11d, 0x4, 0x11e, 0x9, 0x11e, 0x4, 0x11f, 
       0x9, 0x11f, 0x4, 0x120, 0x9, 0x120, 0x4, 0x121, 0x9, 0x121, 0x4, 
       0x122, 0x9, 0x122, 0x4, 0x123, 0x9, 0x123, 0x4, 0x124, 0x9, 0x124, 
       0x4, 0x125, 0x9, 0x125, 0x4, 0x126, 0x9, 0x126, 0x4, 0x127, 0x9, 
       0x127, 0x4, 0x128, 0x9, 0x128, 0x4, 0x129, 0x9, 0x129, 0x4, 0x12a, 
       0x9, 0x12a, 0x4, 0x12b, 0x9, 0x12b, 0x4, 0x12c, 0x9, 0x12c, 0x4, 
       0x12d, 0x9, 0x12d, 0x4, 0x12e, 0x9, 0x12e, 0x4, 0x12f, 0x9, 0x12f, 
       0x4, 0x130, 0x9, 0x130, 0x4, 0x131, 0x9, 0x131, 0x4, 0x132, 0x9, 
       0x132, 0x4, 0x133, 0x9, 0x133, 0x4, 0x134, 0x9, 0x134, 0x4, 0x135, 
       0x9, 0x135, 0x4, 0x136, 0x9, 0x136, 0x4, 0x137, 0x9, 0x137, 0x4, 
       0x138, 0x9, 0x138, 0x4, 0x139, 0x9, 0x139, 0x4, 0x13a, 0x9, 0x13a, 
       0x4, 0x13b, 0x9, 0x13b, 0x4, 0x13c, 0x9, 0x13c, 0x4, 0x13d, 0x9, 
       0x13d, 0x4, 0x13e, 0x9, 0x13e, 0x4, 0x13f, 0x9, 0x13f, 0x4, 0x140, 
       0x9, 0x140, 0x4, 0x141, 0x9, 0x141, 0x4, 0x142, 0x9, 0x142, 0x4, 
       0x143, 0x9, 0x143, 0x4, 0x144, 0x9, 0x144, 0x4, 0x145, 0x9, 0x145, 
       0x4, 0x146, 0x9, 0x146, 0x4, 0x147, 0x9, 0x147, 0x4, 0x148, 0x9, 
       0x148, 0x4, 0x149, 0x9, 0x149, 0x4, 0x14a, 0x9, 0x14a, 0x4, 0x14b, 
       0x9, 0x14b, 0x4, 0x14c, 0x9, 0x14c, 0x4, 0x14d, 0x9, 0x14d, 0x4, 
       0x14e, 0x9, 0x14e, 0x4, 0x14f, 0x9, 0x14f, 0x4, 0x150, 0x9, 0x150, 
       0x4, 0x151, 0x9, 0x151, 0x4, 0x152, 0x9, 0x152, 0x4, 0x153, 0x9, 
       0x153, 0x4, 0x154, 0x9, 0x154, 0x4, 0x155, 0x9, 0x155, 0x4, 0x156, 
       0x9, 0x156, 0x4, 0x157, 0x9, 0x157, 0x4, 0x158, 0x9, 0x158, 0x4, 
       0x159, 0x9, 0x159, 0x4, 0x15a, 0x9, 0x15a, 0x4, 0x15b, 0x9, 0x15b, 
       0x4, 0x15c, 0x9, 0x15c, 0x4, 0x15d, 0x9, 0x15d, 0x4, 0x15e, 0x9, 
       0x15e, 0x4, 0x15f, 0x9, 0x15f, 0x4, 0x160, 0x9, 0x160, 0x4, 0x161, 
       0x9, 0x161, 0x4, 0x162, 0x9, 0x162, 0x4, 0x163, 0x9, 0x163, 0x4, 
       0x164, 0x9, 0x164, 0x4, 0x165, 0x9, 0x165, 0x4, 0x166, 0x9, 0x166, 
       0x4, 0x167, 0x9, 0x167, 0x4, 0x168, 0x9, 0x168, 0x4, 0x169, 0x9, 
       0x169, 0x4, 0x16a, 0x9, 0x16a, 0x4, 0x16b, 0x9, 0x16b, 0x4, 0x16c, 
       0x9, 0x16c, 0x4, 0x16d, 0x9, 0x16d, 0x4, 0x16e, 0x9, 0x16e, 0x4, 
       0x16f, 0x9, 0x16f, 0x4, 0x170, 0x9, 0x170, 0x4, 0x171, 0x9, 0x171, 
       0x4, 0x172, 0x9, 0x172, 0x4, 0x173, 0x9, 0x173, 0x4, 0x174, 0x9, 
       0x174, 0x4, 0x175, 0x9, 0x175, 0x4, 0x176, 0x9, 0x176, 0x4, 0x177, 
       0x9, 0x177, 0x4, 0x178, 0x9, 0x178, 0x4, 0x179, 0x9, 0x179, 0x4, 
       0x17a, 0x9, 0x17a, 0x4, 0x17b, 0x9, 0x17b, 0x4, 0x17c, 0x9, 0x17c, 
       0x4, 0x17d, 0x9, 0x17d, 0x4, 0x17e, 0x9, 0x17e, 0x4, 0x17f, 0x9, 
       0x17f, 0x4, 0x180, 0x9, 0x180, 0x4, 0x181, 0x9, 0x181, 0x4, 0x182, 
       0x9, 0x182, 0x4, 0x183, 0x9, 0x183, 0x4, 0x184, 0x9, 0x184, 0x4, 
       0x185, 0x9, 0x185, 0x4, 0x186, 0x9, 0x186, 0x4, 0x187, 0x9, 0x187, 
       0x4, 0x188, 0x9, 0x188, 0x4, 0x189, 0x9, 0x189, 0x4, 0x18a, 0x9, 
       0x18a, 0x4, 0x18b, 0x9, 0x18b, 0x4, 0x18c, 0x9, 0x18c, 0x4, 0x18d, 
       0x9, 0x18d, 0x4, 0x18e, 0x9, 0x18e, 0x4, 0x18f, 0x9, 0x18f, 0x4, 
       0x190, 0x9, 0x190, 0x4, 0x191, 0x9, 0x191, 0x4, 0x192, 0x9, 0x192, 
       0x4, 0x193, 0x9, 0x193, 0x4, 0x194, 0x9, 0x194, 0x4, 0x195, 0x9, 
       0x195, 0x4, 0x196, 0x9, 0x196, 0x4, 0x197, 0x9, 0x197, 0x4, 0x198, 
       0x9, 0x198, 0x4, 0x199, 0x9, 0x199, 0x4, 0x19a, 0x9, 0x19a, 0x4, 
       0x19b, 0x9, 0x19b, 0x4, 0x19c, 0x9, 0x19c, 0x4, 0x19d, 0x9, 0x19d, 
       0x4, 0x19e, 0x9, 0x19e, 0x4, 0x19f, 0x9, 0x19f, 0x4, 0x1a0, 0x9, 
       0x1a0, 0x4, 0x1a1, 0x9, 0x1a1, 0x4, 0x1a2, 0x9, 0x1a2, 0x4, 0x1a3, 
       0x9, 0x1a3, 0x4, 0x1a4, 0x9, 0x1a4, 0x4, 0x1a5, 0x9, 0x1a5, 0x4, 
       0x1a6, 0x9, 0x1a6, 0x4, 0x1a7, 0x9, 0x1a7, 0x4, 0x1a8, 0x9, 0x1a8, 
       0x4, 0x1a9, 0x9, 0x1a9, 0x4, 0x1aa, 0x9, 0x1aa, 0x4, 0x1ab, 0x9, 
       0x1ab, 0x4, 0x1ac, 0x9, 0x1ac, 0x4, 0x1ad, 0x9, 0x1ad, 0x4, 0x1ae, 
       0x9, 0x1ae, 0x4, 0x1af, 0x9, 0x1af, 0x4, 0x1b0, 0x9, 0x1b0, 0x4, 
       0x1b1, 0x9, 0x1b1, 0x4, 0x1b2, 0x9, 0x1b2, 0x4, 0x1b3, 0x9, 0x1b3, 
       0x4, 0x1b4, 0x9, 0x1b4, 0x4, 0x1b5, 0x9, 0x1b5, 0x4, 0x1b6, 0x9, 
       0x1b6, 0x4, 0x1b7, 0x9, 0x1b7, 0x4, 0x1b8, 0x9, 0x1b8, 0x4, 0x1b9, 
       0x9, 0x1b9, 0x4, 0x1ba, 0x9, 0x1ba, 0x4, 0x1bb, 0x9, 0x1bb, 0x4, 
       0x1bc, 0x9, 0x1bc, 0x4, 0x1bd, 0x9, 0x1bd, 0x4, 0x1be, 0x9, 0x1be, 
       0x4, 0x1bf, 0x9, 0x1bf, 0x4, 0x1c0, 0x9, 0x1c0, 0x4, 0x1c1, 0x9, 
       0x1c1, 0x4, 0x1c2, 0x9, 0x1c2, 0x4, 0x1c3, 0x9, 0x1c3, 0x4, 0x1c4, 
       0x9, 0x1c4, 0x4, 0x1c5, 0x9, 0x1c5, 0x4, 0x1c6, 0x9, 0x1c6, 0x4, 
       0x1c7, 0x9, 0x1c7, 0x4, 0x1c8, 0x9, 0x1c8, 0x4, 0x1c9, 0x9, 0x1c9, 
       0x4, 0x1ca, 0x9, 0x1ca, 0x4, 0x1cb, 0x9, 0x1cb, 0x4, 0x1cc, 0x9, 
       0x1cc, 0x4, 0x1cd, 0x9, 0x1cd, 0x4, 0x1ce, 0x9, 0x1ce, 0x4, 0x1cf, 
       0x9, 0x1cf, 0x4, 0x1d0, 0x9, 0x1d0, 0x4, 0x1d1, 0x9, 0x1d1, 0x4, 
       0x1d2, 0x9, 0x1d2, 0x4, 0x1d3, 0x9, 0x1d3, 0x4, 0x1d4, 0x9, 0x1d4, 
       0x4, 0x1d5, 0x9, 0x1d5, 0x4, 0x1d6, 0x9, 0x1d6, 0x4, 0x1d7, 0x9, 
       0x1d7, 0x4, 0x1d8, 0x9, 0x1d8, 0x4, 0x1d9, 0x9, 0x1d9, 0x4, 0x1da, 
       0x9, 0x1da, 0x4, 0x1db, 0x9, 0x1db, 0x4, 0x1dc, 0x9, 0x1dc, 0x4, 
       0x1dd, 0x9, 0x1dd, 0x4, 0x1de, 0x9, 0x1de, 0x4, 0x1df, 0x9, 0x1df, 
       0x4, 0x1e0, 0x9, 0x1e0, 0x4, 0x1e1, 0x9, 0x1e1, 0x4, 0x1e2, 0x9, 
       0x1e2, 0x4, 0x1e3, 0x9, 0x1e3, 0x4, 0x1e4, 0x9, 0x1e4, 0x4, 0x1e5, 
       0x9, 0x1e5, 0x4, 0x1e6, 0x9, 0x1e6, 0x4, 0x1e7, 0x9, 0x1e7, 0x4, 
       0x1e8, 0x9, 0x1e8, 0x4, 0x1e9, 0x9, 0x1e9, 0x4, 0x1ea, 0x9, 0x1ea, 
       0x4, 0x1eb, 0x9, 0x1eb, 0x4, 0x1ec, 0x9, 0x1ec, 0x4, 0x1ed, 0x9, 
       0x1ed, 0x4, 0x1ee, 0x9, 0x1ee, 0x4, 0x1ef, 0x9, 0x1ef, 0x4, 0x1f0, 
       0x9, 0x1f0, 0x4, 0x1f1, 0x9, 0x1f1, 0x4, 0x1f2, 0x9, 0x1f2, 0x4, 
       0x1f3, 0x9, 0x1f3, 0x4, 0x1f4, 0x9, 0x1f4, 0x4, 0x1f5, 0x9, 0x1f5, 
       0x4, 0x1f6, 0x9, 0x1f6, 0x4, 0x1f7, 0x9, 0x1f7, 0x4, 0x1f8, 0x9, 
       0x1f8, 0x4, 0x1f9, 0x9, 0x1f9, 0x4, 0x1fa, 0x9, 0x1fa, 0x4, 0x1fb, 
       0x9, 0x1fb, 0x4, 0x1fc, 0x9, 0x1fc, 0x4, 0x1fd, 0x9, 0x1fd, 0x4, 
       0x1fe, 0x9, 0x1fe, 0x4, 0x1ff, 0x9, 0x1ff, 0x4, 0x200, 0x9, 0x200, 
       0x4, 0x201, 0x9, 0x201, 0x4, 0x202, 0x9, 0x202, 0x4, 0x203, 0x9, 
       0x203, 0x4, 0x204, 0x9, 0x204, 0x4, 0x205, 0x9, 0x205, 0x4, 0x206, 
       0x9, 0x206, 0x4, 0x207, 0x9, 0x207, 0x4, 0x208, 0x9, 0x208, 0x4, 
       0x209, 0x9, 0x209, 0x4, 0x20a, 0x9, 0x20a, 0x4, 0x20b, 0x9, 0x20b, 
       0x4, 0x20c, 0x9, 0x20c, 0x4, 0x20d, 0x9, 0x20d, 0x4, 0x20e, 0x9, 
       0x20e, 0x4, 0x20f, 0x9, 0x20f, 0x4, 0x210, 0x9, 0x210, 0x4, 0x211, 
       0x9, 0x211, 0x4, 0x212, 0x9, 0x212, 0x4, 0x213, 0x9, 0x213, 0x4, 
       0x214, 0x9, 0x214, 0x4, 0x215, 0x9, 0x215, 0x4, 0x216, 0x9, 0x216, 
       0x4, 0x217, 0x9, 0x217, 0x4, 0x218, 0x9, 0x218, 0x4, 0x219, 0x9, 
       0x219, 0x4, 0x21a, 0x9, 0x21a, 0x4, 0x21b, 0x9, 0x21b, 0x4, 0x21c, 
       0x9, 0x21c, 0x4, 0x21d, 0x9, 0x21d, 0x4, 0x21e, 0x9, 0x21e, 0x4, 
       0x21f, 0x9, 0x21f, 0x4, 0x220, 0x9, 0x220, 0x4, 0x221, 0x9, 0x221, 
       0x4, 0x222, 0x9, 0x222, 0x4, 0x223, 0x9, 0x223, 0x4, 0x224, 0x9, 
       0x224, 0x4, 0x225, 0x9, 0x225, 0x4, 0x226, 0x9, 0x226, 0x4, 0x227, 
       0x9, 0x227, 0x4, 0x228, 0x9, 0x228, 0x4, 0x229, 0x9, 0x229, 0x4, 
       0x22a, 0x9, 0x22a, 0x4, 0x22b, 0x9, 0x22b, 0x4, 0x22c, 0x9, 0x22c, 
       0x4, 0x22d, 0x9, 0x22d, 0x4, 0x22e, 0x9, 0x22e, 0x4, 0x22f, 0x9, 
       0x22f, 0x4, 0x230, 0x9, 0x230, 0x4, 0x231, 0x9, 0x231, 0x4, 0x232, 
       0x9, 0x232, 0x4, 0x233, 0x9, 0x233, 0x4, 0x234, 0x9, 0x234, 0x4, 
       0x235, 0x9, 0x235, 0x4, 0x236, 0x9, 0x236, 0x4, 0x237, 0x9, 0x237, 
       0x4, 0x238, 0x9, 0x238, 0x4, 0x239, 0x9, 0x239, 0x4, 0x23a, 0x9, 
       0x23a, 0x4, 0x23b, 0x9, 0x23b, 0x4, 0x23c, 0x9, 0x23c, 0x4, 0x23d, 
       0x9, 0x23d, 0x4, 0x23e, 0x9, 0x23e, 0x4, 0x23f, 0x9, 0x23f, 0x4, 
       0x240, 0x9, 0x240, 0x4, 0x241, 0x9, 0x241, 0x4, 0x242, 0x9, 0x242, 
       0x4, 0x243, 0x9, 0x243, 0x4, 0x244, 0x9, 0x244, 0x4, 0x245, 0x9, 
       0x245, 0x4, 0x246, 0x9, 0x246, 0x4, 0x247, 0x9, 0x247, 0x4, 0x248, 
       0x9, 0x248, 0x4, 0x249, 0x9, 0x249, 0x4, 0x24a, 0x9, 0x24a, 0x4, 
       0x24b, 0x9, 0x24b, 0x4, 0x24c, 0x9, 0x24c, 0x4, 0x24d, 0x9, 0x24d, 
       0x4, 0x24e, 0x9, 0x24e, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x7, 0x2, 0x4a3, 0xa, 0x2, 0xc, 0x2, 0xe, 0x2, 0x4a6, 
       0xb, 0x2, 0x3, 0x2, 0x5, 0x2, 0x4a9, 0xa, 0x2, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
       0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x4bd, 0xa, 0x3, 0x3, 0x4, 
       0x6, 0x4, 0x4c0, 0xa, 0x4, 0xd, 0x4, 0xe, 0x4, 0x4c1, 0x3, 0x5, 0x3, 
       0x5, 0x7, 0x5, 0x4c6, 0xa, 0x5, 0xc, 0x5, 0xe, 0x5, 0x4c9, 0xb, 0x5, 
       0x3, 0x6, 0x3, 0x6, 0x3, 0x7, 0x3, 0x7, 0x5, 0x7, 0x4cf, 0xa, 0x7, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x4d5, 0xa, 0x9, 
       0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xb, 0x3, 0xb, 0x3, 
       0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 
       0x4e3, 0xa, 0xd, 0x3, 0xd, 0x6, 0xd, 0x4e6, 0xa, 0xd, 0xd, 0xd, 0xe, 
       0xd, 0x4e7, 0x5, 0xd, 0x4ea, 0xa, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 
       0x4ee, 0xa, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 
       0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 
       0xd, 0x7, 0xd, 0x4fc, 0xa, 0xd, 0xc, 0xd, 0xe, 0xd, 0x4ff, 0xb, 0xd, 
       0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x503, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 
       0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 
       0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xf, 0x3, 0xf, 
       0x5, 0xf, 0x514, 0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x548, 
       0xa, 0x10, 0x3, 0x11, 0x3, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x16, 
       0x3, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 0x565, 0xa, 
       0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 
       0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 
       0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x575, 0xa, 0x1a, 0x3, 0x1b, 
       0x3, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 
       0x57d, 0xa, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x580, 0xa, 0x1c, 0x3, 0x1c, 
       0x3, 0x1c, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1f, 
       0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x20, 0x3, 0x20, 
       0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x591, 0xa, 0x20, 0x3, 0x20, 0x3, 
       0x20, 0x5, 0x20, 0x595, 0xa, 0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 
       0x599, 0xa, 0x20, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 
       0x21, 0x5, 0x21, 0x5a0, 0xa, 0x21, 0x3, 0x22, 0x3, 0x22, 0x3, 0x23, 
       0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x24, 0x3, 0x24, 
       0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x5b3, 0xa, 0x25, 0x3, 0x25, 0x3, 
       0x25, 0x5, 0x25, 0x5b7, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x26, 
       0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x5, 0x26, 0x5c0, 0xa, 
       0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 
       0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 0x27, 0x5cc, 
       0xa, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x28, 0x3, 0x28, 
       0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x5, 0x29, 0x5db, 0xa, 0x29, 0x3, 0x2a, 0x3, 
       0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x5e2, 0xa, 0x2a, 
       0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2c, 
       0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 0x5ee, 0xa, 
       0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2d, 0x3, 0x2d, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 
       0x2e, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 
       0x2f, 0x601, 0xa, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x30, 0x3, 0x30, 
       0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x5, 0x31, 
       0x60c, 0xa, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x32, 0x3, 0x32, 0x3, 
       0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x7, 0x33, 0x617, 
       0xa, 0x33, 0xc, 0x33, 0xe, 0x33, 0x61a, 0xb, 0x33, 0x3, 0x33, 0x3, 
       0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 
       0x34, 0x5, 0x34, 0x624, 0xa, 0x34, 0x5, 0x34, 0x626, 0xa, 0x34, 0x3, 
       0x34, 0x3, 0x34, 0x3, 0x35, 0x3, 0x35, 0x3, 0x36, 0x3, 0x36, 0x3, 
       0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 
       0x37, 0x3, 0x37, 0x5, 0x37, 0x636, 0xa, 0x37, 0x3, 0x37, 0x3, 0x37, 
       0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x39, 
       0x3, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3c, 
       0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x649, 0xa, 0x3c, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x650, 
       0xa, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x654, 0xa, 0x3d, 0x3, 
       0x3e, 0x3, 0x3e, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x5, 
       0x3f, 0x65c, 0xa, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x40, 0x3, 0x40, 
       0x3, 0x40, 0x3, 0x40, 0x5, 0x40, 0x664, 0xa, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
       0x42, 0x3, 0x42, 0x5, 0x42, 0x66f, 0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 
       0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x45, 
       0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x67d, 0xa, 
       0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 
       0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x48, 0x3, 
       0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x68d, 0xa, 0x48, 0x3, 0x48, 
       0x3, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 
       0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4b, 
       0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 
       0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 
       0x3, 0x4d, 0x3, 0x4d, 0x7, 0x4d, 0x6aa, 0xa, 0x4d, 0xc, 0x4d, 0xe, 
       0x4d, 0x6ad, 0xb, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 
       0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x7, 0x4e, 0x6b6, 0xa, 0x4e, 0xc, 
       0x4e, 0xe, 0x4e, 0x6b9, 0xb, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 
       0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x50, 0x3, 0x50, 
       0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
       0x3, 0x51, 0x3, 0x51, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 
       0x3, 0x52, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 
       0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x55, 
       0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x56, 0x3, 0x56, 
       0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 
       0x3, 0x57, 0x3, 0x57, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 
       0x3, 0x58, 0x5, 0x58, 0x6ef, 0xa, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 
       0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x5a, 0x3, 
       0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 
       0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5c, 0x3, 
       0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 0x3, 
       0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 
       0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5f, 0x3, 0x5f, 0x3, 
       0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x61, 0x3, 
       0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x720, 0xa, 0x61, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 
       0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 0x3, 0x65, 0x3, 0x66, 0x3, 0x66, 
       0x3, 0x66, 0x3, 0x66, 0x5, 0x66, 0x731, 0xa, 0x66, 0x3, 0x66, 0x3, 
       0x66, 0x3, 0x66, 0x5, 0x66, 0x736, 0xa, 0x66, 0x7, 0x66, 0x738, 0xa, 
       0x66, 0xc, 0x66, 0xe, 0x66, 0x73b, 0xb, 0x66, 0x3, 0x66, 0x3, 0x66, 
       0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 0x68, 0x3, 0x68, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x7, 0x69, 0x747, 0xa, 0x69, 0xc, 0x69, 0xe, 
       0x69, 0x74a, 0xb, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x7, 0x69, 0x750, 0xa, 0x69, 0xc, 0x69, 0xe, 0x69, 0x753, 0xb, 0x69, 
       0x5, 0x69, 0x755, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x5, 
       0x69, 0x75a, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x7, 0x69, 0x769, 0xa, 0x69, 0xc, 
       0x69, 0xe, 0x69, 0x76c, 0xb, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x7, 0x69, 0x772, 0xa, 0x69, 0xc, 0x69, 0xe, 0x69, 0x775, 
       0xb, 0x69, 0x3, 0x69, 0x5, 0x69, 0x778, 0xa, 0x69, 0x5, 0x69, 0x77a, 
       0xa, 0x69, 0x3, 0x6a, 0x5, 0x6a, 0x77d, 0xa, 0x6a, 0x3, 0x6a, 0x3, 
       0x6a, 0x3, 0x6a, 0x5, 0x6a, 0x782, 0xa, 0x6a, 0x3, 0x6a, 0x7, 0x6a, 
       0x785, 0xa, 0x6a, 0xc, 0x6a, 0xe, 0x6a, 0x788, 0xb, 0x6a, 0x3, 0x6a, 
       0x3, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x5, 0x6b, 0x78e, 0xa, 0x6b, 0x3, 
       0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x5, 0x6c, 0x793, 0xa, 0x6c, 0x3, 0x6c, 
       0x7, 0x6c, 0x796, 0xa, 0x6c, 0xc, 0x6c, 0xe, 0x6c, 0x799, 0xb, 0x6c, 
       0x3, 0x6c, 0x5, 0x6c, 0x79c, 0xa, 0x6c, 0x3, 0x6c, 0x7, 0x6c, 0x79f, 
       0xa, 0x6c, 0xc, 0x6c, 0xe, 0x6c, 0x7a2, 0xb, 0x6c, 0x3, 0x6c, 0x5, 
       0x6c, 0x7a5, 0xa, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 
       0x3, 0x6c, 0x7, 0x6c, 0x7ac, 0xa, 0x6c, 0xc, 0x6c, 0xe, 0x6c, 0x7af, 
       0xb, 0x6c, 0x5, 0x6c, 0x7b1, 0xa, 0x6c, 0x3, 0x6d, 0x5, 0x6d, 0x7b4, 
       0xa, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x5, 0x6d, 0x7b9, 0xa, 
       0x6d, 0x3, 0x6d, 0x7, 0x6d, 0x7bc, 0xa, 0x6d, 0xc, 0x6d, 0xe, 0x6d, 
       0x7bf, 0xb, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 
       0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x5, 0x6f, 0x7c8, 0xa, 0x6f, 0x3, 0x6f, 
       0x7, 0x6f, 0x7cb, 0xa, 0x6f, 0xc, 0x6f, 0xe, 0x6f, 0x7ce, 0xb, 0x6f, 
       0x3, 0x6f, 0x5, 0x6f, 0x7d1, 0xa, 0x6f, 0x3, 0x6f, 0x7, 0x6f, 0x7d4, 
       0xa, 0x6f, 0xc, 0x6f, 0xe, 0x6f, 0x7d7, 0xb, 0x6f, 0x3, 0x6f, 0x3, 
       0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x7, 0x6f, 0x7de, 0xa, 0x6f, 
       0xc, 0x6f, 0xe, 0x6f, 0x7e1, 0xb, 0x6f, 0x5, 0x6f, 0x7e3, 0xa, 0x6f, 
       0x3, 0x70, 0x5, 0x70, 0x7e6, 0xa, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 
       0x70, 0x5, 0x70, 0x7eb, 0xa, 0x70, 0x3, 0x70, 0x7, 0x70, 0x7ee, 0xa, 
       0x70, 0xc, 0x70, 0xe, 0x70, 0x7f1, 0xb, 0x70, 0x3, 0x70, 0x3, 0x70, 
       0x3, 0x71, 0x3, 0x71, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 
       0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x5, 0x72, 0x7ff, 0xa, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x5, 0x72, 0x814, 0xa, 0x72, 0x3, 0x72, 0x3, 0x72, 
       0x5, 0x72, 0x818, 0xa, 0x72, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x7, 
       0x73, 0x81d, 0xa, 0x73, 0xc, 0x73, 0xe, 0x73, 0x820, 0xb, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x74, 0x3, 0x74, 0x3, 0x75, 0x3, 0x75, 0x3, 
       0x75, 0x3, 0x75, 0x3, 0x75, 0x5, 0x75, 0x82b, 0xa, 0x75, 0x3, 0x75, 
       0x7, 0x75, 0x82e, 0xa, 0x75, 0xc, 0x75, 0xe, 0x75, 0x831, 0xb, 0x75, 
       0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 
       0x3, 0x75, 0x5, 0x75, 0x83a, 0xa, 0x75, 0x3, 0x76, 0x3, 0x76, 0x7, 
       0x76, 0x83e, 0xa, 0x76, 0xc, 0x76, 0xe, 0x76, 0x841, 0xb, 0x76, 0x3, 
       0x76, 0x7, 0x76, 0x844, 0xa, 0x76, 0xc, 0x76, 0xe, 0x76, 0x847, 0xb, 
       0x76, 0x3, 0x76, 0x5, 0x76, 0x84a, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 
       0x3, 0x77, 0x3, 0x77, 0x7, 0x77, 0x850, 0xa, 0x77, 0xc, 0x77, 0xe, 
       0x77, 0x853, 0xb, 0x77, 0x3, 0x78, 0x3, 0x78, 0x7, 0x78, 0x857, 0xa, 
       0x78, 0xc, 0x78, 0xe, 0x78, 0x85a, 0xb, 0x78, 0x3, 0x79, 0x3, 0x79, 
       0x7, 0x79, 0x85e, 0xa, 0x79, 0xc, 0x79, 0xe, 0x79, 0x861, 0xb, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x5, 0x79, 0x86f, 0xa, 0x79, 0x6, 0x79, 0x871, 0xa, 0x79, 0xd, 0x79, 
       0xe, 0x79, 0x872, 0x3, 0x79, 0x3, 0x79, 0x3, 0x7a, 0x3, 0x7a, 0x7, 
       0x7a, 0x879, 0xa, 0x7a, 0xc, 0x7a, 0xe, 0x7a, 0x87c, 0xb, 0x7a, 0x3, 
       0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x5, 
       0x7a, 0x884, 0xa, 0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x7, 0x7b, 0x888, 0xa, 
       0x7b, 0xc, 0x7b, 0xe, 0x7b, 0x88b, 0xb, 0x7b, 0x3, 0x7b, 0x7, 0x7b, 
       0x88e, 0xa, 0x7b, 0xc, 0x7b, 0xe, 0x7b, 0x891, 0xb, 0x7b, 0x3, 0x7b, 
       0x3, 0x7b, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 
       0x7, 0x7c, 0x89a, 0xa, 0x7c, 0xc, 0x7c, 0xe, 0x7c, 0x89d, 0xb, 0x7c, 
       0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 
       0x5, 0x7c, 0x8a5, 0xa, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 
       0x7d, 0x3, 0x7d, 0x7, 0x7d, 0x8ac, 0xa, 0x7d, 0xc, 0x7d, 0xe, 0x7d, 
       0x8af, 0xb, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 
       0x7d, 0x3, 0x7d, 0x5, 0x7d, 0x8b7, 0xa, 0x7d, 0x3, 0x7e, 0x3, 0x7e, 
       0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x7, 0x7e, 0x8be, 0xa, 0x7e, 0xc, 
       0x7e, 0xe, 0x7e, 0x8c1, 0xb, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x5, 0x7e, 0x8c9, 0xa, 0x7e, 0x3, 
       0x7e, 0x7, 0x7e, 0x8cc, 0xa, 0x7e, 0xc, 0x7e, 0xe, 0x7e, 0x8cf, 0xb, 
       0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x7, 0x7f, 0x8d3, 0xa, 0x7f, 0xc, 0x7f, 
       0xe, 0x7f, 0x8d6, 0xb, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 0x8d9, 0xa, 0x7f, 
       0x3, 0x7f, 0x3, 0x7f, 0x3, 0x80, 0x3, 0x80, 0x7, 0x80, 0x8df, 0xa, 
       0x80, 0xc, 0x80, 0xe, 0x80, 0x8e2, 0xb, 0x80, 0x3, 0x80, 0x3, 0x80, 
       0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 
       0x3, 0x80, 0x5, 0x80, 0x8ed, 0xa, 0x80, 0x5, 0x80, 0x8ef, 0xa, 0x80, 
       0x3, 0x81, 0x3, 0x81, 0x7, 0x81, 0x8f3, 0xa, 0x81, 0xc, 0x81, 0xe, 
       0x81, 0x8f6, 0xb, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 
       0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x5, 0x81, 
       0x901, 0xa, 0x81, 0x5, 0x81, 0x903, 0xa, 0x81, 0x3, 0x82, 0x3, 0x82, 
       0x5, 0x82, 0x907, 0xa, 0x82, 0x3, 0x82, 0x7, 0x82, 0x90a, 0xa, 0x82, 
       0xc, 0x82, 0xe, 0x82, 0x90d, 0xb, 0x82, 0x3, 0x83, 0x3, 0x83, 0x7, 
       0x83, 0x911, 0xa, 0x83, 0xc, 0x83, 0xe, 0x83, 0x914, 0xb, 0x83, 0x3, 
       0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 
       0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0x91f, 0xa, 0x83, 0x3, 0x83, 
       0x7, 0x83, 0x922, 0xa, 0x83, 0xc, 0x83, 0xe, 0x83, 0x925, 0xb, 0x83, 
       0x5, 0x83, 0x927, 0xa, 0x83, 0x3, 0x84, 0x3, 0x84, 0x7, 0x84, 0x92b, 
       0xa, 0x84, 0xc, 0x84, 0xe, 0x84, 0x92e, 0xb, 0x84, 0x3, 0x84, 0x3, 
       0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 
       0x84, 0x3, 0x84, 0x3, 0x84, 0x5, 0x84, 0x93a, 0xa, 0x84, 0x3, 0x84, 
       0x7, 0x84, 0x93d, 0xa, 0x84, 0xc, 0x84, 0xe, 0x84, 0x940, 0xb, 0x84, 
       0x3, 0x84, 0x7, 0x84, 0x943, 0xa, 0x84, 0xc, 0x84, 0xe, 0x84, 0x946, 
       0xb, 0x84, 0x3, 0x85, 0x3, 0x85, 0x7, 0x85, 0x94a, 0xa, 0x85, 0xc, 
       0x85, 0xe, 0x85, 0x94d, 0xb, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 
       0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x5, 0x85, 0x955, 0xa, 0x85, 0x3, 
       0x85, 0x3, 0x85, 0x3, 0x85, 0x5, 0x85, 0x95a, 0xa, 0x85, 0x5, 0x85, 
       0x95c, 0xa, 0x85, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x7, 0x86, 0x961, 
       0xa, 0x86, 0xc, 0x86, 0xe, 0x86, 0x964, 0xb, 0x86, 0x3, 0x86, 0x3, 
       0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x5, 0x86, 0x96c, 
       0xa, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x86, 
       0x3, 0x86, 0x5, 0x86, 0x974, 0xa, 0x86, 0x5, 0x86, 0x976, 0xa, 0x86, 
       0x3, 0x87, 0x3, 0x87, 0x7, 0x87, 0x97a, 0xa, 0x87, 0xc, 0x87, 0xe, 
       0x87, 0x97d, 0xb, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 
       0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 
       0x988, 0xa, 0x87, 0x5, 0x87, 0x98a, 0xa, 0x87, 0x3, 0x88, 0x3, 0x88, 
       0x7, 0x88, 0x98e, 0xa, 0x88, 0xc, 0x88, 0xe, 0x88, 0x991, 0xb, 0x88, 
       0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 0x99c, 0xa, 0x88, 0x5, 
       0x88, 0x99e, 0xa, 0x88, 0x3, 0x89, 0x3, 0x89, 0x7, 0x89, 0x9a2, 0xa, 
       0x89, 0xc, 0x89, 0xe, 0x89, 0x9a5, 0xb, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x3, 0x89, 0x5, 0x89, 0x9b0, 0xa, 0x89, 0x5, 0x89, 0x9b2, 0xa, 0x89, 
       0x3, 0x8a, 0x3, 0x8a, 0x7, 0x8a, 0x9b6, 0xa, 0x8a, 0xc, 0x8a, 0xe, 
       0x8a, 0x9b9, 0xb, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 
       0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0x9c1, 0xa, 0x8a, 0x3, 0x8a, 0x3, 
       0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0x9c9, 
       0xa, 0x8a, 0x5, 0x8a, 0x9cb, 0xa, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x7, 
       0x8b, 0x9cf, 0xa, 0x8b, 0xc, 0x8b, 0xe, 0x8b, 0x9d2, 0xb, 0x8b, 0x3, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0x9de, 0xa, 0x8b, 
       0x5, 0x8b, 0x9e0, 0xa, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x7, 0x8c, 0x9e4, 
       0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0x9e7, 0xb, 0x8c, 0x3, 0x8c, 0x3, 
       0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 
       0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0x9f3, 0xa, 0x8c, 0x3, 0x8c, 
       0x7, 0x8c, 0x9f6, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0x9f9, 0xb, 0x8c, 
       0x3, 0x8c, 0x7, 0x8c, 0x9fc, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0x9ff, 
       0xb, 0x8c, 0x3, 0x8d, 0x3, 0x8d, 0x7, 0x8d, 0xa03, 0xa, 0x8d, 0xc, 
       0x8d, 0xe, 0x8d, 0xa06, 0xb, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 
       0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 
       0x3, 0x8d, 0x5, 0x8d, 0xa12, 0xa, 0x8d, 0x3, 0x8d, 0x7, 0x8d, 0xa15, 
       0xa, 0x8d, 0xc, 0x8d, 0xe, 0x8d, 0xa18, 0xb, 0x8d, 0x3, 0x8d, 0x7, 
       0x8d, 0xa1b, 0xa, 0x8d, 0xc, 0x8d, 0xe, 0x8d, 0xa1e, 0xb, 0x8d, 0x3, 
       0x8e, 0x3, 0x8e, 0x7, 0x8e, 0xa22, 0xa, 0x8e, 0xc, 0x8e, 0xe, 0x8e, 
       0xa25, 0xb, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 
       0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 
       0x8e, 0xa31, 0xa, 0x8e, 0x3, 0x8e, 0x7, 0x8e, 0xa34, 0xa, 0x8e, 0xc, 
       0x8e, 0xe, 0x8e, 0xa37, 0xb, 0x8e, 0x3, 0x8e, 0x7, 0x8e, 0xa3a, 0xa, 
       0x8e, 0xc, 0x8e, 0xe, 0x8e, 0xa3d, 0xb, 0x8e, 0x3, 0x8f, 0x3, 0x8f, 
       0x5, 0x8f, 0xa41, 0xa, 0x8f, 0x3, 0x90, 0x3, 0x90, 0x7, 0x90, 0xa45, 
       0xa, 0x90, 0xc, 0x90, 0xe, 0x90, 0xa48, 0xb, 0x90, 0x3, 0x90, 0x3, 
       0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 
       0x90, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 0xa54, 0xa, 0x90, 0x3, 0x91, 
       0x3, 0x91, 0x7, 0x91, 0xa58, 0xa, 0x91, 0xc, 0x91, 0xe, 0x91, 0xa5b, 
       0xb, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 
       0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 
       0xa67, 0xa, 0x91, 0x3, 0x91, 0x7, 0x91, 0xa6a, 0xa, 0x91, 0xc, 0x91, 
       0xe, 0x91, 0xa6d, 0xb, 0x91, 0x3, 0x92, 0x3, 0x92, 0x7, 0x92, 0xa71, 
       0xa, 0x92, 0xc, 0x92, 0xe, 0x92, 0xa74, 0xb, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x93, 0x3, 0x93, 0x7, 0x93, 0xa7a, 0xa, 0x93, 0xc, 0x93, 
       0xe, 0x93, 0xa7d, 0xb, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 
       0x93, 0xa88, 0xa, 0x93, 0x5, 0x93, 0xa8a, 0xa, 0x93, 0x3, 0x94, 0x3, 
       0x94, 0x7, 0x94, 0xa8e, 0xa, 0x94, 0xc, 0x94, 0xe, 0x94, 0xa91, 0xb, 
       0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 
       0x94, 0x5, 0x94, 0xa99, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x5, 0x94, 0xa9e, 0xa, 0x94, 0x5, 0x94, 0xaa0, 0xa, 0x94, 0x3, 0x95, 
       0x3, 0x95, 0x7, 0x95, 0xaa4, 0xa, 0x95, 0xc, 0x95, 0xe, 0x95, 0xaa7, 
       0xb, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 
       0x3, 0x95, 0x5, 0x95, 0xaaf, 0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 
       0x95, 0x5, 0x95, 0xab4, 0xa, 0x95, 0x5, 0x95, 0xab6, 0xa, 0x95, 0x3, 
       0x96, 0x3, 0x96, 0x7, 0x96, 0xaba, 0xa, 0x96, 0xc, 0x96, 0xe, 0x96, 
       0xabd, 0xb, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 
       0x96, 0x3, 0x96, 0x5, 0x96, 0xac5, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 
       0x3, 0x96, 0x5, 0x96, 0xaca, 0xa, 0x96, 0x5, 0x96, 0xacc, 0xa, 0x96, 
       0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 
       0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x7, 0x97, 
       0xad9, 0xa, 0x97, 0xc, 0x97, 0xe, 0x97, 0xadc, 0xb, 0x97, 0x3, 0x97, 
       0x3, 0x97, 0x3, 0x98, 0x7, 0x98, 0xae1, 0xa, 0x98, 0xc, 0x98, 0xe, 
       0x98, 0xae4, 0xb, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x99, 0x3, 0x99, 
       0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x5, 0x99, 0xaed, 0xa, 0x99, 0x3, 
       0x99, 0x5, 0x99, 0xaf0, 0xa, 0x99, 0x3, 0x99, 0x5, 0x99, 0xaf3, 0xa, 
       0x99, 0x3, 0x99, 0x5, 0x99, 0xaf6, 0xa, 0x99, 0x3, 0x99, 0x3, 0x99, 
       0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 
       0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9b, 
       0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 
       0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 
       0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 
       0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x5, 0x9f, 0xb26, 0xa, 0x9f, 0x3, 0xa0, 0x7, 
       0xa0, 0xb29, 0xa, 0xa0, 0xc, 0xa0, 0xe, 0xa0, 0xb2c, 0xb, 0xa0, 0x3, 
       0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x7, 0xa1, 0xb33, 
       0xa, 0xa1, 0xc, 0xa1, 0xe, 0xa1, 0xb36, 0xb, 0xa1, 0x3, 0xa1, 0x3, 
       0xa1, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 0xb3e, 
       0xa, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x7, 0xa4, 0xb42, 0xa, 0xa4, 0xc, 
       0xa4, 0xe, 0xa4, 0xb45, 0xb, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x5, 0xa5, 
       0xb79, 0xa, 0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 
       0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 
       0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x5, 0xa6, 0xb8a, 
       0xa, 0xa6, 0x3, 0xa6, 0x7, 0xa6, 0xb8d, 0xa, 0xa6, 0xc, 0xa6, 0xe, 
       0xa6, 0xb90, 0xb, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 
       0x7, 0xa7, 0xb96, 0xa, 0xa7, 0xc, 0xa7, 0xe, 0xa7, 0xb99, 0xb, 0xa7, 
       0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 
       0x5, 0xa7, 0xba1, 0xa, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 
       0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 
       0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 
       0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x3, 
       0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x5, 0xaa, 0xbbc, 0xa, 0xaa, 
       0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 
       0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x7, 0xab, 
       0xbc9, 0xa, 0xab, 0xc, 0xab, 0xe, 0xab, 0xbcc, 0xb, 0xab, 0x3, 0xab, 
       0x3, 0xab, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x7, 0xac, 0xbdb, 0xa, 0xac, 0xc, 0xac, 0xe, 0xac, 0xbde, 0xb, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xad, 0x3, 0xad, 0x5, 0xad, 0xbe4, 0xa, 
       0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 
       0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x7, 0xad, 0xbef, 0xa, 0xad, 
       0xc, 0xad, 0xe, 0xad, 0xbf2, 0xb, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 
       0xae, 0x3, 0xae, 0x3, 0xae, 0x7, 0xae, 0xbf9, 0xa, 0xae, 0xc, 0xae, 
       0xe, 0xae, 0xbfc, 0xb, 0xae, 0x5, 0xae, 0xbfe, 0xa, 0xae, 0x3, 0xaf, 
       0x3, 0xaf, 0x5, 0xaf, 0xc02, 0xa, 0xaf, 0x3, 0xaf, 0x7, 0xaf, 0xc05, 
       0xa, 0xaf, 0xc, 0xaf, 0xe, 0xaf, 0xc08, 0xb, 0xaf, 0x3, 0xaf, 0x3, 
       0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0xc0e, 0xa, 0xb0, 0x3, 0xb1, 
       0x3, 0xb1, 0x5, 0xb1, 0xc12, 0xa, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 
       0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xc24, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 
       0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 
       0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x7, 0xb6, 
       0xc33, 0xa, 0xb6, 0xc, 0xb6, 0xe, 0xb6, 0xc36, 0xb, 0xb6, 0x3, 0xb6, 
       0x3, 0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x7, 0xb7, 0xc3c, 0xa, 0xb7, 0xc, 
       0xb7, 0xe, 0xb7, 0xc3f, 0xb, 0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x3, 0xb8, 
       0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xc46, 0xa, 0xb8, 0x3, 0xb9, 0x3, 
       0xb9, 0x5, 0xb9, 0xc4a, 0xa, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 
       0xc4e, 0xa, 0xba, 0x3, 0xbb, 0x3, 0xbb, 0x7, 0xbb, 0xc52, 0xa, 0xbb, 
       0xc, 0xbb, 0xe, 0xbb, 0xc55, 0xb, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 
       0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbc, 0x3, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xc62, 0xa, 0xbc, 0x3, 0xbd, 
       0x3, 0xbd, 0x7, 0xbd, 0xc66, 0xa, 0xbd, 0xc, 0xbd, 0xe, 0xbd, 0xc69, 
       0xb, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 
       0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 
       0xc75, 0xa, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xc79, 0xa, 0xbe, 
       0x3, 0xbf, 0x3, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc1, 0x3, 0xc1, 
       0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x6, 0xc3, 0xc85, 0xa, 
       0xc3, 0xd, 0xc3, 0xe, 0xc3, 0xc86, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 
       0x3, 0xc4, 0x3, 0xc4, 0x5, 0xc4, 0xcee, 0xa, 0xc4, 0x3, 0xc4, 0x5, 
       0xc4, 0xcf1, 0xa, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 
       0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x5, 0xc5, 0xcfb, 0xa, 
       0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0xd01, 
       0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 
       0xd07, 0xa, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x5, 
       0xc8, 0xd0d, 0xa, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc9, 0x3, 0xc9, 
       0x5, 0xc9, 0xd13, 0xa, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcc, 0x3, 
       0xcc, 0x3, 0xcc, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xd0, 0x3, 
       0xd0, 0x3, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd2, 0x3, 
       0xd2, 0x3, 0xd2, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd4, 0x3, 
       0xd4, 0x3, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd6, 0x3, 
       0xd6, 0x3, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd8, 0x3, 
       0xd8, 0x3, 0xd8, 0x3, 0xd9, 0x3, 0xd9, 0x5, 0xd9, 0xd46, 0xa, 0xd9, 
       0x3, 0xd9, 0x3, 0xd9, 0x7, 0xd9, 0xd4a, 0xa, 0xd9, 0xc, 0xd9, 0xe, 
       0xd9, 0xd4d, 0xb, 0xd9, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0xd51, 0xa, 
       0xda, 0x3, 0xda, 0x3, 0xda, 0x7, 0xda, 0xd55, 0xa, 0xda, 0xc, 0xda, 
       0xe, 0xda, 0xd58, 0xb, 0xda, 0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0xd5c, 
       0xa, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdc, 0x3, 0xdc, 
       0x3, 0xdc, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xde, 0x3, 0xde, 
       0x3, 0xde, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 
       0x3, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe2, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe3, 0x3, 0xe3, 0x5, 0xe3, 0xd78, 0xa, 0xe3, 0x3, 
       0xe3, 0x3, 0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x5, 0xe4, 0xd7e, 0xa, 0xe4, 
       0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xd84, 0xa, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe6, 0x3, 0xe6, 0x5, 0xe6, 0xd8a, 
       0xa, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 
       0x3, 0xe8, 0x3, 0xe8, 0x5, 0xe8, 0xd93, 0xa, 0xe8, 0x3, 0xe8, 0x3, 
       0xe8, 0x3, 0xe9, 0x3, 0xe9, 0x5, 0xe9, 0xd99, 0xa, 0xe9, 0x3, 0xe9, 
       0x3, 0xe9, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xeb, 0x3, 0xeb, 
       0x5, 0xeb, 0xda2, 0xa, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xec, 0x3, 
       0xec, 0x3, 0xec, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xdab, 0xa, 0xed, 
       0x3, 0xed, 0x3, 0xed, 0x3, 0xee, 0x3, 0xee, 0x5, 0xee, 0xdb1, 0xa, 
       0xee, 0x3, 0xee, 0x3, 0xee, 0x5, 0xee, 0xdb5, 0xa, 0xee, 0x3, 0xef, 
       0x3, 0xef, 0x3, 0xef, 0x3, 0xf0, 0x3, 0xf0, 0x5, 0xf0, 0xdbc, 0xa, 
       0xf0, 0x3, 0xf0, 0x3, 0xf0, 0x3, 0xf0, 0x3, 0xf1, 0x3, 0xf1, 0x3, 
       0xf1, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf3, 0x3, 0xf3, 0x3, 
       0xf3, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf5, 0x3, 0xf5, 0x3, 
       0xf5, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf7, 0x3, 0xf7, 0x5, 
       0xf7, 0xdd5, 0xa, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf8, 
       0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xfa, 
       0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfc, 
       0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfd, 0x3, 0xfe, 
       0x3, 0xfe, 0x5, 0xfe, 0xdee, 0xa, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 
       0xff, 0x3, 0xff, 0x5, 0xff, 0xdf4, 0xa, 0xff, 0x3, 0xff, 0x3, 0xff, 
       0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x101, 0x3, 0x101, 0x5, 
       0x101, 0xdfd, 0xa, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x102, 0x3, 
       0x102, 0x3, 0x102, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x104, 
       0x3, 0x104, 0x3, 0x104, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x3, 
       0x106, 0x3, 0x106, 0x3, 0x106, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 
       0x3, 0x108, 0x3, 0x108, 0x3, 0x108, 0x3, 0x109, 0x3, 0x109, 0x5, 
       0x109, 0xe18, 0xa, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 0x3, 
       0x109, 0x3, 0x109, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 
       0x3, 0x10b, 0x3, 0x10b, 0x5, 0x10b, 0xe25, 0xa, 0x10b, 0x3, 0x10b, 
       0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10d, 0x3, 0x10d, 0x5, 0x10d, 0xe2f, 0xa, 0x10d, 0x3, 0x10d, 0x3, 
       0x10d, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10f, 0x3, 0x10f, 
       0x5, 0x10f, 0xe38, 0xa, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x110, 
       0x3, 0x110, 0x5, 0x110, 0xe3e, 0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 
       0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0xe44, 0xa, 0x111, 0x3, 0x111, 
       0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0xe49, 0xa, 0x111, 0x3, 0x111, 
       0x3, 0x111, 0x5, 0x111, 0xe4d, 0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 
       0x5, 0x111, 0xe51, 0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 
       0xe55, 0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0xe59, 0xa, 
       0x111, 0x5, 0x111, 0xe5b, 0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 
       0x112, 0x3, 0x112, 0x3, 0x113, 0x3, 0x113, 0x3, 0x114, 0x3, 0x114, 
       0x3, 0x114, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x116, 0x3, 
       0x116, 0x5, 0x116, 0xe6b, 0xa, 0x116, 0x3, 0x116, 0x3, 0x116, 0x3, 
       0x116, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x118, 0x3, 0x118, 
       0x3, 0x118, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x11a, 0x3, 
       0x11a, 0x3, 0x11a, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 0xe84, 
       0xa, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x3, 0x11f, 0x3, 0x11f, 0x3, 0x11f, 0x7, 0x11f, 0xe8e, 0xa, 
       0x11f, 0xc, 0x11f, 0xe, 0x11f, 0xe91, 0xb, 0x11f, 0x3, 0x120, 0x3, 
       0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 
       0x3, 0x120, 0x3, 0x121, 0x3, 0x121, 0x3, 0x121, 0x3, 0x122, 0x3, 
       0x122, 0x3, 0x122, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x125, 0x3, 0x125, 0x3, 0x125, 0x3, 
       0x126, 0x3, 0x126, 0x3, 0x126, 0x3, 0x127, 0x3, 0x127, 0x3, 0x127, 
       0x3, 0x128, 0x3, 0x128, 0x3, 0x128, 0x3, 0x129, 0x3, 0x129, 0x5, 
       0x129, 0xeb5, 0xa, 0x129, 0x3, 0x129, 0x3, 0x129, 0x3, 0x12a, 0x3, 
       0x12a, 0x5, 0x12a, 0xebb, 0xa, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 
       0x12b, 0x3, 0x12b, 0x5, 0x12b, 0xec1, 0xa, 0x12b, 0x3, 0x12b, 0x3, 
       0x12b, 0x3, 0x12c, 0x3, 0x12c, 0x5, 0x12c, 0xec7, 0xa, 0x12c, 0x3, 
       0x12c, 0x3, 0x12c, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 
       0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12d, 0x3, 0x12e, 0x3, 
       0x12e, 0x5, 0x12e, 0xed5, 0xa, 0x12e, 0x3, 0x12e, 0x3, 0x12e, 0x3, 
       0x12f, 0x3, 0x12f, 0x5, 0x12f, 0xedb, 0xa, 0x12f, 0x3, 0x12f, 0x3, 
       0x12f, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x130, 0x7, 0x130, 
       0xee3, 0xa, 0x130, 0xc, 0x130, 0xe, 0x130, 0xee6, 0xb, 0x130, 0x5, 
       0x130, 0xee8, 0xa, 0x130, 0x3, 0x130, 0x3, 0x130, 0x3, 0x131, 0x3, 
       0x131, 0x5, 0x131, 0xeee, 0xa, 0x131, 0x3, 0x132, 0x3, 0x132, 0x5, 
       0x132, 0xef2, 0xa, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x133, 0x3, 
       0x133, 0x3, 0x133, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x135, 
       0x3, 0x135, 0x3, 0x135, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 0x3, 
       0x137, 0x3, 0x137, 0x3, 0x137, 0x3, 0x138, 0x3, 0x138, 0x3, 0x138, 
       0x3, 0x139, 0x3, 0x139, 0x3, 0x139, 0x3, 0x13a, 0x3, 0x13a, 0x5, 
       0x13a, 0xf0d, 0xa, 0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x3, 0x13b, 0x3, 
       0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 
       0x3, 0x13b, 0x3, 0x13c, 0x3, 0x13c, 0x3, 0x13c, 0x7, 0x13c, 0xf1c, 
       0xa, 0x13c, 0xc, 0x13c, 0xe, 0x13c, 0xf1f, 0xb, 0x13c, 0x3, 0x13d, 
       0x3, 0x13d, 0x5, 0x13d, 0xf23, 0xa, 0x13d, 0x3, 0x13d, 0x3, 0x13d, 
       0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 0xf29, 0xa, 0x13e, 0x3, 0x13e, 
       0x3, 0x13e, 0x3, 0x13f, 0x3, 0x13f, 0x5, 0x13f, 0xf2f, 0xa, 0x13f, 
       0x3, 0x13f, 0x3, 0x13f, 0x3, 0x140, 0x3, 0x140, 0x5, 0x140, 0xf35, 
       0xa, 0x140, 0x3, 0x140, 0x3, 0x140, 0x3, 0x141, 0x3, 0x141, 0x5, 
       0x141, 0xf3b, 0xa, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x142, 0x3, 
       0x142, 0x5, 0x142, 0xf41, 0xa, 0x142, 0x3, 0x142, 0x3, 0x142, 0x3, 
       0x143, 0x3, 0x143, 0x5, 0x143, 0xf47, 0xa, 0x143, 0x3, 0x143, 0x3, 
       0x143, 0x3, 0x144, 0x3, 0x144, 0x5, 0x144, 0xf4d, 0xa, 0x144, 0x3, 
       0x144, 0x3, 0x144, 0x3, 0x145, 0x3, 0x145, 0x5, 0x145, 0xf53, 0xa, 
       0x145, 0x3, 0x145, 0x3, 0x145, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 
       0xf59, 0xa, 0x146, 0x3, 0x146, 0x5, 0x146, 0xf5c, 0xa, 0x146, 0x3, 
       0x146, 0x3, 0x146, 0x3, 0x147, 0x3, 0x147, 0x5, 0x147, 0xf62, 0xa, 
       0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x148, 0x3, 0x148, 0x5, 0x148, 
       0xf68, 0xa, 0x148, 0x3, 0x148, 0x3, 0x148, 0x3, 0x149, 0x3, 0x149, 
       0x3, 0x149, 0x3, 0x14a, 0x3, 0x14a, 0x5, 0x14a, 0xf71, 0xa, 0x14a, 
       0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14b, 0x3, 0x14b, 0x5, 0x14b, 0xf77, 
       0xa, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14f, 0x3, 0x14f, 0x5, 0x14f, 0xf86, 0xa, 0x14f, 
       0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x150, 0x3, 0x150, 0x5, 
       0x150, 0xf8d, 0xa, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x151, 0x3, 
       0x151, 0x5, 0x151, 0xf93, 0xa, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x152, 0x3, 0x152, 0x5, 0x152, 0xf99, 0xa, 0x152, 0x3, 0x152, 0x3, 
       0x152, 0x3, 0x153, 0x3, 0x153, 0x5, 0x153, 0xf9f, 0xa, 0x153, 0x3, 
       0x153, 0x3, 0x153, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x155, 
       0x3, 0x155, 0x5, 0x155, 0xfa8, 0xa, 0x155, 0x3, 0x155, 0x3, 0x155, 
       0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x157, 0x3, 0x157, 0x3, 
       0x157, 0x3, 0x158, 0x3, 0x158, 0x3, 0x158, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x159, 0x3, 0x15a, 0x3, 0x15a, 0x5, 0x15a, 0xfba, 0xa, 0x15a, 
       0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15b, 0x3, 0x15b, 0x5, 0x15b, 0xfc0, 
       0xa, 0x15b, 0x3, 0x15b, 0x3, 0x15b, 0x3, 0x15c, 0x3, 0x15c, 0x5, 
       0x15c, 0xfc6, 0xa, 0x15c, 0x3, 0x15c, 0x3, 0x15c, 0x3, 0x15c, 0x3, 
       0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x160, 0x3, 0x160, 0x3, 
       0x160, 0x3, 0x161, 0x3, 0x161, 0x3, 0x161, 0x3, 0x162, 0x3, 0x162, 
       0x3, 0x162, 0x3, 0x163, 0x3, 0x163, 0x5, 0x163, 0xfdf, 0xa, 0x163, 
       0x3, 0x163, 0x3, 0x163, 0x3, 0x164, 0x3, 0x164, 0x5, 0x164, 0xfe5, 
       0xa, 0x164, 0x3, 0x164, 0x3, 0x164, 0x3, 0x165, 0x3, 0x165, 0x5, 
       0x165, 0xfeb, 0xa, 0x165, 0x3, 0x165, 0x3, 0x165, 0x3, 0x166, 0x3, 
       0x166, 0x5, 0x166, 0xff1, 0xa, 0x166, 0x3, 0x166, 0x3, 0x166, 0x3, 
       0x166, 0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 0xff8, 0xa, 0x167, 0x3, 
       0x167, 0x3, 0x167, 0x3, 0x167, 0x3, 0x168, 0x3, 0x168, 0x5, 0x168, 
       0xfff, 0xa, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x169, 0x3, 0x169, 
       0x5, 0x169, 0x1005, 0xa, 0x169, 0x3, 0x169, 0x3, 0x169, 0x3, 0x16a, 
       0x3, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x100c, 0xa, 0x16a, 0x3, 0x16a, 
       0x5, 0x16a, 0x100f, 0xa, 0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x1012, 0xa, 
       0x16a, 0x3, 0x16a, 0x3, 0x16a, 0x3, 0x16b, 0x3, 0x16b, 0x3, 0x16b, 
       0x3, 0x16b, 0x5, 0x16b, 0x101a, 0xa, 0x16b, 0x5, 0x16b, 0x101c, 0xa, 
       0x16b, 0x3, 0x16b, 0x3, 0x16b, 0x3, 0x16b, 0x5, 0x16b, 0x1021, 0xa, 
       0x16b, 0x5, 0x16b, 0x1023, 0xa, 0x16b, 0x3, 0x16c, 0x3, 0x16c, 0x5, 
       0x16c, 0x1027, 0xa, 0x16c, 0x3, 0x16d, 0x3, 0x16d, 0x3, 0x16d, 0x5, 
       0x16d, 0x102c, 0xa, 0x16d, 0x3, 0x16d, 0x5, 0x16d, 0x102f, 0xa, 0x16d, 
       0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x3, 
       0x16f, 0x3, 0x170, 0x3, 0x170, 0x3, 0x170, 0x5, 0x170, 0x103a, 0xa, 
       0x170, 0x5, 0x170, 0x103c, 0xa, 0x170, 0x3, 0x171, 0x3, 0x171, 0x3, 
       0x171, 0x3, 0x171, 0x5, 0x171, 0x1042, 0xa, 0x171, 0x3, 0x171, 0x3, 
       0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 
       0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 
       0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 
       0x5, 0x171, 0x1056, 0xa, 0x171, 0x3, 0x171, 0x3, 0x171, 0x5, 0x171, 
       0x105a, 0xa, 0x171, 0x3, 0x172, 0x3, 0x172, 0x3, 0x173, 0x3, 0x173, 
       0x3, 0x174, 0x3, 0x174, 0x3, 0x174, 0x5, 0x174, 0x1063, 0xa, 0x174, 
       0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 0x3, 0x175, 0x3, 
       0x175, 0x3, 0x176, 0x3, 0x176, 0x3, 0x177, 0x3, 0x177, 0x3, 0x177, 
       0x3, 0x177, 0x3, 0x177, 0x3, 0x177, 0x3, 0x177, 0x3, 0x177, 0x3, 
       0x178, 0x3, 0x178, 0x3, 0x179, 0x3, 0x179, 0x3, 0x17a, 0x3, 0x17a, 
       0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17b, 0x3, 0x17b, 0x7, 0x17b, 0x107f, 
       0xa, 0x17b, 0xc, 0x17b, 0xe, 0x17b, 0x1082, 0xb, 0x17b, 0x5, 0x17b, 
       0x1084, 0xa, 0x17b, 0x3, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 
       0x3, 0x17c, 0x5, 0x17c, 0x108b, 0xa, 0x17c, 0x3, 0x17d, 0x3, 0x17d, 
       0x3, 0x17d, 0x3, 0x17d, 0x3, 0x17d, 0x7, 0x17d, 0x1092, 0xa, 0x17d, 
       0xc, 0x17d, 0xe, 0x17d, 0x1095, 0xb, 0x17d, 0x5, 0x17d, 0x1097, 0xa, 
       0x17d, 0x3, 0x17d, 0x5, 0x17d, 0x109a, 0xa, 0x17d, 0x3, 0x17e, 0x3, 
       0x17e, 0x3, 0x17e, 0x5, 0x17e, 0x109f, 0xa, 0x17e, 0x3, 0x17f, 0x3, 
       0x17f, 0x7, 0x17f, 0x10a3, 0xa, 0x17f, 0xc, 0x17f, 0xe, 0x17f, 0x10a6, 
       0xb, 0x17f, 0x3, 0x17f, 0x3, 0x17f, 0x3, 0x180, 0x3, 0x180, 0x3, 
       0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 
       0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 
       0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 
       0x5, 0x181, 0x10bd, 0xa, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x182, 
       0x3, 0x182, 0x5, 0x182, 0x10c3, 0xa, 0x182, 0x3, 0x183, 0x3, 0x183, 
       0x3, 0x183, 0x3, 0x183, 0x5, 0x183, 0x10c9, 0xa, 0x183, 0x3, 0x183, 
       0x5, 0x183, 0x10cc, 0xa, 0x183, 0x3, 0x183, 0x3, 0x183, 0x5, 0x183, 
       0x10d0, 0xa, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x6, 0x183, 
       0x10d5, 0xa, 0x183, 0xd, 0x183, 0xe, 0x183, 0x10d6, 0x3, 0x183, 0x3, 
       0x183, 0x5, 0x183, 0x10db, 0xa, 0x183, 0x3, 0x184, 0x3, 0x184, 0x3, 
       0x184, 0x3, 0x184, 0x5, 0x184, 0x10e1, 0xa, 0x184, 0x3, 0x184, 0x5, 
       0x184, 0x10e4, 0xa, 0x184, 0x3, 0x184, 0x3, 0x184, 0x5, 0x184, 0x10e8, 
       0xa, 0x184, 0x3, 0x184, 0x3, 0x184, 0x3, 0x184, 0x6, 0x184, 0x10ed, 
       0xa, 0x184, 0xd, 0x184, 0xe, 0x184, 0x10ee, 0x3, 0x184, 0x3, 0x184, 
       0x5, 0x184, 0x10f3, 0xa, 0x184, 0x3, 0x185, 0x3, 0x185, 0x5, 0x185, 
       0x10f7, 0xa, 0x185, 0x3, 0x185, 0x3, 0x185, 0x3, 0x185, 0x3, 0x185, 
       0x3, 0x185, 0x3, 0x186, 0x3, 0x186, 0x5, 0x186, 0x1100, 0xa, 0x186, 
       0x3, 0x186, 0x3, 0x186, 0x3, 0x186, 0x3, 0x186, 0x3, 0x186, 0x3, 
       0x187, 0x3, 0x187, 0x3, 0x188, 0x3, 0x188, 0x3, 0x189, 0x3, 0x189, 
       0x3, 0x189, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18b, 0x3, 
       0x18b, 0x3, 0x18c, 0x3, 0x18c, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18e, 
       0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 0x5, 
       0x18e, 0x111d, 0xa, 0x18e, 0x3, 0x18f, 0x3, 0x18f, 0x3, 0x190, 0x3, 
       0x190, 0x7, 0x190, 0x1123, 0xa, 0x190, 0xc, 0x190, 0xe, 0x190, 0x1126, 
       0xb, 0x190, 0x3, 0x191, 0x3, 0x191, 0x3, 0x192, 0x3, 0x192, 0x3, 
       0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 
       0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 
       0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 
       0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 
       0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 
       0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 
       0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 
       0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x3, 0x192, 0x5, 0x192, 0x1157, 
       0xa, 0x192, 0x3, 0x193, 0x3, 0x193, 0x5, 0x193, 0x115b, 0xa, 0x193, 
       0x3, 0x193, 0x3, 0x193, 0x3, 0x193, 0x3, 0x194, 0x3, 0x194, 0x5, 
       0x194, 0x1162, 0xa, 0x194, 0x5, 0x194, 0x1164, 0xa, 0x194, 0x3, 0x194, 
       0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x7, 0x194, 0x116b, 
       0xa, 0x194, 0xc, 0x194, 0xe, 0x194, 0x116e, 0xb, 0x194, 0x5, 0x194, 
       0x1170, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x195, 0x3, 0x195, 
       0x5, 0x195, 0x1176, 0xa, 0x195, 0x3, 0x195, 0x3, 0x195, 0x3, 0x195, 
       0x5, 0x195, 0x117b, 0xa, 0x195, 0x3, 0x196, 0x3, 0x196, 0x5, 0x196, 
       0x117f, 0xa, 0x196, 0x3, 0x196, 0x5, 0x196, 0x1182, 0xa, 0x196, 0x3, 
       0x196, 0x3, 0x196, 0x3, 0x197, 0x3, 0x197, 0x5, 0x197, 0x1188, 0xa, 
       0x197, 0x3, 0x197, 0x3, 0x197, 0x3, 0x198, 0x3, 0x198, 0x5, 0x198, 
       0x118e, 0xa, 0x198, 0x3, 0x198, 0x5, 0x198, 0x1191, 0xa, 0x198, 0x3, 
       0x199, 0x3, 0x199, 0x5, 0x199, 0x1195, 0xa, 0x199, 0x3, 0x199, 0x3, 
       0x199, 0x3, 0x19a, 0x3, 0x19a, 0x5, 0x19a, 0x119b, 0xa, 0x19a, 0x3, 
       0x19a, 0x5, 0x19a, 0x119e, 0xa, 0x19a, 0x3, 0x19a, 0x3, 0x19a, 0x3, 
       0x19b, 0x3, 0x19b, 0x5, 0x19b, 0x11a4, 0xa, 0x19b, 0x3, 0x19b, 0x3, 
       0x19b, 0x3, 0x19c, 0x3, 0x19c, 0x5, 0x19c, 0x11aa, 0xa, 0x19c, 0x3, 
       0x19c, 0x3, 0x19c, 0x3, 0x19d, 0x3, 0x19d, 0x5, 0x19d, 0x11b0, 0xa, 
       0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x5, 0x19d, 0x11b5, 0xa, 
       0x19d, 0x5, 0x19d, 0x11b7, 0xa, 0x19d, 0x5, 0x19d, 0x11b9, 0xa, 0x19d, 
       0x3, 0x19e, 0x3, 0x19e, 0x5, 0x19e, 0x11bd, 0xa, 0x19e, 0x3, 0x19e, 
       0x5, 0x19e, 0x11c0, 0xa, 0x19e, 0x3, 0x19f, 0x3, 0x19f, 0x3, 0x1a0, 
       0x3, 0x1a0, 0x5, 0x1a0, 0x11c6, 0xa, 0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 
       0x3, 0x1a1, 0x3, 0x1a1, 0x3, 0x1a2, 0x3, 0x1a2, 0x3, 0x1a3, 0x3, 
       0x1a3, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a6, 
       0x3, 0x1a6, 0x5, 0x1a6, 0x11d6, 0xa, 0x1a6, 0x5, 0x1a6, 0x11d8, 0xa, 
       0x1a6, 0x3, 0x1a6, 0x3, 0x1a6, 0x3, 0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 
       0x11de, 0xa, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a8, 0x3, 0x1a8, 
       0x5, 0x1a8, 0x11e4, 0xa, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a9, 
       0x3, 0x1a9, 0x5, 0x1a9, 0x11ea, 0xa, 0x1a9, 0x3, 0x1aa, 0x3, 0x1aa, 
       0x5, 0x1aa, 0x11ee, 0xa, 0x1aa, 0x3, 0x1aa, 0x3, 0x1aa, 0x5, 0x1aa, 
       0x11f2, 0xa, 0x1aa, 0x3, 0x1ab, 0x3, 0x1ab, 0x3, 0x1ab, 0x3, 0x1ac, 
       0x3, 0x1ac, 0x5, 0x1ac, 0x11f9, 0xa, 0x1ac, 0x3, 0x1ac, 0x3, 0x1ac, 
       0x3, 0x1ad, 0x3, 0x1ad, 0x5, 0x1ad, 0x11ff, 0xa, 0x1ad, 0x3, 0x1ad, 
       0x3, 0x1ad, 0x3, 0x1ad, 0x5, 0x1ad, 0x1204, 0xa, 0x1ad, 0x3, 0x1ad, 
       0x3, 0x1ad, 0x5, 0x1ad, 0x1208, 0xa, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 
       0x5, 0x1ad, 0x120c, 0xa, 0x1ad, 0x3, 0x1ae, 0x3, 0x1ae, 0x3, 0x1ae, 
       0x3, 0x1af, 0x3, 0x1af, 0x5, 0x1af, 0x1213, 0xa, 0x1af, 0x3, 0x1af, 
       0x3, 0x1af, 0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1219, 0xa, 0x1b0, 
       0x3, 0x1b0, 0x5, 0x1b0, 0x121c, 0xa, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b1, 0x3, 0x1b1, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b3, 0x3, 
       0x1b3, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b5, 0x3, 0x1b5, 0x5, 0x1b5, 
       0x122a, 0xa, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x5, 0x1b5, 0x122e, 0xa, 
       0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b6, 0x3, 0x1b6, 0x3, 0x1b6, 
       0x3, 0x1b6, 0x7, 0x1b6, 0x1236, 0xa, 0x1b6, 0xc, 0x1b6, 0xe, 0x1b6, 
       0x1239, 0xb, 0x1b6, 0x5, 0x1b6, 0x123b, 0xa, 0x1b6, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x5, 0x1b7, 0x123f, 0xa, 0x1b7, 0x3, 0x1b7, 0x3, 0x1b7, 0x3, 
       0x1b8, 0x3, 0x1b8, 0x3, 0x1b9, 0x3, 0x1b9, 0x5, 0x1b9, 0x1247, 0xa, 
       0x1b9, 0x3, 0x1b9, 0x5, 0x1b9, 0x124a, 0xa, 0x1b9, 0x3, 0x1b9, 0x3, 
       0x1b9, 0x3, 0x1ba, 0x3, 0x1ba, 0x5, 0x1ba, 0x1250, 0xa, 0x1ba, 0x3, 
       0x1ba, 0x3, 0x1ba, 0x5, 0x1ba, 0x1254, 0xa, 0x1ba, 0x3, 0x1ba, 0x3, 
       0x1ba, 0x3, 0x1bb, 0x3, 0x1bb, 0x5, 0x1bb, 0x125a, 0xa, 0x1bb, 0x3, 
       0x1bb, 0x3, 0x1bb, 0x5, 0x1bb, 0x125e, 0xa, 0x1bb, 0x3, 0x1bc, 0x3, 
       0x1bc, 0x5, 0x1bc, 0x1262, 0xa, 0x1bc, 0x3, 0x1bc, 0x3, 0x1bc, 0x5, 
       0x1bc, 0x1266, 0xa, 0x1bc, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x126a, 
       0xa, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x126f, 
       0xa, 0x1bd, 0x3, 0x1be, 0x3, 0x1be, 0x5, 0x1be, 0x1273, 0xa, 0x1be, 
       0x3, 0x1be, 0x3, 0x1be, 0x5, 0x1be, 0x1277, 0xa, 0x1be, 0x3, 0x1bf, 
       0x3, 0x1bf, 0x5, 0x1bf, 0x127b, 0xa, 0x1bf, 0x3, 0x1bf, 0x3, 0x1bf, 
       0x3, 0x1bf, 0x5, 0x1bf, 0x1280, 0xa, 0x1bf, 0x3, 0x1c0, 0x3, 0x1c0, 
       0x5, 0x1c0, 0x1284, 0xa, 0x1c0, 0x3, 0x1c0, 0x3, 0x1c0, 0x5, 0x1c0, 
       0x1288, 0xa, 0x1c0, 0x3, 0x1c0, 0x3, 0x1c0, 0x3, 0x1c1, 0x3, 0x1c1, 
       0x5, 0x1c1, 0x128e, 0xa, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 
       0x5, 0x1c1, 0x1293, 0xa, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c1, 0x3, 0x1c2, 
       0x3, 0x1c2, 0x5, 0x1c2, 0x1299, 0xa, 0x1c2, 0x3, 0x1c2, 0x5, 0x1c2, 
       0x129c, 0xa, 0x1c2, 0x3, 0x1c2, 0x5, 0x1c2, 0x129f, 0xa, 0x1c2, 0x3, 
       0x1c2, 0x3, 0x1c2, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x12a5, 0xa, 
       0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x12a8, 0xa, 0x1c3, 0x3, 0x1c4, 0x3, 
       0x1c4, 0x5, 0x1c4, 0x12ac, 0xa, 0x1c4, 0x3, 0x1c5, 0x3, 0x1c5, 0x3, 
       0x1c6, 0x3, 0x1c6, 0x5, 0x1c6, 0x12b2, 0xa, 0x1c6, 0x3, 0x1c6, 0x3, 
       0x1c6, 0x3, 0x1c6, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x12b9, 0xa, 
       0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c8, 0x3, 0x1c8, 
       0x5, 0x1c8, 0x12c0, 0xa, 0x1c8, 0x3, 0x1c8, 0x3, 0x1c8, 0x5, 0x1c8, 
       0x12c4, 0xa, 0x1c8, 0x3, 0x1c9, 0x3, 0x1c9, 0x5, 0x1c9, 0x12c8, 0xa, 
       0x1c9, 0x3, 0x1c9, 0x5, 0x1c9, 0x12cb, 0xa, 0x1c9, 0x3, 0x1c9, 0x3, 
       0x1c9, 0x3, 0x1ca, 0x3, 0x1ca, 0x5, 0x1ca, 0x12d1, 0xa, 0x1ca, 0x3, 
       0x1ca, 0x3, 0x1ca, 0x3, 0x1cb, 0x3, 0x1cb, 0x5, 0x1cb, 0x12d7, 0xa, 
       0x1cb, 0x3, 0x1cb, 0x3, 0x1cb, 0x3, 0x1cb, 0x5, 0x1cb, 0x12dc, 0xa, 
       0x1cb, 0x3, 0x1cc, 0x3, 0x1cc, 0x5, 0x1cc, 0x12e0, 0xa, 0x1cc, 0x3, 
       0x1cc, 0x3, 0x1cc, 0x3, 0x1cd, 0x3, 0x1cd, 0x5, 0x1cd, 0x12e6, 0xa, 
       0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x5, 0x1cd, 0x12ea, 0xa, 0x1cd, 0x3, 
       0x1ce, 0x3, 0x1ce, 0x5, 0x1ce, 0x12ee, 0xa, 0x1ce, 0x3, 0x1ce, 0x3, 
       0x1ce, 0x3, 0x1ce, 0x3, 0x1cf, 0x3, 0x1cf, 0x5, 0x1cf, 0x12f5, 0xa, 
       0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1d0, 0x3, 0x1d0, 
       0x5, 0x1d0, 0x12fc, 0xa, 0x1d0, 0x3, 0x1d1, 0x3, 0x1d1, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 
       0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 0x3, 0x1d2, 
       0x3, 0x1d2, 0x3, 0x1d2, 0x5, 0x1d2, 0x1350, 0xa, 0x1d2, 0x3, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x7, 0x1d3, 0x1356, 0xa, 0x1d3, 
       0xc, 0x1d3, 0xe, 0x1d3, 0x1359, 0xb, 0x1d3, 0x5, 0x1d3, 0x135b, 0xa, 
       0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x135e, 0xa, 0x1d3, 0x3, 0x1d4, 0x3, 
       0x1d4, 0x3, 0x1d5, 0x3, 0x1d5, 0x3, 0x1d6, 0x3, 0x1d6, 0x3, 0x1d7, 
       0x3, 0x1d7, 0x3, 0x1d7, 0x5, 0x1d7, 0x1369, 0xa, 0x1d7, 0x3, 0x1d8, 
       0x3, 0x1d8, 0x3, 0x1d8, 0x3, 0x1d8, 0x5, 0x1d8, 0x136f, 0xa, 0x1d8, 
       0x3, 0x1d8, 0x3, 0x1d8, 0x5, 0x1d8, 0x1373, 0xa, 0x1d8, 0x3, 0x1d8, 
       0x3, 0x1d8, 0x5, 0x1d8, 0x1377, 0xa, 0x1d8, 0x3, 0x1d8, 0x3, 0x1d8, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1db, 0x3, 
       0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x5, 0x1db, 
       0x1385, 0xa, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1dc, 0x3, 0x1dc, 
       0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 
       0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x5, 0x1dd, 0x1393, 0xa, 0x1dd, 0x3, 
       0x1dd, 0x3, 0x1dd, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 
       0x3, 0x1de, 0x3, 0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x7, 0x1df, 0x13a3, 0xa, 0x1df, 0xc, 
       0x1df, 0xe, 0x1df, 0x13a6, 0xb, 0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x3, 
       0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 0x1e1, 
       0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 
       0x1e1, 0x7, 0x1e1, 0x13b6, 0xa, 0x1e1, 0xc, 0x1e1, 0xe, 0x1e1, 0x13b9, 
       0xb, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 
       0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e2, 0x3, 0x1e3, 
       0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x5, 0x1e3, 0x13c9, 
       0xa, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 
       0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x5, 0x1e4, 
       0x13d4, 0xa, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e5, 0x3, 0x1e5, 
       0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x5, 
       0x1e5, 0x13df, 0xa, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e6, 0x3, 
       0x1e6, 0x3, 0x1e6, 0x5, 0x1e6, 0x13e6, 0xa, 0x1e6, 0x3, 0x1e6, 0x3, 
       0x1e6, 0x5, 0x1e6, 0x13ea, 0xa, 0x1e6, 0x3, 0x1e6, 0x5, 0x1e6, 0x13ed, 
       0xa, 0x1e6, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 
       0x1e7, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 
       0x5, 0x1e8, 0x13f9, 0xa, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x5, 0x1e8, 
       0x13fd, 0xa, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e8, 0x3, 0x1e9, 0x3, 0x1e9, 
       0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1e9, 0x3, 0x1e9, 0x3, 
       0x1e9, 0x3, 0x1e9, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 
       0x3, 0x1ea, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 
       0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1ec, 
       0x3, 0x1ec, 0x3, 0x1ec, 0x3, 0x1ec, 0x3, 0x1ec, 0x3, 0x1ec, 0x3, 
       0x1ec, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 
       0x3, 0x1ed, 0x3, 0x1ed, 0x5, 0x1ed, 0x1426, 0xa, 0x1ed, 0x3, 0x1ed, 
       0x3, 0x1ed, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 0x1ee, 0x3, 
       0x1ee, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1ef, 
       0x3, 0x1ef, 0x3, 0x1ef, 0x3, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f0, 0x3, 
       0x1f0, 0x3, 0x1f0, 0x3, 0x1f1, 0x3, 0x1f1, 0x3, 0x1f1, 0x5, 0x1f1, 
       0x143e, 0xa, 0x1f1, 0x3, 0x1f1, 0x5, 0x1f1, 0x1441, 0xa, 0x1f1, 0x3, 
       0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 0x5, 0x1f2, 
       0x1448, 0xa, 0x1f2, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x5, 0x1f3, 
       0x144d, 0xa, 0x1f3, 0x3, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f4, 
       0x3, 0x1f4, 0x7, 0x1f4, 0x1454, 0xa, 0x1f4, 0xc, 0x1f4, 0xe, 0x1f4, 
       0x1457, 0xb, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f4, 0x3, 0x1f5, 0x3, 0x1f5, 
       0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 
       0x1f6, 0x5, 0x1f6, 0x1463, 0xa, 0x1f6, 0x3, 0x1f6, 0x5, 0x1f6, 0x1466, 
       0xa, 0x1f6, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 
       0x1f7, 0x5, 0x1f7, 0x146d, 0xa, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 
       0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 
       0x3, 0x1f8, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 
       0x1f9, 0x3, 0x1fa, 0x3, 0x1fa, 0x3, 0x1fa, 0x3, 0x1fa, 0x3, 0x1fa, 
       0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 0x3, 
       0x1fc, 0x3, 0x1fc, 0x3, 0x1fc, 0x3, 0x1fc, 0x3, 0x1fc, 0x5, 0x1fc, 
       0x148c, 0xa, 0x1fc, 0x3, 0x1fc, 0x3, 0x1fc, 0x3, 0x1fd, 0x3, 0x1fd, 
       0x3, 0x1fd, 0x3, 0x1fd, 0x3, 0x1fd, 0x5, 0x1fd, 0x1495, 0xa, 0x1fd, 
       0x3, 0x1fd, 0x3, 0x1fd, 0x3, 0x1fe, 0x3, 0x1fe, 0x3, 0x1fe, 0x3, 
       0x1ff, 0x3, 0x1ff, 0x3, 0x1ff, 0x3, 0x200, 0x3, 0x200, 0x3, 0x200, 
       0x3, 0x201, 0x3, 0x201, 0x3, 0x201, 0x3, 0x202, 0x3, 0x202, 0x3, 
       0x202, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 0x3, 0x203, 
       0x3, 0x204, 0x3, 0x204, 0x3, 0x204, 0x3, 0x204, 0x3, 0x204, 0x3, 
       0x205, 0x3, 0x205, 0x3, 0x205, 0x3, 0x205, 0x3, 0x205, 0x3, 0x206, 
       0x3, 0x206, 0x3, 0x206, 0x3, 0x206, 0x3, 0x206, 0x3, 0x207, 0x3, 
       0x207, 0x3, 0x207, 0x3, 0x207, 0x3, 0x207, 0x3, 0x208, 0x3, 0x208, 
       0x3, 0x208, 0x3, 0x208, 0x3, 0x208, 0x3, 0x209, 0x3, 0x209, 0x3, 
       0x209, 0x3, 0x209, 0x3, 0x209, 0x3, 0x20a, 0x3, 0x20a, 0x3, 0x20a, 
       0x5, 0x20a, 0x14ce, 0xa, 0x20a, 0x3, 0x20b, 0x3, 0x20b, 0x3, 0x20b, 
       0x3, 0x20b, 0x3, 0x20b, 0x3, 0x20c, 0x3, 0x20c, 0x3, 0x20c, 0x3, 
       0x20c, 0x3, 0x20c, 0x3, 0x20c, 0x3, 0x20c, 0x3, 0x20d, 0x3, 0x20d, 
       0x3, 0x20d, 0x3, 0x20d, 0x3, 0x20d, 0x3, 0x20d, 0x3, 0x20d, 0x3, 
       0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 
       0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x5, 0x20e, 0x14ec, 0xa, 0x20e, 
       0x5, 0x20e, 0x14ee, 0xa, 0x20e, 0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20f, 
       0x3, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x3, 
       0x20f, 0x5, 0x20f, 0x14f9, 0xa, 0x20f, 0x3, 0x20f, 0x3, 0x20f, 0x3, 
       0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 
       0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x3, 0x210, 0x5, 
       0x210, 0x1508, 0xa, 0x210, 0x5, 0x210, 0x150a, 0xa, 0x210, 0x3, 0x210, 
       0x3, 0x210, 0x3, 0x211, 0x3, 0x211, 0x3, 0x211, 0x3, 0x211, 0x3, 
       0x211, 0x3, 0x212, 0x3, 0x212, 0x3, 0x213, 0x3, 0x213, 0x3, 0x213, 
       0x3, 0x213, 0x3, 0x213, 0x5, 0x213, 0x151a, 0xa, 0x213, 0x3, 0x213, 
       0x3, 0x213, 0x3, 0x214, 0x3, 0x214, 0x3, 0x214, 0x3, 0x214, 0x3, 
       0x214, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 0x3, 0x215, 
       0x5, 0x215, 0x1528, 0xa, 0x215, 0x3, 0x216, 0x3, 0x216, 0x3, 0x216, 
       0x3, 0x216, 0x3, 0x216, 0x5, 0x216, 0x152f, 0xa, 0x216, 0x3, 0x216, 
       0x3, 0x216, 0x3, 0x217, 0x3, 0x217, 0x3, 0x217, 0x3, 0x217, 0x3, 
       0x217, 0x3, 0x217, 0x3, 0x217, 0x5, 0x217, 0x153a, 0xa, 0x217, 0x3, 
       0x217, 0x3, 0x217, 0x3, 0x218, 0x3, 0x218, 0x3, 0x218, 0x3, 0x218, 
       0x3, 0x218, 0x3, 0x218, 0x3, 0x218, 0x3, 0x219, 0x3, 0x219, 0x3, 
       0x219, 0x3, 0x219, 0x3, 0x219, 0x3, 0x219, 0x3, 0x219, 0x5, 0x219, 
       0x154c, 0xa, 0x219, 0x3, 0x219, 0x3, 0x219, 0x3, 0x21a, 0x3, 0x21a, 
       0x3, 0x21b, 0x3, 0x21b, 0x3, 0x21b, 0x5, 0x21b, 0x1555, 0xa, 0x21b, 
       0x3, 0x21b, 0x3, 0x21b, 0x5, 0x21b, 0x1559, 0xa, 0x21b, 0x3, 0x21b, 
       0x5, 0x21b, 0x155c, 0xa, 0x21b, 0x3, 0x21c, 0x3, 0x21c, 0x3, 0x21c, 
       0x5, 0x21c, 0x1561, 0xa, 0x21c, 0x3, 0x21c, 0x3, 0x21c, 0x5, 0x21c, 
       0x1565, 0xa, 0x21c, 0x3, 0x21c, 0x5, 0x21c, 0x1568, 0xa, 0x21c, 0x3, 
       0x21d, 0x3, 0x21d, 0x3, 0x21d, 0x3, 0x21e, 0x3, 0x21e, 0x3, 0x21e, 
       0x3, 0x21f, 0x3, 0x21f, 0x3, 0x21f, 0x3, 0x220, 0x3, 0x220, 0x3, 
       0x220, 0x3, 0x221, 0x3, 0x221, 0x3, 0x221, 0x3, 0x222, 0x3, 0x222, 
       0x3, 0x222, 0x3, 0x222, 0x3, 0x222, 0x5, 0x222, 0x157e, 0xa, 0x222, 
       0x3, 0x222, 0x3, 0x222, 0x3, 0x223, 0x3, 0x223, 0x3, 0x223, 0x3, 
       0x223, 0x3, 0x223, 0x5, 0x223, 0x1587, 0xa, 0x223, 0x3, 0x223, 0x3, 
       0x223, 0x3, 0x224, 0x3, 0x224, 0x3, 0x224, 0x3, 0x224, 0x3, 0x224, 
       0x5, 0x224, 0x1590, 0xa, 0x224, 0x3, 0x224, 0x3, 0x224, 0x3, 0x225, 
       0x3, 0x225, 0x3, 0x225, 0x3, 0x225, 0x3, 0x225, 0x3, 0x226, 0x3, 
       0x226, 0x3, 0x226, 0x3, 0x226, 0x3, 0x226, 0x3, 0x227, 0x3, 0x227, 
       0x3, 0x227, 0x3, 0x227, 0x3, 0x227, 0x3, 0x228, 0x3, 0x228, 0x3, 
       0x228, 0x3, 0x228, 0x3, 0x228, 0x3, 0x229, 0x3, 0x229, 0x3, 0x229, 
       0x3, 0x229, 0x3, 0x229, 0x3, 0x229, 0x3, 0x229, 0x3, 0x229, 0x3, 
       0x229, 0x5, 0x229, 0x15b1, 0xa, 0x229, 0x3, 0x229, 0x3, 0x229, 0x3, 
       0x22a, 0x3, 0x22a, 0x3, 0x22a, 0x3, 0x22a, 0x3, 0x22a, 0x5, 0x22a, 
       0x15ba, 0xa, 0x22a, 0x3, 0x22a, 0x3, 0x22a, 0x3, 0x22b, 0x3, 0x22b, 
       0x3, 0x22b, 0x3, 0x22b, 0x3, 0x22b, 0x3, 0x22c, 0x3, 0x22c, 0x3, 
       0x22d, 0x3, 0x22d, 0x3, 0x22d, 0x5, 0x22d, 0x15c8, 0xa, 0x22d, 0x3, 
       0x22d, 0x5, 0x22d, 0x15cb, 0xa, 0x22d, 0x3, 0x22e, 0x3, 0x22e, 0x5, 
       0x22e, 0x15cf, 0xa, 0x22e, 0x3, 0x22e, 0x5, 0x22e, 0x15d2, 0xa, 0x22e, 
       0x3, 0x22f, 0x3, 0x22f, 0x3, 0x22f, 0x3, 0x230, 0x3, 0x230, 0x6, 
       0x230, 0x15d9, 0xa, 0x230, 0xd, 0x230, 0xe, 0x230, 0x15da, 0x3, 0x230, 
       0x3, 0x230, 0x3, 0x231, 0x3, 0x231, 0x5, 0x231, 0x15e1, 0xa, 0x231, 
       0x3, 0x232, 0x3, 0x232, 0x3, 0x232, 0x3, 0x232, 0x3, 0x232, 0x3, 
       0x233, 0x3, 0x233, 0x3, 0x233, 0x3, 0x233, 0x3, 0x234, 0x3, 0x234, 
       0x3, 0x234, 0x3, 0x234, 0x3, 0x235, 0x3, 0x235, 0x5, 0x235, 0x15f2, 
       0xa, 0x235, 0x3, 0x236, 0x3, 0x236, 0x3, 0x236, 0x3, 0x236, 0x3, 
       0x236, 0x3, 0x236, 0x3, 0x236, 0x3, 0x236, 0x3, 0x236, 0x5, 0x236, 
       0x15fd, 0xa, 0x236, 0x3, 0x237, 0x3, 0x237, 0x3, 0x237, 0x3, 0x238, 
       0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 
       0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x5, 0x238, 
       0x160d, 0xa, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 
       0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 
       0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 
       0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 
       0x238, 0x3, 0x238, 0x5, 0x238, 0x1625, 0xa, 0x238, 0x3, 0x238, 0x3, 
       0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 
       0x7, 0x238, 0x162e, 0xa, 0x238, 0xc, 0x238, 0xe, 0x238, 0x1631, 0xb, 
       0x238, 0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 0x23a, 
       0x3, 0x23a, 0x3, 0x23b, 0x3, 0x23b, 0x3, 0x23b, 0x3, 0x23c, 0x3, 
       0x23c, 0x3, 0x23d, 0x3, 0x23d, 0x3, 0x23e, 0x3, 0x23e, 0x3, 0x23f, 
       0x3, 0x23f, 0x3, 0x23f, 0x3, 0x23f, 0x7, 0x23f, 0x1646, 0xa, 0x23f, 
       0xc, 0x23f, 0xe, 0x23f, 0x1649, 0xb, 0x23f, 0x5, 0x23f, 0x164b, 0xa, 
       0x23f, 0x3, 0x23f, 0x3, 0x23f, 0x3, 0x240, 0x3, 0x240, 0x7, 0x240, 
       0x1651, 0xa, 0x240, 0xc, 0x240, 0xe, 0x240, 0x1654, 0xb, 0x240, 0x3, 
       0x240, 0x3, 0x240, 0x3, 0x241, 0x3, 0x241, 0x3, 0x241, 0x5, 0x241, 
       0x165b, 0xa, 0x241, 0x3, 0x242, 0x3, 0x242, 0x5, 0x242, 0x165f, 0xa, 
       0x242, 0x3, 0x243, 0x3, 0x243, 0x3, 0x244, 0x3, 0x244, 0x3, 0x244, 
       0x7, 0x244, 0x1666, 0xa, 0x244, 0xc, 0x244, 0xe, 0x244, 0x1669, 0xb, 
       0x244, 0x3, 0x245, 0x3, 0x245, 0x5, 0x245, 0x166d, 0xa, 0x245, 0x3, 
       0x246, 0x3, 0x246, 0x3, 0x246, 0x3, 0x246, 0x5, 0x246, 0x1673, 0xa, 
       0x246, 0x3, 0x246, 0x3, 0x246, 0x3, 0x247, 0x3, 0x247, 0x3, 0x248, 
       0x5, 0x248, 0x167a, 0xa, 0x248, 0x3, 0x248, 0x3, 0x248, 0x7, 0x248, 
       0x167e, 0xa, 0x248, 0xc, 0x248, 0xe, 0x248, 0x1681, 0xb, 0x248, 0x3, 
       0x249, 0x3, 0x249, 0x5, 0x249, 0x1685, 0xa, 0x249, 0x3, 0x249, 0x3, 
       0x249, 0x3, 0x249, 0x3, 0x249, 0x3, 0x249, 0x3, 0x249, 0x5, 0x249, 
       0x168d, 0xa, 0x249, 0x3, 0x24a, 0x3, 0x24a, 0x3, 0x24a, 0x6, 0x24a, 
       0x1692, 0xa, 0x24a, 0xd, 0x24a, 0xe, 0x24a, 0x1693, 0x3, 0x24a, 0x3, 
       0x24a, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 
       0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 0x24b, 0x3, 
       0x24b, 0x3, 0x24b, 0x5, 0x24b, 0x16f1, 0xa, 0x24b, 0x3, 0x24c, 0x3, 
       0x24c, 0x3, 0x24d, 0x3, 0x24d, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 
       0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 
       0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x5, 0x24e, 
       0x1704, 0xa, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 0x3, 0x24e, 
       0x3, 0x24e, 0x7, 0x24e, 0x170b, 0xa, 0x24e, 0xc, 0x24e, 0xe, 0x24e, 
       0x170e, 0xb, 0x24e, 0x3, 0x24e, 0x2, 0x4, 0x46e, 0x49a, 0x24f, 0x2, 
       0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 
       0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 
       0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 
       0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 
       0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 
       0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 
       0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 
       0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 
       0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 
       0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 
       0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 
       0xf8, 0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 
       0x10c, 0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 
       0x120, 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 
       0x134, 0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 0x144, 0x146, 
       0x148, 0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 
       0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 
       0x170, 0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 0x180, 0x182, 
       0x184, 0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 0x194, 0x196, 
       0x198, 0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 
       0x1ac, 0x1ae, 0x1b0, 0x1b2, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 
       0x1c0, 0x1c2, 0x1c4, 0x1c6, 0x1c8, 0x1ca, 0x1cc, 0x1ce, 0x1d0, 0x1d2, 
       0x1d4, 0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 
       0x1e8, 0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f2, 0x1f4, 0x1f6, 0x1f8, 0x1fa, 
       0x1fc, 0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 
       0x210, 0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x220, 0x222, 
       0x224, 0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x234, 0x236, 
       0x238, 0x23a, 0x23c, 0x23e, 0x240, 0x242, 0x244, 0x246, 0x248, 0x24a, 
       0x24c, 0x24e, 0x250, 0x252, 0x254, 0x256, 0x258, 0x25a, 0x25c, 0x25e, 
       0x260, 0x262, 0x264, 0x266, 0x268, 0x26a, 0x26c, 0x26e, 0x270, 0x272, 
       0x274, 0x276, 0x278, 0x27a, 0x27c, 0x27e, 0x280, 0x282, 0x284, 0x286, 
       0x288, 0x28a, 0x28c, 0x28e, 0x290, 0x292, 0x294, 0x296, 0x298, 0x29a, 
       0x29c, 0x29e, 0x2a0, 0x2a2, 0x2a4, 0x2a6, 0x2a8, 0x2aa, 0x2ac, 0x2ae, 
       0x2b0, 0x2b2, 0x2b4, 0x2b6, 0x2b8, 0x2ba, 0x2bc, 0x2be, 0x2c0, 0x2c2, 
       0x2c4, 0x2c6, 0x2c8, 0x2ca, 0x2cc, 0x2ce, 0x2d0, 0x2d2, 0x2d4, 0x2d6, 
       0x2d8, 0x2da, 0x2dc, 0x2de, 0x2e0, 0x2e2, 0x2e4, 0x2e6, 0x2e8, 0x2ea, 
       0x2ec, 0x2ee, 0x2f0, 0x2f2, 0x2f4, 0x2f6, 0x2f8, 0x2fa, 0x2fc, 0x2fe, 
       0x300, 0x302, 0x304, 0x306, 0x308, 0x30a, 0x30c, 0x30e, 0x310, 0x312, 
       0x314, 0x316, 0x318, 0x31a, 0x31c, 0x31e, 0x320, 0x322, 0x324, 0x326, 
       0x328, 0x32a, 0x32c, 0x32e, 0x330, 0x332, 0x334, 0x336, 0x338, 0x33a, 
       0x33c, 0x33e, 0x340, 0x342, 0x344, 0x346, 0x348, 0x34a, 0x34c, 0x34e, 
       0x350, 0x352, 0x354, 0x356, 0x358, 0x35a, 0x35c, 0x35e, 0x360, 0x362, 
       0x364, 0x366, 0x368, 0x36a, 0x36c, 0x36e, 0x370, 0x372, 0x374, 0x376, 
       0x378, 0x37a, 0x37c, 0x37e, 0x380, 0x382, 0x384, 0x386, 0x388, 0x38a, 
       0x38c, 0x38e, 0x390, 0x392, 0x394, 0x396, 0x398, 0x39a, 0x39c, 0x39e, 
       0x3a0, 0x3a2, 0x3a4, 0x3a6, 0x3a8, 0x3aa, 0x3ac, 0x3ae, 0x3b0, 0x3b2, 
       0x3b4, 0x3b6, 0x3b8, 0x3ba, 0x3bc, 0x3be, 0x3c0, 0x3c2, 0x3c4, 0x3c6, 
       0x3c8, 0x3ca, 0x3cc, 0x3ce, 0x3d0, 0x3d2, 0x3d4, 0x3d6, 0x3d8, 0x3da, 
       0x3dc, 0x3de, 0x3e0, 0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 0x3ec, 0x3ee, 
       0x3f0, 0x3f2, 0x3f4, 0x3f6, 0x3f8, 0x3fa, 0x3fc, 0x3fe, 0x400, 0x402, 
       0x404, 0x406, 0x408, 0x40a, 0x40c, 0x40e, 0x410, 0x412, 0x414, 0x416, 
       0x418, 0x41a, 0x41c, 0x41e, 0x420, 0x422, 0x424, 0x426, 0x428, 0x42a, 
       0x42c, 0x42e, 0x430, 0x432, 0x434, 0x436, 0x438, 0x43a, 0x43c, 0x43e, 
       0x440, 0x442, 0x444, 0x446, 0x448, 0x44a, 0x44c, 0x44e, 0x450, 0x452, 
       0x454, 0x456, 0x458, 0x45a, 0x45c, 0x45e, 0x460, 0x462, 0x464, 0x466, 
       0x468, 0x46a, 0x46c, 0x46e, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47a, 
       0x47c, 0x47e, 0x480, 0x482, 0x484, 0x486, 0x488, 0x48a, 0x48c, 0x48e, 
       0x490, 0x492, 0x494, 0x496, 0x498, 0x49a, 0x2, 0x21, 0x3, 0x3, 0x276, 
       0x276, 0x6, 0x2, 0x1a9, 0x1a9, 0x1ae, 0x1ae, 0x1b3, 0x1b3, 0x1be, 
       0x1be, 0x5, 0x2, 0xd6, 0xd6, 0x103, 0x104, 0x10b, 0x10b, 0x4, 0x2, 
       0x3d, 0x3d, 0x185, 0x185, 0x3, 0x2, 0x1ad, 0x1ae, 0x3, 0x2, 0x143, 
       0x154, 0x3, 0x3, 0x1d2, 0x1d2, 0x5, 0x2, 0x2b3, 0x2b6, 0x2b8, 0x2bd, 
       0x2c2, 0x2c2, 0x4, 0x2, 0x1c3, 0x1c4, 0x1c9, 0x1c9, 0x3, 0x2, 0x241, 
       0x242, 0x4, 0x2, 0x8, 0xa, 0xd, 0xd, 0x3, 0x2, 0x2b1, 0x2b2, 0x5, 
       0x2, 0x2b3, 0x2b3, 0x2b6, 0x2b8, 0x2be, 0x2c0, 0x4, 0x2, 0x2b3, 0x2b6, 
       0x2b8, 0x2bd, 0x3, 0x2, 0x1c1, 0x1c2, 0x5, 0x2, 0x2b3, 0x2b4, 0x2b6, 
       0x2b6, 0x2b9, 0x2bc, 0x5, 0x2, 0x2b3, 0x2b4, 0x2b6, 0x2b6, 0x2ba, 
       0x2bc, 0x6, 0x2, 0x2b3, 0x2b4, 0x2b6, 0x2b6, 0x2b8, 0x2b8, 0x2ba, 
       0x2bc, 0x4, 0x2, 0x2b3, 0x2b3, 0x2b6, 0x2b6, 0x4, 0x2, 0x2b3, 0x2b3, 
       0x2b9, 0x2b9, 0x4, 0x2, 0x18, 0x18, 0x31, 0x31, 0x9, 0x2, 0x37, 0x3f, 
       0x42, 0x43, 0x4b, 0x52, 0x54, 0x54, 0x56, 0x59, 0x5b, 0x5b, 0x5d, 
       0x74, 0x3, 0x2, 0x12c, 0x139, 0x3, 0x2, 0x86, 0xd5, 0x3, 0x2, 0x1b1, 
       0x1b2, 0x3, 0x2, 0x1b9, 0x1bd, 0x3, 0x2, 0x1b4, 0x1b8, 0x4, 0x2, 
       0x1b4, 0x1b8, 0x1bf, 0x1bf, 0x3, 0x2, 0x1c3, 0x1c9, 0x4, 0x2, 0x241, 
       0x242, 0x248, 0x248, 0x3, 0x2, 0xd6, 0x139, 0x2, 0x18d5, 0x2, 0x4a4, 
       0x3, 0x2, 0x2, 0x2, 0x4, 0x4bc, 0x3, 0x2, 0x2, 0x2, 0x6, 0x4bf, 0x3, 
       0x2, 0x2, 0x2, 0x8, 0x4c3, 0x3, 0x2, 0x2, 0x2, 0xa, 0x4ca, 0x3, 0x2, 
       0x2, 0x2, 0xc, 0x4cc, 0x3, 0x2, 0x2, 0x2, 0xe, 0x4d0, 0x3, 0x2, 0x2, 
       0x2, 0x10, 0x4d2, 0x3, 0x2, 0x2, 0x2, 0x12, 0x4d6, 0x3, 0x2, 0x2, 
       0x2, 0x14, 0x4da, 0x3, 0x2, 0x2, 0x2, 0x16, 0x4dd, 0x3, 0x2, 0x2, 
       0x2, 0x18, 0x502, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x504, 0x3, 0x2, 0x2, 
       0x2, 0x1c, 0x511, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x547, 0x3, 0x2, 0x2, 
       0x2, 0x20, 0x549, 0x3, 0x2, 0x2, 0x2, 0x22, 0x54b, 0x3, 0x2, 0x2, 
       0x2, 0x24, 0x54d, 0x3, 0x2, 0x2, 0x2, 0x26, 0x54f, 0x3, 0x2, 0x2, 
       0x2, 0x28, 0x554, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x559, 0x3, 0x2, 0x2, 
       0x2, 0x2c, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x560, 0x3, 0x2, 0x2, 
       0x2, 0x30, 0x568, 0x3, 0x2, 0x2, 0x2, 0x32, 0x56f, 0x3, 0x2, 0x2, 
       0x2, 0x34, 0x576, 0x3, 0x2, 0x2, 0x2, 0x36, 0x578, 0x3, 0x2, 0x2, 
       0x2, 0x38, 0x583, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x585, 0x3, 0x2, 0x2, 
       0x2, 0x3c, 0x587, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x58c, 0x3, 0x2, 0x2, 
       0x2, 0x40, 0x59a, 0x3, 0x2, 0x2, 0x2, 0x42, 0x5a1, 0x3, 0x2, 0x2, 
       0x2, 0x44, 0x5a3, 0x3, 0x2, 0x2, 0x2, 0x46, 0x5a8, 0x3, 0x2, 0x2, 
       0x2, 0x48, 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x5ba, 0x3, 0x2, 0x2, 
       0x2, 0x4c, 0x5c1, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x5d0, 0x3, 0x2, 0x2, 
       0x2, 0x50, 0x5d5, 0x3, 0x2, 0x2, 0x2, 0x52, 0x5dc, 0x3, 0x2, 0x2, 
       0x2, 0x54, 0x5e3, 0x3, 0x2, 0x2, 0x2, 0x56, 0x5e8, 0x3, 0x2, 0x2, 
       0x2, 0x58, 0x5f1, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x5f6, 0x3, 0x2, 0x2, 
       0x2, 0x5c, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x604, 0x3, 0x2, 0x2, 
       0x2, 0x60, 0x606, 0x3, 0x2, 0x2, 0x2, 0x62, 0x60f, 0x3, 0x2, 0x2, 
       0x2, 0x64, 0x611, 0x3, 0x2, 0x2, 0x2, 0x66, 0x61d, 0x3, 0x2, 0x2, 
       0x2, 0x68, 0x629, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x62b, 0x3, 0x2, 0x2, 
       0x2, 0x6c, 0x630, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x639, 0x3, 0x2, 0x2, 
       0x2, 0x70, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x72, 0x640, 0x3, 0x2, 0x2, 
       0x2, 0x74, 0x642, 0x3, 0x2, 0x2, 0x2, 0x76, 0x644, 0x3, 0x2, 0x2, 
       0x2, 0x78, 0x64a, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x655, 0x3, 0x2, 0x2, 
       0x2, 0x7c, 0x657, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x65f, 0x3, 0x2, 0x2, 
       0x2, 0x80, 0x667, 0x3, 0x2, 0x2, 0x2, 0x82, 0x669, 0x3, 0x2, 0x2, 
       0x2, 0x84, 0x670, 0x3, 0x2, 0x2, 0x2, 0x86, 0x672, 0x3, 0x2, 0x2, 
       0x2, 0x88, 0x677, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x67e, 0x3, 0x2, 0x2, 
       0x2, 0x8c, 0x683, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x688, 0x3, 0x2, 0x2, 
       0x2, 0x90, 0x690, 0x3, 0x2, 0x2, 0x2, 0x92, 0x695, 0x3, 0x2, 0x2, 
       0x2, 0x94, 0x69a, 0x3, 0x2, 0x2, 0x2, 0x96, 0x69f, 0x3, 0x2, 0x2, 
       0x2, 0x98, 0x6a4, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x6b0, 0x3, 0x2, 0x2, 
       0x2, 0x9c, 0x6bc, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x6c1, 0x3, 0x2, 0x2, 
       0x2, 0xa0, 0x6c6, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x6cb, 0x3, 0x2, 0x2, 
       0x2, 0xa4, 0x6d0, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x6d5, 0x3, 0x2, 0x2, 
       0x2, 0xa8, 0x6da, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x6df, 0x3, 0x2, 0x2, 
       0x2, 0xac, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0xae, 0x6e9, 0x3, 0x2, 0x2, 
       0x2, 0xb0, 0x6f2, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x6f7, 0x3, 0x2, 0x2, 
       0x2, 0xb4, 0x6fc, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x703, 0x3, 0x2, 0x2, 
       0x2, 0xb8, 0x708, 0x3, 0x2, 0x2, 0x2, 0xba, 0x70d, 0x3, 0x2, 0x2, 
       0x2, 0xbc, 0x714, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x719, 0x3, 0x2, 0x2, 
       0x2, 0xc0, 0x71b, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x721, 0x3, 0x2, 0x2, 
       0x2, 0xc4, 0x723, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x728, 0x3, 0x2, 0x2, 
       0x2, 0xc8, 0x72a, 0x3, 0x2, 0x2, 0x2, 0xca, 0x72c, 0x3, 0x2, 0x2, 
       0x2, 0xcc, 0x73e, 0x3, 0x2, 0x2, 0x2, 0xce, 0x741, 0x3, 0x2, 0x2, 
       0x2, 0xd0, 0x779, 0x3, 0x2, 0x2, 0x2, 0xd2, 0x77c, 0x3, 0x2, 0x2, 
       0x2, 0xd4, 0x78b, 0x3, 0x2, 0x2, 0x2, 0xd6, 0x7b0, 0x3, 0x2, 0x2, 
       0x2, 0xd8, 0x7b3, 0x3, 0x2, 0x2, 0x2, 0xda, 0x7c2, 0x3, 0x2, 0x2, 
       0x2, 0xdc, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0xde, 0x7e5, 0x3, 0x2, 0x2, 
       0x2, 0xe0, 0x7f4, 0x3, 0x2, 0x2, 0x2, 0xe2, 0x817, 0x3, 0x2, 0x2, 
       0x2, 0xe4, 0x819, 0x3, 0x2, 0x2, 0x2, 0xe6, 0x823, 0x3, 0x2, 0x2, 
       0x2, 0xe8, 0x839, 0x3, 0x2, 0x2, 0x2, 0xea, 0x83b, 0x3, 0x2, 0x2, 
       0x2, 0xec, 0x84d, 0x3, 0x2, 0x2, 0x2, 0xee, 0x854, 0x3, 0x2, 0x2, 
       0x2, 0xf0, 0x870, 0x3, 0x2, 0x2, 0x2, 0xf2, 0x876, 0x3, 0x2, 0x2, 
       0x2, 0xf4, 0x885, 0x3, 0x2, 0x2, 0x2, 0xf6, 0x8a4, 0x3, 0x2, 0x2, 
       0x2, 0xf8, 0x8b6, 0x3, 0x2, 0x2, 0x2, 0xfa, 0x8c8, 0x3, 0x2, 0x2, 
       0x2, 0xfc, 0x8d0, 0x3, 0x2, 0x2, 0x2, 0xfe, 0x8ee, 0x3, 0x2, 0x2, 
       0x2, 0x100, 0x902, 0x3, 0x2, 0x2, 0x2, 0x102, 0x906, 0x3, 0x2, 0x2, 
       0x2, 0x104, 0x926, 0x3, 0x2, 0x2, 0x2, 0x106, 0x928, 0x3, 0x2, 0x2, 
       0x2, 0x108, 0x95b, 0x3, 0x2, 0x2, 0x2, 0x10a, 0x975, 0x3, 0x2, 0x2, 
       0x2, 0x10c, 0x989, 0x3, 0x2, 0x2, 0x2, 0x10e, 0x99d, 0x3, 0x2, 0x2, 
       0x2, 0x110, 0x9b1, 0x3, 0x2, 0x2, 0x2, 0x112, 0x9ca, 0x3, 0x2, 0x2, 
       0x2, 0x114, 0x9df, 0x3, 0x2, 0x2, 0x2, 0x116, 0x9e1, 0x3, 0x2, 0x2, 
       0x2, 0x118, 0xa00, 0x3, 0x2, 0x2, 0x2, 0x11a, 0xa1f, 0x3, 0x2, 0x2, 
       0x2, 0x11c, 0xa40, 0x3, 0x2, 0x2, 0x2, 0x11e, 0xa42, 0x3, 0x2, 0x2, 
       0x2, 0x120, 0xa55, 0x3, 0x2, 0x2, 0x2, 0x122, 0xa6e, 0x3, 0x2, 0x2, 
       0x2, 0x124, 0xa89, 0x3, 0x2, 0x2, 0x2, 0x126, 0xa9f, 0x3, 0x2, 0x2, 
       0x2, 0x128, 0xab5, 0x3, 0x2, 0x2, 0x2, 0x12a, 0xacb, 0x3, 0x2, 0x2, 
       0x2, 0x12c, 0xacd, 0x3, 0x2, 0x2, 0x2, 0x12e, 0xae2, 0x3, 0x2, 0x2, 
       0x2, 0x130, 0xae7, 0x3, 0x2, 0x2, 0x2, 0x132, 0xaf9, 0x3, 0x2, 0x2, 
       0x2, 0x134, 0xb04, 0x3, 0x2, 0x2, 0x2, 0x136, 0xb07, 0x3, 0x2, 0x2, 
       0x2, 0x138, 0xb09, 0x3, 0x2, 0x2, 0x2, 0x13a, 0xb14, 0x3, 0x2, 0x2, 
       0x2, 0x13c, 0xb1b, 0x3, 0x2, 0x2, 0x2, 0x13e, 0xb2a, 0x3, 0x2, 0x2, 
       0x2, 0x140, 0xb2f, 0x3, 0x2, 0x2, 0x2, 0x142, 0xb39, 0x3, 0x2, 0x2, 
       0x2, 0x144, 0xb3d, 0x3, 0x2, 0x2, 0x2, 0x146, 0xb3f, 0x3, 0x2, 0x2, 
       0x2, 0x148, 0xb78, 0x3, 0x2, 0x2, 0x2, 0x14a, 0xb7a, 0x3, 0x2, 0x2, 
       0x2, 0x14c, 0xb93, 0x3, 0x2, 0x2, 0x2, 0x14e, 0xba2, 0x3, 0x2, 0x2, 
       0x2, 0x150, 0xba8, 0x3, 0x2, 0x2, 0x2, 0x152, 0xbbb, 0x3, 0x2, 0x2, 
       0x2, 0x154, 0xbbd, 0x3, 0x2, 0x2, 0x2, 0x156, 0xbcf, 0x3, 0x2, 0x2, 
       0x2, 0x158, 0xbe1, 0x3, 0x2, 0x2, 0x2, 0x15a, 0xbfd, 0x3, 0x2, 0x2, 
       0x2, 0x15c, 0xbff, 0x3, 0x2, 0x2, 0x2, 0x15e, 0xc0d, 0x3, 0x2, 0x2, 
       0x2, 0x160, 0xc11, 0x3, 0x2, 0x2, 0x2, 0x162, 0xc13, 0x3, 0x2, 0x2, 
       0x2, 0x164, 0xc18, 0x3, 0x2, 0x2, 0x2, 0x166, 0xc1c, 0x3, 0x2, 0x2, 
       0x2, 0x168, 0xc21, 0x3, 0x2, 0x2, 0x2, 0x16a, 0xc27, 0x3, 0x2, 0x2, 
       0x2, 0x16c, 0xc39, 0x3, 0x2, 0x2, 0x2, 0x16e, 0xc45, 0x3, 0x2, 0x2, 
       0x2, 0x170, 0xc49, 0x3, 0x2, 0x2, 0x2, 0x172, 0xc4d, 0x3, 0x2, 0x2, 
       0x2, 0x174, 0xc4f, 0x3, 0x2, 0x2, 0x2, 0x176, 0xc5d, 0x3, 0x2, 0x2, 
       0x2, 0x178, 0xc63, 0x3, 0x2, 0x2, 0x2, 0x17a, 0xc71, 0x3, 0x2, 0x2, 
       0x2, 0x17c, 0xc7a, 0x3, 0x2, 0x2, 0x2, 0x17e, 0xc7c, 0x3, 0x2, 0x2, 
       0x2, 0x180, 0xc7e, 0x3, 0x2, 0x2, 0x2, 0x182, 0xc80, 0x3, 0x2, 0x2, 
       0x2, 0x184, 0xc82, 0x3, 0x2, 0x2, 0x2, 0x186, 0xcf0, 0x3, 0x2, 0x2, 
       0x2, 0x188, 0xcf2, 0x3, 0x2, 0x2, 0x2, 0x18a, 0xcfe, 0x3, 0x2, 0x2, 
       0x2, 0x18c, 0xd04, 0x3, 0x2, 0x2, 0x2, 0x18e, 0xd0a, 0x3, 0x2, 0x2, 
       0x2, 0x190, 0xd10, 0x3, 0x2, 0x2, 0x2, 0x192, 0xd16, 0x3, 0x2, 0x2, 
       0x2, 0x194, 0xd19, 0x3, 0x2, 0x2, 0x2, 0x196, 0xd1c, 0x3, 0x2, 0x2, 
       0x2, 0x198, 0xd1f, 0x3, 0x2, 0x2, 0x2, 0x19a, 0xd22, 0x3, 0x2, 0x2, 
       0x2, 0x19c, 0xd25, 0x3, 0x2, 0x2, 0x2, 0x19e, 0xd28, 0x3, 0x2, 0x2, 
       0x2, 0x1a0, 0xd2b, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0xd2e, 0x3, 0x2, 0x2, 
       0x2, 0x1a4, 0xd31, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0xd34, 0x3, 0x2, 0x2, 
       0x2, 0x1a8, 0xd37, 0x3, 0x2, 0x2, 0x2, 0x1aa, 0xd3a, 0x3, 0x2, 0x2, 
       0x2, 0x1ac, 0xd3d, 0x3, 0x2, 0x2, 0x2, 0x1ae, 0xd40, 0x3, 0x2, 0x2, 
       0x2, 0x1b0, 0xd43, 0x3, 0x2, 0x2, 0x2, 0x1b2, 0xd4e, 0x3, 0x2, 0x2, 
       0x2, 0x1b4, 0xd59, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0xd60, 0x3, 0x2, 0x2, 
       0x2, 0x1b8, 0xd63, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0xd66, 0x3, 0x2, 0x2, 
       0x2, 0x1bc, 0xd69, 0x3, 0x2, 0x2, 0x2, 0x1be, 0xd6c, 0x3, 0x2, 0x2, 
       0x2, 0x1c0, 0xd6f, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0xd72, 0x3, 0x2, 0x2, 
       0x2, 0x1c4, 0xd75, 0x3, 0x2, 0x2, 0x2, 0x1c6, 0xd7b, 0x3, 0x2, 0x2, 
       0x2, 0x1c8, 0xd81, 0x3, 0x2, 0x2, 0x2, 0x1ca, 0xd87, 0x3, 0x2, 0x2, 
       0x2, 0x1cc, 0xd8d, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0xd90, 0x3, 0x2, 0x2, 
       0x2, 0x1d0, 0xd96, 0x3, 0x2, 0x2, 0x2, 0x1d2, 0xd9c, 0x3, 0x2, 0x2, 
       0x2, 0x1d4, 0xd9f, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0xda5, 0x3, 0x2, 0x2, 
       0x2, 0x1d8, 0xda8, 0x3, 0x2, 0x2, 0x2, 0x1da, 0xdae, 0x3, 0x2, 0x2, 
       0x2, 0x1dc, 0xdb6, 0x3, 0x2, 0x2, 0x2, 0x1de, 0xdb9, 0x3, 0x2, 0x2, 
       0x2, 0x1e0, 0xdc0, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0xdc3, 0x3, 0x2, 0x2, 
       0x2, 0x1e4, 0xdc6, 0x3, 0x2, 0x2, 0x2, 0x1e6, 0xdc9, 0x3, 0x2, 0x2, 
       0x2, 0x1e8, 0xdcc, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0xdcf, 0x3, 0x2, 0x2, 
       0x2, 0x1ec, 0xdd2, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0xdd9, 0x3, 0x2, 0x2, 
       0x2, 0x1f0, 0xddc, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0xddf, 0x3, 0x2, 0x2, 
       0x2, 0x1f4, 0xde2, 0x3, 0x2, 0x2, 0x2, 0x1f6, 0xde5, 0x3, 0x2, 0x2, 
       0x2, 0x1f8, 0xde8, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0xdeb, 0x3, 0x2, 0x2, 
       0x2, 0x1fc, 0xdf1, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0xdf7, 0x3, 0x2, 0x2, 
       0x2, 0x200, 0xdfa, 0x3, 0x2, 0x2, 0x2, 0x202, 0xe00, 0x3, 0x2, 0x2, 
       0x2, 0x204, 0xe03, 0x3, 0x2, 0x2, 0x2, 0x206, 0xe06, 0x3, 0x2, 0x2, 
       0x2, 0x208, 0xe09, 0x3, 0x2, 0x2, 0x2, 0x20a, 0xe0c, 0x3, 0x2, 0x2, 
       0x2, 0x20c, 0xe0f, 0x3, 0x2, 0x2, 0x2, 0x20e, 0xe12, 0x3, 0x2, 0x2, 
       0x2, 0x210, 0xe15, 0x3, 0x2, 0x2, 0x2, 0x212, 0xe1e, 0x3, 0x2, 0x2, 
       0x2, 0x214, 0xe22, 0x3, 0x2, 0x2, 0x2, 0x216, 0xe29, 0x3, 0x2, 0x2, 
       0x2, 0x218, 0xe2c, 0x3, 0x2, 0x2, 0x2, 0x21a, 0xe32, 0x3, 0x2, 0x2, 
       0x2, 0x21c, 0xe35, 0x3, 0x2, 0x2, 0x2, 0x21e, 0xe3b, 0x3, 0x2, 0x2, 
       0x2, 0x220, 0xe41, 0x3, 0x2, 0x2, 0x2, 0x222, 0xe5e, 0x3, 0x2, 0x2, 
       0x2, 0x224, 0xe60, 0x3, 0x2, 0x2, 0x2, 0x226, 0xe62, 0x3, 0x2, 0x2, 
       0x2, 0x228, 0xe65, 0x3, 0x2, 0x2, 0x2, 0x22a, 0xe68, 0x3, 0x2, 0x2, 
       0x2, 0x22c, 0xe6f, 0x3, 0x2, 0x2, 0x2, 0x22e, 0xe72, 0x3, 0x2, 0x2, 
       0x2, 0x230, 0xe75, 0x3, 0x2, 0x2, 0x2, 0x232, 0xe78, 0x3, 0x2, 0x2, 
       0x2, 0x234, 0xe7b, 0x3, 0x2, 0x2, 0x2, 0x236, 0xe7e, 0x3, 0x2, 0x2, 
       0x2, 0x238, 0xe81, 0x3, 0x2, 0x2, 0x2, 0x23a, 0xe87, 0x3, 0x2, 0x2, 
       0x2, 0x23c, 0xe8a, 0x3, 0x2, 0x2, 0x2, 0x23e, 0xe92, 0x3, 0x2, 0x2, 
       0x2, 0x240, 0xe9a, 0x3, 0x2, 0x2, 0x2, 0x242, 0xe9d, 0x3, 0x2, 0x2, 
       0x2, 0x244, 0xea0, 0x3, 0x2, 0x2, 0x2, 0x246, 0xea3, 0x3, 0x2, 0x2, 
       0x2, 0x248, 0xea6, 0x3, 0x2, 0x2, 0x2, 0x24a, 0xea9, 0x3, 0x2, 0x2, 
       0x2, 0x24c, 0xeac, 0x3, 0x2, 0x2, 0x2, 0x24e, 0xeaf, 0x3, 0x2, 0x2, 
       0x2, 0x250, 0xeb2, 0x3, 0x2, 0x2, 0x2, 0x252, 0xeb8, 0x3, 0x2, 0x2, 
       0x2, 0x254, 0xebe, 0x3, 0x2, 0x2, 0x2, 0x256, 0xec4, 0x3, 0x2, 0x2, 
       0x2, 0x258, 0xeca, 0x3, 0x2, 0x2, 0x2, 0x25a, 0xed2, 0x3, 0x2, 0x2, 
       0x2, 0x25c, 0xed8, 0x3, 0x2, 0x2, 0x2, 0x25e, 0xede, 0x3, 0x2, 0x2, 
       0x2, 0x260, 0xeed, 0x3, 0x2, 0x2, 0x2, 0x262, 0xeef, 0x3, 0x2, 0x2, 
       0x2, 0x264, 0xef5, 0x3, 0x2, 0x2, 0x2, 0x266, 0xef8, 0x3, 0x2, 0x2, 
       0x2, 0x268, 0xefb, 0x3, 0x2, 0x2, 0x2, 0x26a, 0xefe, 0x3, 0x2, 0x2, 
       0x2, 0x26c, 0xf01, 0x3, 0x2, 0x2, 0x2, 0x26e, 0xf04, 0x3, 0x2, 0x2, 
       0x2, 0x270, 0xf07, 0x3, 0x2, 0x2, 0x2, 0x272, 0xf0a, 0x3, 0x2, 0x2, 
       0x2, 0x274, 0xf10, 0x3, 0x2, 0x2, 0x2, 0x276, 0xf18, 0x3, 0x2, 0x2, 
       0x2, 0x278, 0xf20, 0x3, 0x2, 0x2, 0x2, 0x27a, 0xf26, 0x3, 0x2, 0x2, 
       0x2, 0x27c, 0xf2c, 0x3, 0x2, 0x2, 0x2, 0x27e, 0xf32, 0x3, 0x2, 0x2, 
       0x2, 0x280, 0xf38, 0x3, 0x2, 0x2, 0x2, 0x282, 0xf3e, 0x3, 0x2, 0x2, 
       0x2, 0x284, 0xf44, 0x3, 0x2, 0x2, 0x2, 0x286, 0xf4a, 0x3, 0x2, 0x2, 
       0x2, 0x288, 0xf50, 0x3, 0x2, 0x2, 0x2, 0x28a, 0xf56, 0x3, 0x2, 0x2, 
       0x2, 0x28c, 0xf5f, 0x3, 0x2, 0x2, 0x2, 0x28e, 0xf65, 0x3, 0x2, 0x2, 
       0x2, 0x290, 0xf6b, 0x3, 0x2, 0x2, 0x2, 0x292, 0xf6e, 0x3, 0x2, 0x2, 
       0x2, 0x294, 0xf74, 0x3, 0x2, 0x2, 0x2, 0x296, 0xf7a, 0x3, 0x2, 0x2, 
       0x2, 0x298, 0xf7d, 0x3, 0x2, 0x2, 0x2, 0x29a, 0xf80, 0x3, 0x2, 0x2, 
       0x2, 0x29c, 0xf83, 0x3, 0x2, 0x2, 0x2, 0x29e, 0xf8a, 0x3, 0x2, 0x2, 
       0x2, 0x2a0, 0xf90, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0xf96, 0x3, 0x2, 0x2, 
       0x2, 0x2a4, 0xf9c, 0x3, 0x2, 0x2, 0x2, 0x2a6, 0xfa2, 0x3, 0x2, 0x2, 
       0x2, 0x2a8, 0xfa5, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0xfab, 0x3, 0x2, 0x2, 
       0x2, 0x2ac, 0xfae, 0x3, 0x2, 0x2, 0x2, 0x2ae, 0xfb1, 0x3, 0x2, 0x2, 
       0x2, 0x2b0, 0xfb4, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0xfb7, 0x3, 0x2, 0x2, 
       0x2, 0x2b4, 0xfbd, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0xfc3, 0x3, 0x2, 0x2, 
       0x2, 0x2b8, 0xfca, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0xfcd, 0x3, 0x2, 0x2, 
       0x2, 0x2bc, 0xfd0, 0x3, 0x2, 0x2, 0x2, 0x2be, 0xfd3, 0x3, 0x2, 0x2, 
       0x2, 0x2c0, 0xfd6, 0x3, 0x2, 0x2, 0x2, 0x2c2, 0xfd9, 0x3, 0x2, 0x2, 
       0x2, 0x2c4, 0xfdc, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0xfe2, 0x3, 0x2, 0x2, 
       0x2, 0x2c8, 0xfe8, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0xfee, 0x3, 0x2, 0x2, 
       0x2, 0x2cc, 0xff5, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0xffc, 0x3, 0x2, 0x2, 
       0x2, 0x2d0, 0x1002, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x1008, 0x3, 0x2, 
       0x2, 0x2, 0x2d4, 0x1022, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x1026, 0x3, 
       0x2, 0x2, 0x2, 0x2d8, 0x102e, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x1030, 
       0x3, 0x2, 0x2, 0x2, 0x2dc, 0x1032, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x103b, 
       0x3, 0x2, 0x2, 0x2, 0x2e0, 0x103d, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x105b, 
       0x3, 0x2, 0x2, 0x2, 0x2e4, 0x105d, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x105f, 
       0x3, 0x2, 0x2, 0x2, 0x2e8, 0x1064, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x106a, 
       0x3, 0x2, 0x2, 0x2, 0x2ec, 0x106c, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x1074, 
       0x3, 0x2, 0x2, 0x2, 0x2f0, 0x1076, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x1078, 
       0x3, 0x2, 0x2, 0x2, 0x2f4, 0x1083, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x1085, 
       0x3, 0x2, 0x2, 0x2, 0x2f8, 0x108c, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x109e, 
       0x3, 0x2, 0x2, 0x2, 0x2fc, 0x10a0, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x10a9, 
       0x3, 0x2, 0x2, 0x2, 0x300, 0x10ab, 0x3, 0x2, 0x2, 0x2, 0x302, 0x10c0, 
       0x3, 0x2, 0x2, 0x2, 0x304, 0x10c4, 0x3, 0x2, 0x2, 0x2, 0x306, 0x10dc, 
       0x3, 0x2, 0x2, 0x2, 0x308, 0x10f4, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x10fd, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x1106, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x1108, 
       0x3, 0x2, 0x2, 0x2, 0x310, 0x110a, 0x3, 0x2, 0x2, 0x2, 0x312, 0x110d, 
       0x3, 0x2, 0x2, 0x2, 0x314, 0x1110, 0x3, 0x2, 0x2, 0x2, 0x316, 0x1112, 
       0x3, 0x2, 0x2, 0x2, 0x318, 0x1114, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x111c, 
       0x3, 0x2, 0x2, 0x2, 0x31c, 0x111e, 0x3, 0x2, 0x2, 0x2, 0x31e, 0x1120, 
       0x3, 0x2, 0x2, 0x2, 0x320, 0x1127, 0x3, 0x2, 0x2, 0x2, 0x322, 0x1156, 
       0x3, 0x2, 0x2, 0x2, 0x324, 0x1158, 0x3, 0x2, 0x2, 0x2, 0x326, 0x1163, 
       0x3, 0x2, 0x2, 0x2, 0x328, 0x1173, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x117c, 
       0x3, 0x2, 0x2, 0x2, 0x32c, 0x1185, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x118b, 
       0x3, 0x2, 0x2, 0x2, 0x330, 0x1192, 0x3, 0x2, 0x2, 0x2, 0x332, 0x1198, 
       0x3, 0x2, 0x2, 0x2, 0x334, 0x11a1, 0x3, 0x2, 0x2, 0x2, 0x336, 0x11a7, 
       0x3, 0x2, 0x2, 0x2, 0x338, 0x11ad, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x11ba, 
       0x3, 0x2, 0x2, 0x2, 0x33c, 0x11c1, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x11c3, 
       0x3, 0x2, 0x2, 0x2, 0x340, 0x11c9, 0x3, 0x2, 0x2, 0x2, 0x342, 0x11cb, 
       0x3, 0x2, 0x2, 0x2, 0x344, 0x11cd, 0x3, 0x2, 0x2, 0x2, 0x346, 0x11cf, 
       0x3, 0x2, 0x2, 0x2, 0x348, 0x11d1, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x11d7, 
       0x3, 0x2, 0x2, 0x2, 0x34c, 0x11db, 0x3, 0x2, 0x2, 0x2, 0x34e, 0x11e1, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x11e7, 0x3, 0x2, 0x2, 0x2, 0x352, 0x11eb, 
       0x3, 0x2, 0x2, 0x2, 0x354, 0x11f3, 0x3, 0x2, 0x2, 0x2, 0x356, 0x11f6, 
       0x3, 0x2, 0x2, 0x2, 0x358, 0x11fc, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x120d, 
       0x3, 0x2, 0x2, 0x2, 0x35c, 0x1210, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x1216, 
       0x3, 0x2, 0x2, 0x2, 0x360, 0x121f, 0x3, 0x2, 0x2, 0x2, 0x362, 0x1221, 
       0x3, 0x2, 0x2, 0x2, 0x364, 0x1223, 0x3, 0x2, 0x2, 0x2, 0x366, 0x1225, 
       0x3, 0x2, 0x2, 0x2, 0x368, 0x1227, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x1231, 
       0x3, 0x2, 0x2, 0x2, 0x36c, 0x123c, 0x3, 0x2, 0x2, 0x2, 0x36e, 0x1242, 
       0x3, 0x2, 0x2, 0x2, 0x370, 0x1244, 0x3, 0x2, 0x2, 0x2, 0x372, 0x124d, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x1257, 0x3, 0x2, 0x2, 0x2, 0x376, 0x125f, 
       0x3, 0x2, 0x2, 0x2, 0x378, 0x1267, 0x3, 0x2, 0x2, 0x2, 0x37a, 0x1270, 
       0x3, 0x2, 0x2, 0x2, 0x37c, 0x1278, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x1281, 
       0x3, 0x2, 0x2, 0x2, 0x380, 0x128b, 0x3, 0x2, 0x2, 0x2, 0x382, 0x1296, 
       0x3, 0x2, 0x2, 0x2, 0x384, 0x12a2, 0x3, 0x2, 0x2, 0x2, 0x386, 0x12a9, 
       0x3, 0x2, 0x2, 0x2, 0x388, 0x12ad, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x12af, 
       0x3, 0x2, 0x2, 0x2, 0x38c, 0x12b6, 0x3, 0x2, 0x2, 0x2, 0x38e, 0x12bd, 
       0x3, 0x2, 0x2, 0x2, 0x390, 0x12c5, 0x3, 0x2, 0x2, 0x2, 0x392, 0x12ce, 
       0x3, 0x2, 0x2, 0x2, 0x394, 0x12d4, 0x3, 0x2, 0x2, 0x2, 0x396, 0x12dd, 
       0x3, 0x2, 0x2, 0x2, 0x398, 0x12e3, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x12eb, 
       0x3, 0x2, 0x2, 0x2, 0x39c, 0x12f2, 0x3, 0x2, 0x2, 0x2, 0x39e, 0x12fb, 
       0x3, 0x2, 0x2, 0x2, 0x3a0, 0x12fd, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x134f, 
       0x3, 0x2, 0x2, 0x2, 0x3a4, 0x135d, 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x135f, 
       0x3, 0x2, 0x2, 0x2, 0x3a8, 0x1361, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x1363, 
       0x3, 0x2, 0x2, 0x2, 0x3ac, 0x1368, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x136a, 
       0x3, 0x2, 0x2, 0x2, 0x3b0, 0x137a, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x137c, 
       0x3, 0x2, 0x2, 0x2, 0x3b4, 0x137e, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x1388, 
       0x3, 0x2, 0x2, 0x2, 0x3b8, 0x138d, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x1396, 
       0x3, 0x2, 0x2, 0x2, 0x3bc, 0x139b, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x13a9, 
       0x3, 0x2, 0x2, 0x2, 0x3c0, 0x13ae, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x13bc, 
       0x3, 0x2, 0x2, 0x2, 0x3c4, 0x13c3, 0x3, 0x2, 0x2, 0x2, 0x3c6, 0x13cc, 
       0x3, 0x2, 0x2, 0x2, 0x3c8, 0x13d7, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x13e2, 
       0x3, 0x2, 0x2, 0x2, 0x3cc, 0x13ee, 0x3, 0x2, 0x2, 0x2, 0x3ce, 0x13f3, 
       0x3, 0x2, 0x2, 0x2, 0x3d0, 0x1400, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x1409, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x140e, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x1417, 
       0x3, 0x2, 0x2, 0x2, 0x3d8, 0x141e, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x1429, 
       0x3, 0x2, 0x2, 0x2, 0x3dc, 0x142e, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x1435, 
       0x3, 0x2, 0x2, 0x2, 0x3e0, 0x143a, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x1442, 
       0x3, 0x2, 0x2, 0x2, 0x3e4, 0x1449, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x144e, 
       0x3, 0x2, 0x2, 0x2, 0x3e8, 0x145a, 0x3, 0x2, 0x2, 0x2, 0x3ea, 0x145f, 
       0x3, 0x2, 0x2, 0x2, 0x3ec, 0x1467, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x1470, 
       0x3, 0x2, 0x2, 0x2, 0x3f0, 0x1477, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x147c, 
       0x3, 0x2, 0x2, 0x2, 0x3f4, 0x1481, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x1486, 
       0x3, 0x2, 0x2, 0x2, 0x3f8, 0x148f, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x1498, 
       0x3, 0x2, 0x2, 0x2, 0x3fc, 0x149b, 0x3, 0x2, 0x2, 0x2, 0x3fe, 0x149e, 
       0x3, 0x2, 0x2, 0x2, 0x400, 0x14a1, 0x3, 0x2, 0x2, 0x2, 0x402, 0x14a4, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x14a7, 0x3, 0x2, 0x2, 0x2, 0x406, 0x14ac, 
       0x3, 0x2, 0x2, 0x2, 0x408, 0x14b1, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x14b6, 
       0x3, 0x2, 0x2, 0x2, 0x40c, 0x14bb, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x14c0, 
       0x3, 0x2, 0x2, 0x2, 0x410, 0x14c5, 0x3, 0x2, 0x2, 0x2, 0x412, 0x14ca, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x14cf, 0x3, 0x2, 0x2, 0x2, 0x416, 0x14d4, 
       0x3, 0x2, 0x2, 0x2, 0x418, 0x14db, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x14e2, 
       0x3, 0x2, 0x2, 0x2, 0x41c, 0x14f1, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x14fc, 
       0x3, 0x2, 0x2, 0x2, 0x420, 0x150d, 0x3, 0x2, 0x2, 0x2, 0x422, 0x1512, 
       0x3, 0x2, 0x2, 0x2, 0x424, 0x1514, 0x3, 0x2, 0x2, 0x2, 0x426, 0x151d, 
       0x3, 0x2, 0x2, 0x2, 0x428, 0x1522, 0x3, 0x2, 0x2, 0x2, 0x42a, 0x1529, 
       0x3, 0x2, 0x2, 0x2, 0x42c, 0x1532, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x153d, 
       0x3, 0x2, 0x2, 0x2, 0x430, 0x1544, 0x3, 0x2, 0x2, 0x2, 0x432, 0x154f, 
       0x3, 0x2, 0x2, 0x2, 0x434, 0x1551, 0x3, 0x2, 0x2, 0x2, 0x436, 0x155d, 
       0x3, 0x2, 0x2, 0x2, 0x438, 0x1569, 0x3, 0x2, 0x2, 0x2, 0x43a, 0x156c, 
       0x3, 0x2, 0x2, 0x2, 0x43c, 0x156f, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x1572, 
       0x3, 0x2, 0x2, 0x2, 0x440, 0x1575, 0x3, 0x2, 0x2, 0x2, 0x442, 0x1578, 
       0x3, 0x2, 0x2, 0x2, 0x444, 0x1581, 0x3, 0x2, 0x2, 0x2, 0x446, 0x158a, 
       0x3, 0x2, 0x2, 0x2, 0x448, 0x1593, 0x3, 0x2, 0x2, 0x2, 0x44a, 0x1598, 
       0x3, 0x2, 0x2, 0x2, 0x44c, 0x159d, 0x3, 0x2, 0x2, 0x2, 0x44e, 0x15a2, 
       0x3, 0x2, 0x2, 0x2, 0x450, 0x15a7, 0x3, 0x2, 0x2, 0x2, 0x452, 0x15b4, 
       0x3, 0x2, 0x2, 0x2, 0x454, 0x15bd, 0x3, 0x2, 0x2, 0x2, 0x456, 0x15c2, 
       0x3, 0x2, 0x2, 0x2, 0x458, 0x15ca, 0x3, 0x2, 0x2, 0x2, 0x45a, 0x15d1, 
       0x3, 0x2, 0x2, 0x2, 0x45c, 0x15d3, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x15d6, 
       0x3, 0x2, 0x2, 0x2, 0x460, 0x15e0, 0x3, 0x2, 0x2, 0x2, 0x462, 0x15e2, 
       0x3, 0x2, 0x2, 0x2, 0x464, 0x15e7, 0x3, 0x2, 0x2, 0x2, 0x466, 0x15eb, 
       0x3, 0x2, 0x2, 0x2, 0x468, 0x15f1, 0x3, 0x2, 0x2, 0x2, 0x46a, 0x15fc, 
       0x3, 0x2, 0x2, 0x2, 0x46c, 0x15fe, 0x3, 0x2, 0x2, 0x2, 0x46e, 0x160c, 
       0x3, 0x2, 0x2, 0x2, 0x470, 0x1632, 0x3, 0x2, 0x2, 0x2, 0x472, 0x1636, 
       0x3, 0x2, 0x2, 0x2, 0x474, 0x1638, 0x3, 0x2, 0x2, 0x2, 0x476, 0x163b, 
       0x3, 0x2, 0x2, 0x2, 0x478, 0x163d, 0x3, 0x2, 0x2, 0x2, 0x47a, 0x163f, 
       0x3, 0x2, 0x2, 0x2, 0x47c, 0x1641, 0x3, 0x2, 0x2, 0x2, 0x47e, 0x164e, 
       0x3, 0x2, 0x2, 0x2, 0x480, 0x165a, 0x3, 0x2, 0x2, 0x2, 0x482, 0x165c, 
       0x3, 0x2, 0x2, 0x2, 0x484, 0x1660, 0x3, 0x2, 0x2, 0x2, 0x486, 0x1662, 
       0x3, 0x2, 0x2, 0x2, 0x488, 0x166c, 0x3, 0x2, 0x2, 0x2, 0x48a, 0x166e, 
       0x3, 0x2, 0x2, 0x2, 0x48c, 0x1676, 0x3, 0x2, 0x2, 0x2, 0x48e, 0x1679, 
       0x3, 0x2, 0x2, 0x2, 0x490, 0x168c, 0x3, 0x2, 0x2, 0x2, 0x492, 0x1691, 
       0x3, 0x2, 0x2, 0x2, 0x494, 0x16f0, 0x3, 0x2, 0x2, 0x2, 0x496, 0x16f2, 
       0x3, 0x2, 0x2, 0x2, 0x498, 0x16f4, 0x3, 0x2, 0x2, 0x2, 0x49a, 0x1703, 
       0x3, 0x2, 0x2, 0x2, 0x49c, 0x4a3, 0x5, 0xd6, 0x6c, 0x2, 0x49d, 0x4a3, 
       0x5, 0xdc, 0x6f, 0x2, 0x49e, 0x4a3, 0x5, 0xe4, 0x73, 0x2, 0x49f, 
       0x4a3, 0x5, 0x16c, 0xb7, 0x2, 0x4a0, 0x4a3, 0x5, 0x4, 0x3, 0x2, 0x4a1, 
       0x4a3, 0x5, 0x15c, 0xaf, 0x2, 0x4a2, 0x49c, 0x3, 0x2, 0x2, 0x2, 0x4a2, 
       0x49d, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x49e, 0x3, 0x2, 0x2, 0x2, 0x4a2, 
       0x49f, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x4a0, 0x3, 0x2, 0x2, 0x2, 0x4a2, 
       0x4a1, 0x3, 0x2, 0x2, 0x2, 0x4a3, 0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4a4, 
       0x4a2, 0x3, 0x2, 0x2, 0x2, 0x4a4, 0x4a5, 0x3, 0x2, 0x2, 0x2, 0x4a5, 
       0x4a8, 0x3, 0x2, 0x2, 0x2, 0x4a6, 0x4a4, 0x3, 0x2, 0x2, 0x2, 0x4a7, 
       0x4a9, 0x5, 0x6, 0x4, 0x2, 0x4a8, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0x4a8, 
       0x4a9, 0x3, 0x2, 0x2, 0x2, 0x4a9, 0x3, 0x3, 0x2, 0x2, 0x2, 0x4aa, 
       0x4bd, 0x5, 0x18, 0xd, 0x2, 0x4ab, 0x4bd, 0x5, 0xd0, 0x69, 0x2, 0x4ac, 
       0x4bd, 0x5, 0xe2, 0x72, 0x2, 0x4ad, 0x4bd, 0x5, 0x12c, 0x97, 0x2, 
       0x4ae, 0x4bd, 0x5, 0x130, 0x99, 0x2, 0x4af, 0x4bd, 0x5, 0x140, 0xa1, 
       0x2, 0x4b0, 0x4bd, 0x5, 0x14a, 0xa6, 0x2, 0x4b1, 0x4bd, 0x5, 0xe8, 
       0x75, 0x2, 0x4b2, 0x4bd, 0x5, 0x14c, 0xa7, 0x2, 0x4b3, 0x4bd, 0x5, 
       0x152, 0xaa, 0x2, 0x4b4, 0x4bd, 0x5, 0x184, 0xc3, 0x2, 0x4b5, 0x4bd, 
       0x5, 0x2e0, 0x171, 0x2, 0x4b6, 0x4bd, 0x5, 0x2f2, 0x17a, 0x2, 0x4b7, 
       0x4bd, 0x5, 0x10, 0x9, 0x2, 0x4b8, 0x4bd, 0x5, 0x14, 0xb, 0x2, 0x4b9, 
       0x4bd, 0x5, 0x2fe, 0x180, 0x2, 0x4ba, 0x4bd, 0x5, 0x300, 0x181, 0x2, 
       0x4bb, 0x4bd, 0x5, 0x458, 0x22d, 0x2, 0x4bc, 0x4aa, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4ab, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4ac, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4ad, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4ae, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4af, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4b0, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4b1, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4b2, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4b3, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4b4, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4b5, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4b6, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4b7, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4b8, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4ba, 0x3, 0x2, 0x2, 
       0x2, 0x4bc, 0x4bb, 0x3, 0x2, 0x2, 0x2, 0x4bd, 0x5, 0x3, 0x2, 0x2, 
       0x2, 0x4be, 0x4c0, 0x5, 0x8, 0x5, 0x2, 0x4bf, 0x4be, 0x3, 0x2, 0x2, 
       0x2, 0x4c0, 0x4c1, 0x3, 0x2, 0x2, 0x2, 0x4c1, 0x4bf, 0x3, 0x2, 0x2, 
       0x2, 0x4c1, 0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4c2, 0x7, 0x3, 0x2, 0x2, 
       0x2, 0x4c3, 0x4c7, 0x5, 0xa, 0x6, 0x2, 0x4c4, 0x4c6, 0x5, 0xc, 0x7, 
       0x2, 0x4c5, 0x4c4, 0x3, 0x2, 0x2, 0x2, 0x4c6, 0x4c9, 0x3, 0x2, 0x2, 
       0x2, 0x4c7, 0x4c5, 0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4c8, 0x3, 0x2, 0x2, 
       0x2, 0x4c8, 0x9, 0x3, 0x2, 0x2, 0x2, 0x4c9, 0x4c7, 0x3, 0x2, 0x2, 
       0x2, 0x4ca, 0x4cb, 0x7, 0x3, 0x2, 0x2, 0x4cb, 0xb, 0x3, 0x2, 0x2, 
       0x2, 0x4cc, 0x4ce, 0x5, 0xe, 0x8, 0x2, 0x4cd, 0x4cf, 0x7, 0x276, 
       0x2, 0x2, 0x4ce, 0x4cd, 0x3, 0x2, 0x2, 0x2, 0x4ce, 0x4cf, 0x3, 0x2, 
       0x2, 0x2, 0x4cf, 0xd, 0x3, 0x2, 0x2, 0x2, 0x4d0, 0x4d1, 0x7, 0x35, 
       0x2, 0x2, 0x4d1, 0xf, 0x3, 0x2, 0x2, 0x2, 0x4d2, 0x4d4, 0x7, 0x7, 
       0x2, 0x2, 0x4d3, 0x4d5, 0x5, 0x16, 0xc, 0x2, 0x4d4, 0x4d3, 0x3, 0x2, 
       0x2, 0x2, 0x4d4, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x4d5, 0x11, 0x3, 0x2, 
       0x2, 0x2, 0x4d6, 0x4d7, 0x7, 0x13, 0x2, 0x2, 0x4d7, 0x4d8, 0x5, 0x16, 
       0xc, 0x2, 0x4d8, 0x4d9, 0x7, 0x251, 0x2, 0x2, 0x4d9, 0x13, 0x3, 0x2, 
       0x2, 0x2, 0x4da, 0x4db, 0x7, 0x13, 0x2, 0x2, 0x4db, 0x4dc, 0x5, 0x16, 
       0xc, 0x2, 0x4dc, 0x15, 0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4de, 0x7, 0x250, 
       0x2, 0x2, 0x4de, 0x17, 0x3, 0x2, 0x2, 0x2, 0x4df, 0x4e0, 0x7, 0x76, 
       0x2, 0x2, 0x4e0, 0x4e2, 0x5, 0x480, 0x241, 0x2, 0x4e1, 0x4e3, 0x5, 
       0x1c, 0xf, 0x2, 0x4e2, 0x4e1, 0x3, 0x2, 0x2, 0x2, 0x4e2, 0x4e3, 0x3, 
       0x2, 0x2, 0x2, 0x4e3, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x4e4, 0x4e6, 0x5, 
       0x1e, 0x10, 0x2, 0x4e5, 0x4e4, 0x3, 0x2, 0x2, 0x2, 0x4e6, 0x4e7, 
       0x3, 0x2, 0x2, 0x2, 0x4e7, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0x4e7, 0x4e8, 
       0x3, 0x2, 0x2, 0x2, 0x4e8, 0x4ea, 0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4e5, 
       0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4ea, 0x3, 0x2, 0x2, 0x2, 0x4ea, 0x4eb, 
       0x3, 0x2, 0x2, 0x2, 0x4eb, 0x4ed, 0x7, 0x1d4, 0x2, 0x2, 0x4ec, 0x4ee, 
       0x5, 0x14, 0xb, 0x2, 0x4ed, 0x4ec, 0x3, 0x2, 0x2, 0x2, 0x4ed, 0x4ee, 
       0x3, 0x2, 0x2, 0x2, 0x4ee, 0x503, 0x3, 0x2, 0x2, 0x2, 0x4ef, 0x503, 
       0x5, 0x1a, 0xe, 0x2, 0x4f0, 0x4f1, 0x7, 0x8, 0x2, 0x2, 0x4f1, 0x4f2, 
       0x5, 0x12e, 0x98, 0x2, 0x4f2, 0x4f3, 0x7, 0x266, 0x2, 0x2, 0x4f3, 
       0x4f4, 0x7, 0x267, 0x2, 0x2, 0x4f4, 0x4f5, 0x7, 0x26c, 0x2, 0x2, 
       0x4f5, 0x4f6, 0x7, 0x26f, 0x2, 0x2, 0x4f6, 0x4f7, 0x7, 0x270, 0x2, 
       0x2, 0x4f7, 0x4f8, 0x7, 0x271, 0x2, 0x2, 0x4f8, 0x4f9, 0x7, 0x272, 
       0x2, 0x2, 0x4f9, 0x4fd, 0x7, 0x273, 0x2, 0x2, 0x4fa, 0x4fc, 0x5, 
       0x1e, 0x10, 0x2, 0x4fb, 0x4fa, 0x3, 0x2, 0x2, 0x2, 0x4fc, 0x4ff, 
       0x3, 0x2, 0x2, 0x2, 0x4fd, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4fd, 0x4fe, 
       0x3, 0x2, 0x2, 0x2, 0x4fe, 0x500, 0x3, 0x2, 0x2, 0x2, 0x4ff, 0x4fd, 
       0x3, 0x2, 0x2, 0x2, 0x500, 0x501, 0x9, 0x2, 0x2, 0x2, 0x501, 0x503, 
       0x3, 0x2, 0x2, 0x2, 0x502, 0x4df, 0x3, 0x2, 0x2, 0x2, 0x502, 0x4ef, 
       0x3, 0x2, 0x2, 0x2, 0x502, 0x4f0, 0x3, 0x2, 0x2, 0x2, 0x503, 0x19, 
       0x3, 0x2, 0x2, 0x2, 0x504, 0x505, 0x7, 0x8, 0x2, 0x2, 0x505, 0x506, 
       0x5, 0x12e, 0x98, 0x2, 0x506, 0x507, 0x7, 0x266, 0x2, 0x2, 0x507, 
       0x508, 0x7, 0x267, 0x2, 0x2, 0x508, 0x509, 0x7, 0x268, 0x2, 0x2, 
       0x509, 0x50a, 0x7, 0x26f, 0x2, 0x2, 0x50a, 0x50b, 0x7, 0x270, 0x2, 
       0x2, 0x50b, 0x50c, 0x7, 0x271, 0x2, 0x2, 0x50c, 0x50d, 0x7, 0x272, 
       0x2, 0x2, 0x50d, 0x50e, 0x7, 0x273, 0x2, 0x2, 0x50e, 0x50f, 0x5, 
       0x48e, 0x248, 0x2, 0x50f, 0x510, 0x9, 0x2, 0x2, 0x2, 0x510, 0x1b, 
       0x3, 0x2, 0x2, 0x2, 0x511, 0x513, 0x5, 0xe6, 0x74, 0x2, 0x512, 0x514, 
       0x5, 0x47c, 0x23f, 0x2, 0x513, 0x512, 0x3, 0x2, 0x2, 0x2, 0x513, 
       0x514, 0x3, 0x2, 0x2, 0x2, 0x514, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x515, 
       0x548, 0x5, 0x22, 0x12, 0x2, 0x516, 0x548, 0x5, 0x24, 0x13, 0x2, 
       0x517, 0x548, 0x5, 0x26, 0x14, 0x2, 0x518, 0x548, 0x5, 0x28, 0x15, 
       0x2, 0x519, 0x548, 0x5, 0x2a, 0x16, 0x2, 0x51a, 0x548, 0x5, 0x2c, 
       0x17, 0x2, 0x51b, 0x548, 0x5, 0x2e, 0x18, 0x2, 0x51c, 0x548, 0x5, 
       0x30, 0x19, 0x2, 0x51d, 0x548, 0x5, 0x32, 0x1a, 0x2, 0x51e, 0x548, 
       0x5, 0x34, 0x1b, 0x2, 0x51f, 0x548, 0x5, 0x36, 0x1c, 0x2, 0x520, 
       0x548, 0x5, 0x3a, 0x1e, 0x2, 0x521, 0x548, 0x5, 0x3c, 0x1f, 0x2, 
       0x522, 0x548, 0x5, 0x3e, 0x20, 0x2, 0x523, 0x548, 0x5, 0x40, 0x21, 
       0x2, 0x524, 0x548, 0x5, 0x42, 0x22, 0x2, 0x525, 0x548, 0x5, 0x44, 
       0x23, 0x2, 0x526, 0x548, 0x5, 0x46, 0x24, 0x2, 0x527, 0x548, 0x5, 
       0x48, 0x25, 0x2, 0x528, 0x548, 0x5, 0x4a, 0x26, 0x2, 0x529, 0x548, 
       0x5, 0x4c, 0x27, 0x2, 0x52a, 0x548, 0x5, 0x4e, 0x28, 0x2, 0x52b, 
       0x548, 0x5, 0x50, 0x29, 0x2, 0x52c, 0x548, 0x5, 0x52, 0x2a, 0x2, 
       0x52d, 0x548, 0x5, 0x54, 0x2b, 0x2, 0x52e, 0x548, 0x5, 0x56, 0x2c, 
       0x2, 0x52f, 0x548, 0x5, 0x58, 0x2d, 0x2, 0x530, 0x548, 0x5, 0x5a, 
       0x2e, 0x2, 0x531, 0x548, 0x5, 0x5c, 0x2f, 0x2, 0x532, 0x548, 0x5, 
       0x5e, 0x30, 0x2, 0x533, 0x548, 0x5, 0x60, 0x31, 0x2, 0x534, 0x548, 
       0x5, 0x62, 0x32, 0x2, 0x535, 0x548, 0x5, 0x64, 0x33, 0x2, 0x536, 
       0x548, 0x5, 0x66, 0x34, 0x2, 0x537, 0x548, 0x5, 0x68, 0x35, 0x2, 
       0x538, 0x548, 0x5, 0x6a, 0x36, 0x2, 0x539, 0x548, 0x5, 0x6c, 0x37, 
       0x2, 0x53a, 0x548, 0x5, 0x6e, 0x38, 0x2, 0x53b, 0x548, 0x5, 0x70, 
       0x39, 0x2, 0x53c, 0x548, 0x5, 0x72, 0x3a, 0x2, 0x53d, 0x548, 0x5, 
       0x74, 0x3b, 0x2, 0x53e, 0x548, 0x5, 0x76, 0x3c, 0x2, 0x53f, 0x548, 
       0x5, 0x78, 0x3d, 0x2, 0x540, 0x548, 0x5, 0x7a, 0x3e, 0x2, 0x541, 
       0x548, 0x5, 0x7c, 0x3f, 0x2, 0x542, 0x548, 0x5, 0x7e, 0x40, 0x2, 
       0x543, 0x548, 0x5, 0x80, 0x41, 0x2, 0x544, 0x548, 0x5, 0x82, 0x42, 
       0x2, 0x545, 0x548, 0x5, 0x84, 0x43, 0x2, 0x546, 0x548, 0x5, 0x20, 
       0x11, 0x2, 0x547, 0x515, 0x3, 0x2, 0x2, 0x2, 0x547, 0x516, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x517, 0x3, 0x2, 0x2, 0x2, 0x547, 0x518, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x519, 0x3, 0x2, 0x2, 0x2, 0x547, 0x51a, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x51b, 0x3, 0x2, 0x2, 0x2, 0x547, 0x51c, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x51d, 0x3, 0x2, 0x2, 0x2, 0x547, 0x51e, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x547, 0x520, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x521, 0x3, 0x2, 0x2, 0x2, 0x547, 0x522, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x523, 0x3, 0x2, 0x2, 0x2, 0x547, 0x524, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x525, 0x3, 0x2, 0x2, 0x2, 0x547, 0x526, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x527, 0x3, 0x2, 0x2, 0x2, 0x547, 0x528, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x529, 0x3, 0x2, 0x2, 0x2, 0x547, 0x52a, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x52b, 0x3, 0x2, 0x2, 0x2, 0x547, 0x52c, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x52d, 0x3, 0x2, 0x2, 0x2, 0x547, 0x52e, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x547, 0x530, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x531, 0x3, 0x2, 0x2, 0x2, 0x547, 0x532, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x533, 0x3, 0x2, 0x2, 0x2, 0x547, 0x534, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x535, 0x3, 0x2, 0x2, 0x2, 0x547, 0x536, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x537, 0x3, 0x2, 0x2, 0x2, 0x547, 0x538, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x539, 0x3, 0x2, 0x2, 0x2, 0x547, 0x53a, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x53b, 0x3, 0x2, 0x2, 0x2, 0x547, 0x53c, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x547, 0x53e, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x53f, 0x3, 0x2, 0x2, 0x2, 0x547, 0x540, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x541, 0x3, 0x2, 0x2, 0x2, 0x547, 0x542, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x543, 0x3, 0x2, 0x2, 0x2, 0x547, 0x544, 0x3, 0x2, 
       0x2, 0x2, 0x547, 0x545, 0x3, 0x2, 0x2, 0x2, 0x547, 0x546, 0x3, 0x2, 
       0x2, 0x2, 0x548, 0x1f, 0x3, 0x2, 0x2, 0x2, 0x549, 0x54a, 0x5, 0x3de, 
       0x1f0, 0x2, 0x54a, 0x21, 0x3, 0x2, 0x2, 0x2, 0x54b, 0x54c, 0x7, 0x155, 
       0x2, 0x2, 0x54c, 0x23, 0x3, 0x2, 0x2, 0x2, 0x54d, 0x54e, 0x7, 0x156, 
       0x2, 0x2, 0x54e, 0x25, 0x3, 0x2, 0x2, 0x2, 0x54f, 0x550, 0x7, 0x157, 
       0x2, 0x2, 0x550, 0x551, 0x7, 0x16, 0x2, 0x2, 0x551, 0x552, 0x5, 0x46a, 
       0x236, 0x2, 0x552, 0x553, 0x7, 0x17, 0x2, 0x2, 0x553, 0x27, 0x3, 
       0x2, 0x2, 0x2, 0x554, 0x555, 0x7, 0x158, 0x2, 0x2, 0x555, 0x556, 
       0x7, 0x16, 0x2, 0x2, 0x556, 0x557, 0x7, 0xd7, 0x2, 0x2, 0x557, 0x558, 
       0x7, 0x17, 0x2, 0x2, 0x558, 0x29, 0x3, 0x2, 0x2, 0x2, 0x559, 0x55a, 
       0x7, 0x159, 0x2, 0x2, 0x55a, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55c, 
       0x7, 0x15a, 0x2, 0x2, 0x55c, 0x55d, 0x7, 0x16, 0x2, 0x2, 0x55d, 0x55e, 
       0x5, 0x46a, 0x236, 0x2, 0x55e, 0x55f, 0x7, 0x17, 0x2, 0x2, 0x55f, 
       0x2d, 0x3, 0x2, 0x2, 0x2, 0x560, 0x561, 0x7, 0x15b, 0x2, 0x2, 0x561, 
       0x564, 0x7, 0x16, 0x2, 0x2, 0x562, 0x565, 0x5, 0x48e, 0x248, 0x2, 
       0x563, 0x565, 0x7, 0xea, 0x2, 0x2, 0x564, 0x562, 0x3, 0x2, 0x2, 0x2, 
       0x564, 0x563, 0x3, 0x2, 0x2, 0x2, 0x565, 0x566, 0x3, 0x2, 0x2, 0x2, 
       0x566, 0x567, 0x7, 0x17, 0x2, 0x2, 0x567, 0x2f, 0x3, 0x2, 0x2, 0x2, 
       0x568, 0x569, 0x7, 0x15c, 0x2, 0x2, 0x569, 0x56a, 0x7, 0x16, 0x2, 
       0x2, 0x56a, 0x56b, 0x7, 0xed, 0x2, 0x2, 0x56b, 0x56c, 0x7, 0x1a, 
       0x2, 0x2, 0x56c, 0x56d, 0x5, 0x46a, 0x236, 0x2, 0x56d, 0x56e, 0x7, 
       0x17, 0x2, 0x2, 0x56e, 0x31, 0x3, 0x2, 0x2, 0x2, 0x56f, 0x574, 0x7, 
       0x15d, 0x2, 0x2, 0x570, 0x571, 0x7, 0x16, 0x2, 0x2, 0x571, 0x572, 
       0x5, 0x46a, 0x236, 0x2, 0x572, 0x573, 0x7, 0x17, 0x2, 0x2, 0x573, 
       0x575, 0x3, 0x2, 0x2, 0x2, 0x574, 0x570, 0x3, 0x2, 0x2, 0x2, 0x574, 
       0x575, 0x3, 0x2, 0x2, 0x2, 0x575, 0x33, 0x3, 0x2, 0x2, 0x2, 0x576, 
       0x577, 0x7, 0x15e, 0x2, 0x2, 0x577, 0x35, 0x3, 0x2, 0x2, 0x2, 0x578, 
       0x579, 0x7, 0x15f, 0x2, 0x2, 0x579, 0x57c, 0x7, 0x16, 0x2, 0x2, 0x57a, 
       0x57d, 0x5, 0x46a, 0x236, 0x2, 0x57b, 0x57d, 0x5, 0x498, 0x24d, 0x2, 
       0x57c, 0x57a, 0x3, 0x2, 0x2, 0x2, 0x57c, 0x57b, 0x3, 0x2, 0x2, 0x2, 
       0x57d, 0x57f, 0x3, 0x2, 0x2, 0x2, 0x57e, 0x580, 0x5, 0x38, 0x1d, 
       0x2, 0x57f, 0x57e, 0x3, 0x2, 0x2, 0x2, 0x57f, 0x580, 0x3, 0x2, 0x2, 
       0x2, 0x580, 0x581, 0x3, 0x2, 0x2, 0x2, 0x581, 0x582, 0x7, 0x17, 0x2, 
       0x2, 0x582, 0x37, 0x3, 0x2, 0x2, 0x2, 0x583, 0x584, 0x9, 0x3, 0x2, 
       0x2, 0x584, 0x39, 0x3, 0x2, 0x2, 0x2, 0x585, 0x586, 0x7, 0x160, 0x2, 
       0x2, 0x586, 0x3b, 0x3, 0x2, 0x2, 0x2, 0x587, 0x588, 0x7, 0x161, 0x2, 
       0x2, 0x588, 0x589, 0x7, 0x16, 0x2, 0x2, 0x589, 0x58a, 0x5, 0x46a, 
       0x236, 0x2, 0x58a, 0x58b, 0x7, 0x17, 0x2, 0x2, 0x58b, 0x3d, 0x3, 
       0x2, 0x2, 0x2, 0x58c, 0x598, 0x7, 0x162, 0x2, 0x2, 0x58d, 0x590, 
       0x7, 0x16, 0x2, 0x2, 0x58e, 0x58f, 0x7, 0x11f, 0x2, 0x2, 0x58f, 0x591, 
       0x7, 0x1a, 0x2, 0x2, 0x590, 0x58e, 0x3, 0x2, 0x2, 0x2, 0x590, 0x591, 
       0x3, 0x2, 0x2, 0x2, 0x591, 0x594, 0x3, 0x2, 0x2, 0x2, 0x592, 0x595, 
       0x5, 0x47e, 0x240, 0x2, 0x593, 0x595, 0x5, 0x46a, 0x236, 0x2, 0x594, 
       0x592, 0x3, 0x2, 0x2, 0x2, 0x594, 0x593, 0x3, 0x2, 0x2, 0x2, 0x595, 
       0x596, 0x3, 0x2, 0x2, 0x2, 0x596, 0x597, 0x7, 0x17, 0x2, 0x2, 0x597, 
       0x599, 0x3, 0x2, 0x2, 0x2, 0x598, 0x58d, 0x3, 0x2, 0x2, 0x2, 0x598, 
       0x599, 0x3, 0x2, 0x2, 0x2, 0x599, 0x3f, 0x3, 0x2, 0x2, 0x2, 0x59a, 
       0x59f, 0x7, 0x163, 0x2, 0x2, 0x59b, 0x59c, 0x7, 0x16, 0x2, 0x2, 0x59c, 
       0x59d, 0x5, 0x46a, 0x236, 0x2, 0x59d, 0x59e, 0x7, 0x17, 0x2, 0x2, 
       0x59e, 0x5a0, 0x3, 0x2, 0x2, 0x2, 0x59f, 0x59b, 0x3, 0x2, 0x2, 0x2, 
       0x59f, 0x5a0, 0x3, 0x2, 0x2, 0x2, 0x5a0, 0x41, 0x3, 0x2, 0x2, 0x2, 
       0x5a1, 0x5a2, 0x7, 0x164, 0x2, 0x2, 0x5a2, 0x43, 0x3, 0x2, 0x2, 0x2, 
       0x5a3, 0x5a4, 0x7, 0x165, 0x2, 0x2, 0x5a4, 0x5a5, 0x7, 0x16, 0x2, 
       0x2, 0x5a5, 0x5a6, 0x5, 0x46a, 0x236, 0x2, 0x5a6, 0x5a7, 0x7, 0x17, 
       0x2, 0x2, 0x5a7, 0x45, 0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5a9, 0x7, 0x166, 
       0x2, 0x2, 0x5a9, 0x5aa, 0x7, 0x16, 0x2, 0x2, 0x5aa, 0x5ab, 0x5, 0x46a, 
       0x236, 0x2, 0x5ab, 0x5ac, 0x7, 0x17, 0x2, 0x2, 0x5ac, 0x47, 0x3, 
       0x2, 0x2, 0x2, 0x5ad, 0x5ae, 0x7, 0x167, 0x2, 0x2, 0x5ae, 0x5af, 
       0x7, 0x16, 0x2, 0x2, 0x5af, 0x5b2, 0x5, 0x46a, 0x236, 0x2, 0x5b0, 
       0x5b1, 0x7, 0x1a, 0x2, 0x2, 0x5b1, 0x5b3, 0x5, 0x46a, 0x236, 0x2, 
       0x5b2, 0x5b0, 0x3, 0x2, 0x2, 0x2, 0x5b2, 0x5b3, 0x3, 0x2, 0x2, 0x2, 
       0x5b3, 0x5b6, 0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5b5, 0x7, 0x1a, 0x2, 0x2, 
       0x5b5, 0x5b7, 0x9, 0x4, 0x2, 0x2, 0x5b6, 0x5b4, 0x3, 0x2, 0x2, 0x2, 
       0x5b6, 0x5b7, 0x3, 0x2, 0x2, 0x2, 0x5b7, 0x5b8, 0x3, 0x2, 0x2, 0x2, 
       0x5b8, 0x5b9, 0x7, 0x17, 0x2, 0x2, 0x5b9, 0x49, 0x3, 0x2, 0x2, 0x2, 
       0x5ba, 0x5bf, 0x7, 0x168, 0x2, 0x2, 0x5bb, 0x5bc, 0x7, 0x16, 0x2, 
       0x2, 0x5bc, 0x5bd, 0x5, 0x46a, 0x236, 0x2, 0x5bd, 0x5be, 0x7, 0x17, 
       0x2, 0x2, 0x5be, 0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5bf, 0x5bb, 0x3, 0x2, 
       0x2, 0x2, 0x5bf, 0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5c0, 0x4b, 0x3, 0x2, 
       0x2, 0x2, 0x5c1, 0x5c2, 0x7, 0x169, 0x2, 0x2, 0x5c2, 0x5cb, 0x7, 
       0x16, 0x2, 0x2, 0x5c3, 0x5c4, 0x7, 0xed, 0x2, 0x2, 0x5c4, 0x5c5, 
       0x7, 0x1a, 0x2, 0x2, 0x5c5, 0x5c6, 0x5, 0x46a, 0x236, 0x2, 0x5c6, 
       0x5c7, 0x7, 0x1a, 0x2, 0x2, 0x5c7, 0x5cc, 0x3, 0x2, 0x2, 0x2, 0x5c8, 
       0x5c9, 0x5, 0x480, 0x241, 0x2, 0x5c9, 0x5ca, 0x7, 0x1a, 0x2, 0x2, 
       0x5ca, 0x5cc, 0x3, 0x2, 0x2, 0x2, 0x5cb, 0x5c3, 0x3, 0x2, 0x2, 0x2, 
       0x5cb, 0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5cb, 0x5cc, 0x3, 0x2, 0x2, 0x2, 
       0x5cc, 0x5cd, 0x3, 0x2, 0x2, 0x2, 0x5cd, 0x5ce, 0x5, 0x46a, 0x236, 
       0x2, 0x5ce, 0x5cf, 0x7, 0x17, 0x2, 0x2, 0x5cf, 0x4d, 0x3, 0x2, 0x2, 
       0x2, 0x5d0, 0x5d1, 0x7, 0x16a, 0x2, 0x2, 0x5d1, 0x5d2, 0x7, 0x16, 
       0x2, 0x2, 0x5d2, 0x5d3, 0x5, 0x46a, 0x236, 0x2, 0x5d3, 0x5d4, 0x7, 
       0x17, 0x2, 0x2, 0x5d4, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x5d5, 0x5da, 0x7, 
       0x16b, 0x2, 0x2, 0x5d6, 0x5d7, 0x7, 0x16, 0x2, 0x2, 0x5d7, 0x5d8, 
       0x5, 0x46a, 0x236, 0x2, 0x5d8, 0x5d9, 0x7, 0x17, 0x2, 0x2, 0x5d9, 
       0x5db, 0x3, 0x2, 0x2, 0x2, 0x5da, 0x5d6, 0x3, 0x2, 0x2, 0x2, 0x5da, 
       0x5db, 0x3, 0x2, 0x2, 0x2, 0x5db, 0x51, 0x3, 0x2, 0x2, 0x2, 0x5dc, 
       0x5e1, 0x7, 0x16c, 0x2, 0x2, 0x5dd, 0x5de, 0x7, 0x16, 0x2, 0x2, 0x5de, 
       0x5df, 0x5, 0x46a, 0x236, 0x2, 0x5df, 0x5e0, 0x7, 0x17, 0x2, 0x2, 
       0x5e0, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0x5e1, 0x5dd, 0x3, 0x2, 0x2, 0x2, 
       0x5e1, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0x5e2, 0x53, 0x3, 0x2, 0x2, 0x2, 
       0x5e3, 0x5e4, 0x7, 0x16d, 0x2, 0x2, 0x5e4, 0x5e5, 0x7, 0x16, 0x2, 
       0x2, 0x5e5, 0x5e6, 0x5, 0x46a, 0x236, 0x2, 0x5e6, 0x5e7, 0x7, 0x17, 
       0x2, 0x2, 0x5e7, 0x55, 0x3, 0x2, 0x2, 0x2, 0x5e8, 0x5e9, 0x7, 0x16e, 
       0x2, 0x2, 0x5e9, 0x5ea, 0x7, 0x16, 0x2, 0x2, 0x5ea, 0x5ed, 0x5, 0x46a, 
       0x236, 0x2, 0x5eb, 0x5ec, 0x7, 0x1a, 0x2, 0x2, 0x5ec, 0x5ee, 0x5, 
       0xcc, 0x67, 0x2, 0x5ed, 0x5eb, 0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5ee, 
       0x3, 0x2, 0x2, 0x2, 0x5ee, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5ef, 0x5f0, 
       0x7, 0x17, 0x2, 0x2, 0x5f0, 0x57, 0x3, 0x2, 0x2, 0x2, 0x5f1, 0x5f2, 
       0x7, 0x16f, 0x2, 0x2, 0x5f2, 0x5f3, 0x7, 0x16, 0x2, 0x2, 0x5f3, 0x5f4, 
       0x5, 0x46a, 0x236, 0x2, 0x5f4, 0x5f5, 0x7, 0x17, 0x2, 0x2, 0x5f5, 
       0x59, 0x3, 0x2, 0x2, 0x2, 0x5f6, 0x5f7, 0x7, 0x170, 0x2, 0x2, 0x5f7, 
       0x5f8, 0x7, 0x16, 0x2, 0x2, 0x5f8, 0x5f9, 0x5, 0x46a, 0x236, 0x2, 
       0x5f9, 0x5fa, 0x7, 0x17, 0x2, 0x2, 0x5fa, 0x5b, 0x3, 0x2, 0x2, 0x2, 
       0x5fb, 0x5fc, 0x7, 0x171, 0x2, 0x2, 0x5fc, 0x5fd, 0x7, 0x16, 0x2, 
       0x2, 0x5fd, 0x600, 0x5, 0x46a, 0x236, 0x2, 0x5fe, 0x5ff, 0x7, 0x1a, 
       0x2, 0x2, 0x5ff, 0x601, 0x9, 0x4, 0x2, 0x2, 0x600, 0x5fe, 0x3, 0x2, 
       0x2, 0x2, 0x600, 0x601, 0x3, 0x2, 0x2, 0x2, 0x601, 0x602, 0x3, 0x2, 
       0x2, 0x2, 0x602, 0x603, 0x7, 0x17, 0x2, 0x2, 0x603, 0x5d, 0x3, 0x2, 
       0x2, 0x2, 0x604, 0x605, 0x7, 0x172, 0x2, 0x2, 0x605, 0x5f, 0x3, 0x2, 
       0x2, 0x2, 0x606, 0x607, 0x7, 0x173, 0x2, 0x2, 0x607, 0x60b, 0x7, 
       0x16, 0x2, 0x2, 0x608, 0x60c, 0x5, 0x48e, 0x248, 0x2, 0x609, 0x60c, 
       0x5, 0x474, 0x23b, 0x2, 0x60a, 0x60c, 0x5, 0x480, 0x241, 0x2, 0x60b, 
       0x608, 0x3, 0x2, 0x2, 0x2, 0x60b, 0x609, 0x3, 0x2, 0x2, 0x2, 0x60b, 
       0x60a, 0x3, 0x2, 0x2, 0x2, 0x60c, 0x60d, 0x3, 0x2, 0x2, 0x2, 0x60d, 
       0x60e, 0x7, 0x17, 0x2, 0x2, 0x60e, 0x61, 0x3, 0x2, 0x2, 0x2, 0x60f, 
       0x610, 0x7, 0x174, 0x2, 0x2, 0x610, 0x63, 0x3, 0x2, 0x2, 0x2, 0x611, 
       0x612, 0x7, 0x175, 0x2, 0x2, 0x612, 0x613, 0x7, 0x16, 0x2, 0x2, 0x613, 
       0x618, 0x5, 0x480, 0x241, 0x2, 0x614, 0x615, 0x7, 0x1a, 0x2, 0x2, 
       0x615, 0x617, 0x5, 0x480, 0x241, 0x2, 0x616, 0x614, 0x3, 0x2, 0x2, 
       0x2, 0x617, 0x61a, 0x3, 0x2, 0x2, 0x2, 0x618, 0x616, 0x3, 0x2, 0x2, 
       0x2, 0x618, 0x619, 0x3, 0x2, 0x2, 0x2, 0x619, 0x61b, 0x3, 0x2, 0x2, 
       0x2, 0x61a, 0x618, 0x3, 0x2, 0x2, 0x2, 0x61b, 0x61c, 0x7, 0x17, 0x2, 
       0x2, 0x61c, 0x65, 0x3, 0x2, 0x2, 0x2, 0x61d, 0x61e, 0x7, 0x176, 0x2, 
       0x2, 0x61e, 0x61f, 0x7, 0x16, 0x2, 0x2, 0x61f, 0x625, 0x5, 0x46a, 
       0x236, 0x2, 0x620, 0x623, 0x7, 0x1a, 0x2, 0x2, 0x621, 0x624, 0x7, 
       0x10d, 0x2, 0x2, 0x622, 0x624, 0x5, 0x46a, 0x236, 0x2, 0x623, 0x621, 
       0x3, 0x2, 0x2, 0x2, 0x623, 0x622, 0x3, 0x2, 0x2, 0x2, 0x624, 0x626, 
       0x3, 0x2, 0x2, 0x2, 0x625, 0x620, 0x3, 0x2, 0x2, 0x2, 0x625, 0x626, 
       0x3, 0x2, 0x2, 0x2, 0x626, 0x627, 0x3, 0x2, 0x2, 0x2, 0x627, 0x628, 
       0x7, 0x17, 0x2, 0x2, 0x628, 0x67, 0x3, 0x2, 0x2, 0x2, 0x629, 0x62a, 
       0x7, 0x177, 0x2, 0x2, 0x62a, 0x69, 0x3, 0x2, 0x2, 0x2, 0x62b, 0x62c, 
       0x7, 0x178, 0x2, 0x2, 0x62c, 0x62d, 0x7, 0x16, 0x2, 0x2, 0x62d, 0x62e, 
       0x5, 0x46a, 0x236, 0x2, 0x62e, 0x62f, 0x7, 0x17, 0x2, 0x2, 0x62f, 
       0x6b, 0x3, 0x2, 0x2, 0x2, 0x630, 0x631, 0x7, 0x179, 0x2, 0x2, 0x631, 
       0x632, 0x7, 0x16, 0x2, 0x2, 0x632, 0x635, 0x5, 0x46a, 0x236, 0x2, 
       0x633, 0x634, 0x7, 0x1a, 0x2, 0x2, 0x634, 0x636, 0x5, 0x46a, 0x236, 
       0x2, 0x635, 0x633, 0x3, 0x2, 0x2, 0x2, 0x635, 0x636, 0x3, 0x2, 0x2, 
       0x2, 0x636, 0x637, 0x3, 0x2, 0x2, 0x2, 0x637, 0x638, 0x7, 0x17, 0x2, 
       0x2, 0x638, 0x6d, 0x3, 0x2, 0x2, 0x2, 0x639, 0x63a, 0x7, 0x17a, 0x2, 
       0x2, 0x63a, 0x63b, 0x7, 0x16, 0x2, 0x2, 0x63b, 0x63c, 0x5, 0x46a, 
       0x236, 0x2, 0x63c, 0x63d, 0x7, 0x17, 0x2, 0x2, 0x63d, 0x6f, 0x3, 
       0x2, 0x2, 0x2, 0x63e, 0x63f, 0x7, 0x17b, 0x2, 0x2, 0x63f, 0x71, 0x3, 
       0x2, 0x2, 0x2, 0x640, 0x641, 0x7, 0x17c, 0x2, 0x2, 0x641, 0x73, 0x3, 
       0x2, 0x2, 0x2, 0x642, 0x643, 0x7, 0x17d, 0x2, 0x2, 0x643, 0x75, 0x3, 
       0x2, 0x2, 0x2, 0x644, 0x648, 0x7, 0x17e, 0x2, 0x2, 0x645, 0x646, 
       0x7, 0x16, 0x2, 0x2, 0x646, 0x647, 0x7, 0xe1, 0x2, 0x2, 0x647, 0x649, 
       0x7, 0x17, 0x2, 0x2, 0x648, 0x645, 0x3, 0x2, 0x2, 0x2, 0x648, 0x649, 
       0x3, 0x2, 0x2, 0x2, 0x649, 0x77, 0x3, 0x2, 0x2, 0x2, 0x64a, 0x653, 
       0x7, 0x1a0, 0x2, 0x2, 0x64b, 0x64c, 0x7, 0x16, 0x2, 0x2, 0x64c, 0x64f, 
       0x5, 0x46a, 0x236, 0x2, 0x64d, 0x64e, 0x7, 0x1a, 0x2, 0x2, 0x64e, 
       0x650, 0x5, 0x48e, 0x248, 0x2, 0x64f, 0x64d, 0x3, 0x2, 0x2, 0x2, 
       0x64f, 0x650, 0x3, 0x2, 0x2, 0x2, 0x650, 0x651, 0x3, 0x2, 0x2, 0x2, 
       0x651, 0x652, 0x7, 0x17, 0x2, 0x2, 0x652, 0x654, 0x3, 0x2, 0x2, 0x2, 
       0x653, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x653, 0x654, 0x3, 0x2, 0x2, 0x2, 
       0x654, 0x79, 0x3, 0x2, 0x2, 0x2, 0x655, 0x656, 0x7, 0x17f, 0x2, 0x2, 
       0x656, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x657, 0x658, 0x7, 0x180, 0x2, 0x2, 
       0x658, 0x659, 0x7, 0x16, 0x2, 0x2, 0x659, 0x65b, 0x5, 0x46a, 0x236, 
       0x2, 0x65a, 0x65c, 0x7, 0x1a, 0x2, 0x2, 0x65b, 0x65a, 0x3, 0x2, 0x2, 
       0x2, 0x65b, 0x65c, 0x3, 0x2, 0x2, 0x2, 0x65c, 0x65d, 0x3, 0x2, 0x2, 
       0x2, 0x65d, 0x65e, 0x7, 0x17, 0x2, 0x2, 0x65e, 0x7d, 0x3, 0x2, 0x2, 
       0x2, 0x65f, 0x660, 0x7, 0x181, 0x2, 0x2, 0x660, 0x661, 0x7, 0x16, 
       0x2, 0x2, 0x661, 0x663, 0x5, 0x46a, 0x236, 0x2, 0x662, 0x664, 0x5, 
       0x46a, 0x236, 0x2, 0x663, 0x662, 0x3, 0x2, 0x2, 0x2, 0x663, 0x664, 
       0x3, 0x2, 0x2, 0x2, 0x664, 0x665, 0x3, 0x2, 0x2, 0x2, 0x665, 0x666, 
       0x7, 0x17, 0x2, 0x2, 0x666, 0x7f, 0x3, 0x2, 0x2, 0x2, 0x667, 0x668, 
       0x7, 0x182, 0x2, 0x2, 0x668, 0x81, 0x3, 0x2, 0x2, 0x2, 0x669, 0x66e, 
       0x7, 0x183, 0x2, 0x2, 0x66a, 0x66b, 0x7, 0x16, 0x2, 0x2, 0x66b, 0x66c, 
       0x5, 0x46a, 0x236, 0x2, 0x66c, 0x66d, 0x7, 0x17, 0x2, 0x2, 0x66d, 
       0x66f, 0x3, 0x2, 0x2, 0x2, 0x66e, 0x66a, 0x3, 0x2, 0x2, 0x2, 0x66e, 
       0x66f, 0x3, 0x2, 0x2, 0x2, 0x66f, 0x83, 0x3, 0x2, 0x2, 0x2, 0x670, 
       0x671, 0x7, 0x1a8, 0x2, 0x2, 0x671, 0x85, 0x3, 0x2, 0x2, 0x2, 0x672, 
       0x673, 0x7, 0x184, 0x2, 0x2, 0x673, 0x674, 0x7, 0x16, 0x2, 0x2, 0x674, 
       0x675, 0x5, 0x498, 0x24d, 0x2, 0x675, 0x676, 0x7, 0x17, 0x2, 0x2, 
       0x676, 0x87, 0x3, 0x2, 0x2, 0x2, 0x677, 0x67c, 0x9, 0x5, 0x2, 0x2, 
       0x678, 0x679, 0x7, 0x16, 0x2, 0x2, 0x679, 0x67a, 0x5, 0x46a, 0x236, 
       0x2, 0x67a, 0x67b, 0x7, 0x17, 0x2, 0x2, 0x67b, 0x67d, 0x3, 0x2, 0x2, 
       0x2, 0x67c, 0x678, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x67d, 0x3, 0x2, 0x2, 
       0x2, 0x67d, 0x89, 0x3, 0x2, 0x2, 0x2, 0x67e, 0x67f, 0x7, 0x186, 0x2, 
       0x2, 0x67f, 0x680, 0x7, 0x16, 0x2, 0x2, 0x680, 0x681, 0x5, 0x46a, 
       0x236, 0x2, 0x681, 0x682, 0x7, 0x17, 0x2, 0x2, 0x682, 0x8b, 0x3, 
       0x2, 0x2, 0x2, 0x683, 0x684, 0x7, 0x187, 0x2, 0x2, 0x684, 0x685, 
       0x7, 0x16, 0x2, 0x2, 0x685, 0x686, 0x5, 0x46a, 0x236, 0x2, 0x686, 
       0x687, 0x7, 0x17, 0x2, 0x2, 0x687, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x688, 
       0x689, 0x7, 0x188, 0x2, 0x2, 0x689, 0x68c, 0x7, 0x16, 0x2, 0x2, 0x68a, 
       0x68d, 0x5, 0x46a, 0x236, 0x2, 0x68b, 0x68d, 0x5, 0x498, 0x24d, 0x2, 
       0x68c, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x68c, 0x68b, 0x3, 0x2, 0x2, 0x2, 
       0x68d, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x68e, 0x68f, 0x7, 0x17, 0x2, 0x2, 
       0x68f, 0x8f, 0x3, 0x2, 0x2, 0x2, 0x690, 0x691, 0x7, 0x189, 0x2, 0x2, 
       0x691, 0x692, 0x7, 0x16, 0x2, 0x2, 0x692, 0x693, 0x5, 0x46a, 0x236, 
       0x2, 0x693, 0x694, 0x7, 0x17, 0x2, 0x2, 0x694, 0x91, 0x3, 0x2, 0x2, 
       0x2, 0x695, 0x696, 0x7, 0x18a, 0x2, 0x2, 0x696, 0x697, 0x7, 0x16, 
       0x2, 0x2, 0x697, 0x698, 0x5, 0x46a, 0x236, 0x2, 0x698, 0x699, 0x7, 
       0x17, 0x2, 0x2, 0x699, 0x93, 0x3, 0x2, 0x2, 0x2, 0x69a, 0x69b, 0x7, 
       0x18b, 0x2, 0x2, 0x69b, 0x69c, 0x7, 0x16, 0x2, 0x2, 0x69c, 0x69d, 
       0x5, 0x48e, 0x248, 0x2, 0x69d, 0x69e, 0x7, 0x17, 0x2, 0x2, 0x69e, 
       0x95, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x6a0, 0x7, 0x18c, 0x2, 0x2, 0x6a0, 
       0x6a1, 0x7, 0x16, 0x2, 0x2, 0x6a1, 0x6a2, 0x5, 0x48e, 0x248, 0x2, 
       0x6a2, 0x6a3, 0x7, 0x17, 0x2, 0x2, 0x6a3, 0x97, 0x3, 0x2, 0x2, 0x2, 
       0x6a4, 0x6a5, 0x7, 0x18d, 0x2, 0x2, 0x6a5, 0x6a6, 0x7, 0x16, 0x2, 
       0x2, 0x6a6, 0x6ab, 0x5, 0x46a, 0x236, 0x2, 0x6a7, 0x6a8, 0x7, 0x1a, 
       0x2, 0x2, 0x6a8, 0x6aa, 0x5, 0x46a, 0x236, 0x2, 0x6a9, 0x6a7, 0x3, 
       0x2, 0x2, 0x2, 0x6aa, 0x6ad, 0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6a9, 0x3, 
       0x2, 0x2, 0x2, 0x6ab, 0x6ac, 0x3, 0x2, 0x2, 0x2, 0x6ac, 0x6ae, 0x3, 
       0x2, 0x2, 0x2, 0x6ad, 0x6ab, 0x3, 0x2, 0x2, 0x2, 0x6ae, 0x6af, 0x7, 
       0x17, 0x2, 0x2, 0x6af, 0x99, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b1, 0x7, 
       0x18e, 0x2, 0x2, 0x6b1, 0x6b2, 0x7, 0x16, 0x2, 0x2, 0x6b2, 0x6b7, 
       0x5, 0x46a, 0x236, 0x2, 0x6b3, 0x6b4, 0x7, 0x1a, 0x2, 0x2, 0x6b4, 
       0x6b6, 0x5, 0x46a, 0x236, 0x2, 0x6b5, 0x6b3, 0x3, 0x2, 0x2, 0x2, 
       0x6b6, 0x6b9, 0x3, 0x2, 0x2, 0x2, 0x6b7, 0x6b5, 0x3, 0x2, 0x2, 0x2, 
       0x6b7, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x6b8, 0x6ba, 0x3, 0x2, 0x2, 0x2, 
       0x6b9, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6bb, 0x7, 0x17, 0x2, 0x2, 
       0x6bb, 0x9b, 0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6bd, 0x7, 0x18f, 0x2, 0x2, 
       0x6bd, 0x6be, 0x7, 0x16, 0x2, 0x2, 0x6be, 0x6bf, 0x5, 0x46a, 0x236, 
       0x2, 0x6bf, 0x6c0, 0x7, 0x17, 0x2, 0x2, 0x6c0, 0x9d, 0x3, 0x2, 0x2, 
       0x2, 0x6c1, 0x6c2, 0x7, 0x190, 0x2, 0x2, 0x6c2, 0x6c3, 0x7, 0x16, 
       0x2, 0x2, 0x6c3, 0x6c4, 0x5, 0x46a, 0x236, 0x2, 0x6c4, 0x6c5, 0x7, 
       0x17, 0x2, 0x2, 0x6c5, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0x6c7, 0x7, 
       0x191, 0x2, 0x2, 0x6c7, 0x6c8, 0x7, 0x16, 0x2, 0x2, 0x6c8, 0x6c9, 
       0x5, 0x46a, 0x236, 0x2, 0x6c9, 0x6ca, 0x7, 0x17, 0x2, 0x2, 0x6ca, 
       0xa1, 0x3, 0x2, 0x2, 0x2, 0x6cb, 0x6cc, 0x7, 0x192, 0x2, 0x2, 0x6cc, 
       0x6cd, 0x7, 0x16, 0x2, 0x2, 0x6cd, 0x6ce, 0x5, 0x48e, 0x248, 0x2, 
       0x6ce, 0x6cf, 0x7, 0x17, 0x2, 0x2, 0x6cf, 0xa3, 0x3, 0x2, 0x2, 0x2, 
       0x6d0, 0x6d1, 0x7, 0x193, 0x2, 0x2, 0x6d1, 0x6d2, 0x7, 0x16, 0x2, 
       0x2, 0x6d2, 0x6d3, 0x5, 0x498, 0x24d, 0x2, 0x6d3, 0x6d4, 0x7, 0x17, 
       0x2, 0x2, 0x6d4, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d6, 0x7, 0x194, 
       0x2, 0x2, 0x6d6, 0x6d7, 0x7, 0x16, 0x2, 0x2, 0x6d7, 0x6d8, 0x5, 0x46a, 
       0x236, 0x2, 0x6d8, 0x6d9, 0x7, 0x17, 0x2, 0x2, 0x6d9, 0xa7, 0x3, 
       0x2, 0x2, 0x2, 0x6da, 0x6db, 0x7, 0x195, 0x2, 0x2, 0x6db, 0x6dc, 
       0x7, 0x16, 0x2, 0x2, 0x6dc, 0x6dd, 0x5, 0x498, 0x24d, 0x2, 0x6dd, 
       0x6de, 0x7, 0x17, 0x2, 0x2, 0x6de, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x6df, 
       0x6e0, 0x7, 0x196, 0x2, 0x2, 0x6e0, 0x6e1, 0x7, 0x16, 0x2, 0x2, 0x6e1, 
       0x6e2, 0x5, 0x46a, 0x236, 0x2, 0x6e2, 0x6e3, 0x7, 0x17, 0x2, 0x2, 
       0x6e3, 0xab, 0x3, 0x2, 0x2, 0x2, 0x6e4, 0x6e5, 0x7, 0x197, 0x2, 0x2, 
       0x6e5, 0x6e6, 0x7, 0x16, 0x2, 0x2, 0x6e6, 0x6e7, 0x5, 0x46a, 0x236, 
       0x2, 0x6e7, 0x6e8, 0x7, 0x17, 0x2, 0x2, 0x6e8, 0xad, 0x3, 0x2, 0x2, 
       0x2, 0x6e9, 0x6ea, 0x7, 0x198, 0x2, 0x2, 0x6ea, 0x6eb, 0x7, 0x16, 
       0x2, 0x2, 0x6eb, 0x6ee, 0x5, 0x46a, 0x236, 0x2, 0x6ec, 0x6ed, 0x7, 
       0x1a, 0x2, 0x2, 0x6ed, 0x6ef, 0x5, 0x498, 0x24d, 0x2, 0x6ee, 0x6ec, 
       0x3, 0x2, 0x2, 0x2, 0x6ee, 0x6ef, 0x3, 0x2, 0x2, 0x2, 0x6ef, 0x6f0, 
       0x3, 0x2, 0x2, 0x2, 0x6f0, 0x6f1, 0x7, 0x17, 0x2, 0x2, 0x6f1, 0xaf, 
       0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f3, 0x7, 0x199, 0x2, 0x2, 0x6f3, 0x6f4, 
       0x7, 0x16, 0x2, 0x2, 0x6f4, 0x6f5, 0x5, 0x46a, 0x236, 0x2, 0x6f5, 
       0x6f6, 0x7, 0x17, 0x2, 0x2, 0x6f6, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x6f7, 
       0x6f8, 0x7, 0x19a, 0x2, 0x2, 0x6f8, 0x6f9, 0x7, 0x16, 0x2, 0x2, 0x6f9, 
       0x6fa, 0x5, 0x46a, 0x236, 0x2, 0x6fa, 0x6fb, 0x7, 0x17, 0x2, 0x2, 
       0x6fb, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0x6fd, 0x7, 0x19b, 0x2, 0x2, 
       0x6fd, 0x6fe, 0x7, 0x16, 0x2, 0x2, 0x6fe, 0x6ff, 0x5, 0x46a, 0x236, 
       0x2, 0x6ff, 0x700, 0x7, 0x1a, 0x2, 0x2, 0x700, 0x701, 0x5, 0x46a, 
       0x236, 0x2, 0x701, 0x702, 0x7, 0x17, 0x2, 0x2, 0x702, 0xb5, 0x3, 
       0x2, 0x2, 0x2, 0x703, 0x704, 0x7, 0x19c, 0x2, 0x2, 0x704, 0x705, 
       0x7, 0x16, 0x2, 0x2, 0x705, 0x706, 0x5, 0x46a, 0x236, 0x2, 0x706, 
       0x707, 0x7, 0x17, 0x2, 0x2, 0x707, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x708, 
       0x709, 0x7, 0x19d, 0x2, 0x2, 0x709, 0x70a, 0x7, 0x16, 0x2, 0x2, 0x70a, 
       0x70b, 0x5, 0x48e, 0x248, 0x2, 0x70b, 0x70c, 0x7, 0x17, 0x2, 0x2, 
       0x70c, 0xb9, 0x3, 0x2, 0x2, 0x2, 0x70d, 0x70e, 0x7, 0x19e, 0x2, 0x2, 
       0x70e, 0x70f, 0x7, 0x16, 0x2, 0x2, 0x70f, 0x710, 0x5, 0x46a, 0x236, 
       0x2, 0x710, 0x711, 0x7, 0x1a, 0x2, 0x2, 0x711, 0x712, 0x5, 0x46a, 
       0x236, 0x2, 0x712, 0x713, 0x7, 0x17, 0x2, 0x2, 0x713, 0xbb, 0x3, 
       0x2, 0x2, 0x2, 0x714, 0x715, 0x7, 0x19f, 0x2, 0x2, 0x715, 0x716, 
       0x7, 0x16, 0x2, 0x2, 0x716, 0x717, 0x5, 0x48e, 0x248, 0x2, 0x717, 
       0x718, 0x7, 0x17, 0x2, 0x2, 0x718, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x719, 
       0x71a, 0x7, 0x1a1, 0x2, 0x2, 0x71a, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x71b, 
       0x71f, 0x7, 0x1a2, 0x2, 0x2, 0x71c, 0x71d, 0x7, 0x16, 0x2, 0x2, 0x71d, 
       0x71e, 0x7, 0xfb, 0x2, 0x2, 0x71e, 0x720, 0x7, 0x17, 0x2, 0x2, 0x71f, 
       0x71c, 0x3, 0x2, 0x2, 0x2, 0x71f, 0x720, 0x3, 0x2, 0x2, 0x2, 0x720, 
       0xc1, 0x3, 0x2, 0x2, 0x2, 0x721, 0x722, 0x7, 0x1a3, 0x2, 0x2, 0x722, 
       0xc3, 0x3, 0x2, 0x2, 0x2, 0x723, 0x724, 0x7, 0x1a4, 0x2, 0x2, 0x724, 
       0x725, 0x7, 0x16, 0x2, 0x2, 0x725, 0x726, 0x5, 0x498, 0x24d, 0x2, 
       0x726, 0x727, 0x7, 0x17, 0x2, 0x2, 0x727, 0xc5, 0x3, 0x2, 0x2, 0x2, 
       0x728, 0x729, 0x7, 0x1a5, 0x2, 0x2, 0x729, 0xc7, 0x3, 0x2, 0x2, 0x2, 
       0x72a, 0x72b, 0x7, 0x1a6, 0x2, 0x2, 0x72b, 0xc9, 0x3, 0x2, 0x2, 0x2, 
       0x72c, 0x72d, 0x7, 0x1a7, 0x2, 0x2, 0x72d, 0x730, 0x7, 0x16, 0x2, 
       0x2, 0x72e, 0x731, 0x5, 0x498, 0x24d, 0x2, 0x72f, 0x731, 0x7, 0x1b, 
       0x2, 0x2, 0x730, 0x72e, 0x3, 0x2, 0x2, 0x2, 0x730, 0x72f, 0x3, 0x2, 
       0x2, 0x2, 0x731, 0x739, 0x3, 0x2, 0x2, 0x2, 0x732, 0x735, 0x7, 0x1a, 
       0x2, 0x2, 0x733, 0x736, 0x5, 0x498, 0x24d, 0x2, 0x734, 0x736, 0x7, 
       0x1b, 0x2, 0x2, 0x735, 0x733, 0x3, 0x2, 0x2, 0x2, 0x735, 0x734, 0x3, 
       0x2, 0x2, 0x2, 0x736, 0x738, 0x3, 0x2, 0x2, 0x2, 0x737, 0x732, 0x3, 
       0x2, 0x2, 0x2, 0x738, 0x73b, 0x3, 0x2, 0x2, 0x2, 0x739, 0x737, 0x3, 
       0x2, 0x2, 0x2, 0x739, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73c, 0x3, 
       0x2, 0x2, 0x2, 0x73b, 0x739, 0x3, 0x2, 0x2, 0x2, 0x73c, 0x73d, 0x7, 
       0x17, 0x2, 0x2, 0x73d, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x73f, 0x5, 
       0xce, 0x68, 0x2, 0x73f, 0x740, 0x5, 0x48e, 0x248, 0x2, 0x740, 0xcd, 
       0x3, 0x2, 0x2, 0x2, 0x741, 0x742, 0x9, 0x6, 0x2, 0x2, 0x742, 0xcf, 
       0x3, 0x2, 0x2, 0x2, 0x743, 0x744, 0x7, 0x77, 0x2, 0x2, 0x744, 0x748, 
       0x5, 0x480, 0x241, 0x2, 0x745, 0x747, 0x5, 0x1e, 0x10, 0x2, 0x746, 
       0x745, 0x3, 0x2, 0x2, 0x2, 0x747, 0x74a, 0x3, 0x2, 0x2, 0x2, 0x748, 
       0x746, 0x3, 0x2, 0x2, 0x2, 0x748, 0x749, 0x3, 0x2, 0x2, 0x2, 0x749, 
       0x759, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x748, 0x3, 0x2, 0x2, 0x2, 0x74b, 
       0x751, 0x7, 0x1d4, 0x2, 0x2, 0x74c, 0x750, 0x5, 0x10, 0x9, 0x2, 0x74d, 
       0x750, 0x5, 0x300, 0x181, 0x2, 0x74e, 0x750, 0x5, 0xd2, 0x6a, 0x2, 
       0x74f, 0x74c, 0x3, 0x2, 0x2, 0x2, 0x74f, 0x74d, 0x3, 0x2, 0x2, 0x2, 
       0x74f, 0x74e, 0x3, 0x2, 0x2, 0x2, 0x750, 0x753, 0x3, 0x2, 0x2, 0x2, 
       0x751, 0x74f, 0x3, 0x2, 0x2, 0x2, 0x751, 0x752, 0x3, 0x2, 0x2, 0x2, 
       0x752, 0x755, 0x3, 0x2, 0x2, 0x2, 0x753, 0x751, 0x3, 0x2, 0x2, 0x2, 
       0x754, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x754, 0x755, 0x3, 0x2, 0x2, 0x2, 
       0x755, 0x756, 0x3, 0x2, 0x2, 0x2, 0x756, 0x75a, 0x5, 0xd4, 0x6b, 
       0x2, 0x757, 0x75a, 0x5, 0x5c, 0x2f, 0x2, 0x758, 0x75a, 0x5, 0x58, 
       0x2d, 0x2, 0x759, 0x754, 0x3, 0x2, 0x2, 0x2, 0x759, 0x757, 0x3, 0x2, 
       0x2, 0x2, 0x759, 0x758, 0x3, 0x2, 0x2, 0x2, 0x75a, 0x75b, 0x3, 0x2, 
       0x2, 0x2, 0x75b, 0x75c, 0x7, 0x1d4, 0x2, 0x2, 0x75c, 0x77a, 0x3, 
       0x2, 0x2, 0x2, 0x75d, 0x75e, 0x7, 0x8, 0x2, 0x2, 0x75e, 0x75f, 0x5, 
       0x12e, 0x98, 0x2, 0x75f, 0x760, 0x7, 0x266, 0x2, 0x2, 0x760, 0x761, 
       0x7, 0x267, 0x2, 0x2, 0x761, 0x762, 0x7, 0x26b, 0x2, 0x2, 0x762, 
       0x763, 0x7, 0x26f, 0x2, 0x2, 0x763, 0x764, 0x7, 0x270, 0x2, 0x2, 
       0x764, 0x765, 0x7, 0x271, 0x2, 0x2, 0x765, 0x766, 0x7, 0x272, 0x2, 
       0x2, 0x766, 0x76a, 0x7, 0x273, 0x2, 0x2, 0x767, 0x769, 0x5, 0x1e, 
       0x10, 0x2, 0x768, 0x767, 0x3, 0x2, 0x2, 0x2, 0x769, 0x76c, 0x3, 0x2, 
       0x2, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x2, 0x76a, 0x768, 0x3, 0x2, 0x2, 0x2, 0x76a, 0x76b, 0x3, 0x2, 0x2, 
       0x2, 0x76b, 0x76d, 0x3, 0x2, 0x2, 0x2, 0x76c, 0x76a, 0x3, 0x2, 0x2, 
       0x2, 0x76d, 0x777, 0x9, 0x2, 0x2, 0x2, 0x76e, 0x772, 0x5, 0x10, 0x9, 
       0x2, 0x76f, 0x772, 0x5, 0x300, 0x181, 0x2, 0x770, 0x772, 0x5, 0x156, 
       0xac, 0x2, 0x771, 0x76e, 0x3, 0x2, 0x2, 0x2, 0x771, 0x76f, 0x3, 0x2, 
       0x2, 0x2, 0x771, 0x770, 0x3, 0x2, 0x2, 0x2, 0x772, 0x775, 0x3, 0x2, 
       0x2, 0x2, 0x773, 0x771, 0x3, 0x2, 0x2, 0x2, 0x773, 0x774, 0x3, 0x2, 
       0x2, 0x2, 0x774, 0x776, 0x3, 0x2, 0x2, 0x2, 0x775, 0x773, 0x3, 0x2, 
       0x2, 0x2, 0x776, 0x778, 0x5, 0x156, 0xac, 0x2, 0x777, 0x773, 0x3, 
       0x2, 0x2, 0x2, 0x777, 0x778, 0x3, 0x2, 0x2, 0x2, 0x778, 0x77a, 0x3, 
       0x2, 0x2, 0x2, 0x779, 0x743, 0x3, 0x2, 0x2, 0x2, 0x779, 0x75d, 0x3, 
       0x2, 0x2, 0x2, 0x77a, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x77d, 0x7, 
       0x7c, 0x2, 0x2, 0x77c, 0x77b, 0x3, 0x2, 0x2, 0x2, 0x77c, 0x77d, 0x3, 
       0x2, 0x2, 0x2, 0x77d, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x77e, 0x781, 0x5, 
       0x480, 0x241, 0x2, 0x77f, 0x782, 0x5, 0x1c, 0xf, 0x2, 0x780, 0x782, 
       0x5, 0x480, 0x241, 0x2, 0x781, 0x77f, 0x3, 0x2, 0x2, 0x2, 0x781, 
       0x780, 0x3, 0x2, 0x2, 0x2, 0x781, 0x782, 0x3, 0x2, 0x2, 0x2, 0x782, 
       0x786, 0x3, 0x2, 0x2, 0x2, 0x783, 0x785, 0x5, 0x1e, 0x10, 0x2, 0x784, 
       0x783, 0x3, 0x2, 0x2, 0x2, 0x785, 0x788, 0x3, 0x2, 0x2, 0x2, 0x786, 
       0x784, 0x3, 0x2, 0x2, 0x2, 0x786, 0x787, 0x3, 0x2, 0x2, 0x2, 0x787, 
       0x789, 0x3, 0x2, 0x2, 0x2, 0x788, 0x786, 0x3, 0x2, 0x2, 0x2, 0x789, 
       0x78a, 0x7, 0x1d4, 0x2, 0x2, 0x78a, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x78b, 
       0x78d, 0x7, 0x78, 0x2, 0x2, 0x78c, 0x78e, 0x5, 0x480, 0x241, 0x2, 
       0x78d, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x78d, 0x78e, 0x3, 0x2, 0x2, 0x2, 
       0x78e, 0xd5, 0x3, 0x2, 0x2, 0x2, 0x78f, 0x790, 0x7, 0x79, 0x2, 0x2, 
       0x790, 0x792, 0x5, 0x480, 0x241, 0x2, 0x791, 0x793, 0x5, 0x1c, 0xf, 
       0x2, 0x792, 0x791, 0x3, 0x2, 0x2, 0x2, 0x792, 0x793, 0x3, 0x2, 0x2, 
       0x2, 0x793, 0x797, 0x3, 0x2, 0x2, 0x2, 0x794, 0x796, 0x5, 0x1e, 0x10, 
       0x2, 0x795, 0x794, 0x3, 0x2, 0x2, 0x2, 0x796, 0x799, 0x3, 0x2, 0x2, 
       0x2, 0x797, 0x795, 0x3, 0x2, 0x2, 0x2, 0x797, 0x798, 0x3, 0x2, 0x2, 
       0x2, 0x798, 0x79b, 0x3, 0x2, 0x2, 0x2, 0x799, 0x797, 0x3, 0x2, 0x2, 
       0x2, 0x79a, 0x79c, 0x7, 0x1d4, 0x2, 0x2, 0x79b, 0x79a, 0x3, 0x2, 
       0x2, 0x2, 0x79b, 0x79c, 0x3, 0x2, 0x2, 0x2, 0x79c, 0x7a0, 0x3, 0x2, 
       0x2, 0x2, 0x79d, 0x79f, 0x5, 0xd8, 0x6d, 0x2, 0x79e, 0x79d, 0x3, 
       0x2, 0x2, 0x2, 0x79f, 0x7a2, 0x3, 0x2, 0x2, 0x2, 0x7a0, 0x79e, 0x3, 
       0x2, 0x2, 0x2, 0x7a0, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a1, 0x7a4, 0x3, 
       0x2, 0x2, 0x2, 0x7a2, 0x7a0, 0x3, 0x2, 0x2, 0x2, 0x7a3, 0x7a5, 0x5, 
       0xdc, 0x6f, 0x2, 0x7a4, 0x7a3, 0x3, 0x2, 0x2, 0x2, 0x7a4, 0x7a5, 
       0x3, 0x2, 0x2, 0x2, 0x7a5, 0x7a6, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x7a7, 
       0x5, 0xda, 0x6e, 0x2, 0x7a7, 0x7a8, 0x7, 0x1d4, 0x2, 0x2, 0x7a8, 
       0x7b1, 0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7ad, 0x5, 0x16a, 0xb6, 0x2, 0x7aa, 
       0x7ac, 0x5, 0x156, 0xac, 0x2, 0x7ab, 0x7aa, 0x3, 0x2, 0x2, 0x2, 0x7ac, 
       0x7af, 0x3, 0x2, 0x2, 0x2, 0x7ad, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7ad, 
       0x7ae, 0x3, 0x2, 0x2, 0x2, 0x7ae, 0x7b1, 0x3, 0x2, 0x2, 0x2, 0x7af, 
       0x7ad, 0x3, 0x2, 0x2, 0x2, 0x7b0, 0x78f, 0x3, 0x2, 0x2, 0x2, 0x7b0, 
       0x7a9, 0x3, 0x2, 0x2, 0x2, 0x7b1, 0xd7, 0x3, 0x2, 0x2, 0x2, 0x7b2, 
       0x7b4, 0x7, 0x7b, 0x2, 0x2, 0x7b3, 0x7b2, 0x3, 0x2, 0x2, 0x2, 0x7b3, 
       0x7b4, 0x3, 0x2, 0x2, 0x2, 0x7b4, 0x7b5, 0x3, 0x2, 0x2, 0x2, 0x7b5, 
       0x7b8, 0x5, 0x480, 0x241, 0x2, 0x7b6, 0x7b9, 0x5, 0x1c, 0xf, 0x2, 
       0x7b7, 0x7b9, 0x5, 0x56, 0x2c, 0x2, 0x7b8, 0x7b6, 0x3, 0x2, 0x2, 
       0x2, 0x7b8, 0x7b7, 0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7bd, 0x3, 0x2, 0x2, 
       0x2, 0x7ba, 0x7bc, 0x5, 0x1e, 0x10, 0x2, 0x7bb, 0x7ba, 0x3, 0x2, 
       0x2, 0x2, 0x7bc, 0x7bf, 0x3, 0x2, 0x2, 0x2, 0x7bd, 0x7bb, 0x3, 0x2, 
       0x2, 0x2, 0x7bd, 0x7be, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7c0, 0x3, 0x2, 
       0x2, 0x2, 0x7bf, 0x7bd, 0x3, 0x2, 0x2, 0x2, 0x7c0, 0x7c1, 0x7, 0x1d4, 
       0x2, 0x2, 0x7c1, 0xd9, 0x3, 0x2, 0x2, 0x2, 0x7c2, 0x7c3, 0x7, 0x7a, 
       0x2, 0x2, 0x7c3, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x7c4, 0x7c5, 0x7, 0x7d, 
       0x2, 0x2, 0x7c5, 0x7c7, 0x5, 0x480, 0x241, 0x2, 0x7c6, 0x7c8, 0x5, 
       0x1c, 0xf, 0x2, 0x7c7, 0x7c6, 0x3, 0x2, 0x2, 0x2, 0x7c7, 0x7c8, 0x3, 
       0x2, 0x2, 0x2, 0x7c8, 0x7cc, 0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7cb, 0x5, 
       0x1e, 0x10, 0x2, 0x7ca, 0x7c9, 0x3, 0x2, 0x2, 0x2, 0x7cb, 0x7ce, 
       0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7cd, 
       0x3, 0x2, 0x2, 0x2, 0x7cd, 0x7d0, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7cc, 
       0x3, 0x2, 0x2, 0x2, 0x7cf, 0x7d1, 0x7, 0x1d4, 0x2, 0x2, 0x7d0, 0x7cf, 
       0x3, 0x2, 0x2, 0x2, 0x7d0, 0x7d1, 0x3, 0x2, 0x2, 0x2, 0x7d1, 0x7d5, 
       0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7d4, 0x5, 0xde, 0x70, 0x2, 0x7d3, 0x7d2, 
       0x3, 0x2, 0x2, 0x2, 0x7d4, 0x7d7, 0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7d3, 
       0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7d6, 0x3, 0x2, 0x2, 0x2, 0x7d6, 0x7d8, 
       0x3, 0x2, 0x2, 0x2, 0x7d7, 0x7d5, 0x3, 0x2, 0x2, 0x2, 0x7d8, 0x7d9, 
       0x5, 0xe0, 0x71, 0x2, 0x7d9, 0x7da, 0x7, 0x1d4, 0x2, 0x2, 0x7da, 
       0x7e3, 0x3, 0x2, 0x2, 0x2, 0x7db, 0x7df, 0x5, 0x154, 0xab, 0x2, 0x7dc, 
       0x7de, 0x5, 0x15a, 0xae, 0x2, 0x7dd, 0x7dc, 0x3, 0x2, 0x2, 0x2, 0x7de, 
       0x7e1, 0x3, 0x2, 0x2, 0x2, 0x7df, 0x7dd, 0x3, 0x2, 0x2, 0x2, 0x7df, 
       0x7e0, 0x3, 0x2, 0x2, 0x2, 0x7e0, 0x7e3, 0x3, 0x2, 0x2, 0x2, 0x7e1, 
       0x7df, 0x3, 0x2, 0x2, 0x2, 0x7e2, 0x7c4, 0x3, 0x2, 0x2, 0x2, 0x7e2, 
       0x7db, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0xdd, 0x3, 0x2, 0x2, 0x2, 0x7e4, 
       0x7e6, 0x7, 0x7b, 0x2, 0x2, 0x7e5, 0x7e4, 0x3, 0x2, 0x2, 0x2, 0x7e5, 
       0x7e6, 0x3, 0x2, 0x2, 0x2, 0x7e6, 0x7e7, 0x3, 0x2, 0x2, 0x2, 0x7e7, 
       0x7ea, 0x5, 0x480, 0x241, 0x2, 0x7e8, 0x7eb, 0x5, 0x1c, 0xf, 0x2, 
       0x7e9, 0x7eb, 0x5, 0x56, 0x2c, 0x2, 0x7ea, 0x7e8, 0x3, 0x2, 0x2, 
       0x2, 0x7ea, 0x7e9, 0x3, 0x2, 0x2, 0x2, 0x7eb, 0x7ef, 0x3, 0x2, 0x2, 
       0x2, 0x7ec, 0x7ee, 0x5, 0x1e, 0x10, 0x2, 0x7ed, 0x7ec, 0x3, 0x2, 
       0x2, 0x2, 0x7ee, 0x7f1, 0x3, 0x2, 0x2, 0x2, 0x7ef, 0x7ed, 0x3, 0x2, 
       0x2, 0x2, 0x7ef, 0x7f0, 0x3, 0x2, 0x2, 0x2, 0x7f0, 0x7f2, 0x3, 0x2, 
       0x2, 0x2, 0x7f1, 0x7ef, 0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7f3, 0x7, 0x1d4, 
       0x2, 0x2, 0x7f3, 0xdf, 0x3, 0x2, 0x2, 0x2, 0x7f4, 0x7f5, 0x7, 0x7e, 
       0x2, 0x2, 0x7f5, 0xe1, 0x3, 0x2, 0x2, 0x2, 0x7f6, 0x7f7, 0x7, 0x81, 
       0x2, 0x2, 0x7f7, 0x7fe, 0x5, 0x480, 0x241, 0x2, 0x7f8, 0x7ff, 0x5, 
       0x32, 0x1a, 0x2, 0x7f9, 0x7ff, 0x5, 0x47e, 0x240, 0x2, 0x7fa, 0x7ff, 
       0x7, 0x112, 0x2, 0x2, 0x7fb, 0x7ff, 0x7, 0x114, 0x2, 0x2, 0x7fc, 
       0x7ff, 0x7, 0x121, 0x2, 0x2, 0x7fd, 0x7ff, 0x7, 0xe3, 0x2, 0x2, 0x7fe, 
       0x7f8, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7f9, 0x3, 0x2, 0x2, 0x2, 0x7fe, 
       0x7fa, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7fb, 0x3, 0x2, 0x2, 0x2, 0x7fe, 
       0x7fc, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7fe, 
       0x7ff, 0x3, 0x2, 0x2, 0x2, 0x7ff, 0x800, 0x3, 0x2, 0x2, 0x2, 0x800, 
       0x801, 0x7, 0x1d4, 0x2, 0x2, 0x801, 0x818, 0x3, 0x2, 0x2, 0x2, 0x802, 
       0x803, 0x7, 0x8, 0x2, 0x2, 0x803, 0x804, 0x5, 0x12e, 0x98, 0x2, 0x804, 
       0x805, 0x7, 0x266, 0x2, 0x2, 0x805, 0x806, 0x7, 0x267, 0x2, 0x2, 
       0x806, 0x807, 0x7, 0x268, 0x2, 0x2, 0x807, 0x808, 0x7, 0x26f, 0x2, 
       0x2, 0x808, 0x809, 0x7, 0x270, 0x2, 0x2, 0x809, 0x80a, 0x7, 0x271, 
       0x2, 0x2, 0x80a, 0x80b, 0x7, 0x272, 0x2, 0x2, 0x80b, 0x813, 0x7, 
       0x273, 0x2, 0x2, 0x80c, 0x814, 0x5, 0x32, 0x1a, 0x2, 0x80d, 0x814, 
       0x5, 0x47e, 0x240, 0x2, 0x80e, 0x814, 0x5, 0x20, 0x11, 0x2, 0x80f, 
       0x814, 0x7, 0x112, 0x2, 0x2, 0x810, 0x814, 0x7, 0x114, 0x2, 0x2, 
       0x811, 0x814, 0x7, 0x121, 0x2, 0x2, 0x812, 0x814, 0x7, 0xe3, 0x2, 
       0x2, 0x813, 0x80c, 0x3, 0x2, 0x2, 0x2, 0x813, 0x80d, 0x3, 0x2, 0x2, 
       0x2, 0x813, 0x80e, 0x3, 0x2, 0x2, 0x2, 0x813, 0x80f, 0x3, 0x2, 0x2, 
       0x2, 0x813, 0x810, 0x3, 0x2, 0x2, 0x2, 0x813, 0x811, 0x3, 0x2, 0x2, 
       0x2, 0x813, 0x812, 0x3, 0x2, 0x2, 0x2, 0x813, 0x814, 0x3, 0x2, 0x2, 
       0x2, 0x814, 0x815, 0x3, 0x2, 0x2, 0x2, 0x815, 0x816, 0x9, 0x2, 0x2, 
       0x2, 0x816, 0x818, 0x3, 0x2, 0x2, 0x2, 0x817, 0x7f6, 0x3, 0x2, 0x2, 
       0x2, 0x817, 0x802, 0x3, 0x2, 0x2, 0x2, 0x818, 0xe3, 0x3, 0x2, 0x2, 
       0x2, 0x819, 0x81e, 0x7, 0x83, 0x2, 0x2, 0x81a, 0x81d, 0x5, 0x480, 
       0x241, 0x2, 0x81b, 0x81d, 0x5, 0x46e, 0x238, 0x2, 0x81c, 0x81a, 0x3, 
       0x2, 0x2, 0x2, 0x81c, 0x81b, 0x3, 0x2, 0x2, 0x2, 0x81d, 0x820, 0x3, 
       0x2, 0x2, 0x2, 0x81e, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x81e, 0x81f, 0x3, 
       0x2, 0x2, 0x2, 0x81f, 0x821, 0x3, 0x2, 0x2, 0x2, 0x820, 0x81e, 0x3, 
       0x2, 0x2, 0x2, 0x821, 0x822, 0x7, 0x1d4, 0x2, 0x2, 0x822, 0xe5, 0x3, 
       0x2, 0x2, 0x2, 0x823, 0x824, 0x9, 0x7, 0x2, 0x2, 0x824, 0xe7, 0x3, 
       0x2, 0x2, 0x2, 0x825, 0x82b, 0x5, 0x118, 0x8d, 0x2, 0x826, 0x82b, 
       0x5, 0x11a, 0x8e, 0x2, 0x827, 0x82b, 0x5, 0x10c, 0x87, 0x2, 0x828, 
       0x82b, 0x5, 0x10e, 0x88, 0x2, 0x829, 0x82b, 0x5, 0x110, 0x89, 0x2, 
       0x82a, 0x825, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x826, 0x3, 0x2, 0x2, 0x2, 
       0x82a, 0x827, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x828, 0x3, 0x2, 0x2, 0x2, 
       0x82a, 0x829, 0x3, 0x2, 0x2, 0x2, 0x82b, 0x82f, 0x3, 0x2, 0x2, 0x2, 
       0x82c, 0x82e, 0x5, 0x4, 0x3, 0x2, 0x82d, 0x82c, 0x3, 0x2, 0x2, 0x2, 
       0x82e, 0x831, 0x3, 0x2, 0x2, 0x2, 0x82f, 0x82d, 0x3, 0x2, 0x2, 0x2, 
       0x82f, 0x830, 0x3, 0x2, 0x2, 0x2, 0x830, 0x832, 0x3, 0x2, 0x2, 0x2, 
       0x831, 0x82f, 0x3, 0x2, 0x2, 0x2, 0x832, 0x833, 0x5, 0x128, 0x95, 
       0x2, 0x833, 0x83a, 0x3, 0x2, 0x2, 0x2, 0x834, 0x83a, 0x5, 0xea, 0x76, 
       0x2, 0x835, 0x83a, 0x5, 0xfc, 0x7f, 0x2, 0x836, 0x83a, 0x5, 0x122, 
       0x92, 0x2, 0x837, 0x83a, 0x5, 0xf4, 0x7b, 0x2, 0x838, 0x83a, 0x5, 
       0xf0, 0x79, 0x2, 0x839, 0x82a, 0x3, 0x2, 0x2, 0x2, 0x839, 0x834, 
       0x3, 0x2, 0x2, 0x2, 0x839, 0x835, 0x3, 0x2, 0x2, 0x2, 0x839, 0x836, 
       0x3, 0x2, 0x2, 0x2, 0x839, 0x837, 0x3, 0x2, 0x2, 0x2, 0x839, 0x838, 
       0x3, 0x2, 0x2, 0x2, 0x83a, 0xe9, 0x3, 0x2, 0x2, 0x2, 0x83b, 0x83f, 
       0x5, 0x10a, 0x86, 0x2, 0x83c, 0x83e, 0x5, 0x4, 0x3, 0x2, 0x83d, 0x83c, 
       0x3, 0x2, 0x2, 0x2, 0x83e, 0x841, 0x3, 0x2, 0x2, 0x2, 0x83f, 0x83d, 
       0x3, 0x2, 0x2, 0x2, 0x83f, 0x840, 0x3, 0x2, 0x2, 0x2, 0x840, 0x845, 
       0x3, 0x2, 0x2, 0x2, 0x841, 0x83f, 0x3, 0x2, 0x2, 0x2, 0x842, 0x844, 
       0x5, 0xec, 0x77, 0x2, 0x843, 0x842, 0x3, 0x2, 0x2, 0x2, 0x844, 0x847, 
       0x3, 0x2, 0x2, 0x2, 0x845, 0x843, 0x3, 0x2, 0x2, 0x2, 0x845, 0x846, 
       0x3, 0x2, 0x2, 0x2, 0x846, 0x849, 0x3, 0x2, 0x2, 0x2, 0x847, 0x845, 
       0x3, 0x2, 0x2, 0x2, 0x848, 0x84a, 0x5, 0xee, 0x78, 0x2, 0x849, 0x848, 
       0x3, 0x2, 0x2, 0x2, 0x849, 0x84a, 0x3, 0x2, 0x2, 0x2, 0x84a, 0x84b, 
       0x3, 0x2, 0x2, 0x2, 0x84b, 0x84c, 0x5, 0x126, 0x94, 0x2, 0x84c, 0xeb, 
       0x3, 0x2, 0x2, 0x2, 0x84d, 0x851, 0x5, 0x112, 0x8a, 0x2, 0x84e, 0x850, 
       0x5, 0x4, 0x3, 0x2, 0x84f, 0x84e, 0x3, 0x2, 0x2, 0x2, 0x850, 0x853, 
       0x3, 0x2, 0x2, 0x2, 0x851, 0x84f, 0x3, 0x2, 0x2, 0x2, 0x851, 0x852, 
       0x3, 0x2, 0x2, 0x2, 0x852, 0xed, 0x3, 0x2, 0x2, 0x2, 0x853, 0x851, 
       0x3, 0x2, 0x2, 0x2, 0x854, 0x858, 0x5, 0x114, 0x8b, 0x2, 0x855, 0x857, 
       0x5, 0x4, 0x3, 0x2, 0x856, 0x855, 0x3, 0x2, 0x2, 0x2, 0x857, 0x85a, 
       0x3, 0x2, 0x2, 0x2, 0x858, 0x856, 0x3, 0x2, 0x2, 0x2, 0x858, 0x859, 
       0x3, 0x2, 0x2, 0x2, 0x859, 0xef, 0x3, 0x2, 0x2, 0x2, 0x85a, 0x858, 
       0x3, 0x2, 0x2, 0x2, 0x85b, 0x85f, 0x7, 0xb, 0x2, 0x2, 0x85c, 0x85e, 
       0x5, 0x14e, 0xa8, 0x2, 0x85d, 0x85c, 0x3, 0x2, 0x2, 0x2, 0x85e, 0x861, 
       0x3, 0x2, 0x2, 0x2, 0x85f, 0x85d, 0x3, 0x2, 0x2, 0x2, 0x85f, 0x860, 
       0x3, 0x2, 0x2, 0x2, 0x860, 0x862, 0x3, 0x2, 0x2, 0x2, 0x861, 0x85f, 
       0x3, 0x2, 0x2, 0x2, 0x862, 0x863, 0x5, 0x17e, 0xc0, 0x2, 0x863, 0x864, 
       0x5, 0x17c, 0xbf, 0x2, 0x864, 0x865, 0x5, 0x180, 0xc1, 0x2, 0x865, 
       0x866, 0x5, 0x2d4, 0x16b, 0x2, 0x866, 0x86e, 0x3, 0x2, 0x2, 0x2, 
       0x867, 0x86f, 0x5, 0x1b6, 0xdc, 0x2, 0x868, 0x86f, 0x5, 0x1b8, 0xdd, 
       0x2, 0x869, 0x86f, 0x5, 0x1ba, 0xde, 0x2, 0x86a, 0x86f, 0x5, 0x1bc, 
       0xdf, 0x2, 0x86b, 0x86f, 0x5, 0x1be, 0xe0, 0x2, 0x86c, 0x86f, 0x5, 
       0x1c0, 0xe1, 0x2, 0x86d, 0x86f, 0x5, 0x1c2, 0xe2, 0x2, 0x86e, 0x867, 
       0x3, 0x2, 0x2, 0x2, 0x86e, 0x868, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x869, 
       0x3, 0x2, 0x2, 0x2, 0x86e, 0x86a, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x86b, 
       0x3, 0x2, 0x2, 0x2, 0x86e, 0x86c, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x86d, 
       0x3, 0x2, 0x2, 0x2, 0x86f, 0x871, 0x3, 0x2, 0x2, 0x2, 0x870, 0x85b, 
       0x3, 0x2, 0x2, 0x2, 0x871, 0x872, 0x3, 0x2, 0x2, 0x2, 0x872, 0x870, 
       0x3, 0x2, 0x2, 0x2, 0x872, 0x873, 0x3, 0x2, 0x2, 0x2, 0x873, 0x874, 
       0x3, 0x2, 0x2, 0x2, 0x874, 0x875, 0x5, 0xf2, 0x7a, 0x2, 0x875, 0xf1, 
       0x3, 0x2, 0x2, 0x2, 0x876, 0x87a, 0x7, 0xb, 0x2, 0x2, 0x877, 0x879, 
       0x5, 0x14e, 0xa8, 0x2, 0x878, 0x877, 0x3, 0x2, 0x2, 0x2, 0x879, 0x87c, 
       0x3, 0x2, 0x2, 0x2, 0x87a, 0x878, 0x3, 0x2, 0x2, 0x2, 0x87a, 0x87b, 
       0x3, 0x2, 0x2, 0x2, 0x87b, 0x87d, 0x3, 0x2, 0x2, 0x2, 0x87c, 0x87a, 
       0x3, 0x2, 0x2, 0x2, 0x87d, 0x87e, 0x5, 0x17e, 0xc0, 0x2, 0x87e, 0x87f, 
       0x5, 0x17c, 0xbf, 0x2, 0x87f, 0x880, 0x5, 0x180, 0xc1, 0x2, 0x880, 
       0x883, 0x5, 0x2d4, 0x16b, 0x2, 0x881, 0x884, 0x5, 0x202, 0x102, 0x2, 
       0x882, 0x884, 0x5, 0x204, 0x103, 0x2, 0x883, 0x881, 0x3, 0x2, 0x2, 
       0x2, 0x883, 0x882, 0x3, 0x2, 0x2, 0x2, 0x884, 0xf3, 0x3, 0x2, 0x2, 
       0x2, 0x885, 0x889, 0x5, 0xf6, 0x7c, 0x2, 0x886, 0x888, 0x5, 0x4, 
       0x3, 0x2, 0x887, 0x886, 0x3, 0x2, 0x2, 0x2, 0x888, 0x88b, 0x3, 0x2, 
       0x2, 0x2, 0x889, 0x887, 0x3, 0x2, 0x2, 0x2, 0x889, 0x88a, 0x3, 0x2, 
       0x2, 0x2, 0x88a, 0x88f, 0x3, 0x2, 0x2, 0x2, 0x88b, 0x889, 0x3, 0x2, 
       0x2, 0x2, 0x88c, 0x88e, 0x5, 0xfa, 0x7e, 0x2, 0x88d, 0x88c, 0x3, 
       0x2, 0x2, 0x2, 0x88e, 0x891, 0x3, 0x2, 0x2, 0x2, 0x88f, 0x88d, 0x3, 
       0x2, 0x2, 0x2, 0x88f, 0x890, 0x3, 0x2, 0x2, 0x2, 0x890, 0x892, 0x3, 
       0x2, 0x2, 0x2, 0x891, 0x88f, 0x3, 0x2, 0x2, 0x2, 0x892, 0x893, 0x5, 
       0xf8, 0x7d, 0x2, 0x893, 0xf5, 0x3, 0x2, 0x2, 0x2, 0x894, 0x895, 0x5, 
       0x366, 0x1b4, 0x2, 0x895, 0x896, 0x7, 0x1d4, 0x2, 0x2, 0x896, 0x8a5, 
       0x3, 0x2, 0x2, 0x2, 0x897, 0x89b, 0x7, 0xb, 0x2, 0x2, 0x898, 0x89a, 
       0x5, 0x14e, 0xa8, 0x2, 0x899, 0x898, 0x3, 0x2, 0x2, 0x2, 0x89a, 0x89d, 
       0x3, 0x2, 0x2, 0x2, 0x89b, 0x899, 0x3, 0x2, 0x2, 0x2, 0x89b, 0x89c, 
       0x3, 0x2, 0x2, 0x2, 0x89c, 0x89e, 0x3, 0x2, 0x2, 0x2, 0x89d, 0x89b, 
       0x3, 0x2, 0x2, 0x2, 0x89e, 0x89f, 0x5, 0x17e, 0xc0, 0x2, 0x89f, 0x8a0, 
       0x5, 0x17c, 0xbf, 0x2, 0x8a0, 0x8a1, 0x5, 0x180, 0xc1, 0x2, 0x8a1, 
       0x8a2, 0x5, 0x2d4, 0x16b, 0x2, 0x8a2, 0x8a3, 0x5, 0x24e, 0x128, 0x2, 
       0x8a3, 0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a4, 0x894, 0x3, 0x2, 0x2, 0x2, 
       0x8a4, 0x897, 0x3, 0x2, 0x2, 0x2, 0x8a5, 0xf7, 0x3, 0x2, 0x2, 0x2, 
       0x8a6, 0x8a7, 0x5, 0x346, 0x1a4, 0x2, 0x8a7, 0x8a8, 0x7, 0x1d4, 0x2, 
       0x2, 0x8a8, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8a9, 0x8ad, 0x7, 0xb, 0x2, 
       0x2, 0x8aa, 0x8ac, 0x5, 0x14e, 0xa8, 0x2, 0x8ab, 0x8aa, 0x3, 0x2, 
       0x2, 0x2, 0x8ac, 0x8af, 0x3, 0x2, 0x2, 0x2, 0x8ad, 0x8ab, 0x3, 0x2, 
       0x2, 0x2, 0x8ad, 0x8ae, 0x3, 0x2, 0x2, 0x2, 0x8ae, 0x8b0, 0x3, 0x2, 
       0x2, 0x2, 0x8af, 0x8ad, 0x3, 0x2, 0x2, 0x2, 0x8b0, 0x8b1, 0x5, 0x17e, 
       0xc0, 0x2, 0x8b1, 0x8b2, 0x5, 0x17c, 0xbf, 0x2, 0x8b2, 0x8b3, 0x5, 
       0x180, 0xc1, 0x2, 0x8b3, 0x8b4, 0x5, 0x2d4, 0x16b, 0x2, 0x8b4, 0x8b5, 
       0x5, 0x20c, 0x107, 0x2, 0x8b5, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8b6, 
       0x8a6, 0x3, 0x2, 0x2, 0x2, 0x8b6, 0x8a9, 0x3, 0x2, 0x2, 0x2, 0x8b7, 
       0xf9, 0x3, 0x2, 0x2, 0x2, 0x8b8, 0x8b9, 0x5, 0x36a, 0x1b6, 0x2, 0x8b9, 
       0x8ba, 0x7, 0x1d4, 0x2, 0x2, 0x8ba, 0x8c9, 0x3, 0x2, 0x2, 0x2, 0x8bb, 
       0x8bf, 0x7, 0xb, 0x2, 0x2, 0x8bc, 0x8be, 0x5, 0x14e, 0xa8, 0x2, 0x8bd, 
       0x8bc, 0x3, 0x2, 0x2, 0x2, 0x8be, 0x8c1, 0x3, 0x2, 0x2, 0x2, 0x8bf, 
       0x8bd, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c0, 0x3, 0x2, 0x2, 0x2, 0x8c0, 
       0x8c2, 0x3, 0x2, 0x2, 0x2, 0x8c1, 0x8bf, 0x3, 0x2, 0x2, 0x2, 0x8c2, 
       0x8c3, 0x5, 0x17e, 0xc0, 0x2, 0x8c3, 0x8c4, 0x5, 0x17c, 0xbf, 0x2, 
       0x8c4, 0x8c5, 0x5, 0x180, 0xc1, 0x2, 0x8c5, 0x8c6, 0x5, 0x2d4, 0x16b, 
       0x2, 0x8c6, 0x8c7, 0x5, 0x25e, 0x130, 0x2, 0x8c7, 0x8c9, 0x3, 0x2, 
       0x2, 0x2, 0x8c8, 0x8b8, 0x3, 0x2, 0x2, 0x2, 0x8c8, 0x8bb, 0x3, 0x2, 
       0x2, 0x2, 0x8c9, 0x8cd, 0x3, 0x2, 0x2, 0x2, 0x8ca, 0x8cc, 0x5, 0x4, 
       0x3, 0x2, 0x8cb, 0x8ca, 0x3, 0x2, 0x2, 0x2, 0x8cc, 0x8cf, 0x3, 0x2, 
       0x2, 0x2, 0x8cd, 0x8cb, 0x3, 0x2, 0x2, 0x2, 0x8cd, 0x8ce, 0x3, 0x2, 
       0x2, 0x2, 0x8ce, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x8cf, 0x8cd, 0x3, 0x2, 
       0x2, 0x2, 0x8d0, 0x8d4, 0x5, 0x100, 0x81, 0x2, 0x8d1, 0x8d3, 0x5, 
       0x102, 0x82, 0x2, 0x8d2, 0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8d3, 0x8d6, 
       0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d2, 0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d5, 
       0x3, 0x2, 0x2, 0x2, 0x8d5, 0x8d8, 0x3, 0x2, 0x2, 0x2, 0x8d6, 0x8d4, 
       0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d9, 0x5, 0xfe, 0x80, 0x2, 0x8d8, 0x8d7, 
       0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d9, 0x3, 0x2, 0x2, 0x2, 0x8d9, 0x8da, 
       0x3, 0x2, 0x2, 0x2, 0x8da, 0x8db, 0x5, 0x108, 0x85, 0x2, 0x8db, 0xfd, 
       0x3, 0x2, 0x2, 0x2, 0x8dc, 0x8e0, 0x7, 0xb, 0x2, 0x2, 0x8dd, 0x8df, 
       0x5, 0x14e, 0xa8, 0x2, 0x8de, 0x8dd, 0x3, 0x2, 0x2, 0x2, 0x8df, 0x8e2, 
       0x3, 0x2, 0x2, 0x2, 0x8e0, 0x8de, 0x3, 0x2, 0x2, 0x2, 0x8e0, 0x8e1, 
       0x3, 0x2, 0x2, 0x2, 0x8e1, 0x8e3, 0x3, 0x2, 0x2, 0x2, 0x8e2, 0x8e0, 
       0x3, 0x2, 0x2, 0x2, 0x8e3, 0x8e4, 0x5, 0x17e, 0xc0, 0x2, 0x8e4, 0x8e5, 
       0x5, 0x17c, 0xbf, 0x2, 0x8e5, 0x8e6, 0x5, 0x180, 0xc1, 0x2, 0x8e6, 
       0x8e7, 0x5, 0x2d4, 0x16b, 0x2, 0x8e7, 0x8e8, 0x5, 0x270, 0x139, 0x2, 
       0x8e8, 0x8ef, 0x3, 0x2, 0x2, 0x2, 0x8e9, 0x8ea, 0x5, 0x36e, 0x1b8, 
       0x2, 0x8ea, 0x8ec, 0x7, 0x1d4, 0x2, 0x2, 0x8eb, 0x8ed, 0x5, 0x14, 
       0xb, 0x2, 0x8ec, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8ec, 0x8ed, 0x3, 0x2, 
       0x2, 0x2, 0x8ed, 0x8ef, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8dc, 0x3, 0x2, 
       0x2, 0x2, 0x8ee, 0x8e9, 0x3, 0x2, 0x2, 0x2, 0x8ef, 0xff, 0x3, 0x2, 
       0x2, 0x2, 0x8f0, 0x8f4, 0x7, 0xb, 0x2, 0x2, 0x8f1, 0x8f3, 0x5, 0x14e, 
       0xa8, 0x2, 0x8f2, 0x8f1, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8f6, 0x3, 0x2, 
       0x2, 0x2, 0x8f4, 0x8f2, 0x3, 0x2, 0x2, 0x2, 0x8f4, 0x8f5, 0x3, 0x2, 
       0x2, 0x2, 0x8f5, 0x8f7, 0x3, 0x2, 0x2, 0x2, 0x8f6, 0x8f4, 0x3, 0x2, 
       0x2, 0x2, 0x8f7, 0x8f8, 0x5, 0x17e, 0xc0, 0x2, 0x8f8, 0x8f9, 0x5, 
       0x17c, 0xbf, 0x2, 0x8f9, 0x8fa, 0x5, 0x180, 0xc1, 0x2, 0x8fa, 0x8fb, 
       0x5, 0x2d4, 0x16b, 0x2, 0x8fb, 0x8fc, 0x5, 0x290, 0x149, 0x2, 0x8fc, 
       0x903, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8fe, 0x5, 0x388, 0x1c5, 0x2, 
       0x8fe, 0x900, 0x7, 0x1d4, 0x2, 0x2, 0x8ff, 0x901, 0x5, 0x14, 0xb, 
       0x2, 0x900, 0x8ff, 0x3, 0x2, 0x2, 0x2, 0x900, 0x901, 0x3, 0x2, 0x2, 
       0x2, 0x901, 0x903, 0x3, 0x2, 0x2, 0x2, 0x902, 0x8f0, 0x3, 0x2, 0x2, 
       0x2, 0x902, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x903, 0x101, 0x3, 0x2, 0x2, 
       0x2, 0x904, 0x907, 0x5, 0x106, 0x84, 0x2, 0x905, 0x907, 0x5, 0x104, 
       0x83, 0x2, 0x906, 0x904, 0x3, 0x2, 0x2, 0x2, 0x906, 0x905, 0x3, 0x2, 
       0x2, 0x2, 0x907, 0x90b, 0x3, 0x2, 0x2, 0x2, 0x908, 0x90a, 0x5, 0x4, 
       0x3, 0x2, 0x909, 0x908, 0x3, 0x2, 0x2, 0x2, 0x90a, 0x90d, 0x3, 0x2, 
       0x2, 0x2, 0x90b, 0x909, 0x3, 0x2, 0x2, 0x2, 0x90b, 0x90c, 0x3, 0x2, 
       0x2, 0x2, 0x90c, 0x103, 0x3, 0x2, 0x2, 0x2, 0x90d, 0x90b, 0x3, 0x2, 
       0x2, 0x2, 0x90e, 0x912, 0x7, 0xb, 0x2, 0x2, 0x90f, 0x911, 0x5, 0x14e, 
       0xa8, 0x2, 0x910, 0x90f, 0x3, 0x2, 0x2, 0x2, 0x911, 0x914, 0x3, 0x2, 
       0x2, 0x2, 0x912, 0x910, 0x3, 0x2, 0x2, 0x2, 0x912, 0x913, 0x3, 0x2, 
       0x2, 0x2, 0x913, 0x915, 0x3, 0x2, 0x2, 0x2, 0x914, 0x912, 0x3, 0x2, 
       0x2, 0x2, 0x915, 0x916, 0x5, 0x17e, 0xc0, 0x2, 0x916, 0x917, 0x5, 
       0x17c, 0xbf, 0x2, 0x917, 0x918, 0x5, 0x180, 0xc1, 0x2, 0x918, 0x919, 
       0x5, 0x2d4, 0x16b, 0x2, 0x919, 0x91a, 0x5, 0x2b6, 0x15c, 0x2, 0x91a, 
       0x927, 0x3, 0x2, 0x2, 0x2, 0x91b, 0x91c, 0x5, 0x396, 0x1cc, 0x2, 
       0x91c, 0x91e, 0x7, 0x1d4, 0x2, 0x2, 0x91d, 0x91f, 0x5, 0x14, 0xb, 
       0x2, 0x91e, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91e, 0x91f, 0x3, 0x2, 0x2, 
       0x2, 0x91f, 0x923, 0x3, 0x2, 0x2, 0x2, 0x920, 0x922, 0x5, 0x4, 0x3, 
       0x2, 0x921, 0x920, 0x3, 0x2, 0x2, 0x2, 0x922, 0x925, 0x3, 0x2, 0x2, 
       0x2, 0x923, 0x921, 0x3, 0x2, 0x2, 0x2, 0x923, 0x924, 0x3, 0x2, 0x2, 
       0x2, 0x924, 0x927, 0x3, 0x2, 0x2, 0x2, 0x925, 0x923, 0x3, 0x2, 0x2, 
       0x2, 0x926, 0x90e, 0x3, 0x2, 0x2, 0x2, 0x926, 0x91b, 0x3, 0x2, 0x2, 
       0x2, 0x927, 0x105, 0x3, 0x2, 0x2, 0x2, 0x928, 0x92c, 0x7, 0xb, 0x2, 
       0x2, 0x929, 0x92b, 0x5, 0x14e, 0xa8, 0x2, 0x92a, 0x929, 0x3, 0x2, 
       0x2, 0x2, 0x92b, 0x92e, 0x3, 0x2, 0x2, 0x2, 0x92c, 0x92a, 0x3, 0x2, 
       0x2, 0x2, 0x92c, 0x92d, 0x3, 0x2, 0x2, 0x2, 0x92d, 0x92f, 0x3, 0x2, 
       0x2, 0x2, 0x92e, 0x92c, 0x3, 0x2, 0x2, 0x2, 0x92f, 0x930, 0x5, 0x17e, 
       0xc0, 0x2, 0x930, 0x931, 0x5, 0x17c, 0xbf, 0x2, 0x931, 0x932, 0x5, 
       0x180, 0xc1, 0x2, 0x932, 0x939, 0x5, 0x2d4, 0x16b, 0x2, 0x933, 0x93a, 
       0x5, 0x2b8, 0x15d, 0x2, 0x934, 0x93a, 0x5, 0x2ba, 0x15e, 0x2, 0x935, 
       0x93a, 0x5, 0x2bc, 0x15f, 0x2, 0x936, 0x93a, 0x5, 0x2be, 0x160, 0x2, 
       0x937, 0x93a, 0x5, 0x2c0, 0x161, 0x2, 0x938, 0x93a, 0x5, 0x2c2, 0x162, 
       0x2, 0x939, 0x933, 0x3, 0x2, 0x2, 0x2, 0x939, 0x934, 0x3, 0x2, 0x2, 
       0x2, 0x939, 0x935, 0x3, 0x2, 0x2, 0x2, 0x939, 0x936, 0x3, 0x2, 0x2, 
       0x2, 0x939, 0x937, 0x3, 0x2, 0x2, 0x2, 0x939, 0x938, 0x3, 0x2, 0x2, 
       0x2, 0x93a, 0x93e, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x93d, 0x5, 0x11e, 
       0x90, 0x2, 0x93c, 0x93b, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x940, 0x3, 0x2, 
       0x2, 0x2, 0x93e, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x93e, 0x93f, 0x3, 0x2, 
       0x2, 0x2, 0x93f, 0x944, 0x3, 0x2, 0x2, 0x2, 0x940, 0x93e, 0x3, 0x2, 
       0x2, 0x2, 0x941, 0x943, 0x5, 0x120, 0x91, 0x2, 0x942, 0x941, 0x3, 
       0x2, 0x2, 0x2, 0x943, 0x946, 0x3, 0x2, 0x2, 0x2, 0x944, 0x942, 0x3, 
       0x2, 0x2, 0x2, 0x944, 0x945, 0x3, 0x2, 0x2, 0x2, 0x945, 0x107, 0x3, 
       0x2, 0x2, 0x2, 0x946, 0x944, 0x3, 0x2, 0x2, 0x2, 0x947, 0x94b, 0x7, 
       0xb, 0x2, 0x2, 0x948, 0x94a, 0x5, 0x14e, 0xa8, 0x2, 0x949, 0x948, 
       0x3, 0x2, 0x2, 0x2, 0x94a, 0x94d, 0x3, 0x2, 0x2, 0x2, 0x94b, 0x949, 
       0x3, 0x2, 0x2, 0x2, 0x94b, 0x94c, 0x3, 0x2, 0x2, 0x2, 0x94c, 0x94e, 
       0x3, 0x2, 0x2, 0x2, 0x94d, 0x94b, 0x3, 0x2, 0x2, 0x2, 0x94e, 0x94f, 
       0x5, 0x17e, 0xc0, 0x2, 0x94f, 0x950, 0x5, 0x17c, 0xbf, 0x2, 0x950, 
       0x951, 0x5, 0x180, 0xc1, 0x2, 0x951, 0x954, 0x5, 0x2d4, 0x16b, 0x2, 
       0x952, 0x955, 0x5, 0x202, 0x102, 0x2, 0x953, 0x955, 0x5, 0x20e, 0x108, 
       0x2, 0x954, 0x952, 0x3, 0x2, 0x2, 0x2, 0x954, 0x953, 0x3, 0x2, 0x2, 
       0x2, 0x955, 0x95c, 0x3, 0x2, 0x2, 0x2, 0x956, 0x957, 0x5, 0x348, 
       0x1a5, 0x2, 0x957, 0x959, 0x7, 0x1d4, 0x2, 0x2, 0x958, 0x95a, 0x5, 
       0x14, 0xb, 0x2, 0x959, 0x958, 0x3, 0x2, 0x2, 0x2, 0x959, 0x95a, 0x3, 
       0x2, 0x2, 0x2, 0x95a, 0x95c, 0x3, 0x2, 0x2, 0x2, 0x95b, 0x947, 0x3, 
       0x2, 0x2, 0x2, 0x95b, 0x956, 0x3, 0x2, 0x2, 0x2, 0x95c, 0x109, 0x3, 
       0x2, 0x2, 0x2, 0x95d, 0x976, 0x5, 0x116, 0x8c, 0x2, 0x95e, 0x962, 
       0x7, 0xb, 0x2, 0x2, 0x95f, 0x961, 0x5, 0x14e, 0xa8, 0x2, 0x960, 0x95f, 
       0x3, 0x2, 0x2, 0x2, 0x961, 0x964, 0x3, 0x2, 0x2, 0x2, 0x962, 0x960, 
       0x3, 0x2, 0x2, 0x2, 0x962, 0x963, 0x3, 0x2, 0x2, 0x2, 0x963, 0x965, 
       0x3, 0x2, 0x2, 0x2, 0x964, 0x962, 0x3, 0x2, 0x2, 0x2, 0x965, 0x966, 
       0x5, 0x17e, 0xc0, 0x2, 0x966, 0x967, 0x5, 0x17c, 0xbf, 0x2, 0x967, 
       0x968, 0x5, 0x180, 0xc1, 0x2, 0x968, 0x969, 0x5, 0x2d4, 0x16b, 0x2, 
       0x969, 0x96b, 0x7, 0x55, 0x2, 0x2, 0x96a, 0x96c, 0x5, 0x2d2, 0x16a, 
       0x2, 0x96b, 0x96a, 0x3, 0x2, 0x2, 0x2, 0x96b, 0x96c, 0x3, 0x2, 0x2, 
       0x2, 0x96c, 0x96d, 0x3, 0x2, 0x2, 0x2, 0x96d, 0x96e, 0x5, 0x45a, 
       0x22e, 0x2, 0x96e, 0x96f, 0x9, 0x8, 0x2, 0x2, 0x96f, 0x976, 0x3, 
       0x2, 0x2, 0x2, 0x970, 0x971, 0x5, 0x35c, 0x1af, 0x2, 0x971, 0x973, 
       0x7, 0x1d4, 0x2, 0x2, 0x972, 0x974, 0x5, 0x14, 0xb, 0x2, 0x973, 0x972, 
       0x3, 0x2, 0x2, 0x2, 0x973, 0x974, 0x3, 0x2, 0x2, 0x2, 0x974, 0x976, 
       0x3, 0x2, 0x2, 0x2, 0x975, 0x95d, 0x3, 0x2, 0x2, 0x2, 0x975, 0x95e, 
       0x3, 0x2, 0x2, 0x2, 0x975, 0x970, 0x3, 0x2, 0x2, 0x2, 0x976, 0x10b, 
       0x3, 0x2, 0x2, 0x2, 0x977, 0x97b, 0x7, 0xb, 0x2, 0x2, 0x978, 0x97a, 
       0x5, 0x14e, 0xa8, 0x2, 0x979, 0x978, 0x3, 0x2, 0x2, 0x2, 0x97a, 0x97d, 
       0x3, 0x2, 0x2, 0x2, 0x97b, 0x979, 0x3, 0x2, 0x2, 0x2, 0x97b, 0x97c, 
       0x3, 0x2, 0x2, 0x2, 0x97c, 0x97e, 0x3, 0x2, 0x2, 0x2, 0x97d, 0x97b, 
       0x3, 0x2, 0x2, 0x2, 0x97e, 0x97f, 0x5, 0x17e, 0xc0, 0x2, 0x97f, 0x980, 
       0x5, 0x17c, 0xbf, 0x2, 0x980, 0x981, 0x5, 0x180, 0xc1, 0x2, 0x981, 
       0x982, 0x5, 0x2d4, 0x16b, 0x2, 0x982, 0x983, 0x5, 0x1de, 0xf0, 0x2, 
       0x983, 0x98a, 0x3, 0x2, 0x2, 0x2, 0x984, 0x985, 0x5, 0x334, 0x19b, 
       0x2, 0x985, 0x987, 0x7, 0x1d4, 0x2, 0x2, 0x986, 0x988, 0x5, 0x14, 
       0xb, 0x2, 0x987, 0x986, 0x3, 0x2, 0x2, 0x2, 0x987, 0x988, 0x3, 0x2, 
       0x2, 0x2, 0x988, 0x98a, 0x3, 0x2, 0x2, 0x2, 0x989, 0x977, 0x3, 0x2, 
       0x2, 0x2, 0x989, 0x984, 0x3, 0x2, 0x2, 0x2, 0x98a, 0x10d, 0x3, 0x2, 
       0x2, 0x2, 0x98b, 0x98f, 0x7, 0xb, 0x2, 0x2, 0x98c, 0x98e, 0x5, 0x14e, 
       0xa8, 0x2, 0x98d, 0x98c, 0x3, 0x2, 0x2, 0x2, 0x98e, 0x991, 0x3, 0x2, 
       0x2, 0x2, 0x98f, 0x98d, 0x3, 0x2, 0x2, 0x2, 0x98f, 0x990, 0x3, 0x2, 
       0x2, 0x2, 0x990, 0x992, 0x3, 0x2, 0x2, 0x2, 0x991, 0x98f, 0x3, 0x2, 
       0x2, 0x2, 0x992, 0x993, 0x5, 0x17e, 0xc0, 0x2, 0x993, 0x994, 0x5, 
       0x17c, 0xbf, 0x2, 0x994, 0x995, 0x5, 0x180, 0xc1, 0x2, 0x995, 0x996, 
       0x5, 0x2d4, 0x16b, 0x2, 0x996, 0x997, 0x5, 0x1ec, 0xf7, 0x2, 0x997, 
       0x99e, 0x3, 0x2, 0x2, 0x2, 0x998, 0x999, 0x5, 0x336, 0x19c, 0x2, 
       0x999, 0x99b, 0x7, 0x1d4, 0x2, 0x2, 0x99a, 0x99c, 0x5, 0x14, 0xb, 
       0x2, 0x99b, 0x99a, 0x3, 0x2, 0x2, 0x2, 0x99b, 0x99c, 0x3, 0x2, 0x2, 
       0x2, 0x99c, 0x99e, 0x3, 0x2, 0x2, 0x2, 0x99d, 0x98b, 0x3, 0x2, 0x2, 
       0x2, 0x99d, 0x998, 0x3, 0x2, 0x2, 0x2, 0x99e, 0x10f, 0x3, 0x2, 0x2, 
       0x2, 0x99f, 0x9a3, 0x7, 0xb, 0x2, 0x2, 0x9a0, 0x9a2, 0x5, 0x14e, 
       0xa8, 0x2, 0x9a1, 0x9a0, 0x3, 0x2, 0x2, 0x2, 0x9a2, 0x9a5, 0x3, 0x2, 
       0x2, 0x2, 0x9a3, 0x9a1, 0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a4, 0x3, 0x2, 
       0x2, 0x2, 0x9a4, 0x9a6, 0x3, 0x2, 0x2, 0x2, 0x9a5, 0x9a3, 0x3, 0x2, 
       0x2, 0x2, 0x9a6, 0x9a7, 0x5, 0x17e, 0xc0, 0x2, 0x9a7, 0x9a8, 0x5, 
       0x17c, 0xbf, 0x2, 0x9a8, 0x9a9, 0x5, 0x180, 0xc1, 0x2, 0x9a9, 0x9aa, 
       0x5, 0x2d4, 0x16b, 0x2, 0x9aa, 0x9ab, 0x5, 0x1dc, 0xef, 0x2, 0x9ab, 
       0x9b2, 0x3, 0x2, 0x2, 0x2, 0x9ac, 0x9ad, 0x5, 0x336, 0x19c, 0x2, 
       0x9ad, 0x9af, 0x7, 0x1d4, 0x2, 0x2, 0x9ae, 0x9b0, 0x5, 0x14, 0xb, 
       0x2, 0x9af, 0x9ae, 0x3, 0x2, 0x2, 0x2, 0x9af, 0x9b0, 0x3, 0x2, 0x2, 
       0x2, 0x9b0, 0x9b2, 0x3, 0x2, 0x2, 0x2, 0x9b1, 0x99f, 0x3, 0x2, 0x2, 
       0x2, 0x9b1, 0x9ac, 0x3, 0x2, 0x2, 0x2, 0x9b2, 0x111, 0x3, 0x2, 0x2, 
       0x2, 0x9b3, 0x9b7, 0x7, 0xb, 0x2, 0x2, 0x9b4, 0x9b6, 0x5, 0x14e, 
       0xa8, 0x2, 0x9b5, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b6, 0x9b9, 0x3, 0x2, 
       0x2, 0x2, 0x9b7, 0x9b5, 0x3, 0x2, 0x2, 0x2, 0x9b7, 0x9b8, 0x3, 0x2, 
       0x2, 0x2, 0x9b8, 0x9ba, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9b7, 0x3, 0x2, 
       0x2, 0x2, 0x9ba, 0x9bb, 0x5, 0x17e, 0xc0, 0x2, 0x9bb, 0x9bc, 0x5, 
       0x17c, 0xbf, 0x2, 0x9bc, 0x9bd, 0x5, 0x180, 0xc1, 0x2, 0x9bd, 0x9be, 
       0x5, 0x2d4, 0x16b, 0x2, 0x9be, 0x9c0, 0x7, 0x45, 0x2, 0x2, 0x9bf, 
       0x9c1, 0x5, 0x2d2, 0x16a, 0x2, 0x9c0, 0x9bf, 0x3, 0x2, 0x2, 0x2, 
       0x9c0, 0x9c1, 0x3, 0x2, 0x2, 0x2, 0x9c1, 0x9c2, 0x3, 0x2, 0x2, 0x2, 
       0x9c2, 0x9c3, 0x5, 0x45a, 0x22e, 0x2, 0x9c3, 0x9c4, 0x9, 0x8, 0x2, 
       0x2, 0x9c4, 0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9c5, 0x9c6, 0x5, 0x33e, 
       0x1a0, 0x2, 0x9c6, 0x9c8, 0x7, 0x1d4, 0x2, 0x2, 0x9c7, 0x9c9, 0x5, 
       0x14, 0xb, 0x2, 0x9c8, 0x9c7, 0x3, 0x2, 0x2, 0x2, 0x9c8, 0x9c9, 0x3, 
       0x2, 0x2, 0x2, 0x9c9, 0x9cb, 0x3, 0x2, 0x2, 0x2, 0x9ca, 0x9b3, 0x3, 
       0x2, 0x2, 0x2, 0x9ca, 0x9c5, 0x3, 0x2, 0x2, 0x2, 0x9cb, 0x113, 0x3, 
       0x2, 0x2, 0x2, 0x9cc, 0x9d0, 0x7, 0xb, 0x2, 0x2, 0x9cd, 0x9cf, 0x5, 
       0x14e, 0xa8, 0x2, 0x9ce, 0x9cd, 0x3, 0x2, 0x2, 0x2, 0x9cf, 0x9d2, 
       0x3, 0x2, 0x2, 0x2, 0x9d0, 0x9ce, 0x3, 0x2, 0x2, 0x2, 0x9d0, 0x9d1, 
       0x3, 0x2, 0x2, 0x2, 0x9d1, 0x9d3, 0x3, 0x2, 0x2, 0x2, 0x9d2, 0x9d0, 
       0x3, 0x2, 0x2, 0x2, 0x9d3, 0x9d4, 0x5, 0x17e, 0xc0, 0x2, 0x9d4, 0x9d5, 
       0x5, 0x17c, 0xbf, 0x2, 0x9d5, 0x9d6, 0x5, 0x180, 0xc1, 0x2, 0x9d6, 
       0x9d7, 0x5, 0x2d4, 0x16b, 0x2, 0x9d7, 0x9d8, 0x7, 0x44, 0x2, 0x2, 
       0x9d8, 0x9d9, 0x5, 0x188, 0xc5, 0x2, 0x9d9, 0x9e0, 0x3, 0x2, 0x2, 
       0x2, 0x9da, 0x9db, 0x5, 0x33c, 0x19f, 0x2, 0x9db, 0x9dd, 0x7, 0x1d4, 
       0x2, 0x2, 0x9dc, 0x9de, 0x5, 0x14, 0xb, 0x2, 0x9dd, 0x9dc, 0x3, 0x2, 
       0x2, 0x2, 0x9dd, 0x9de, 0x3, 0x2, 0x2, 0x2, 0x9de, 0x9e0, 0x3, 0x2, 
       0x2, 0x2, 0x9df, 0x9cc, 0x3, 0x2, 0x2, 0x2, 0x9df, 0x9da, 0x3, 0x2, 
       0x2, 0x2, 0x9e0, 0x115, 0x3, 0x2, 0x2, 0x2, 0x9e1, 0x9e5, 0x7, 0xb, 
       0x2, 0x2, 0x9e2, 0x9e4, 0x5, 0x14e, 0xa8, 0x2, 0x9e3, 0x9e2, 0x3, 
       0x2, 0x2, 0x2, 0x9e4, 0x9e7, 0x3, 0x2, 0x2, 0x2, 0x9e5, 0x9e3, 0x3, 
       0x2, 0x2, 0x2, 0x9e5, 0x9e6, 0x3, 0x2, 0x2, 0x2, 0x9e6, 0x9e8, 0x3, 
       0x2, 0x2, 0x2, 0x9e7, 0x9e5, 0x3, 0x2, 0x2, 0x2, 0x9e8, 0x9e9, 0x5, 
       0x17e, 0xc0, 0x2, 0x9e9, 0x9ea, 0x5, 0x17c, 0xbf, 0x2, 0x9ea, 0x9eb, 
       0x5, 0x180, 0xc1, 0x2, 0x9eb, 0x9f2, 0x5, 0x2d4, 0x16b, 0x2, 0x9ec, 
       0x9f3, 0x5, 0x22c, 0x117, 0x2, 0x9ed, 0x9f3, 0x5, 0x22e, 0x118, 0x2, 
       0x9ee, 0x9f3, 0x5, 0x230, 0x119, 0x2, 0x9ef, 0x9f3, 0x5, 0x232, 0x11a, 
       0x2, 0x9f0, 0x9f3, 0x5, 0x234, 0x11b, 0x2, 0x9f1, 0x9f3, 0x5, 0x236, 
       0x11c, 0x2, 0x9f2, 0x9ec, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0x9ed, 0x3, 
       0x2, 0x2, 0x2, 0x9f2, 0x9ee, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0x9ef, 0x3, 
       0x2, 0x2, 0x2, 0x9f2, 0x9f0, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0x9f1, 0x3, 
       0x2, 0x2, 0x2, 0x9f3, 0x9f7, 0x3, 0x2, 0x2, 0x2, 0x9f4, 0x9f6, 0x5, 
       0x11e, 0x90, 0x2, 0x9f5, 0x9f4, 0x3, 0x2, 0x2, 0x2, 0x9f6, 0x9f9, 
       0x3, 0x2, 0x2, 0x2, 0x9f7, 0x9f5, 0x3, 0x2, 0x2, 0x2, 0x9f7, 0x9f8, 
       0x3, 0x2, 0x2, 0x2, 0x9f8, 0x9fd, 0x3, 0x2, 0x2, 0x2, 0x9f9, 0x9f7, 
       0x3, 0x2, 0x2, 0x2, 0x9fa, 0x9fc, 0x5, 0x120, 0x91, 0x2, 0x9fb, 0x9fa, 
       0x3, 0x2, 0x2, 0x2, 0x9fc, 0x9ff, 0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fb, 
       0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fe, 0x3, 0x2, 0x2, 0x2, 0x9fe, 0x117, 
       0x3, 0x2, 0x2, 0x2, 0x9ff, 0x9fd, 0x3, 0x2, 0x2, 0x2, 0xa00, 0xa04, 
       0x7, 0xb, 0x2, 0x2, 0xa01, 0xa03, 0x5, 0x14e, 0xa8, 0x2, 0xa02, 0xa01, 
       0x3, 0x2, 0x2, 0x2, 0xa03, 0xa06, 0x3, 0x2, 0x2, 0x2, 0xa04, 0xa02, 
       0x3, 0x2, 0x2, 0x2, 0xa04, 0xa05, 0x3, 0x2, 0x2, 0x2, 0xa05, 0xa07, 
       0x3, 0x2, 0x2, 0x2, 0xa06, 0xa04, 0x3, 0x2, 0x2, 0x2, 0xa07, 0xa08, 
       0x5, 0x17e, 0xc0, 0x2, 0xa08, 0xa09, 0x5, 0x17c, 0xbf, 0x2, 0xa09, 
       0xa0a, 0x5, 0x180, 0xc1, 0x2, 0xa0a, 0xa11, 0x5, 0x2d4, 0x16b, 0x2, 
       0xa0b, 0xa12, 0x5, 0x1e0, 0xf1, 0x2, 0xa0c, 0xa12, 0x5, 0x1e2, 0xf2, 
       0x2, 0xa0d, 0xa12, 0x5, 0x1e4, 0xf3, 0x2, 0xa0e, 0xa12, 0x5, 0x1e6, 
       0xf4, 0x2, 0xa0f, 0xa12, 0x5, 0x1e8, 0xf5, 0x2, 0xa10, 0xa12, 0x5, 
       0x1ea, 0xf6, 0x2, 0xa11, 0xa0b, 0x3, 0x2, 0x2, 0x2, 0xa11, 0xa0c, 
       0x3, 0x2, 0x2, 0x2, 0xa11, 0xa0d, 0x3, 0x2, 0x2, 0x2, 0xa11, 0xa0e, 
       0x3, 0x2, 0x2, 0x2, 0xa11, 0xa0f, 0x3, 0x2, 0x2, 0x2, 0xa11, 0xa10, 
       0x3, 0x2, 0x2, 0x2, 0xa12, 0xa16, 0x3, 0x2, 0x2, 0x2, 0xa13, 0xa15, 
       0x5, 0x11e, 0x90, 0x2, 0xa14, 0xa13, 0x3, 0x2, 0x2, 0x2, 0xa15, 0xa18, 
       0x3, 0x2, 0x2, 0x2, 0xa16, 0xa14, 0x3, 0x2, 0x2, 0x2, 0xa16, 0xa17, 
       0x3, 0x2, 0x2, 0x2, 0xa17, 0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa18, 0xa16, 
       0x3, 0x2, 0x2, 0x2, 0xa19, 0xa1b, 0x5, 0x120, 0x91, 0x2, 0xa1a, 0xa19, 
       0x3, 0x2, 0x2, 0x2, 0xa1b, 0xa1e, 0x3, 0x2, 0x2, 0x2, 0xa1c, 0xa1a, 
       0x3, 0x2, 0x2, 0x2, 0xa1c, 0xa1d, 0x3, 0x2, 0x2, 0x2, 0xa1d, 0x119, 
       0x3, 0x2, 0x2, 0x2, 0xa1e, 0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa1f, 0xa23, 
       0x7, 0xb, 0x2, 0x2, 0xa20, 0xa22, 0x5, 0x14e, 0xa8, 0x2, 0xa21, 0xa20, 
       0x3, 0x2, 0x2, 0x2, 0xa22, 0xa25, 0x3, 0x2, 0x2, 0x2, 0xa23, 0xa21, 
       0x3, 0x2, 0x2, 0x2, 0xa23, 0xa24, 0x3, 0x2, 0x2, 0x2, 0xa24, 0xa26, 
       0x3, 0x2, 0x2, 0x2, 0xa25, 0xa23, 0x3, 0x2, 0x2, 0x2, 0xa26, 0xa27, 
       0x5, 0x17e, 0xc0, 0x2, 0xa27, 0xa28, 0x5, 0x17c, 0xbf, 0x2, 0xa28, 
       0xa29, 0x5, 0x180, 0xc1, 0x2, 0xa29, 0xa30, 0x5, 0x2d4, 0x16b, 0x2, 
       0xa2a, 0xa31, 0x5, 0x1ee, 0xf8, 0x2, 0xa2b, 0xa31, 0x5, 0x1f0, 0xf9, 
       0x2, 0xa2c, 0xa31, 0x5, 0x1f2, 0xfa, 0x2, 0xa2d, 0xa31, 0x5, 0x1f4, 
       0xfb, 0x2, 0xa2e, 0xa31, 0x5, 0x1f6, 0xfc, 0x2, 0xa2f, 0xa31, 0x5, 
       0x1f8, 0xfd, 0x2, 0xa30, 0xa2a, 0x3, 0x2, 0x2, 0x2, 0xa30, 0xa2b, 
       0x3, 0x2, 0x2, 0x2, 0xa30, 0xa2c, 0x3, 0x2, 0x2, 0x2, 0xa30, 0xa2d, 
       0x3, 0x2, 0x2, 0x2, 0xa30, 0xa2e, 0x3, 0x2, 0x2, 0x2, 0xa30, 0xa2f, 
       0x3, 0x2, 0x2, 0x2, 0xa31, 0xa35, 0x3, 0x2, 0x2, 0x2, 0xa32, 0xa34, 
       0x5, 0x11e, 0x90, 0x2, 0xa33, 0xa32, 0x3, 0x2, 0x2, 0x2, 0xa34, 0xa37, 
       0x3, 0x2, 0x2, 0x2, 0xa35, 0xa33, 0x3, 0x2, 0x2, 0x2, 0xa35, 0xa36, 
       0x3, 0x2, 0x2, 0x2, 0xa36, 0xa3b, 0x3, 0x2, 0x2, 0x2, 0xa37, 0xa35, 
       0x3, 0x2, 0x2, 0x2, 0xa38, 0xa3a, 0x5, 0x120, 0x91, 0x2, 0xa39, 0xa38, 
       0x3, 0x2, 0x2, 0x2, 0xa3a, 0xa3d, 0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa39, 
       0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3c, 0x3, 0x2, 0x2, 0x2, 0xa3c, 0x11b, 
       0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa3b, 0x3, 0x2, 0x2, 0x2, 0xa3e, 0xa41, 
       0x5, 0x11e, 0x90, 0x2, 0xa3f, 0xa41, 0x5, 0x120, 0x91, 0x2, 0xa40, 
       0xa3e, 0x3, 0x2, 0x2, 0x2, 0xa40, 0xa3f, 0x3, 0x2, 0x2, 0x2, 0xa41, 
       0x11d, 0x3, 0x2, 0x2, 0x2, 0xa42, 0xa46, 0x7, 0xb, 0x2, 0x2, 0xa43, 
       0xa45, 0x5, 0x14e, 0xa8, 0x2, 0xa44, 0xa43, 0x3, 0x2, 0x2, 0x2, 0xa45, 
       0xa48, 0x3, 0x2, 0x2, 0x2, 0xa46, 0xa44, 0x3, 0x2, 0x2, 0x2, 0xa46, 
       0xa47, 0x3, 0x2, 0x2, 0x2, 0xa47, 0xa49, 0x3, 0x2, 0x2, 0x2, 0xa48, 
       0xa46, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa4a, 0x5, 0x17e, 0xc0, 0x2, 0xa4a, 
       0xa4b, 0x5, 0x17c, 0xbf, 0x2, 0xa4b, 0xa4c, 0x5, 0x180, 0xc1, 0x2, 
       0xa4c, 0xa53, 0x5, 0x2d4, 0x16b, 0x2, 0xa4d, 0xa54, 0x5, 0x192, 0xca, 
       0x2, 0xa4e, 0xa54, 0x5, 0x194, 0xcb, 0x2, 0xa4f, 0xa54, 0x5, 0x196, 
       0xcc, 0x2, 0xa50, 0xa54, 0x5, 0x198, 0xcd, 0x2, 0xa51, 0xa54, 0x5, 
       0x19a, 0xce, 0x2, 0xa52, 0xa54, 0x5, 0x19c, 0xcf, 0x2, 0xa53, 0xa4d, 
       0x3, 0x2, 0x2, 0x2, 0xa53, 0xa4e, 0x3, 0x2, 0x2, 0x2, 0xa53, 0xa4f, 
       0x3, 0x2, 0x2, 0x2, 0xa53, 0xa50, 0x3, 0x2, 0x2, 0x2, 0xa53, 0xa51, 
       0x3, 0x2, 0x2, 0x2, 0xa53, 0xa52, 0x3, 0x2, 0x2, 0x2, 0xa54, 0x11f, 
       0x3, 0x2, 0x2, 0x2, 0xa55, 0xa59, 0x7, 0xb, 0x2, 0x2, 0xa56, 0xa58, 
       0x5, 0x14e, 0xa8, 0x2, 0xa57, 0xa56, 0x3, 0x2, 0x2, 0x2, 0xa58, 0xa5b, 
       0x3, 0x2, 0x2, 0x2, 0xa59, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa59, 0xa5a, 
       0x3, 0x2, 0x2, 0x2, 0xa5a, 0xa5c, 0x3, 0x2, 0x2, 0x2, 0xa5b, 0xa59, 
       0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa5d, 0x5, 0x17e, 0xc0, 0x2, 0xa5d, 0xa5e, 
       0x5, 0x17c, 0xbf, 0x2, 0xa5e, 0xa5f, 0x5, 0x180, 0xc1, 0x2, 0xa5f, 
       0xa66, 0x5, 0x2d4, 0x16b, 0x2, 0xa60, 0xa67, 0x5, 0x264, 0x133, 0x2, 
       0xa61, 0xa67, 0x5, 0x266, 0x134, 0x2, 0xa62, 0xa67, 0x5, 0x268, 0x135, 
       0x2, 0xa63, 0xa67, 0x5, 0x26a, 0x136, 0x2, 0xa64, 0xa67, 0x5, 0x26c, 
       0x137, 0x2, 0xa65, 0xa67, 0x5, 0x26e, 0x138, 0x2, 0xa66, 0xa60, 0x3, 
       0x2, 0x2, 0x2, 0xa66, 0xa61, 0x3, 0x2, 0x2, 0x2, 0xa66, 0xa62, 0x3, 
       0x2, 0x2, 0x2, 0xa66, 0xa63, 0x3, 0x2, 0x2, 0x2, 0xa66, 0xa64, 0x3, 
       0x2, 0x2, 0x2, 0xa66, 0xa65, 0x3, 0x2, 0x2, 0x2, 0xa67, 0xa6b, 0x3, 
       0x2, 0x2, 0x2, 0xa68, 0xa6a, 0x5, 0x11e, 0x90, 0x2, 0xa69, 0xa68, 
       0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa6d, 0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa69, 
       0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa6c, 0x121, 
       0x3, 0x2, 0x2, 0x2, 0xa6d, 0xa6b, 0x3, 0x2, 0x2, 0x2, 0xa6e, 0xa72, 
       0x5, 0x124, 0x93, 0x2, 0xa6f, 0xa71, 0x5, 0x4, 0x3, 0x2, 0xa70, 0xa6f, 
       0x3, 0x2, 0x2, 0x2, 0xa71, 0xa74, 0x3, 0x2, 0x2, 0x2, 0xa72, 0xa70, 
       0x3, 0x2, 0x2, 0x2, 0xa72, 0xa73, 0x3, 0x2, 0x2, 0x2, 0xa73, 0xa75, 
       0x3, 0x2, 0x2, 0x2, 0xa74, 0xa72, 0x3, 0x2, 0x2, 0x2, 0xa75, 0xa76, 
       0x5, 0x12a, 0x96, 0x2, 0xa76, 0x123, 0x3, 0x2, 0x2, 0x2, 0xa77, 0xa7b, 
       0x7, 0xb, 0x2, 0x2, 0xa78, 0xa7a, 0x5, 0x14e, 0xa8, 0x2, 0xa79, 0xa78, 
       0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa7d, 0x3, 0x2, 0x2, 0x2, 0xa7b, 0xa79, 
       0x3, 0x2, 0x2, 0x2, 0xa7b, 0xa7c, 0x3, 0x2, 0x2, 0x2, 0xa7c, 0xa7e, 
       0x3, 0x2, 0x2, 0x2, 0xa7d, 0xa7b, 0x3, 0x2, 0x2, 0x2, 0xa7e, 0xa7f, 
       0x5, 0x17e, 0xc0, 0x2, 0xa7f, 0xa80, 0x5, 0x17c, 0xbf, 0x2, 0xa80, 
       0xa81, 0x5, 0x180, 0xc1, 0x2, 0xa81, 0xa82, 0x5, 0x2d4, 0x16b, 0x2, 
       0xa82, 0xa83, 0x5, 0x220, 0x111, 0x2, 0xa83, 0xa8a, 0x3, 0x2, 0x2, 
       0x2, 0xa84, 0xa85, 0x5, 0x358, 0x1ad, 0x2, 0xa85, 0xa87, 0x7, 0x1d4, 
       0x2, 0x2, 0xa86, 0xa88, 0x5, 0x14, 0xb, 0x2, 0xa87, 0xa86, 0x3, 0x2, 
       0x2, 0x2, 0xa87, 0xa88, 0x3, 0x2, 0x2, 0x2, 0xa88, 0xa8a, 0x3, 0x2, 
       0x2, 0x2, 0xa89, 0xa77, 0x3, 0x2, 0x2, 0x2, 0xa89, 0xa84, 0x3, 0x2, 
       0x2, 0x2, 0xa8a, 0x125, 0x3, 0x2, 0x2, 0x2, 0xa8b, 0xa8f, 0x7, 0xb, 
       0x2, 0x2, 0xa8c, 0xa8e, 0x5, 0x14e, 0xa8, 0x2, 0xa8d, 0xa8c, 0x3, 
       0x2, 0x2, 0x2, 0xa8e, 0xa91, 0x3, 0x2, 0x2, 0x2, 0xa8f, 0xa8d, 0x3, 
       0x2, 0x2, 0x2, 0xa8f, 0xa90, 0x3, 0x2, 0x2, 0x2, 0xa90, 0xa92, 0x3, 
       0x2, 0x2, 0x2, 0xa91, 0xa8f, 0x3, 0x2, 0x2, 0x2, 0xa92, 0xa93, 0x5, 
       0x17e, 0xc0, 0x2, 0xa93, 0xa94, 0x5, 0x17c, 0xbf, 0x2, 0xa94, 0xa95, 
       0x5, 0x180, 0xc1, 0x2, 0xa95, 0xa98, 0x5, 0x2d4, 0x16b, 0x2, 0xa96, 
       0xa99, 0x5, 0x202, 0x102, 0x2, 0xa97, 0xa99, 0x5, 0x20a, 0x106, 0x2, 
       0xa98, 0xa96, 0x3, 0x2, 0x2, 0x2, 0xa98, 0xa97, 0x3, 0x2, 0x2, 0x2, 
       0xa99, 0xaa0, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa9b, 0x5, 0x344, 0x1a3, 
       0x2, 0xa9b, 0xa9d, 0x7, 0x1d4, 0x2, 0x2, 0xa9c, 0xa9e, 0x5, 0x14, 
       0xb, 0x2, 0xa9d, 0xa9c, 0x3, 0x2, 0x2, 0x2, 0xa9d, 0xa9e, 0x3, 0x2, 
       0x2, 0x2, 0xa9e, 0xaa0, 0x3, 0x2, 0x2, 0x2, 0xa9f, 0xa8b, 0x3, 0x2, 
       0x2, 0x2, 0xa9f, 0xa9a, 0x3, 0x2, 0x2, 0x2, 0xaa0, 0x127, 0x3, 0x2, 
       0x2, 0x2, 0xaa1, 0xaa5, 0x7, 0xb, 0x2, 0x2, 0xaa2, 0xaa4, 0x5, 0x14e, 
       0xa8, 0x2, 0xaa3, 0xaa2, 0x3, 0x2, 0x2, 0x2, 0xaa4, 0xaa7, 0x3, 0x2, 
       0x2, 0x2, 0xaa5, 0xaa3, 0x3, 0x2, 0x2, 0x2, 0xaa5, 0xaa6, 0x3, 0x2, 
       0x2, 0x2, 0xaa6, 0xaa8, 0x3, 0x2, 0x2, 0x2, 0xaa7, 0xaa5, 0x3, 0x2, 
       0x2, 0x2, 0xaa8, 0xaa9, 0x5, 0x17e, 0xc0, 0x2, 0xaa9, 0xaaa, 0x5, 
       0x17c, 0xbf, 0x2, 0xaaa, 0xaab, 0x5, 0x180, 0xc1, 0x2, 0xaab, 0xaae, 
       0x5, 0x2d4, 0x16b, 0x2, 0xaac, 0xaaf, 0x5, 0x202, 0x102, 0x2, 0xaad, 
       0xaaf, 0x5, 0x206, 0x104, 0x2, 0xaae, 0xaac, 0x3, 0x2, 0x2, 0x2, 
       0xaae, 0xaad, 0x3, 0x2, 0x2, 0x2, 0xaaf, 0xab6, 0x3, 0x2, 0x2, 0x2, 
       0xab0, 0xab1, 0x5, 0x340, 0x1a1, 0x2, 0xab1, 0xab3, 0x7, 0x1d4, 0x2, 
       0x2, 0xab2, 0xab4, 0x5, 0x14, 0xb, 0x2, 0xab3, 0xab2, 0x3, 0x2, 0x2, 
       0x2, 0xab3, 0xab4, 0x3, 0x2, 0x2, 0x2, 0xab4, 0xab6, 0x3, 0x2, 0x2, 
       0x2, 0xab5, 0xaa1, 0x3, 0x2, 0x2, 0x2, 0xab5, 0xab0, 0x3, 0x2, 0x2, 
       0x2, 0xab6, 0x129, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xabb, 0x7, 0xb, 0x2, 
       0x2, 0xab8, 0xaba, 0x5, 0x14e, 0xa8, 0x2, 0xab9, 0xab8, 0x3, 0x2, 
       0x2, 0x2, 0xaba, 0xabd, 0x3, 0x2, 0x2, 0x2, 0xabb, 0xab9, 0x3, 0x2, 
       0x2, 0x2, 0xabb, 0xabc, 0x3, 0x2, 0x2, 0x2, 0xabc, 0xabe, 0x3, 0x2, 
       0x2, 0x2, 0xabd, 0xabb, 0x3, 0x2, 0x2, 0x2, 0xabe, 0xabf, 0x5, 0x17e, 
       0xc0, 0x2, 0xabf, 0xac0, 0x5, 0x17c, 0xbf, 0x2, 0xac0, 0xac1, 0x5, 
       0x180, 0xc1, 0x2, 0xac1, 0xac4, 0x5, 0x2d4, 0x16b, 0x2, 0xac2, 0xac5, 
       0x5, 0x202, 0x102, 0x2, 0xac3, 0xac5, 0x5, 0x208, 0x105, 0x2, 0xac4, 
       0xac2, 0x3, 0x2, 0x2, 0x2, 0xac4, 0xac3, 0x3, 0x2, 0x2, 0x2, 0xac5, 
       0xacc, 0x3, 0x2, 0x2, 0x2, 0xac6, 0xac7, 0x5, 0x342, 0x1a2, 0x2, 
       0xac7, 0xac9, 0x7, 0x1d4, 0x2, 0x2, 0xac8, 0xaca, 0x5, 0x14, 0xb, 
       0x2, 0xac9, 0xac8, 0x3, 0x2, 0x2, 0x2, 0xac9, 0xaca, 0x3, 0x2, 0x2, 
       0x2, 0xaca, 0xacc, 0x3, 0x2, 0x2, 0x2, 0xacb, 0xab7, 0x3, 0x2, 0x2, 
       0x2, 0xacb, 0xac6, 0x3, 0x2, 0x2, 0x2, 0xacc, 0x12b, 0x3, 0x2, 0x2, 
       0x2, 0xacd, 0xace, 0x7, 0x8, 0x2, 0x2, 0xace, 0xacf, 0x5, 0x12e, 
       0x98, 0x2, 0xacf, 0xad0, 0x7, 0x266, 0x2, 0x2, 0xad0, 0xad1, 0x7, 
       0x267, 0x2, 0x2, 0xad1, 0xad2, 0x7, 0x26e, 0x2, 0x2, 0xad2, 0xad3, 
       0x7, 0x26f, 0x2, 0x2, 0xad3, 0xad4, 0x7, 0x270, 0x2, 0x2, 0xad4, 
       0xad5, 0x7, 0x271, 0x2, 0x2, 0xad5, 0xad6, 0x7, 0x272, 0x2, 0x2, 
       0xad6, 0xada, 0x7, 0x273, 0x2, 0x2, 0xad7, 0xad9, 0x5, 0x1e, 0x10, 
       0x2, 0xad8, 0xad7, 0x3, 0x2, 0x2, 0x2, 0xad9, 0xadc, 0x3, 0x2, 0x2, 
       0x2, 0xada, 0xad8, 0x3, 0x2, 0x2, 0x2, 0xada, 0xadb, 0x3, 0x2, 0x2, 
       0x2, 0xadb, 0xadd, 0x3, 0x2, 0x2, 0x2, 0xadc, 0xada, 0x3, 0x2, 0x2, 
       0x2, 0xadd, 0xade, 0x9, 0x2, 0x2, 0x2, 0xade, 0x12d, 0x3, 0x2, 0x2, 
       0x2, 0xadf, 0xae1, 0x7, 0x263, 0x2, 0x2, 0xae0, 0xadf, 0x3, 0x2, 
       0x2, 0x2, 0xae1, 0xae4, 0x3, 0x2, 0x2, 0x2, 0xae2, 0xae0, 0x3, 0x2, 
       0x2, 0x2, 0xae2, 0xae3, 0x3, 0x2, 0x2, 0x2, 0xae3, 0xae5, 0x3, 0x2, 
       0x2, 0x2, 0xae4, 0xae2, 0x3, 0x2, 0x2, 0x2, 0xae5, 0xae6, 0x7, 0x265, 
       0x2, 0x2, 0xae6, 0x12f, 0x3, 0x2, 0x2, 0x2, 0xae7, 0xaf2, 0x7, 0xa, 
       0x2, 0x2, 0xae8, 0xae9, 0x7, 0x28d, 0x2, 0x2, 0xae9, 0xaec, 0x7, 
       0x290, 0x2, 0x2, 0xaea, 0xaed, 0x5, 0x132, 0x9a, 0x2, 0xaeb, 0xaed, 
       0x5, 0x13a, 0x9e, 0x2, 0xaec, 0xaea, 0x3, 0x2, 0x2, 0x2, 0xaec, 0xaeb, 
       0x3, 0x2, 0x2, 0x2, 0xaed, 0xaf0, 0x3, 0x2, 0x2, 0x2, 0xaee, 0xaf0, 
       0x5, 0x13c, 0x9f, 0x2, 0xaef, 0xae8, 0x3, 0x2, 0x2, 0x2, 0xaef, 0xaee, 
       0x3, 0x2, 0x2, 0x2, 0xaf0, 0xaf3, 0x3, 0x2, 0x2, 0x2, 0xaf1, 0xaf3, 
       0x5, 0x138, 0x9d, 0x2, 0xaf2, 0xaef, 0x3, 0x2, 0x2, 0x2, 0xaf2, 0xaf1, 
       0x3, 0x2, 0x2, 0x2, 0xaf3, 0xaf5, 0x3, 0x2, 0x2, 0x2, 0xaf4, 0xaf6, 
       0x7, 0x296, 0x2, 0x2, 0xaf5, 0xaf4, 0x3, 0x2, 0x2, 0x2, 0xaf5, 0xaf6, 
       0x3, 0x2, 0x2, 0x2, 0xaf6, 0xaf7, 0x3, 0x2, 0x2, 0x2, 0xaf7, 0xaf8, 
       0x9, 0x2, 0x2, 0x2, 0xaf8, 0x131, 0x3, 0x2, 0x2, 0x2, 0xaf9, 0xafa, 
       0x7, 0x292, 0x2, 0x2, 0xafa, 0xafb, 0x5, 0x134, 0x9b, 0x2, 0xafb, 
       0xafc, 0x5, 0x134, 0x9b, 0x2, 0xafc, 0xafd, 0x5, 0x134, 0x9b, 0x2, 
       0xafd, 0xafe, 0x7, 0x293, 0x2, 0x2, 0xafe, 0xaff, 0x7, 0x294, 0x2, 
       0x2, 0xaff, 0xb00, 0x7, 0x294, 0x2, 0x2, 0xb00, 0xb01, 0x7, 0x294, 
       0x2, 0x2, 0xb01, 0xb02, 0x7, 0x294, 0x2, 0x2, 0xb02, 0xb03, 0x7, 
       0x295, 0x2, 0x2, 0xb03, 0x133, 0x3, 0x2, 0x2, 0x2, 0xb04, 0xb05, 
       0x5, 0x17c, 0xbf, 0x2, 0xb05, 0xb06, 0x5, 0x136, 0x9c, 0x2, 0xb06, 
       0x135, 0x3, 0x2, 0x2, 0x2, 0xb07, 0xb08, 0x9, 0x9, 0x2, 0x2, 0xb08, 
       0x137, 0x3, 0x2, 0x2, 0x2, 0xb09, 0xb0a, 0x7, 0x28e, 0x2, 0x2, 0xb0a, 
       0xb0b, 0x5, 0x134, 0x9b, 0x2, 0xb0b, 0xb0c, 0x5, 0x134, 0x9b, 0x2, 
       0xb0c, 0xb0d, 0x5, 0x134, 0x9b, 0x2, 0xb0d, 0xb0e, 0x7, 0x293, 0x2, 
       0x2, 0xb0e, 0xb0f, 0x7, 0x294, 0x2, 0x2, 0xb0f, 0xb10, 0x7, 0x294, 
       0x2, 0x2, 0xb10, 0xb11, 0x7, 0x294, 0x2, 0x2, 0xb11, 0xb12, 0x7, 
       0x294, 0x2, 0x2, 0xb12, 0xb13, 0x7, 0x295, 0x2, 0x2, 0xb13, 0x139, 
       0x3, 0x2, 0x2, 0x2, 0xb14, 0xb15, 0x7, 0x291, 0x2, 0x2, 0xb15, 0xb16, 
       0x5, 0x134, 0x9b, 0x2, 0xb16, 0xb17, 0x5, 0x134, 0x9b, 0x2, 0xb17, 
       0xb18, 0x5, 0x134, 0x9b, 0x2, 0xb18, 0xb19, 0x7, 0x293, 0x2, 0x2, 
       0xb19, 0xb1a, 0x7, 0x295, 0x2, 0x2, 0xb1a, 0x13b, 0x3, 0x2, 0x2, 
       0x2, 0xb1b, 0xb1c, 0x7, 0x28f, 0x2, 0x2, 0xb1c, 0xb1d, 0x5, 0x134, 
       0x9b, 0x2, 0xb1d, 0xb1e, 0x5, 0x134, 0x9b, 0x2, 0xb1e, 0xb1f, 0x5, 
       0x134, 0x9b, 0x2, 0xb1f, 0xb20, 0x7, 0x298, 0x2, 0x2, 0xb20, 0xb21, 
       0x7, 0x299, 0x2, 0x2, 0xb21, 0xb22, 0x7, 0x29a, 0x2, 0x2, 0xb22, 
       0xb23, 0x7, 0x29c, 0x2, 0x2, 0xb23, 0xb25, 0x7, 0x29d, 0x2, 0x2, 
       0xb24, 0xb26, 0x5, 0x47e, 0x240, 0x2, 0xb25, 0xb24, 0x3, 0x2, 0x2, 
       0x2, 0xb25, 0xb26, 0x3, 0x2, 0x2, 0x2, 0xb26, 0x13d, 0x3, 0x2, 0x2, 
       0x2, 0xb27, 0xb29, 0x7, 0x258, 0x2, 0x2, 0xb28, 0xb27, 0x3, 0x2, 
       0x2, 0x2, 0xb29, 0xb2c, 0x3, 0x2, 0x2, 0x2, 0xb2a, 0xb28, 0x3, 0x2, 
       0x2, 0x2, 0xb2a, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb2d, 0x3, 0x2, 
       0x2, 0x2, 0xb2c, 0xb2a, 0x3, 0x2, 0x2, 0x2, 0xb2d, 0xb2e, 0x7, 0x257, 
       0x2, 0x2, 0xb2e, 0x13f, 0x3, 0x2, 0x2, 0x2, 0xb2f, 0xb30, 0x7, 0x82, 
       0x2, 0x2, 0xb30, 0xb34, 0x5, 0x142, 0xa2, 0x2, 0xb31, 0xb33, 0x5, 
       0x148, 0xa5, 0x2, 0xb32, 0xb31, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb36, 
       0x3, 0x2, 0x2, 0x2, 0xb34, 0xb32, 0x3, 0x2, 0x2, 0x2, 0xb34, 0xb35, 
       0x3, 0x2, 0x2, 0x2, 0xb35, 0xb37, 0x3, 0x2, 0x2, 0x2, 0xb36, 0xb34, 
       0x3, 0x2, 0x2, 0x2, 0xb37, 0xb38, 0x7, 0x1d4, 0x2, 0x2, 0xb38, 0x141, 
       0x3, 0x2, 0x2, 0x2, 0xb39, 0xb3a, 0x7, 0x1b, 0x2, 0x2, 0xb3a, 0x143, 
       0x3, 0x2, 0x2, 0x2, 0xb3b, 0xb3e, 0x5, 0x46e, 0x238, 0x2, 0xb3c, 
       0xb3e, 0x5, 0x146, 0xa4, 0x2, 0xb3d, 0xb3b, 0x3, 0x2, 0x2, 0x2, 0xb3d, 
       0xb3c, 0x3, 0x2, 0x2, 0x2, 0xb3e, 0x145, 0x3, 0x2, 0x2, 0x2, 0xb3f, 
       0xb43, 0x9, 0xa, 0x2, 0x2, 0xb40, 0xb42, 0x9, 0xb, 0x2, 0x2, 0xb41, 
       0xb40, 0x3, 0x2, 0x2, 0x2, 0xb42, 0xb45, 0x3, 0x2, 0x2, 0x2, 0xb43, 
       0xb41, 0x3, 0x2, 0x2, 0x2, 0xb43, 0xb44, 0x3, 0x2, 0x2, 0x2, 0xb44, 
       0xb46, 0x3, 0x2, 0x2, 0x2, 0xb45, 0xb43, 0x3, 0x2, 0x2, 0x2, 0xb46, 
       0xb47, 0x7, 0x243, 0x2, 0x2, 0xb47, 0x147, 0x3, 0x2, 0x2, 0x2, 0xb48, 
       0xb79, 0x5, 0x22, 0x12, 0x2, 0xb49, 0xb79, 0x5, 0x86, 0x44, 0x2, 
       0xb4a, 0xb79, 0x5, 0x88, 0x45, 0x2, 0xb4b, 0xb79, 0x5, 0x36, 0x1c, 
       0x2, 0xb4c, 0xb79, 0x5, 0x8a, 0x46, 0x2, 0xb4d, 0xb79, 0x5, 0x3c, 
       0x1f, 0x2, 0xb4e, 0xb79, 0x5, 0x3e, 0x20, 0x2, 0xb4f, 0xb79, 0x5, 
       0x8c, 0x47, 0x2, 0xb50, 0xb79, 0x5, 0x8e, 0x48, 0x2, 0xb51, 0xb79, 
       0x5, 0x90, 0x49, 0x2, 0xb52, 0xb79, 0x5, 0x92, 0x4a, 0x2, 0xb53, 
       0xb79, 0x5, 0x94, 0x4b, 0x2, 0xb54, 0xb79, 0x5, 0x96, 0x4c, 0x2, 
       0xb55, 0xb79, 0x5, 0x98, 0x4d, 0x2, 0xb56, 0xb79, 0x5, 0x9a, 0x4e, 
       0x2, 0xb57, 0xb79, 0x5, 0x9c, 0x4f, 0x2, 0xb58, 0xb79, 0x5, 0x9e, 
       0x50, 0x2, 0xb59, 0xb79, 0x5, 0xa0, 0x51, 0x2, 0xb5a, 0xb79, 0x5, 
       0xa2, 0x52, 0x2, 0xb5b, 0xb79, 0x5, 0x5a, 0x2e, 0x2, 0xb5c, 0xb79, 
       0x5, 0xa4, 0x53, 0x2, 0xb5d, 0xb79, 0x5, 0xa6, 0x54, 0x2, 0xb5e, 
       0xb79, 0x5, 0xa8, 0x55, 0x2, 0xb5f, 0xb79, 0x5, 0xaa, 0x56, 0x2, 
       0xb60, 0xb79, 0x5, 0xac, 0x57, 0x2, 0xb61, 0xb79, 0x5, 0x6c, 0x37, 
       0x2, 0xb62, 0xb79, 0x5, 0xae, 0x58, 0x2, 0xb63, 0xb79, 0x5, 0x72, 
       0x3a, 0x2, 0xb64, 0xb79, 0x5, 0xb0, 0x59, 0x2, 0xb65, 0xb79, 0x5, 
       0xb2, 0x5a, 0x2, 0xb66, 0xb79, 0x5, 0xb4, 0x5b, 0x2, 0xb67, 0xb79, 
       0x5, 0xb6, 0x5c, 0x2, 0xb68, 0xb79, 0x5, 0xb8, 0x5d, 0x2, 0xb69, 
       0xb79, 0x5, 0xba, 0x5e, 0x2, 0xb6a, 0xb79, 0x5, 0xbc, 0x5f, 0x2, 
       0xb6b, 0xb79, 0x5, 0x76, 0x3c, 0x2, 0xb6c, 0xb79, 0x5, 0x7a, 0x3e, 
       0x2, 0xb6d, 0xb79, 0x5, 0x7c, 0x3f, 0x2, 0xb6e, 0xb79, 0x5, 0x7e, 
       0x40, 0x2, 0xb6f, 0xb79, 0x5, 0xbe, 0x60, 0x2, 0xb70, 0xb79, 0x5, 
       0x80, 0x41, 0x2, 0xb71, 0xb79, 0x5, 0x82, 0x42, 0x2, 0xb72, 0xb79, 
       0x5, 0xc0, 0x61, 0x2, 0xb73, 0xb79, 0x5, 0xc2, 0x62, 0x2, 0xb74, 
       0xb79, 0x5, 0xc4, 0x63, 0x2, 0xb75, 0xb79, 0x5, 0xc6, 0x64, 0x2, 
       0xb76, 0xb79, 0x5, 0xc8, 0x65, 0x2, 0xb77, 0xb79, 0x5, 0xca, 0x66, 
       0x2, 0xb78, 0xb48, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb49, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb4a, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb4b, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb4c, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb4d, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb4e, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb4f, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb50, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb51, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb52, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb53, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb54, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb55, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb56, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb57, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb58, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb59, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb5a, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb5b, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb5c, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb5d, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb5e, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb5f, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb60, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb61, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb62, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb63, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb64, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb65, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb66, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb67, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb68, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb69, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb6a, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb6b, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb6c, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb6d, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb6e, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb6f, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb70, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb71, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb72, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb73, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb74, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb75, 0x3, 0x2, 0x2, 
       0x2, 0xb78, 0xb76, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb77, 0x3, 0x2, 0x2, 
       0x2, 0xb79, 0x149, 0x3, 0x2, 0x2, 0x2, 0xb7a, 0xb7b, 0x7, 0x9, 0x2, 
       0x2, 0xb7b, 0xb7c, 0x7, 0x27e, 0x2, 0x2, 0xb7c, 0xb7d, 0x7, 0x27f, 
       0x2, 0x2, 0xb7d, 0xb7e, 0x7, 0x280, 0x2, 0x2, 0xb7e, 0xb7f, 0x7, 
       0x281, 0x2, 0x2, 0xb7f, 0xb80, 0x7, 0x282, 0x2, 0x2, 0xb80, 0xb81, 
       0x7, 0x283, 0x2, 0x2, 0xb81, 0xb82, 0x7, 0x284, 0x2, 0x2, 0xb82, 
       0xb83, 0x7, 0x285, 0x2, 0x2, 0xb83, 0xb84, 0x7, 0x286, 0x2, 0x2, 
       0xb84, 0xb85, 0x7, 0x287, 0x2, 0x2, 0xb85, 0xb86, 0x7, 0x288, 0x2, 
       0x2, 0xb86, 0xb87, 0x7, 0x289, 0x2, 0x2, 0xb87, 0xb89, 0x7, 0x28a, 
       0x2, 0x2, 0xb88, 0xb8a, 0x7, 0x28b, 0x2, 0x2, 0xb89, 0xb88, 0x3, 
       0x2, 0x2, 0x2, 0xb89, 0xb8a, 0x3, 0x2, 0x2, 0x2, 0xb8a, 0xb8e, 0x3, 
       0x2, 0x2, 0x2, 0xb8b, 0xb8d, 0x5, 0x148, 0xa5, 0x2, 0xb8c, 0xb8b, 
       0x3, 0x2, 0x2, 0x2, 0xb8d, 0xb90, 0x3, 0x2, 0x2, 0x2, 0xb8e, 0xb8c, 
       0x3, 0x2, 0x2, 0x2, 0xb8e, 0xb8f, 0x3, 0x2, 0x2, 0x2, 0xb8f, 0xb91, 
       0x3, 0x2, 0x2, 0x2, 0xb90, 0xb8e, 0x3, 0x2, 0x2, 0x2, 0xb91, 0xb92, 
       0x9, 0x2, 0x2, 0x2, 0xb92, 0x14b, 0x3, 0x2, 0x2, 0x2, 0xb93, 0xb97, 
       0x7, 0xb, 0x2, 0x2, 0xb94, 0xb96, 0x5, 0x14e, 0xa8, 0x2, 0xb95, 0xb94, 
       0x3, 0x2, 0x2, 0x2, 0xb96, 0xb99, 0x3, 0x2, 0x2, 0x2, 0xb97, 0xb95, 
       0x3, 0x2, 0x2, 0x2, 0xb97, 0xb98, 0x3, 0x2, 0x2, 0x2, 0xb98, 0xb9a, 
       0x3, 0x2, 0x2, 0x2, 0xb99, 0xb97, 0x3, 0x2, 0x2, 0x2, 0xb9a, 0xb9b, 
       0x5, 0x17e, 0xc0, 0x2, 0xb9b, 0xb9c, 0x5, 0x17c, 0xbf, 0x2, 0xb9c, 
       0xb9d, 0x5, 0x180, 0xc1, 0x2, 0xb9d, 0xba0, 0x5, 0x2d4, 0x16b, 0x2, 
       0xb9e, 0xba1, 0x5, 0x186, 0xc4, 0x2, 0xb9f, 0xba1, 0x5, 0x2dc, 0x16f, 
       0x2, 0xba0, 0xb9e, 0x3, 0x2, 0x2, 0x2, 0xba0, 0xb9f, 0x3, 0x2, 0x2, 
       0x2, 0xba1, 0x14d, 0x3, 0x2, 0x2, 0x2, 0xba2, 0xba3, 0x5, 0x17e, 
       0xc0, 0x2, 0xba3, 0xba4, 0x5, 0x17c, 0xbf, 0x2, 0xba4, 0xba5, 0x5, 
       0x180, 0xc1, 0x2, 0xba5, 0xba6, 0x7, 0x276, 0x2, 0x2, 0xba6, 0xba7, 
       0x7, 0xb, 0x2, 0x2, 0xba7, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xba8, 0xba9, 
       0x7, 0xb, 0x2, 0x2, 0xba9, 0xbaa, 0x7, 0x2b3, 0x2, 0x2, 0xbaa, 0xbab, 
       0x7, 0x2b1, 0x2, 0x2, 0xbab, 0xbac, 0x7, 0x2b3, 0x2, 0x2, 0xbac, 
       0xbad, 0x7, 0x29f, 0x2, 0x2, 0xbad, 0xbae, 0x7, 0x2a3, 0x2, 0x2, 
       0xbae, 0xbaf, 0x7, 0x29f, 0x2, 0x2, 0xbaf, 0xbb0, 0x7, 0x29f, 0x2, 
       0x2, 0xbb0, 0xbb1, 0x7, 0x2a6, 0x2, 0x2, 0xbb1, 0xbb2, 0x7, 0x2a7, 
       0x2, 0x2, 0xbb2, 0xbb3, 0x7, 0x2b3, 0x2, 0x2, 0xbb3, 0xbb4, 0x7, 
       0x2b3, 0x2, 0x2, 0xbb4, 0xbb5, 0x7, 0x2b3, 0x2, 0x2, 0xbb5, 0xbb6, 
       0x9, 0x2, 0x2, 0x2, 0xbb6, 0x151, 0x3, 0x2, 0x2, 0x2, 0xbb7, 0xbbc, 
       0x5, 0x150, 0xa9, 0x2, 0xbb8, 0xbb9, 0x9, 0xc, 0x2, 0x2, 0xbb9, 0xbba, 
       0x7, 0x262, 0x2, 0x2, 0xbba, 0xbbc, 0x9, 0x2, 0x2, 0x2, 0xbbb, 0xbb7, 
       0x3, 0x2, 0x2, 0x2, 0xbbb, 0xbb8, 0x3, 0x2, 0x2, 0x2, 0xbbc, 0x153, 
       0x3, 0x2, 0x2, 0x2, 0xbbd, 0xbbe, 0x7, 0x8, 0x2, 0x2, 0xbbe, 0xbbf, 
       0x5, 0x12e, 0x98, 0x2, 0xbbf, 0xbc0, 0x7, 0x266, 0x2, 0x2, 0xbc0, 
       0xbc1, 0x7, 0x267, 0x2, 0x2, 0xbc1, 0xbc2, 0x7, 0x269, 0x2, 0x2, 
       0xbc2, 0xbc3, 0x7, 0x26f, 0x2, 0x2, 0xbc3, 0xbc4, 0x7, 0x270, 0x2, 
       0x2, 0xbc4, 0xbc5, 0x7, 0x271, 0x2, 0x2, 0xbc5, 0xbc6, 0x7, 0x272, 
       0x2, 0x2, 0xbc6, 0xbca, 0x7, 0x273, 0x2, 0x2, 0xbc7, 0xbc9, 0x5, 
       0x1e, 0x10, 0x2, 0xbc8, 0xbc7, 0x3, 0x2, 0x2, 0x2, 0xbc9, 0xbcc, 
       0x3, 0x2, 0x2, 0x2, 0xbca, 0xbc8, 0x3, 0x2, 0x2, 0x2, 0xbca, 0xbcb, 
       0x3, 0x2, 0x2, 0x2, 0xbcb, 0xbcd, 0x3, 0x2, 0x2, 0x2, 0xbcc, 0xbca, 
       0x3, 0x2, 0x2, 0x2, 0xbcd, 0xbce, 0x9, 0x2, 0x2, 0x2, 0xbce, 0x155, 
       0x3, 0x2, 0x2, 0x2, 0xbcf, 0xbd0, 0x7, 0x8, 0x2, 0x2, 0xbd0, 0xbd1, 
       0x5, 0x12e, 0x98, 0x2, 0xbd1, 0xbd2, 0x7, 0x266, 0x2, 0x2, 0xbd2, 
       0xbd3, 0x7, 0x267, 0x2, 0x2, 0xbd3, 0xbd4, 0x7, 0x26d, 0x2, 0x2, 
       0xbd4, 0xbd5, 0x7, 0x26f, 0x2, 0x2, 0xbd5, 0xbd6, 0x7, 0x270, 0x2, 
       0x2, 0xbd6, 0xbd7, 0x7, 0x271, 0x2, 0x2, 0xbd7, 0xbd8, 0x7, 0x272, 
       0x2, 0x2, 0xbd8, 0xbdc, 0x7, 0x273, 0x2, 0x2, 0xbd9, 0xbdb, 0x5, 
       0x1e, 0x10, 0x2, 0xbda, 0xbd9, 0x3, 0x2, 0x2, 0x2, 0xbdb, 0xbde, 
       0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbda, 0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbdd, 
       0x3, 0x2, 0x2, 0x2, 0xbdd, 0xbdf, 0x3, 0x2, 0x2, 0x2, 0xbde, 0xbdc, 
       0x3, 0x2, 0x2, 0x2, 0xbdf, 0xbe0, 0x9, 0x2, 0x2, 0x2, 0xbe0, 0x157, 
       0x3, 0x2, 0x2, 0x2, 0xbe1, 0xbe3, 0x7, 0x8, 0x2, 0x2, 0xbe2, 0xbe4, 
       0x5, 0x12e, 0x98, 0x2, 0xbe3, 0xbe2, 0x3, 0x2, 0x2, 0x2, 0xbe3, 0xbe4, 
       0x3, 0x2, 0x2, 0x2, 0xbe4, 0xbe5, 0x3, 0x2, 0x2, 0x2, 0xbe5, 0xbe6, 
       0x7, 0x266, 0x2, 0x2, 0xbe6, 0xbe7, 0x7, 0x267, 0x2, 0x2, 0xbe7, 
       0xbe8, 0x7, 0x26d, 0x2, 0x2, 0xbe8, 0xbe9, 0x7, 0x26f, 0x2, 0x2, 
       0xbe9, 0xbea, 0x7, 0x270, 0x2, 0x2, 0xbea, 0xbeb, 0x7, 0x271, 0x2, 
       0x2, 0xbeb, 0xbec, 0x7, 0x272, 0x2, 0x2, 0xbec, 0xbf0, 0x7, 0x273, 
       0x2, 0x2, 0xbed, 0xbef, 0x5, 0x1e, 0x10, 0x2, 0xbee, 0xbed, 0x3, 
       0x2, 0x2, 0x2, 0xbef, 0xbf2, 0x3, 0x2, 0x2, 0x2, 0xbf0, 0xbee, 0x3, 
       0x2, 0x2, 0x2, 0xbf0, 0xbf1, 0x3, 0x2, 0x2, 0x2, 0xbf1, 0xbf3, 0x3, 
       0x2, 0x2, 0x2, 0xbf2, 0xbf0, 0x3, 0x2, 0x2, 0x2, 0xbf3, 0xbf4, 0x9, 
       0x2, 0x2, 0x2, 0xbf4, 0x159, 0x3, 0x2, 0x2, 0x2, 0xbf5, 0xbfe, 0x5, 
       0x156, 0xac, 0x2, 0xbf6, 0xbfa, 0x5, 0x16a, 0xb6, 0x2, 0xbf7, 0xbf9, 
       0x5, 0x158, 0xad, 0x2, 0xbf8, 0xbf7, 0x3, 0x2, 0x2, 0x2, 0xbf9, 0xbfc, 
       0x3, 0x2, 0x2, 0x2, 0xbfa, 0xbf8, 0x3, 0x2, 0x2, 0x2, 0xbfa, 0xbfb, 
       0x3, 0x2, 0x2, 0x2, 0xbfb, 0xbfe, 0x3, 0x2, 0x2, 0x2, 0xbfc, 0xbfa, 
       0x3, 0x2, 0x2, 0x2, 0xbfd, 0xbf5, 0x3, 0x2, 0x2, 0x2, 0xbfd, 0xbf6, 
       0x3, 0x2, 0x2, 0x2, 0xbfe, 0x15b, 0x3, 0x2, 0x2, 0x2, 0xbff, 0xc01, 
       0x5, 0x15e, 0xb0, 0x2, 0xc00, 0xc02, 0x5, 0xdc, 0x6f, 0x2, 0xc01, 
       0xc00, 0x3, 0x2, 0x2, 0x2, 0xc01, 0xc02, 0x3, 0x2, 0x2, 0x2, 0xc02, 
       0xc06, 0x3, 0x2, 0x2, 0x2, 0xc03, 0xc05, 0x5, 0x16e, 0xb8, 0x2, 0xc04, 
       0xc03, 0x3, 0x2, 0x2, 0x2, 0xc05, 0xc08, 0x3, 0x2, 0x2, 0x2, 0xc06, 
       0xc04, 0x3, 0x2, 0x2, 0x2, 0xc06, 0xc07, 0x3, 0x2, 0x2, 0x2, 0xc07, 
       0xc09, 0x3, 0x2, 0x2, 0x2, 0xc08, 0xc06, 0x3, 0x2, 0x2, 0x2, 0xc09, 
       0xc0a, 0x5, 0x160, 0xb1, 0x2, 0xc0a, 0x15d, 0x3, 0x2, 0x2, 0x2, 0xc0b, 
       0xc0e, 0x5, 0x162, 0xb2, 0x2, 0xc0c, 0xc0e, 0x5, 0x164, 0xb3, 0x2, 
       0xc0d, 0xc0b, 0x3, 0x2, 0x2, 0x2, 0xc0d, 0xc0c, 0x3, 0x2, 0x2, 0x2, 
       0xc0e, 0x15f, 0x3, 0x2, 0x2, 0x2, 0xc0f, 0xc12, 0x5, 0x166, 0xb4, 
       0x2, 0xc10, 0xc12, 0x5, 0x168, 0xb5, 0x2, 0xc11, 0xc0f, 0x3, 0x2, 
       0x2, 0x2, 0xc11, 0xc10, 0x3, 0x2, 0x2, 0x2, 0xc12, 0x161, 0x3, 0x2, 
       0x2, 0x2, 0xc13, 0xc14, 0x7, 0xe, 0x2, 0x2, 0xc14, 0xc15, 0x5, 0x13e, 
       0xa0, 0x2, 0xc15, 0xc16, 0x7, 0x25b, 0x2, 0x2, 0xc16, 0xc17, 0x7, 
       0x25e, 0x2, 0x2, 0xc17, 0x163, 0x3, 0x2, 0x2, 0x2, 0xc18, 0xc19, 
       0x7, 0x7f, 0x2, 0x2, 0xc19, 0xc1a, 0x5, 0x480, 0x241, 0x2, 0xc1a, 
       0xc1b, 0x7, 0x1d4, 0x2, 0x2, 0xc1b, 0x165, 0x3, 0x2, 0x2, 0x2, 0xc1c, 
       0xc1d, 0x7, 0xe, 0x2, 0x2, 0xc1d, 0xc1e, 0x5, 0x13e, 0xa0, 0x2, 0xc1e, 
       0xc1f, 0x7, 0x25c, 0x2, 0x2, 0xc1f, 0xc20, 0x7, 0x25e, 0x2, 0x2, 
       0xc20, 0x167, 0x3, 0x2, 0x2, 0x2, 0xc21, 0xc23, 0x7, 0x80, 0x2, 0x2, 
       0xc22, 0xc24, 0x5, 0x480, 0x241, 0x2, 0xc23, 0xc22, 0x3, 0x2, 0x2, 
       0x2, 0xc23, 0xc24, 0x3, 0x2, 0x2, 0x2, 0xc24, 0xc25, 0x3, 0x2, 0x2, 
       0x2, 0xc25, 0xc26, 0x7, 0x1d4, 0x2, 0x2, 0xc26, 0x169, 0x3, 0x2, 
       0x2, 0x2, 0xc27, 0xc28, 0x7, 0x8, 0x2, 0x2, 0xc28, 0xc29, 0x5, 0x12e, 
       0x98, 0x2, 0xc29, 0xc2a, 0x7, 0x266, 0x2, 0x2, 0xc2a, 0xc2b, 0x7, 
       0x267, 0x2, 0x2, 0xc2b, 0xc2c, 0x7, 0x26a, 0x2, 0x2, 0xc2c, 0xc2d, 
       0x7, 0x26f, 0x2, 0x2, 0xc2d, 0xc2e, 0x7, 0x270, 0x2, 0x2, 0xc2e, 
       0xc2f, 0x7, 0x271, 0x2, 0x2, 0xc2f, 0xc30, 0x7, 0x272, 0x2, 0x2, 
       0xc30, 0xc34, 0x7, 0x273, 0x2, 0x2, 0xc31, 0xc33, 0x5, 0x1e, 0x10, 
       0x2, 0xc32, 0xc31, 0x3, 0x2, 0x2, 0x2, 0xc33, 0xc36, 0x3, 0x2, 0x2, 
       0x2, 0xc34, 0xc32, 0x3, 0x2, 0x2, 0x2, 0xc34, 0xc35, 0x3, 0x2, 0x2, 
       0x2, 0xc35, 0xc37, 0x3, 0x2, 0x2, 0x2, 0xc36, 0xc34, 0x3, 0x2, 0x2, 
       0x2, 0xc37, 0xc38, 0x9, 0x2, 0x2, 0x2, 0xc38, 0x16b, 0x3, 0x2, 0x2, 
       0x2, 0xc39, 0xc3d, 0x5, 0x170, 0xb9, 0x2, 0xc3a, 0xc3c, 0x5, 0x4, 
       0x3, 0x2, 0xc3b, 0xc3a, 0x3, 0x2, 0x2, 0x2, 0xc3c, 0xc3f, 0x3, 0x2, 
       0x2, 0x2, 0xc3d, 0xc3b, 0x3, 0x2, 0x2, 0x2, 0xc3d, 0xc3e, 0x3, 0x2, 
       0x2, 0x2, 0xc3e, 0xc40, 0x3, 0x2, 0x2, 0x2, 0xc3f, 0xc3d, 0x3, 0x2, 
       0x2, 0x2, 0xc40, 0xc41, 0x5, 0x172, 0xba, 0x2, 0xc41, 0x16d, 0x3, 
       0x2, 0x2, 0x2, 0xc42, 0xc46, 0x5, 0x4, 0x3, 0x2, 0xc43, 0xc46, 0x5, 
       0x16c, 0xb7, 0x2, 0xc44, 0xc46, 0x5, 0xd6, 0x6c, 0x2, 0xc45, 0xc42, 
       0x3, 0x2, 0x2, 0x2, 0xc45, 0xc43, 0x3, 0x2, 0x2, 0x2, 0xc45, 0xc44, 
       0x3, 0x2, 0x2, 0x2, 0xc46, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xc47, 0xc4a, 
       0x5, 0x174, 0xbb, 0x2, 0xc48, 0xc4a, 0x5, 0x176, 0xbc, 0x2, 0xc49, 
       0xc47, 0x3, 0x2, 0x2, 0x2, 0xc49, 0xc48, 0x3, 0x2, 0x2, 0x2, 0xc4a, 
       0x171, 0x3, 0x2, 0x2, 0x2, 0xc4b, 0xc4e, 0x5, 0x178, 0xbd, 0x2, 0xc4c, 
       0xc4e, 0x5, 0x17a, 0xbe, 0x2, 0xc4d, 0xc4b, 0x3, 0x2, 0x2, 0x2, 0xc4d, 
       0xc4c, 0x3, 0x2, 0x2, 0x2, 0xc4e, 0x173, 0x3, 0x2, 0x2, 0x2, 0xc4f, 
       0xc53, 0x7, 0xb, 0x2, 0x2, 0xc50, 0xc52, 0x5, 0x14e, 0xa8, 0x2, 0xc51, 
       0xc50, 0x3, 0x2, 0x2, 0x2, 0xc52, 0xc55, 0x3, 0x2, 0x2, 0x2, 0xc53, 
       0xc51, 0x3, 0x2, 0x2, 0x2, 0xc53, 0xc54, 0x3, 0x2, 0x2, 0x2, 0xc54, 
       0xc56, 0x3, 0x2, 0x2, 0x2, 0xc55, 0xc53, 0x3, 0x2, 0x2, 0x2, 0xc56, 
       0xc57, 0x5, 0x17e, 0xc0, 0x2, 0xc57, 0xc58, 0x5, 0x17c, 0xbf, 0x2, 
       0xc58, 0xc59, 0x5, 0x180, 0xc1, 0x2, 0xc59, 0xc5a, 0x5, 0x2d4, 0x16b, 
       0x2, 0xc5a, 0xc5b, 0x7, 0x38, 0x2, 0x2, 0xc5b, 0xc5c, 0x5, 0x188, 
       0xc5, 0x2, 0xc5c, 0x175, 0x3, 0x2, 0x2, 0x2, 0xc5d, 0xc5e, 0x7, 0x38, 
       0x2, 0x2, 0xc5e, 0xc5f, 0x5, 0x480, 0x241, 0x2, 0xc5f, 0xc61, 0x7, 
       0x1d4, 0x2, 0x2, 0xc60, 0xc62, 0x5, 0x14, 0xb, 0x2, 0xc61, 0xc60, 
       0x3, 0x2, 0x2, 0x2, 0xc61, 0xc62, 0x3, 0x2, 0x2, 0x2, 0xc62, 0x177, 
       0x3, 0x2, 0x2, 0x2, 0xc63, 0xc67, 0x7, 0xb, 0x2, 0x2, 0xc64, 0xc66, 
       0x5, 0x14e, 0xa8, 0x2, 0xc65, 0xc64, 0x3, 0x2, 0x2, 0x2, 0xc66, 0xc69, 
       0x3, 0x2, 0x2, 0x2, 0xc67, 0xc65, 0x3, 0x2, 0x2, 0x2, 0xc67, 0xc68, 
       0x3, 0x2, 0x2, 0x2, 0xc68, 0xc6a, 0x3, 0x2, 0x2, 0x2, 0xc69, 0xc67, 
       0x3, 0x2, 0x2, 0x2, 0xc6a, 0xc6b, 0x5, 0x17e, 0xc0, 0x2, 0xc6b, 0xc6c, 
       0x5, 0x17c, 0xbf, 0x2, 0xc6c, 0xc6d, 0x5, 0x180, 0xc1, 0x2, 0xc6d, 
       0xc6e, 0x5, 0x2d4, 0x16b, 0x2, 0xc6e, 0xc6f, 0x7, 0x4b, 0x2, 0x2, 
       0xc6f, 0xc70, 0x5, 0x188, 0xc5, 0x2, 0xc70, 0x179, 0x3, 0x2, 0x2, 
       0x2, 0xc71, 0xc74, 0x7, 0x4b, 0x2, 0x2, 0xc72, 0xc75, 0x5, 0x480, 
       0x241, 0x2, 0xc73, 0xc75, 0x5, 0x47e, 0x240, 0x2, 0xc74, 0xc72, 0x3, 
       0x2, 0x2, 0x2, 0xc74, 0xc73, 0x3, 0x2, 0x2, 0x2, 0xc74, 0xc75, 0x3, 
       0x2, 0x2, 0x2, 0xc75, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xc76, 0xc78, 0x7, 
       0x1d4, 0x2, 0x2, 0xc77, 0xc79, 0x5, 0x14, 0xb, 0x2, 0xc78, 0xc77, 
       0x3, 0x2, 0x2, 0x2, 0xc78, 0xc79, 0x3, 0x2, 0x2, 0x2, 0xc79, 0x17b, 
       0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc7b, 0x9, 0xd, 0x2, 0x2, 0xc7b, 0x17d, 
       0x3, 0x2, 0x2, 0x2, 0xc7c, 0xc7d, 0x9, 0xe, 0x2, 0x2, 0xc7d, 0x17f, 
       0x3, 0x2, 0x2, 0x2, 0xc7e, 0xc7f, 0x9, 0xf, 0x2, 0x2, 0xc7f, 0x181, 
       0x3, 0x2, 0x2, 0x2, 0xc80, 0xc81, 0x9, 0xf, 0x2, 0x2, 0xc81, 0x183, 
       0x3, 0x2, 0x2, 0x2, 0xc82, 0xc84, 0x7, 0xc, 0x2, 0x2, 0xc83, 0xc85, 
       0x7, 0x2c6, 0x2, 0x2, 0xc84, 0xc83, 0x3, 0x2, 0x2, 0x2, 0xc85, 0xc86, 
       0x3, 0x2, 0x2, 0x2, 0xc86, 0xc84, 0x3, 0x2, 0x2, 0x2, 0xc86, 0xc87, 
       0x3, 0x2, 0x2, 0x2, 0xc87, 0xc88, 0x3, 0x2, 0x2, 0x2, 0xc88, 0xc89, 
       0x7, 0x2c9, 0x2, 0x2, 0xc89, 0x185, 0x3, 0x2, 0x2, 0x2, 0xc8a, 0xcf1, 
       0x5, 0x18a, 0xc6, 0x2, 0xc8b, 0xcf1, 0x5, 0x18c, 0xc7, 0x2, 0xc8c, 
       0xcf1, 0x5, 0x18e, 0xc8, 0x2, 0xc8d, 0xcf1, 0x5, 0x190, 0xc9, 0x2, 
       0xc8e, 0xcf1, 0x5, 0x19e, 0xd0, 0x2, 0xc8f, 0xcf1, 0x5, 0x1a0, 0xd1, 
       0x2, 0xc90, 0xcf1, 0x5, 0x1a2, 0xd2, 0x2, 0xc91, 0xcf1, 0x5, 0x1a4, 
       0xd3, 0x2, 0xc92, 0xcf1, 0x5, 0x1a6, 0xd4, 0x2, 0xc93, 0xcf1, 0x5, 
       0x1a8, 0xd5, 0x2, 0xc94, 0xcf1, 0x5, 0x1aa, 0xd6, 0x2, 0xc95, 0xcf1, 
       0x5, 0x1ac, 0xd7, 0x2, 0xc96, 0xcf1, 0x5, 0x1ae, 0xd8, 0x2, 0xc97, 
       0xcf1, 0x5, 0x1b0, 0xd9, 0x2, 0xc98, 0xcf1, 0x5, 0x1b2, 0xda, 0x2, 
       0xc99, 0xcf1, 0x5, 0x1c4, 0xe3, 0x2, 0xc9a, 0xcf1, 0x5, 0x1c6, 0xe4, 
       0x2, 0xc9b, 0xcf1, 0x5, 0x1c8, 0xe5, 0x2, 0xc9c, 0xcf1, 0x5, 0x1ca, 
       0xe6, 0x2, 0xc9d, 0xcf1, 0x5, 0x1cc, 0xe7, 0x2, 0xc9e, 0xcf1, 0x5, 
       0x1ce, 0xe8, 0x2, 0xc9f, 0xcf1, 0x5, 0x1d0, 0xe9, 0x2, 0xca0, 0xcf1, 
       0x5, 0x1d2, 0xea, 0x2, 0xca1, 0xcf1, 0x5, 0x1d4, 0xeb, 0x2, 0xca2, 
       0xcf1, 0x5, 0x1d6, 0xec, 0x2, 0xca3, 0xcf1, 0x5, 0x1d8, 0xed, 0x2, 
       0xca4, 0xcf1, 0x5, 0x1da, 0xee, 0x2, 0xca5, 0xcf1, 0x5, 0x1dc, 0xef, 
       0x2, 0xca6, 0xcf1, 0x5, 0x1fa, 0xfe, 0x2, 0xca7, 0xcf1, 0x5, 0x1fc, 
       0xff, 0x2, 0xca8, 0xcf1, 0x5, 0x210, 0x109, 0x2, 0xca9, 0xcf1, 0x5, 
       0x212, 0x10a, 0x2, 0xcaa, 0xcf1, 0x5, 0x214, 0x10b, 0x2, 0xcab, 0xcf1, 
       0x5, 0x216, 0x10c, 0x2, 0xcac, 0xcf1, 0x5, 0x218, 0x10d, 0x2, 0xcad, 
       0xcf1, 0x5, 0x21a, 0x10e, 0x2, 0xcae, 0xcf1, 0x5, 0x21c, 0x10f, 0x2, 
       0xcaf, 0xcf1, 0x5, 0x21e, 0x110, 0x2, 0xcb0, 0xcf1, 0x5, 0x226, 0x114, 
       0x2, 0xcb1, 0xcf1, 0x5, 0x228, 0x115, 0x2, 0xcb2, 0xcf1, 0x5, 0x238, 
       0x11d, 0x2, 0xcb3, 0xcf1, 0x5, 0x23a, 0x11e, 0x2, 0xcb4, 0xcf1, 0x5, 
       0x23c, 0x11f, 0x2, 0xcb5, 0xcf1, 0x5, 0x240, 0x121, 0x2, 0xcb6, 0xcf1, 
       0x5, 0x242, 0x122, 0x2, 0xcb7, 0xcf1, 0x5, 0x244, 0x123, 0x2, 0xcb8, 
       0xcf1, 0x5, 0x246, 0x124, 0x2, 0xcb9, 0xcf1, 0x5, 0x248, 0x125, 0x2, 
       0xcba, 0xcf1, 0x5, 0x24a, 0x126, 0x2, 0xcbb, 0xcf1, 0x5, 0x24c, 0x127, 
       0x2, 0xcbc, 0xcf1, 0x5, 0x250, 0x129, 0x2, 0xcbd, 0xcf1, 0x5, 0x252, 
       0x12a, 0x2, 0xcbe, 0xcf1, 0x5, 0x254, 0x12b, 0x2, 0xcbf, 0xcf1, 0x5, 
       0x256, 0x12c, 0x2, 0xcc0, 0xcf1, 0x5, 0x25a, 0x12e, 0x2, 0xcc1, 0xcf1, 
       0x5, 0x25c, 0x12f, 0x2, 0xcc2, 0xcf1, 0x5, 0x262, 0x132, 0x2, 0xcc3, 
       0xcf1, 0x5, 0x270, 0x139, 0x2, 0xcc4, 0xcf1, 0x5, 0x272, 0x13a, 0x2, 
       0xcc5, 0xcf1, 0x5, 0x276, 0x13c, 0x2, 0xcc6, 0xcf1, 0x5, 0x278, 0x13d, 
       0x2, 0xcc7, 0xcf1, 0x5, 0x27a, 0x13e, 0x2, 0xcc8, 0xcf1, 0x5, 0x27c, 
       0x13f, 0x2, 0xcc9, 0xcf1, 0x5, 0x27e, 0x140, 0x2, 0xcca, 0xcf1, 0x5, 
       0x280, 0x141, 0x2, 0xccb, 0xcf1, 0x5, 0x282, 0x142, 0x2, 0xccc, 0xcf1, 
       0x5, 0x284, 0x143, 0x2, 0xccd, 0xcf1, 0x5, 0x286, 0x144, 0x2, 0xcce, 
       0xcf1, 0x5, 0x288, 0x145, 0x2, 0xccf, 0xcf1, 0x5, 0x28a, 0x146, 0x2, 
       0xcd0, 0xcf1, 0x5, 0x28c, 0x147, 0x2, 0xcd1, 0xcf1, 0x5, 0x28e, 0x148, 
       0x2, 0xcd2, 0xcf1, 0x5, 0x292, 0x14a, 0x2, 0xcd3, 0xcf1, 0x5, 0x294, 
       0x14b, 0x2, 0xcd4, 0xcf1, 0x5, 0x296, 0x14c, 0x2, 0xcd5, 0xcf1, 0x5, 
       0x298, 0x14d, 0x2, 0xcd6, 0xcf1, 0x5, 0x29a, 0x14e, 0x2, 0xcd7, 0xcf1, 
       0x5, 0x29c, 0x14f, 0x2, 0xcd8, 0xcf1, 0x5, 0x29e, 0x150, 0x2, 0xcd9, 
       0xcf1, 0x5, 0x2a0, 0x151, 0x2, 0xcda, 0xcf1, 0x5, 0x2a2, 0x152, 0x2, 
       0xcdb, 0xcf1, 0x5, 0x2a4, 0x153, 0x2, 0xcdc, 0xcf1, 0x5, 0x2a6, 0x154, 
       0x2, 0xcdd, 0xcf1, 0x5, 0x2a8, 0x155, 0x2, 0xcde, 0xcf1, 0x5, 0x2aa, 
       0x156, 0x2, 0xcdf, 0xcf1, 0x5, 0x2ac, 0x157, 0x2, 0xce0, 0xcf1, 0x5, 
       0x2ae, 0x158, 0x2, 0xce1, 0xcf1, 0x5, 0x2b0, 0x159, 0x2, 0xce2, 0xcf1, 
       0x5, 0x2b2, 0x15a, 0x2, 0xce3, 0xcf1, 0x5, 0x2b4, 0x15b, 0x2, 0xce4, 
       0xcf1, 0x5, 0x2c4, 0x163, 0x2, 0xce5, 0xcf1, 0x5, 0x2c6, 0x164, 0x2, 
       0xce6, 0xcf1, 0x5, 0x2c8, 0x165, 0x2, 0xce7, 0xcf1, 0x5, 0x2ca, 0x166, 
       0x2, 0xce8, 0xcf1, 0x5, 0x2cc, 0x167, 0x2, 0xce9, 0xcf1, 0x5, 0x2ce, 
       0x168, 0x2, 0xcea, 0xcf1, 0x5, 0x2d0, 0x169, 0x2, 0xceb, 0xced, 0x7, 
       0x2a5, 0x2, 0x2, 0xcec, 0xcee, 0x5, 0x2d2, 0x16a, 0x2, 0xced, 0xcec, 
       0x3, 0x2, 0x2, 0x2, 0xced, 0xcee, 0x3, 0x2, 0x2, 0x2, 0xcee, 0xcef, 
       0x3, 0x2, 0x2, 0x2, 0xcef, 0xcf1, 0x5, 0x188, 0xc5, 0x2, 0xcf0, 0xc8a, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc8b, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc8c, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc8e, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc8f, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc90, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc91, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc92, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc93, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc94, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc95, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc96, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc97, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc98, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc99, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc9a, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc9b, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc9c, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc9d, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc9e, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xc9f, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca0, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca1, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca2, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca3, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca4, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca5, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca6, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca7, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca8, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xca9, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcaa, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcab, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcac, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcad, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcae, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcaf, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb0, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb1, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb2, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb3, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb4, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb5, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb6, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb7, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb8, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcb9, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcba, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcbb, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcbc, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcbd, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcbe, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcbf, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc0, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc1, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc2, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc3, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc4, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc5, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc6, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc7, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc8, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcc9, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcca, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xccb, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xccc, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xccd, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcce, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xccf, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd0, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd1, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd2, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd3, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd4, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd5, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd6, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd7, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd8, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcda, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcdb, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcdc, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcdd, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcde, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcdf, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce0, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce1, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce2, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce3, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce4, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce5, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce6, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce7, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce8, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xce9, 0x3, 0x2, 0x2, 0x2, 0xcf0, 0xcea, 
       0x3, 0x2, 0x2, 0x2, 0xcf0, 0xceb, 0x3, 0x2, 0x2, 0x2, 0xcf1, 0x187, 
       0x3, 0x2, 0x2, 0x2, 0xcf2, 0xcf3, 0x5, 0x2d4, 0x16b, 0x2, 0xcf3, 
       0xcf4, 0x5, 0x2d8, 0x16d, 0x2, 0xcf4, 0xcf5, 0x7, 0x2a6, 0x2, 0x2, 
       0xcf5, 0xcf6, 0x7, 0x2a7, 0x2, 0x2, 0xcf6, 0xcf7, 0x5, 0x182, 0xc2, 
       0x2, 0xcf7, 0xcf8, 0x5, 0x182, 0xc2, 0x2, 0xcf8, 0xcfa, 0x5, 0x182, 
       0xc2, 0x2, 0xcf9, 0xcfb, 0x5, 0x2da, 0x16e, 0x2, 0xcfa, 0xcf9, 0x3, 
       0x2, 0x2, 0x2, 0xcfa, 0xcfb, 0x3, 0x2, 0x2, 0x2, 0xcfb, 0xcfc, 0x3, 
       0x2, 0x2, 0x2, 0xcfc, 0xcfd, 0x9, 0x2, 0x2, 0x2, 0xcfd, 0x189, 0x3, 
       0x2, 0x2, 0x2, 0xcfe, 0xd00, 0x7, 0x37, 0x2, 0x2, 0xcff, 0xd01, 0x5, 
       0x2d2, 0x16a, 0x2, 0xd00, 0xcff, 0x3, 0x2, 0x2, 0x2, 0xd00, 0xd01, 
       0x3, 0x2, 0x2, 0x2, 0xd01, 0xd02, 0x3, 0x2, 0x2, 0x2, 0xd02, 0xd03, 
       0x5, 0x188, 0xc5, 0x2, 0xd03, 0x18b, 0x3, 0x2, 0x2, 0x2, 0xd04, 0xd06, 
       0x7, 0x1d8, 0x2, 0x2, 0xd05, 0xd07, 0x5, 0x2d2, 0x16a, 0x2, 0xd06, 
       0xd05, 0x3, 0x2, 0x2, 0x2, 0xd06, 0xd07, 0x3, 0x2, 0x2, 0x2, 0xd07, 
       0xd08, 0x3, 0x2, 0x2, 0x2, 0xd08, 0xd09, 0x5, 0x188, 0xc5, 0x2, 0xd09, 
       0x18d, 0x3, 0x2, 0x2, 0x2, 0xd0a, 0xd0c, 0x7, 0x1d9, 0x2, 0x2, 0xd0b, 
       0xd0d, 0x5, 0x2d2, 0x16a, 0x2, 0xd0c, 0xd0b, 0x3, 0x2, 0x2, 0x2, 
       0xd0c, 0xd0d, 0x3, 0x2, 0x2, 0x2, 0xd0d, 0xd0e, 0x3, 0x2, 0x2, 0x2, 
       0xd0e, 0xd0f, 0x5, 0x188, 0xc5, 0x2, 0xd0f, 0x18f, 0x3, 0x2, 0x2, 
       0x2, 0xd10, 0xd12, 0x7, 0x1da, 0x2, 0x2, 0xd11, 0xd13, 0x5, 0x2d2, 
       0x16a, 0x2, 0xd12, 0xd11, 0x3, 0x2, 0x2, 0x2, 0xd12, 0xd13, 0x3, 
       0x2, 0x2, 0x2, 0xd13, 0xd14, 0x3, 0x2, 0x2, 0x2, 0xd14, 0xd15, 0x5, 
       0x188, 0xc5, 0x2, 0xd15, 0x191, 0x3, 0x2, 0x2, 0x2, 0xd16, 0xd17, 
       0x7, 0x1dc, 0x2, 0x2, 0xd17, 0xd18, 0x5, 0x188, 0xc5, 0x2, 0xd18, 
       0x193, 0x3, 0x2, 0x2, 0x2, 0xd19, 0xd1a, 0x7, 0x1dd, 0x2, 0x2, 0xd1a, 
       0xd1b, 0x5, 0x188, 0xc5, 0x2, 0xd1b, 0x195, 0x3, 0x2, 0x2, 0x2, 0xd1c, 
       0xd1d, 0x7, 0x1de, 0x2, 0x2, 0xd1d, 0xd1e, 0x5, 0x188, 0xc5, 0x2, 
       0xd1e, 0x197, 0x3, 0x2, 0x2, 0x2, 0xd1f, 0xd20, 0x7, 0x1df, 0x2, 
       0x2, 0xd20, 0xd21, 0x5, 0x188, 0xc5, 0x2, 0xd21, 0x199, 0x3, 0x2, 
       0x2, 0x2, 0xd22, 0xd23, 0x7, 0x1e0, 0x2, 0x2, 0xd23, 0xd24, 0x5, 
       0x188, 0xc5, 0x2, 0xd24, 0x19b, 0x3, 0x2, 0x2, 0x2, 0xd25, 0xd26, 
       0x7, 0x1e1, 0x2, 0x2, 0xd26, 0xd27, 0x5, 0x188, 0xc5, 0x2, 0xd27, 
       0x19d, 0x3, 0x2, 0x2, 0x2, 0xd28, 0xd29, 0x7, 0x1e2, 0x2, 0x2, 0xd29, 
       0xd2a, 0x5, 0x188, 0xc5, 0x2, 0xd2a, 0x19f, 0x3, 0x2, 0x2, 0x2, 0xd2b, 
       0xd2c, 0x7, 0x1e3, 0x2, 0x2, 0xd2c, 0xd2d, 0x5, 0x188, 0xc5, 0x2, 
       0xd2d, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0xd2e, 0xd2f, 0x7, 0x1e4, 0x2, 
       0x2, 0xd2f, 0xd30, 0x5, 0x188, 0xc5, 0x2, 0xd30, 0x1a3, 0x3, 0x2, 
       0x2, 0x2, 0xd31, 0xd32, 0x7, 0x1e5, 0x2, 0x2, 0xd32, 0xd33, 0x5, 
       0x188, 0xc5, 0x2, 0xd33, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0xd34, 0xd35, 
       0x7, 0x1e6, 0x2, 0x2, 0xd35, 0xd36, 0x5, 0x188, 0xc5, 0x2, 0xd36, 
       0x1a7, 0x3, 0x2, 0x2, 0x2, 0xd37, 0xd38, 0x7, 0x1e7, 0x2, 0x2, 0xd38, 
       0xd39, 0x5, 0x188, 0xc5, 0x2, 0xd39, 0x1a9, 0x3, 0x2, 0x2, 0x2, 0xd3a, 
       0xd3b, 0x7, 0x1e8, 0x2, 0x2, 0xd3b, 0xd3c, 0x5, 0x188, 0xc5, 0x2, 
       0xd3c, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0xd3d, 0xd3e, 0x7, 0x1e9, 0x2, 
       0x2, 0xd3e, 0xd3f, 0x5, 0x188, 0xc5, 0x2, 0xd3f, 0x1ad, 0x3, 0x2, 
       0x2, 0x2, 0xd40, 0xd41, 0x7, 0x1ea, 0x2, 0x2, 0xd41, 0xd42, 0x5, 
       0x188, 0xc5, 0x2, 0xd42, 0x1af, 0x3, 0x2, 0x2, 0x2, 0xd43, 0xd45, 
       0x7, 0x1eb, 0x2, 0x2, 0xd44, 0xd46, 0x5, 0x2d2, 0x16a, 0x2, 0xd45, 
       0xd44, 0x3, 0x2, 0x2, 0x2, 0xd45, 0xd46, 0x3, 0x2, 0x2, 0x2, 0xd46, 
       0xd47, 0x3, 0x2, 0x2, 0x2, 0xd47, 0xd4b, 0x5, 0x188, 0xc5, 0x2, 0xd48, 
       0xd4a, 0x5, 0x274, 0x13b, 0x2, 0xd49, 0xd48, 0x3, 0x2, 0x2, 0x2, 
       0xd4a, 0xd4d, 0x3, 0x2, 0x2, 0x2, 0xd4b, 0xd49, 0x3, 0x2, 0x2, 0x2, 
       0xd4b, 0xd4c, 0x3, 0x2, 0x2, 0x2, 0xd4c, 0x1b1, 0x3, 0x2, 0x2, 0x2, 
       0xd4d, 0xd4b, 0x3, 0x2, 0x2, 0x2, 0xd4e, 0xd50, 0x7, 0x1ec, 0x2, 
       0x2, 0xd4f, 0xd51, 0x5, 0x2d2, 0x16a, 0x2, 0xd50, 0xd4f, 0x3, 0x2, 
       0x2, 0x2, 0xd50, 0xd51, 0x3, 0x2, 0x2, 0x2, 0xd51, 0xd52, 0x3, 0x2, 
       0x2, 0x2, 0xd52, 0xd56, 0x5, 0x188, 0xc5, 0x2, 0xd53, 0xd55, 0x5, 
       0x274, 0x13b, 0x2, 0xd54, 0xd53, 0x3, 0x2, 0x2, 0x2, 0xd55, 0xd58, 
       0x3, 0x2, 0x2, 0x2, 0xd56, 0xd54, 0x3, 0x2, 0x2, 0x2, 0xd56, 0xd57, 
       0x3, 0x2, 0x2, 0x2, 0xd57, 0x1b3, 0x3, 0x2, 0x2, 0x2, 0xd58, 0xd56, 
       0x3, 0x2, 0x2, 0x2, 0xd59, 0xd5b, 0x7, 0x39, 0x2, 0x2, 0xd5a, 0xd5c, 
       0x5, 0x2d2, 0x16a, 0x2, 0xd5b, 0xd5a, 0x3, 0x2, 0x2, 0x2, 0xd5b, 
       0xd5c, 0x3, 0x2, 0x2, 0x2, 0xd5c, 0xd5d, 0x3, 0x2, 0x2, 0x2, 0xd5d, 
       0xd5e, 0x5, 0x45a, 0x22e, 0x2, 0xd5e, 0xd5f, 0x9, 0x8, 0x2, 0x2, 
       0xd5f, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0xd60, 0xd61, 0x7, 0x1ed, 0x2, 
       0x2, 0xd61, 0xd62, 0x5, 0x188, 0xc5, 0x2, 0xd62, 0x1b7, 0x3, 0x2, 
       0x2, 0x2, 0xd63, 0xd64, 0x7, 0x1ee, 0x2, 0x2, 0xd64, 0xd65, 0x5, 
       0x188, 0xc5, 0x2, 0xd65, 0x1b9, 0x3, 0x2, 0x2, 0x2, 0xd66, 0xd67, 
       0x7, 0x1ef, 0x2, 0x2, 0xd67, 0xd68, 0x5, 0x188, 0xc5, 0x2, 0xd68, 
       0x1bb, 0x3, 0x2, 0x2, 0x2, 0xd69, 0xd6a, 0x7, 0x1f0, 0x2, 0x2, 0xd6a, 
       0xd6b, 0x5, 0x188, 0xc5, 0x2, 0xd6b, 0x1bd, 0x3, 0x2, 0x2, 0x2, 0xd6c, 
       0xd6d, 0x7, 0x1f1, 0x2, 0x2, 0xd6d, 0xd6e, 0x5, 0x188, 0xc5, 0x2, 
       0xd6e, 0x1bf, 0x3, 0x2, 0x2, 0x2, 0xd6f, 0xd70, 0x7, 0x1f2, 0x2, 
       0x2, 0xd70, 0xd71, 0x5, 0x188, 0xc5, 0x2, 0xd71, 0x1c1, 0x3, 0x2, 
       0x2, 0x2, 0xd72, 0xd73, 0x7, 0x1f3, 0x2, 0x2, 0xd73, 0xd74, 0x5, 
       0x188, 0xc5, 0x2, 0xd74, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0xd75, 0xd77, 
       0x7, 0x1f4, 0x2, 0x2, 0xd76, 0xd78, 0x5, 0x2d2, 0x16a, 0x2, 0xd77, 
       0xd76, 0x3, 0x2, 0x2, 0x2, 0xd77, 0xd78, 0x3, 0x2, 0x2, 0x2, 0xd78, 
       0xd79, 0x3, 0x2, 0x2, 0x2, 0xd79, 0xd7a, 0x5, 0x188, 0xc5, 0x2, 0xd7a, 
       0x1c5, 0x3, 0x2, 0x2, 0x2, 0xd7b, 0xd7d, 0x7, 0x3a, 0x2, 0x2, 0xd7c, 
       0xd7e, 0x5, 0x2d2, 0x16a, 0x2, 0xd7d, 0xd7c, 0x3, 0x2, 0x2, 0x2, 
       0xd7d, 0xd7e, 0x3, 0x2, 0x2, 0x2, 0xd7e, 0xd7f, 0x3, 0x2, 0x2, 0x2, 
       0xd7f, 0xd80, 0x5, 0x188, 0xc5, 0x2, 0xd80, 0x1c7, 0x3, 0x2, 0x2, 
       0x2, 0xd81, 0xd83, 0x7, 0x1f5, 0x2, 0x2, 0xd82, 0xd84, 0x5, 0x2d2, 
       0x16a, 0x2, 0xd83, 0xd82, 0x3, 0x2, 0x2, 0x2, 0xd83, 0xd84, 0x3, 
       0x2, 0x2, 0x2, 0xd84, 0xd85, 0x3, 0x2, 0x2, 0x2, 0xd85, 0xd86, 0x5, 
       0x188, 0xc5, 0x2, 0xd86, 0x1c9, 0x3, 0x2, 0x2, 0x2, 0xd87, 0xd89, 
       0x7, 0x1f6, 0x2, 0x2, 0xd88, 0xd8a, 0x5, 0x2d2, 0x16a, 0x2, 0xd89, 
       0xd88, 0x3, 0x2, 0x2, 0x2, 0xd89, 0xd8a, 0x3, 0x2, 0x2, 0x2, 0xd8a, 
       0xd8b, 0x3, 0x2, 0x2, 0x2, 0xd8b, 0xd8c, 0x5, 0x188, 0xc5, 0x2, 0xd8c, 
       0x1cb, 0x3, 0x2, 0x2, 0x2, 0xd8d, 0xd8e, 0x7, 0x3b, 0x2, 0x2, 0xd8e, 
       0xd8f, 0x5, 0x188, 0xc5, 0x2, 0xd8f, 0x1cd, 0x3, 0x2, 0x2, 0x2, 0xd90, 
       0xd92, 0x7, 0x3c, 0x2, 0x2, 0xd91, 0xd93, 0x5, 0x2d2, 0x16a, 0x2, 
       0xd92, 0xd91, 0x3, 0x2, 0x2, 0x2, 0xd92, 0xd93, 0x3, 0x2, 0x2, 0x2, 
       0xd93, 0xd94, 0x3, 0x2, 0x2, 0x2, 0xd94, 0xd95, 0x5, 0x188, 0xc5, 
       0x2, 0xd95, 0x1cf, 0x3, 0x2, 0x2, 0x2, 0xd96, 0xd98, 0x7, 0x3d, 0x2, 
       0x2, 0xd97, 0xd99, 0x5, 0x2d2, 0x16a, 0x2, 0xd98, 0xd97, 0x3, 0x2, 
       0x2, 0x2, 0xd98, 0xd99, 0x3, 0x2, 0x2, 0x2, 0xd99, 0xd9a, 0x3, 0x2, 
       0x2, 0x2, 0xd9a, 0xd9b, 0x5, 0x188, 0xc5, 0x2, 0xd9b, 0x1d1, 0x3, 
       0x2, 0x2, 0x2, 0xd9c, 0xd9d, 0x7, 0x1f7, 0x2, 0x2, 0xd9d, 0xd9e, 
       0x5, 0x188, 0xc5, 0x2, 0xd9e, 0x1d3, 0x3, 0x2, 0x2, 0x2, 0xd9f, 0xda1, 
       0x7, 0x3e, 0x2, 0x2, 0xda0, 0xda2, 0x5, 0x2d2, 0x16a, 0x2, 0xda1, 
       0xda0, 0x3, 0x2, 0x2, 0x2, 0xda1, 0xda2, 0x3, 0x2, 0x2, 0x2, 0xda2, 
       0xda3, 0x3, 0x2, 0x2, 0x2, 0xda3, 0xda4, 0x5, 0x188, 0xc5, 0x2, 0xda4, 
       0x1d5, 0x3, 0x2, 0x2, 0x2, 0xda5, 0xda6, 0x7, 0x1f8, 0x2, 0x2, 0xda6, 
       0xda7, 0x5, 0x188, 0xc5, 0x2, 0xda7, 0x1d7, 0x3, 0x2, 0x2, 0x2, 0xda8, 
       0xdaa, 0x7, 0x3f, 0x2, 0x2, 0xda9, 0xdab, 0x5, 0x2d2, 0x16a, 0x2, 
       0xdaa, 0xda9, 0x3, 0x2, 0x2, 0x2, 0xdaa, 0xdab, 0x3, 0x2, 0x2, 0x2, 
       0xdab, 0xdac, 0x3, 0x2, 0x2, 0x2, 0xdac, 0xdad, 0x5, 0x188, 0xc5, 
       0x2, 0xdad, 0x1d9, 0x3, 0x2, 0x2, 0x2, 0xdae, 0xdb0, 0x7, 0x1f9, 
       0x2, 0x2, 0xdaf, 0xdb1, 0x5, 0x2d2, 0x16a, 0x2, 0xdb0, 0xdaf, 0x3, 
       0x2, 0x2, 0x2, 0xdb0, 0xdb1, 0x3, 0x2, 0x2, 0x2, 0xdb1, 0xdb2, 0x3, 
       0x2, 0x2, 0x2, 0xdb2, 0xdb4, 0x5, 0x188, 0xc5, 0x2, 0xdb3, 0xdb5, 
       0x5, 0x258, 0x12d, 0x2, 0xdb4, 0xdb3, 0x3, 0x2, 0x2, 0x2, 0xdb4, 
       0xdb5, 0x3, 0x2, 0x2, 0x2, 0xdb5, 0x1db, 0x3, 0x2, 0x2, 0x2, 0xdb6, 
       0xdb7, 0x7, 0x1fa, 0x2, 0x2, 0xdb7, 0xdb8, 0x5, 0x188, 0xc5, 0x2, 
       0xdb8, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0xdb9, 0xdbb, 0x7, 0x40, 0x2, 0x2, 
       0xdba, 0xdbc, 0x5, 0x2d2, 0x16a, 0x2, 0xdbb, 0xdba, 0x3, 0x2, 0x2, 
       0x2, 0xdbb, 0xdbc, 0x3, 0x2, 0x2, 0x2, 0xdbc, 0xdbd, 0x3, 0x2, 0x2, 
       0x2, 0xdbd, 0xdbe, 0x5, 0x45a, 0x22e, 0x2, 0xdbe, 0xdbf, 0x9, 0x8, 
       0x2, 0x2, 0xdbf, 0x1df, 0x3, 0x2, 0x2, 0x2, 0xdc0, 0xdc1, 0x7, 0x1fb, 
       0x2, 0x2, 0xdc1, 0xdc2, 0x5, 0x188, 0xc5, 0x2, 0xdc2, 0x1e1, 0x3, 
       0x2, 0x2, 0x2, 0xdc3, 0xdc4, 0x7, 0x1fc, 0x2, 0x2, 0xdc4, 0xdc5, 
       0x5, 0x188, 0xc5, 0x2, 0xdc5, 0x1e3, 0x3, 0x2, 0x2, 0x2, 0xdc6, 0xdc7, 
       0x7, 0x1fd, 0x2, 0x2, 0xdc7, 0xdc8, 0x5, 0x188, 0xc5, 0x2, 0xdc8, 
       0x1e5, 0x3, 0x2, 0x2, 0x2, 0xdc9, 0xdca, 0x7, 0x1fe, 0x2, 0x2, 0xdca, 
       0xdcb, 0x5, 0x188, 0xc5, 0x2, 0xdcb, 0x1e7, 0x3, 0x2, 0x2, 0x2, 0xdcc, 
       0xdcd, 0x7, 0x1ff, 0x2, 0x2, 0xdcd, 0xdce, 0x5, 0x188, 0xc5, 0x2, 
       0xdce, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0xdcf, 0xdd0, 0x7, 0x200, 0x2, 
       0x2, 0xdd0, 0xdd1, 0x5, 0x188, 0xc5, 0x2, 0xdd1, 0x1eb, 0x3, 0x2, 
       0x2, 0x2, 0xdd2, 0xdd4, 0x7, 0x41, 0x2, 0x2, 0xdd3, 0xdd5, 0x5, 0x2d2, 
       0x16a, 0x2, 0xdd4, 0xdd3, 0x3, 0x2, 0x2, 0x2, 0xdd4, 0xdd5, 0x3, 
       0x2, 0x2, 0x2, 0xdd5, 0xdd6, 0x3, 0x2, 0x2, 0x2, 0xdd6, 0xdd7, 0x5, 
       0x45a, 0x22e, 0x2, 0xdd7, 0xdd8, 0x9, 0x8, 0x2, 0x2, 0xdd8, 0x1ed, 
       0x3, 0x2, 0x2, 0x2, 0xdd9, 0xdda, 0x7, 0x201, 0x2, 0x2, 0xdda, 0xddb, 
       0x5, 0x188, 0xc5, 0x2, 0xddb, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0xddc, 0xddd, 
       0x7, 0x202, 0x2, 0x2, 0xddd, 0xdde, 0x5, 0x188, 0xc5, 0x2, 0xdde, 
       0x1f1, 0x3, 0x2, 0x2, 0x2, 0xddf, 0xde0, 0x7, 0x203, 0x2, 0x2, 0xde0, 
       0xde1, 0x5, 0x188, 0xc5, 0x2, 0xde1, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0xde2, 
       0xde3, 0x7, 0x204, 0x2, 0x2, 0xde3, 0xde4, 0x5, 0x188, 0xc5, 0x2, 
       0xde4, 0x1f5, 0x3, 0x2, 0x2, 0x2, 0xde5, 0xde6, 0x7, 0x205, 0x2, 
       0x2, 0xde6, 0xde7, 0x5, 0x188, 0xc5, 0x2, 0xde7, 0x1f7, 0x3, 0x2, 
       0x2, 0x2, 0xde8, 0xde9, 0x7, 0x206, 0x2, 0x2, 0xde9, 0xdea, 0x5, 
       0x188, 0xc5, 0x2, 0xdea, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0xdeb, 0xded, 
       0x7, 0x42, 0x2, 0x2, 0xdec, 0xdee, 0x5, 0x2d2, 0x16a, 0x2, 0xded, 
       0xdec, 0x3, 0x2, 0x2, 0x2, 0xded, 0xdee, 0x3, 0x2, 0x2, 0x2, 0xdee, 
       0xdef, 0x3, 0x2, 0x2, 0x2, 0xdef, 0xdf0, 0x5, 0x188, 0xc5, 0x2, 0xdf0, 
       0x1fb, 0x3, 0x2, 0x2, 0x2, 0xdf1, 0xdf3, 0x7, 0x43, 0x2, 0x2, 0xdf2, 
       0xdf4, 0x5, 0x2d2, 0x16a, 0x2, 0xdf3, 0xdf2, 0x3, 0x2, 0x2, 0x2, 
       0xdf3, 0xdf4, 0x3, 0x2, 0x2, 0x2, 0xdf4, 0xdf5, 0x3, 0x2, 0x2, 0x2, 
       0xdf5, 0xdf6, 0x5, 0x188, 0xc5, 0x2, 0xdf6, 0x1fd, 0x3, 0x2, 0x2, 
       0x2, 0xdf7, 0xdf8, 0x7, 0x44, 0x2, 0x2, 0xdf8, 0xdf9, 0x5, 0x188, 
       0xc5, 0x2, 0xdf9, 0x1ff, 0x3, 0x2, 0x2, 0x2, 0xdfa, 0xdfc, 0x7, 0x45, 
       0x2, 0x2, 0xdfb, 0xdfd, 0x5, 0x2d2, 0x16a, 0x2, 0xdfc, 0xdfb, 0x3, 
       0x2, 0x2, 0x2, 0xdfc, 0xdfd, 0x3, 0x2, 0x2, 0x2, 0xdfd, 0xdfe, 0x3, 
       0x2, 0x2, 0x2, 0xdfe, 0xdff, 0x5, 0x188, 0xc5, 0x2, 0xdff, 0x201, 
       0x3, 0x2, 0x2, 0x2, 0xe00, 0xe01, 0x7, 0x207, 0x2, 0x2, 0xe01, 0xe02, 
       0x5, 0x188, 0xc5, 0x2, 0xe02, 0x203, 0x3, 0x2, 0x2, 0x2, 0xe03, 0xe04, 
       0x7, 0x208, 0x2, 0x2, 0xe04, 0xe05, 0x5, 0x188, 0xc5, 0x2, 0xe05, 
       0x205, 0x3, 0x2, 0x2, 0x2, 0xe06, 0xe07, 0x7, 0x46, 0x2, 0x2, 0xe07, 
       0xe08, 0x5, 0x188, 0xc5, 0x2, 0xe08, 0x207, 0x3, 0x2, 0x2, 0x2, 0xe09, 
       0xe0a, 0x7, 0x47, 0x2, 0x2, 0xe0a, 0xe0b, 0x5, 0x188, 0xc5, 0x2, 
       0xe0b, 0x209, 0x3, 0x2, 0x2, 0x2, 0xe0c, 0xe0d, 0x7, 0x48, 0x2, 0x2, 
       0xe0d, 0xe0e, 0x5, 0x188, 0xc5, 0x2, 0xe0e, 0x20b, 0x3, 0x2, 0x2, 
       0x2, 0xe0f, 0xe10, 0x7, 0x49, 0x2, 0x2, 0xe10, 0xe11, 0x5, 0x188, 
       0xc5, 0x2, 0xe11, 0x20d, 0x3, 0x2, 0x2, 0x2, 0xe12, 0xe13, 0x7, 0x4a, 
       0x2, 0x2, 0xe13, 0xe14, 0x5, 0x188, 0xc5, 0x2, 0xe14, 0x20f, 0x3, 
       0x2, 0x2, 0x2, 0xe15, 0xe17, 0x7, 0x4c, 0x2, 0x2, 0xe16, 0xe18, 0x5, 
       0x2d2, 0x16a, 0x2, 0xe17, 0xe16, 0x3, 0x2, 0x2, 0x2, 0xe17, 0xe18, 
       0x3, 0x2, 0x2, 0x2, 0xe18, 0xe19, 0x3, 0x2, 0x2, 0x2, 0xe19, 0xe1a, 
       0x5, 0x49a, 0x24e, 0x2, 0xe1a, 0xe1b, 0x5, 0x47a, 0x23e, 0x2, 0xe1b, 
       0xe1c, 0x5, 0x45a, 0x22e, 0x2, 0xe1c, 0xe1d, 0x9, 0x8, 0x2, 0x2, 
       0xe1d, 0x211, 0x3, 0x2, 0x2, 0x2, 0xe1e, 0xe1f, 0x7, 0x4e, 0x2, 0x2, 
       0xe1f, 0xe20, 0x5, 0x45a, 0x22e, 0x2, 0xe20, 0xe21, 0x9, 0x8, 0x2, 
       0x2, 0xe21, 0x213, 0x3, 0x2, 0x2, 0x2, 0xe22, 0xe24, 0x7, 0x4d, 0x2, 
       0x2, 0xe23, 0xe25, 0x5, 0x2d2, 0x16a, 0x2, 0xe24, 0xe23, 0x3, 0x2, 
       0x2, 0x2, 0xe24, 0xe25, 0x3, 0x2, 0x2, 0x2, 0xe25, 0xe26, 0x3, 0x2, 
       0x2, 0x2, 0xe26, 0xe27, 0x5, 0x45a, 0x22e, 0x2, 0xe27, 0xe28, 0x9, 
       0x8, 0x2, 0x2, 0xe28, 0x215, 0x3, 0x2, 0x2, 0x2, 0xe29, 0xe2a, 0x7, 
       0x4f, 0x2, 0x2, 0xe2a, 0xe2b, 0x5, 0x188, 0xc5, 0x2, 0xe2b, 0x217, 
       0x3, 0x2, 0x2, 0x2, 0xe2c, 0xe2e, 0x7, 0x50, 0x2, 0x2, 0xe2d, 0xe2f, 
       0x5, 0x2d2, 0x16a, 0x2, 0xe2e, 0xe2d, 0x3, 0x2, 0x2, 0x2, 0xe2e, 
       0xe2f, 0x3, 0x2, 0x2, 0x2, 0xe2f, 0xe30, 0x3, 0x2, 0x2, 0x2, 0xe30, 
       0xe31, 0x5, 0x188, 0xc5, 0x2, 0xe31, 0x219, 0x3, 0x2, 0x2, 0x2, 0xe32, 
       0xe33, 0x7, 0x51, 0x2, 0x2, 0xe33, 0xe34, 0x5, 0x188, 0xc5, 0x2, 
       0xe34, 0x21b, 0x3, 0x2, 0x2, 0x2, 0xe35, 0xe37, 0x7, 0x209, 0x2, 
       0x2, 0xe36, 0xe38, 0x5, 0x2d2, 0x16a, 0x2, 0xe37, 0xe36, 0x3, 0x2, 
       0x2, 0x2, 0xe37, 0xe38, 0x3, 0x2, 0x2, 0x2, 0xe38, 0xe39, 0x3, 0x2, 
       0x2, 0x2, 0xe39, 0xe3a, 0x5, 0x188, 0xc5, 0x2, 0xe3a, 0x21d, 0x3, 
       0x2, 0x2, 0x2, 0xe3b, 0xe3d, 0x7, 0x52, 0x2, 0x2, 0xe3c, 0xe3e, 0x5, 
       0x2d2, 0x16a, 0x2, 0xe3d, 0xe3c, 0x3, 0x2, 0x2, 0x2, 0xe3d, 0xe3e, 
       0x3, 0x2, 0x2, 0x2, 0xe3e, 0xe3f, 0x3, 0x2, 0x2, 0x2, 0xe3f, 0xe40, 
       0x5, 0x188, 0xc5, 0x2, 0xe40, 0x21f, 0x3, 0x2, 0x2, 0x2, 0xe41, 0xe43, 
       0x7, 0x53, 0x2, 0x2, 0xe42, 0xe44, 0x5, 0x2d2, 0x16a, 0x2, 0xe43, 
       0xe42, 0x3, 0x2, 0x2, 0x2, 0xe43, 0xe44, 0x3, 0x2, 0x2, 0x2, 0xe44, 
       0xe45, 0x3, 0x2, 0x2, 0x2, 0xe45, 0xe48, 0x5, 0x46e, 0x238, 0x2, 
       0xe46, 0xe47, 0x7, 0x1bf, 0x2, 0x2, 0xe47, 0xe49, 0x5, 0x46e, 0x238, 
       0x2, 0xe48, 0xe46, 0x3, 0x2, 0x2, 0x2, 0xe48, 0xe49, 0x3, 0x2, 0x2, 
       0x2, 0xe49, 0xe5a, 0x3, 0x2, 0x2, 0x2, 0xe4a, 0xe4b, 0x7, 0x1c0, 
       0x2, 0x2, 0xe4b, 0xe4d, 0x5, 0x222, 0x112, 0x2, 0xe4c, 0xe4a, 0x3, 
       0x2, 0x2, 0x2, 0xe4c, 0xe4d, 0x3, 0x2, 0x2, 0x2, 0xe4d, 0xe50, 0x3, 
       0x2, 0x2, 0x2, 0xe4e, 0xe4f, 0x9, 0x10, 0x2, 0x2, 0xe4f, 0xe51, 0x5, 
       0x224, 0x113, 0x2, 0xe50, 0xe4e, 0x3, 0x2, 0x2, 0x2, 0xe50, 0xe51, 
       0x3, 0x2, 0x2, 0x2, 0xe51, 0xe5b, 0x3, 0x2, 0x2, 0x2, 0xe52, 0xe53, 
       0x9, 0x10, 0x2, 0x2, 0xe53, 0xe55, 0x5, 0x224, 0x113, 0x2, 0xe54, 
       0xe52, 0x3, 0x2, 0x2, 0x2, 0xe54, 0xe55, 0x3, 0x2, 0x2, 0x2, 0xe55, 
       0xe58, 0x3, 0x2, 0x2, 0x2, 0xe56, 0xe57, 0x7, 0x1c0, 0x2, 0x2, 0xe57, 
       0xe59, 0x5, 0x222, 0x112, 0x2, 0xe58, 0xe56, 0x3, 0x2, 0x2, 0x2, 
       0xe58, 0xe59, 0x3, 0x2, 0x2, 0x2, 0xe59, 0xe5b, 0x3, 0x2, 0x2, 0x2, 
       0xe5a, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0xe5a, 0xe54, 0x3, 0x2, 0x2, 0x2, 
       0xe5b, 0xe5c, 0x3, 0x2, 0x2, 0x2, 0xe5c, 0xe5d, 0x9, 0x8, 0x2, 0x2, 
       0xe5d, 0x221, 0x3, 0x2, 0x2, 0x2, 0xe5e, 0xe5f, 0x5, 0x46e, 0x238, 
       0x2, 0xe5f, 0x223, 0x3, 0x2, 0x2, 0x2, 0xe60, 0xe61, 0x5, 0x46e, 
       0x238, 0x2, 0xe61, 0x225, 0x3, 0x2, 0x2, 0x2, 0xe62, 0xe63, 0x7, 
       0x54, 0x2, 0x2, 0xe63, 0xe64, 0x5, 0x188, 0xc5, 0x2, 0xe64, 0x227, 
       0x3, 0x2, 0x2, 0x2, 0xe65, 0xe66, 0x7, 0x20a, 0x2, 0x2, 0xe66, 0xe67, 
       0x5, 0x188, 0xc5, 0x2, 0xe67, 0x229, 0x3, 0x2, 0x2, 0x2, 0xe68, 0xe6a, 
       0x7, 0x55, 0x2, 0x2, 0xe69, 0xe6b, 0x5, 0x2d2, 0x16a, 0x2, 0xe6a, 
       0xe69, 0x3, 0x2, 0x2, 0x2, 0xe6a, 0xe6b, 0x3, 0x2, 0x2, 0x2, 0xe6b, 
       0xe6c, 0x3, 0x2, 0x2, 0x2, 0xe6c, 0xe6d, 0x5, 0x45a, 0x22e, 0x2, 
       0xe6d, 0xe6e, 0x9, 0x8, 0x2, 0x2, 0xe6e, 0x22b, 0x3, 0x2, 0x2, 0x2, 
       0xe6f, 0xe70, 0x7, 0x20b, 0x2, 0x2, 0xe70, 0xe71, 0x5, 0x188, 0xc5, 
       0x2, 0xe71, 0x22d, 0x3, 0x2, 0x2, 0x2, 0xe72, 0xe73, 0x7, 0x20c, 
       0x2, 0x2, 0xe73, 0xe74, 0x5, 0x188, 0xc5, 0x2, 0xe74, 0x22f, 0x3, 
       0x2, 0x2, 0x2, 0xe75, 0xe76, 0x7, 0x20d, 0x2, 0x2, 0xe76, 0xe77, 
       0x5, 0x188, 0xc5, 0x2, 0xe77, 0x231, 0x3, 0x2, 0x2, 0x2, 0xe78, 0xe79, 
       0x7, 0x20e, 0x2, 0x2, 0xe79, 0xe7a, 0x5, 0x188, 0xc5, 0x2, 0xe7a, 
       0x233, 0x3, 0x2, 0x2, 0x2, 0xe7b, 0xe7c, 0x7, 0x20f, 0x2, 0x2, 0xe7c, 
       0xe7d, 0x5, 0x188, 0xc5, 0x2, 0xe7d, 0x235, 0x3, 0x2, 0x2, 0x2, 0xe7e, 
       0xe7f, 0x7, 0x210, 0x2, 0x2, 0xe7f, 0xe80, 0x5, 0x188, 0xc5, 0x2, 
       0xe80, 0x237, 0x3, 0x2, 0x2, 0x2, 0xe81, 0xe83, 0x7, 0x56, 0x2, 0x2, 
       0xe82, 0xe84, 0x5, 0x2d2, 0x16a, 0x2, 0xe83, 0xe82, 0x3, 0x2, 0x2, 
       0x2, 0xe83, 0xe84, 0x3, 0x2, 0x2, 0x2, 0xe84, 0xe85, 0x3, 0x2, 0x2, 
       0x2, 0xe85, 0xe86, 0x5, 0x188, 0xc5, 0x2, 0xe86, 0x239, 0x3, 0x2, 
       0x2, 0x2, 0xe87, 0xe88, 0x7, 0x57, 0x2, 0x2, 0xe88, 0xe89, 0x5, 0x188, 
       0xc5, 0x2, 0xe89, 0x23b, 0x3, 0x2, 0x2, 0x2, 0xe8a, 0xe8b, 0x7, 0x212, 
       0x2, 0x2, 0xe8b, 0xe8f, 0x5, 0x188, 0xc5, 0x2, 0xe8c, 0xe8e, 0x5, 
       0x23e, 0x120, 0x2, 0xe8d, 0xe8c, 0x3, 0x2, 0x2, 0x2, 0xe8e, 0xe91, 
       0x3, 0x2, 0x2, 0x2, 0xe8f, 0xe8d, 0x3, 0x2, 0x2, 0x2, 0xe8f, 0xe90, 
       0x3, 0x2, 0x2, 0x2, 0xe90, 0x23d, 0x3, 0x2, 0x2, 0x2, 0xe91, 0xe8f, 
       0x3, 0x2, 0x2, 0x2, 0xe92, 0xe93, 0x7, 0xb, 0x2, 0x2, 0xe93, 0xe94, 
       0x7, 0x2b3, 0x2, 0x2, 0xe94, 0xe95, 0x7, 0x2b1, 0x2, 0x2, 0xe95, 
       0xe96, 0x7, 0x2b3, 0x2, 0x2, 0xe96, 0xe97, 0x7, 0x29f, 0x2, 0x2, 
       0xe97, 0xe98, 0x7, 0x211, 0x2, 0x2, 0xe98, 0xe99, 0x5, 0x188, 0xc5, 
       0x2, 0xe99, 0x23f, 0x3, 0x2, 0x2, 0x2, 0xe9a, 0xe9b, 0x7, 0x58, 0x2, 
       0x2, 0xe9b, 0xe9c, 0x5, 0x188, 0xc5, 0x2, 0xe9c, 0x241, 0x3, 0x2, 
       0x2, 0x2, 0xe9d, 0xe9e, 0x7, 0x59, 0x2, 0x2, 0xe9e, 0xe9f, 0x5, 0x188, 
       0xc5, 0x2, 0xe9f, 0x243, 0x3, 0x2, 0x2, 0x2, 0xea0, 0xea1, 0x7, 0x213, 
       0x2, 0x2, 0xea1, 0xea2, 0x5, 0x188, 0xc5, 0x2, 0xea2, 0x245, 0x3, 
       0x2, 0x2, 0x2, 0xea3, 0xea4, 0x7, 0x214, 0x2, 0x2, 0xea4, 0xea5, 
       0x5, 0x188, 0xc5, 0x2, 0xea5, 0x247, 0x3, 0x2, 0x2, 0x2, 0xea6, 0xea7, 
       0x7, 0x215, 0x2, 0x2, 0xea7, 0xea8, 0x5, 0x188, 0xc5, 0x2, 0xea8, 
       0x249, 0x3, 0x2, 0x2, 0x2, 0xea9, 0xeaa, 0x7, 0x216, 0x2, 0x2, 0xeaa, 
       0xeab, 0x5, 0x188, 0xc5, 0x2, 0xeab, 0x24b, 0x3, 0x2, 0x2, 0x2, 0xeac, 
       0xead, 0x7, 0x217, 0x2, 0x2, 0xead, 0xeae, 0x5, 0x188, 0xc5, 0x2, 
       0xeae, 0x24d, 0x3, 0x2, 0x2, 0x2, 0xeaf, 0xeb0, 0x7, 0x5a, 0x2, 0x2, 
       0xeb0, 0xeb1, 0x5, 0x188, 0xc5, 0x2, 0xeb1, 0x24f, 0x3, 0x2, 0x2, 
       0x2, 0xeb2, 0xeb4, 0x7, 0x218, 0x2, 0x2, 0xeb3, 0xeb5, 0x5, 0x2d2, 
       0x16a, 0x2, 0xeb4, 0xeb3, 0x3, 0x2, 0x2, 0x2, 0xeb4, 0xeb5, 0x3, 
       0x2, 0x2, 0x2, 0xeb5, 0xeb6, 0x3, 0x2, 0x2, 0x2, 0xeb6, 0xeb7, 0x5, 
       0x188, 0xc5, 0x2, 0xeb7, 0x251, 0x3, 0x2, 0x2, 0x2, 0xeb8, 0xeba, 
       0x7, 0x219, 0x2, 0x2, 0xeb9, 0xebb, 0x5, 0x2d2, 0x16a, 0x2, 0xeba, 
       0xeb9, 0x3, 0x2, 0x2, 0x2, 0xeba, 0xebb, 0x3, 0x2, 0x2, 0x2, 0xebb, 
       0xebc, 0x3, 0x2, 0x2, 0x2, 0xebc, 0xebd, 0x5, 0x188, 0xc5, 0x2, 0xebd, 
       0x253, 0x3, 0x2, 0x2, 0x2, 0xebe, 0xec0, 0x7, 0x21a, 0x2, 0x2, 0xebf, 
       0xec1, 0x5, 0x2d2, 0x16a, 0x2, 0xec0, 0xebf, 0x3, 0x2, 0x2, 0x2, 
       0xec0, 0xec1, 0x3, 0x2, 0x2, 0x2, 0xec1, 0xec2, 0x3, 0x2, 0x2, 0x2, 
       0xec2, 0xec3, 0x5, 0x188, 0xc5, 0x2, 0xec3, 0x255, 0x3, 0x2, 0x2, 
       0x2, 0xec4, 0xec6, 0x7, 0x21b, 0x2, 0x2, 0xec5, 0xec7, 0x5, 0x2d2, 
       0x16a, 0x2, 0xec6, 0xec5, 0x3, 0x2, 0x2, 0x2, 0xec6, 0xec7, 0x3, 
       0x2, 0x2, 0x2, 0xec7, 0xec8, 0x3, 0x2, 0x2, 0x2, 0xec8, 0xec9, 0x5, 
       0x188, 0xc5, 0x2, 0xec9, 0x257, 0x3, 0x2, 0x2, 0x2, 0xeca, 0xecb, 
       0x7, 0xb, 0x2, 0x2, 0xecb, 0xecc, 0x7, 0x2b3, 0x2, 0x2, 0xecc, 0xecd, 
       0x7, 0x2b1, 0x2, 0x2, 0xecd, 0xece, 0x7, 0x2b3, 0x2, 0x2, 0xece, 
       0xecf, 0x7, 0x29f, 0x2, 0x2, 0xecf, 0xed0, 0x7, 0x21c, 0x2, 0x2, 
       0xed0, 0xed1, 0x5, 0x188, 0xc5, 0x2, 0xed1, 0x259, 0x3, 0x2, 0x2, 
       0x2, 0xed2, 0xed4, 0x7, 0x5b, 0x2, 0x2, 0xed3, 0xed5, 0x5, 0x2d2, 
       0x16a, 0x2, 0xed4, 0xed3, 0x3, 0x2, 0x2, 0x2, 0xed4, 0xed5, 0x3, 
       0x2, 0x2, 0x2, 0xed5, 0xed6, 0x3, 0x2, 0x2, 0x2, 0xed6, 0xed7, 0x5, 
       0x188, 0xc5, 0x2, 0xed7, 0x25b, 0x3, 0x2, 0x2, 0x2, 0xed8, 0xeda, 
       0x7, 0x21d, 0x2, 0x2, 0xed9, 0xedb, 0x5, 0x2d2, 0x16a, 0x2, 0xeda, 
       0xed9, 0x3, 0x2, 0x2, 0x2, 0xeda, 0xedb, 0x3, 0x2, 0x2, 0x2, 0xedb, 
       0xedc, 0x3, 0x2, 0x2, 0x2, 0xedc, 0xedd, 0x5, 0x188, 0xc5, 0x2, 0xedd, 
       0x25d, 0x3, 0x2, 0x2, 0x2, 0xede, 0xee7, 0x7, 0x5c, 0x2, 0x2, 0xedf, 
       0xee4, 0x5, 0x260, 0x131, 0x2, 0xee0, 0xee1, 0x7, 0x1a, 0x2, 0x2, 
       0xee1, 0xee3, 0x5, 0x260, 0x131, 0x2, 0xee2, 0xee0, 0x3, 0x2, 0x2, 
       0x2, 0xee3, 0xee6, 0x3, 0x2, 0x2, 0x2, 0xee4, 0xee2, 0x3, 0x2, 0x2, 
       0x2, 0xee4, 0xee5, 0x3, 0x2, 0x2, 0x2, 0xee5, 0xee8, 0x3, 0x2, 0x2, 
       0x2, 0xee6, 0xee4, 0x3, 0x2, 0x2, 0x2, 0xee7, 0xedf, 0x3, 0x2, 0x2, 
       0x2, 0xee7, 0xee8, 0x3, 0x2, 0x2, 0x2, 0xee8, 0xee9, 0x3, 0x2, 0x2, 
       0x2, 0xee9, 0xeea, 0x9, 0x8, 0x2, 0x2, 0xeea, 0x25f, 0x3, 0x2, 0x2, 
       0x2, 0xeeb, 0xeee, 0x5, 0x480, 0x241, 0x2, 0xeec, 0xeee, 0x5, 0x48e, 
       0x248, 0x2, 0xeed, 0xeeb, 0x3, 0x2, 0x2, 0x2, 0xeed, 0xeec, 0x3, 
       0x2, 0x2, 0x2, 0xeee, 0x261, 0x3, 0x2, 0x2, 0x2, 0xeef, 0xef1, 0x7, 
       0x5d, 0x2, 0x2, 0xef0, 0xef2, 0x5, 0x2d2, 0x16a, 0x2, 0xef1, 0xef0, 
       0x3, 0x2, 0x2, 0x2, 0xef1, 0xef2, 0x3, 0x2, 0x2, 0x2, 0xef2, 0xef3, 
       0x3, 0x2, 0x2, 0x2, 0xef3, 0xef4, 0x5, 0x188, 0xc5, 0x2, 0xef4, 0x263, 
       0x3, 0x2, 0x2, 0x2, 0xef5, 0xef6, 0x7, 0x21e, 0x2, 0x2, 0xef6, 0xef7, 
       0x5, 0x188, 0xc5, 0x2, 0xef7, 0x265, 0x3, 0x2, 0x2, 0x2, 0xef8, 0xef9, 
       0x7, 0x21f, 0x2, 0x2, 0xef9, 0xefa, 0x5, 0x188, 0xc5, 0x2, 0xefa, 
       0x267, 0x3, 0x2, 0x2, 0x2, 0xefb, 0xefc, 0x7, 0x220, 0x2, 0x2, 0xefc, 
       0xefd, 0x5, 0x188, 0xc5, 0x2, 0xefd, 0x269, 0x3, 0x2, 0x2, 0x2, 0xefe, 
       0xeff, 0x7, 0x221, 0x2, 0x2, 0xeff, 0xf00, 0x5, 0x188, 0xc5, 0x2, 
       0xf00, 0x26b, 0x3, 0x2, 0x2, 0x2, 0xf01, 0xf02, 0x7, 0x222, 0x2, 
       0x2, 0xf02, 0xf03, 0x5, 0x188, 0xc5, 0x2, 0xf03, 0x26d, 0x3, 0x2, 
       0x2, 0x2, 0xf04, 0xf05, 0x7, 0x223, 0x2, 0x2, 0xf05, 0xf06, 0x5, 
       0x188, 0xc5, 0x2, 0xf06, 0x26f, 0x3, 0x2, 0x2, 0x2, 0xf07, 0xf08, 
       0x7, 0x5e, 0x2, 0x2, 0xf08, 0xf09, 0x5, 0x188, 0xc5, 0x2, 0xf09, 
       0x271, 0x3, 0x2, 0x2, 0x2, 0xf0a, 0xf0c, 0x7, 0x5f, 0x2, 0x2, 0xf0b, 
       0xf0d, 0x5, 0x2d2, 0x16a, 0x2, 0xf0c, 0xf0b, 0x3, 0x2, 0x2, 0x2, 
       0xf0c, 0xf0d, 0x3, 0x2, 0x2, 0x2, 0xf0d, 0xf0e, 0x3, 0x2, 0x2, 0x2, 
       0xf0e, 0xf0f, 0x5, 0x188, 0xc5, 0x2, 0xf0f, 0x273, 0x3, 0x2, 0x2, 
       0x2, 0xf10, 0xf11, 0x7, 0xb, 0x2, 0x2, 0xf11, 0xf12, 0x7, 0x2b3, 
       0x2, 0x2, 0xf12, 0xf13, 0x7, 0x2b1, 0x2, 0x2, 0xf13, 0xf14, 0x7, 
       0x2b3, 0x2, 0x2, 0xf14, 0xf15, 0x5, 0x2d4, 0x16b, 0x2, 0xf15, 0xf16, 
       0x7, 0x224, 0x2, 0x2, 0xf16, 0xf17, 0x5, 0x188, 0xc5, 0x2, 0xf17, 
       0x275, 0x3, 0x2, 0x2, 0x2, 0xf18, 0xf19, 0x7, 0x225, 0x2, 0x2, 0xf19, 
       0xf1d, 0x5, 0x188, 0xc5, 0x2, 0xf1a, 0xf1c, 0x5, 0x274, 0x13b, 0x2, 
       0xf1b, 0xf1a, 0x3, 0x2, 0x2, 0x2, 0xf1c, 0xf1f, 0x3, 0x2, 0x2, 0x2, 
       0xf1d, 0xf1b, 0x3, 0x2, 0x2, 0x2, 0xf1d, 0xf1e, 0x3, 0x2, 0x2, 0x2, 
       0xf1e, 0x277, 0x3, 0x2, 0x2, 0x2, 0xf1f, 0xf1d, 0x3, 0x2, 0x2, 0x2, 
       0xf20, 0xf22, 0x7, 0x60, 0x2, 0x2, 0xf21, 0xf23, 0x5, 0x2d2, 0x16a, 
       0x2, 0xf22, 0xf21, 0x3, 0x2, 0x2, 0x2, 0xf22, 0xf23, 0x3, 0x2, 0x2, 
       0x2, 0xf23, 0xf24, 0x3, 0x2, 0x2, 0x2, 0xf24, 0xf25, 0x5, 0x188, 
       0xc5, 0x2, 0xf25, 0x279, 0x3, 0x2, 0x2, 0x2, 0xf26, 0xf28, 0x7, 0x61, 
       0x2, 0x2, 0xf27, 0xf29, 0x5, 0x2d2, 0x16a, 0x2, 0xf28, 0xf27, 0x3, 
       0x2, 0x2, 0x2, 0xf28, 0xf29, 0x3, 0x2, 0x2, 0x2, 0xf29, 0xf2a, 0x3, 
       0x2, 0x2, 0x2, 0xf2a, 0xf2b, 0x5, 0x188, 0xc5, 0x2, 0xf2b, 0x27b, 
       0x3, 0x2, 0x2, 0x2, 0xf2c, 0xf2e, 0x7, 0x62, 0x2, 0x2, 0xf2d, 0xf2f, 
       0x5, 0x2d2, 0x16a, 0x2, 0xf2e, 0xf2d, 0x3, 0x2, 0x2, 0x2, 0xf2e, 
       0xf2f, 0x3, 0x2, 0x2, 0x2, 0xf2f, 0xf30, 0x3, 0x2, 0x2, 0x2, 0xf30, 
       0xf31, 0x5, 0x188, 0xc5, 0x2, 0xf31, 0x27d, 0x3, 0x2, 0x2, 0x2, 0xf32, 
       0xf34, 0x7, 0x63, 0x2, 0x2, 0xf33, 0xf35, 0x5, 0x2d2, 0x16a, 0x2, 
       0xf34, 0xf33, 0x3, 0x2, 0x2, 0x2, 0xf34, 0xf35, 0x3, 0x2, 0x2, 0x2, 
       0xf35, 0xf36, 0x3, 0x2, 0x2, 0x2, 0xf36, 0xf37, 0x5, 0x188, 0xc5, 
       0x2, 0xf37, 0x27f, 0x3, 0x2, 0x2, 0x2, 0xf38, 0xf3a, 0x7, 0x64, 0x2, 
       0x2, 0xf39, 0xf3b, 0x5, 0x2d2, 0x16a, 0x2, 0xf3a, 0xf39, 0x3, 0x2, 
       0x2, 0x2, 0xf3a, 0xf3b, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf3c, 0x3, 0x2, 
       0x2, 0x2, 0xf3c, 0xf3d, 0x5, 0x188, 0xc5, 0x2, 0xf3d, 0x281, 0x3, 
       0x2, 0x2, 0x2, 0xf3e, 0xf40, 0x7, 0x65, 0x2, 0x2, 0xf3f, 0xf41, 0x5, 
       0x2d2, 0x16a, 0x2, 0xf40, 0xf3f, 0x3, 0x2, 0x2, 0x2, 0xf40, 0xf41, 
       0x3, 0x2, 0x2, 0x2, 0xf41, 0xf42, 0x3, 0x2, 0x2, 0x2, 0xf42, 0xf43, 
       0x5, 0x188, 0xc5, 0x2, 0xf43, 0x283, 0x3, 0x2, 0x2, 0x2, 0xf44, 0xf46, 
       0x7, 0x226, 0x2, 0x2, 0xf45, 0xf47, 0x5, 0x2d2, 0x16a, 0x2, 0xf46, 
       0xf45, 0x3, 0x2, 0x2, 0x2, 0xf46, 0xf47, 0x3, 0x2, 0x2, 0x2, 0xf47, 
       0xf48, 0x3, 0x2, 0x2, 0x2, 0xf48, 0xf49, 0x5, 0x188, 0xc5, 0x2, 0xf49, 
       0x285, 0x3, 0x2, 0x2, 0x2, 0xf4a, 0xf4c, 0x7, 0x66, 0x2, 0x2, 0xf4b, 
       0xf4d, 0x5, 0x2d2, 0x16a, 0x2, 0xf4c, 0xf4b, 0x3, 0x2, 0x2, 0x2, 
       0xf4c, 0xf4d, 0x3, 0x2, 0x2, 0x2, 0xf4d, 0xf4e, 0x3, 0x2, 0x2, 0x2, 
       0xf4e, 0xf4f, 0x5, 0x188, 0xc5, 0x2, 0xf4f, 0x287, 0x3, 0x2, 0x2, 
       0x2, 0xf50, 0xf52, 0x7, 0x67, 0x2, 0x2, 0xf51, 0xf53, 0x5, 0x2d2, 
       0x16a, 0x2, 0xf52, 0xf51, 0x3, 0x2, 0x2, 0x2, 0xf52, 0xf53, 0x3, 
       0x2, 0x2, 0x2, 0xf53, 0xf54, 0x3, 0x2, 0x2, 0x2, 0xf54, 0xf55, 0x5, 
       0x188, 0xc5, 0x2, 0xf55, 0x289, 0x3, 0x2, 0x2, 0x2, 0xf56, 0xf58, 
       0x7, 0x68, 0x2, 0x2, 0xf57, 0xf59, 0x5, 0x2d2, 0x16a, 0x2, 0xf58, 
       0xf57, 0x3, 0x2, 0x2, 0x2, 0xf58, 0xf59, 0x3, 0x2, 0x2, 0x2, 0xf59, 
       0xf5b, 0x3, 0x2, 0x2, 0x2, 0xf5a, 0xf5c, 0x5, 0x45a, 0x22e, 0x2, 
       0xf5b, 0xf5a, 0x3, 0x2, 0x2, 0x2, 0xf5b, 0xf5c, 0x3, 0x2, 0x2, 0x2, 
       0xf5c, 0xf5d, 0x3, 0x2, 0x2, 0x2, 0xf5d, 0xf5e, 0x9, 0x8, 0x2, 0x2, 
       0xf5e, 0x28b, 0x3, 0x2, 0x2, 0x2, 0xf5f, 0xf61, 0x7, 0x69, 0x2, 0x2, 
       0xf60, 0xf62, 0x5, 0x2d2, 0x16a, 0x2, 0xf61, 0xf60, 0x3, 0x2, 0x2, 
       0x2, 0xf61, 0xf62, 0x3, 0x2, 0x2, 0x2, 0xf62, 0xf63, 0x3, 0x2, 0x2, 
       0x2, 0xf63, 0xf64, 0x5, 0x188, 0xc5, 0x2, 0xf64, 0x28d, 0x3, 0x2, 
       0x2, 0x2, 0xf65, 0xf67, 0x7, 0x227, 0x2, 0x2, 0xf66, 0xf68, 0x5, 
       0x2d2, 0x16a, 0x2, 0xf67, 0xf66, 0x3, 0x2, 0x2, 0x2, 0xf67, 0xf68, 
       0x3, 0x2, 0x2, 0x2, 0xf68, 0xf69, 0x3, 0x2, 0x2, 0x2, 0xf69, 0xf6a, 
       0x5, 0x188, 0xc5, 0x2, 0xf6a, 0x28f, 0x3, 0x2, 0x2, 0x2, 0xf6b, 0xf6c, 
       0x7, 0x6a, 0x2, 0x2, 0xf6c, 0xf6d, 0x5, 0x188, 0xc5, 0x2, 0xf6d, 
       0x291, 0x3, 0x2, 0x2, 0x2, 0xf6e, 0xf70, 0x7, 0x6b, 0x2, 0x2, 0xf6f, 
       0xf71, 0x5, 0x2d2, 0x16a, 0x2, 0xf70, 0xf6f, 0x3, 0x2, 0x2, 0x2, 
       0xf70, 0xf71, 0x3, 0x2, 0x2, 0x2, 0xf71, 0xf72, 0x3, 0x2, 0x2, 0x2, 
       0xf72, 0xf73, 0x5, 0x188, 0xc5, 0x2, 0xf73, 0x293, 0x3, 0x2, 0x2, 
       0x2, 0xf74, 0xf76, 0x7, 0x6c, 0x2, 0x2, 0xf75, 0xf77, 0x5, 0x2d2, 
       0x16a, 0x2, 0xf76, 0xf75, 0x3, 0x2, 0x2, 0x2, 0xf76, 0xf77, 0x3, 
       0x2, 0x2, 0x2, 0xf77, 0xf78, 0x3, 0x2, 0x2, 0x2, 0xf78, 0xf79, 0x5, 
       0x188, 0xc5, 0x2, 0xf79, 0x295, 0x3, 0x2, 0x2, 0x2, 0xf7a, 0xf7b, 
       0x7, 0x228, 0x2, 0x2, 0xf7b, 0xf7c, 0x5, 0x188, 0xc5, 0x2, 0xf7c, 
       0x297, 0x3, 0x2, 0x2, 0x2, 0xf7d, 0xf7e, 0x7, 0x229, 0x2, 0x2, 0xf7e, 
       0xf7f, 0x5, 0x188, 0xc5, 0x2, 0xf7f, 0x299, 0x3, 0x2, 0x2, 0x2, 0xf80, 
       0xf81, 0x7, 0x22a, 0x2, 0x2, 0xf81, 0xf82, 0x5, 0x188, 0xc5, 0x2, 
       0xf82, 0x29b, 0x3, 0x2, 0x2, 0x2, 0xf83, 0xf85, 0x7, 0x6d, 0x2, 0x2, 
       0xf84, 0xf86, 0x5, 0x2d2, 0x16a, 0x2, 0xf85, 0xf84, 0x3, 0x2, 0x2, 
       0x2, 0xf85, 0xf86, 0x3, 0x2, 0x2, 0x2, 0xf86, 0xf87, 0x3, 0x2, 0x2, 
       0x2, 0xf87, 0xf88, 0x5, 0x45a, 0x22e, 0x2, 0xf88, 0xf89, 0x9, 0x8, 
       0x2, 0x2, 0xf89, 0x29d, 0x3, 0x2, 0x2, 0x2, 0xf8a, 0xf8c, 0x7, 0x22b, 
       0x2, 0x2, 0xf8b, 0xf8d, 0x5, 0x2d2, 0x16a, 0x2, 0xf8c, 0xf8b, 0x3, 
       0x2, 0x2, 0x2, 0xf8c, 0xf8d, 0x3, 0x2, 0x2, 0x2, 0xf8d, 0xf8e, 0x3, 
       0x2, 0x2, 0x2, 0xf8e, 0xf8f, 0x5, 0x188, 0xc5, 0x2, 0xf8f, 0x29f, 
       0x3, 0x2, 0x2, 0x2, 0xf90, 0xf92, 0x7, 0x22c, 0x2, 0x2, 0xf91, 0xf93, 
       0x5, 0x2d2, 0x16a, 0x2, 0xf92, 0xf91, 0x3, 0x2, 0x2, 0x2, 0xf92, 
       0xf93, 0x3, 0x2, 0x2, 0x2, 0xf93, 0xf94, 0x3, 0x2, 0x2, 0x2, 0xf94, 
       0xf95, 0x5, 0x188, 0xc5, 0x2, 0xf95, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0xf96, 
       0xf98, 0x7, 0x22d, 0x2, 0x2, 0xf97, 0xf99, 0x5, 0x2d2, 0x16a, 0x2, 
       0xf98, 0xf97, 0x3, 0x2, 0x2, 0x2, 0xf98, 0xf99, 0x3, 0x2, 0x2, 0x2, 
       0xf99, 0xf9a, 0x3, 0x2, 0x2, 0x2, 0xf9a, 0xf9b, 0x5, 0x188, 0xc5, 
       0x2, 0xf9b, 0x2a3, 0x3, 0x2, 0x2, 0x2, 0xf9c, 0xf9e, 0x7, 0x22e, 
       0x2, 0x2, 0xf9d, 0xf9f, 0x5, 0x2d2, 0x16a, 0x2, 0xf9e, 0xf9d, 0x3, 
       0x2, 0x2, 0x2, 0xf9e, 0xf9f, 0x3, 0x2, 0x2, 0x2, 0xf9f, 0xfa0, 0x3, 
       0x2, 0x2, 0x2, 0xfa0, 0xfa1, 0x5, 0x188, 0xc5, 0x2, 0xfa1, 0x2a5, 
       0x3, 0x2, 0x2, 0x2, 0xfa2, 0xfa3, 0x7, 0x22f, 0x2, 0x2, 0xfa3, 0xfa4, 
       0x5, 0x188, 0xc5, 0x2, 0xfa4, 0x2a7, 0x3, 0x2, 0x2, 0x2, 0xfa5, 0xfa7, 
       0x7, 0x6e, 0x2, 0x2, 0xfa6, 0xfa8, 0x5, 0x2d2, 0x16a, 0x2, 0xfa7, 
       0xfa6, 0x3, 0x2, 0x2, 0x2, 0xfa7, 0xfa8, 0x3, 0x2, 0x2, 0x2, 0xfa8, 
       0xfa9, 0x3, 0x2, 0x2, 0x2, 0xfa9, 0xfaa, 0x5, 0x188, 0xc5, 0x2, 0xfaa, 
       0x2a9, 0x3, 0x2, 0x2, 0x2, 0xfab, 0xfac, 0x7, 0x230, 0x2, 0x2, 0xfac, 
       0xfad, 0x5, 0x188, 0xc5, 0x2, 0xfad, 0x2ab, 0x3, 0x2, 0x2, 0x2, 0xfae, 
       0xfaf, 0x7, 0x231, 0x2, 0x2, 0xfaf, 0xfb0, 0x5, 0x188, 0xc5, 0x2, 
       0xfb0, 0x2ad, 0x3, 0x2, 0x2, 0x2, 0xfb1, 0xfb2, 0x7, 0x232, 0x2, 
       0x2, 0xfb2, 0xfb3, 0x5, 0x188, 0xc5, 0x2, 0xfb3, 0x2af, 0x3, 0x2, 
       0x2, 0x2, 0xfb4, 0xfb5, 0x7, 0x233, 0x2, 0x2, 0xfb5, 0xfb6, 0x5, 
       0x188, 0xc5, 0x2, 0xfb6, 0x2b1, 0x3, 0x2, 0x2, 0x2, 0xfb7, 0xfb9, 
       0x7, 0x6f, 0x2, 0x2, 0xfb8, 0xfba, 0x5, 0x2d2, 0x16a, 0x2, 0xfb9, 
       0xfb8, 0x3, 0x2, 0x2, 0x2, 0xfb9, 0xfba, 0x3, 0x2, 0x2, 0x2, 0xfba, 
       0xfbb, 0x3, 0x2, 0x2, 0x2, 0xfbb, 0xfbc, 0x5, 0x188, 0xc5, 0x2, 0xfbc, 
       0x2b3, 0x3, 0x2, 0x2, 0x2, 0xfbd, 0xfbf, 0x7, 0x70, 0x2, 0x2, 0xfbe, 
       0xfc0, 0x5, 0x2d2, 0x16a, 0x2, 0xfbf, 0xfbe, 0x3, 0x2, 0x2, 0x2, 
       0xfbf, 0xfc0, 0x3, 0x2, 0x2, 0x2, 0xfc0, 0xfc1, 0x3, 0x2, 0x2, 0x2, 
       0xfc1, 0xfc2, 0x5, 0x188, 0xc5, 0x2, 0xfc2, 0x2b5, 0x3, 0x2, 0x2, 
       0x2, 0xfc3, 0xfc5, 0x7, 0x71, 0x2, 0x2, 0xfc4, 0xfc6, 0x5, 0x2d2, 
       0x16a, 0x2, 0xfc5, 0xfc4, 0x3, 0x2, 0x2, 0x2, 0xfc5, 0xfc6, 0x3, 
       0x2, 0x2, 0x2, 0xfc6, 0xfc7, 0x3, 0x2, 0x2, 0x2, 0xfc7, 0xfc8, 0x5, 
       0x45a, 0x22e, 0x2, 0xfc8, 0xfc9, 0x9, 0x8, 0x2, 0x2, 0xfc9, 0x2b7, 
       0x3, 0x2, 0x2, 0x2, 0xfca, 0xfcb, 0x7, 0x234, 0x2, 0x2, 0xfcb, 0xfcc, 
       0x5, 0x188, 0xc5, 0x2, 0xfcc, 0x2b9, 0x3, 0x2, 0x2, 0x2, 0xfcd, 0xfce, 
       0x7, 0x235, 0x2, 0x2, 0xfce, 0xfcf, 0x5, 0x188, 0xc5, 0x2, 0xfcf, 
       0x2bb, 0x3, 0x2, 0x2, 0x2, 0xfd0, 0xfd1, 0x7, 0x236, 0x2, 0x2, 0xfd1, 
       0xfd2, 0x5, 0x188, 0xc5, 0x2, 0xfd2, 0x2bd, 0x3, 0x2, 0x2, 0x2, 0xfd3, 
       0xfd4, 0x7, 0x237, 0x2, 0x2, 0xfd4, 0xfd5, 0x5, 0x188, 0xc5, 0x2, 
       0xfd5, 0x2bf, 0x3, 0x2, 0x2, 0x2, 0xfd6, 0xfd7, 0x7, 0x238, 0x2, 
       0x2, 0xfd7, 0xfd8, 0x5, 0x188, 0xc5, 0x2, 0xfd8, 0x2c1, 0x3, 0x2, 
       0x2, 0x2, 0xfd9, 0xfda, 0x7, 0x239, 0x2, 0x2, 0xfda, 0xfdb, 0x5, 
       0x188, 0xc5, 0x2, 0xfdb, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0xfdc, 0xfde, 
       0x7, 0x72, 0x2, 0x2, 0xfdd, 0xfdf, 0x5, 0x2d2, 0x16a, 0x2, 0xfde, 
       0xfdd, 0x3, 0x2, 0x2, 0x2, 0xfde, 0xfdf, 0x3, 0x2, 0x2, 0x2, 0xfdf, 
       0xfe0, 0x3, 0x2, 0x2, 0x2, 0xfe0, 0xfe1, 0x5, 0x188, 0xc5, 0x2, 0xfe1, 
       0x2c5, 0x3, 0x2, 0x2, 0x2, 0xfe2, 0xfe4, 0x7, 0x23a, 0x2, 0x2, 0xfe3, 
       0xfe5, 0x5, 0x2d2, 0x16a, 0x2, 0xfe4, 0xfe3, 0x3, 0x2, 0x2, 0x2, 
       0xfe4, 0xfe5, 0x3, 0x2, 0x2, 0x2, 0xfe5, 0xfe6, 0x3, 0x2, 0x2, 0x2, 
       0xfe6, 0xfe7, 0x5, 0x188, 0xc5, 0x2, 0xfe7, 0x2c7, 0x3, 0x2, 0x2, 
       0x2, 0xfe8, 0xfea, 0x7, 0x23b, 0x2, 0x2, 0xfe9, 0xfeb, 0x5, 0x2d2, 
       0x16a, 0x2, 0xfea, 0xfe9, 0x3, 0x2, 0x2, 0x2, 0xfea, 0xfeb, 0x3, 
       0x2, 0x2, 0x2, 0xfeb, 0xfec, 0x3, 0x2, 0x2, 0x2, 0xfec, 0xfed, 0x5, 
       0x188, 0xc5, 0x2, 0xfed, 0x2c9, 0x3, 0x2, 0x2, 0x2, 0xfee, 0xff0, 
       0x7, 0x73, 0x2, 0x2, 0xfef, 0xff1, 0x5, 0x2d2, 0x16a, 0x2, 0xff0, 
       0xfef, 0x3, 0x2, 0x2, 0x2, 0xff0, 0xff1, 0x3, 0x2, 0x2, 0x2, 0xff1, 
       0xff2, 0x3, 0x2, 0x2, 0x2, 0xff2, 0xff3, 0x5, 0x45a, 0x22e, 0x2, 
       0xff3, 0xff4, 0x9, 0x8, 0x2, 0x2, 0xff4, 0x2cb, 0x3, 0x2, 0x2, 0x2, 
       0xff5, 0xff7, 0x7, 0x74, 0x2, 0x2, 0xff6, 0xff8, 0x5, 0x2d2, 0x16a, 
       0x2, 0xff7, 0xff6, 0x3, 0x2, 0x2, 0x2, 0xff7, 0xff8, 0x3, 0x2, 0x2, 
       0x2, 0xff8, 0xff9, 0x3, 0x2, 0x2, 0x2, 0xff9, 0xffa, 0x5, 0x45a, 
       0x22e, 0x2, 0xffa, 0xffb, 0x9, 0x8, 0x2, 0x2, 0xffb, 0x2cd, 0x3, 
       0x2, 0x2, 0x2, 0xffc, 0xffe, 0x7, 0x23c, 0x2, 0x2, 0xffd, 0xfff, 
       0x5, 0x2d2, 0x16a, 0x2, 0xffe, 0xffd, 0x3, 0x2, 0x2, 0x2, 0xffe, 
       0xfff, 0x3, 0x2, 0x2, 0x2, 0xfff, 0x1000, 0x3, 0x2, 0x2, 0x2, 0x1000, 
       0x1001, 0x5, 0x188, 0xc5, 0x2, 0x1001, 0x2cf, 0x3, 0x2, 0x2, 0x2, 
       0x1002, 0x1004, 0x7, 0x23d, 0x2, 0x2, 0x1003, 0x1005, 0x5, 0x2d2, 
       0x16a, 0x2, 0x1004, 0x1003, 0x3, 0x2, 0x2, 0x2, 0x1004, 0x1005, 0x3, 
       0x2, 0x2, 0x2, 0x1005, 0x1006, 0x3, 0x2, 0x2, 0x2, 0x1006, 0x1007, 
       0x5, 0x188, 0xc5, 0x2, 0x1007, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x1008, 
       0x1009, 0x7, 0x16, 0x2, 0x2, 0x1009, 0x100b, 0x7, 0x2a5, 0x2, 0x2, 
       0x100a, 0x100c, 0x7, 0x2a5, 0x2, 0x2, 0x100b, 0x100a, 0x3, 0x2, 0x2, 
       0x2, 0x100b, 0x100c, 0x3, 0x2, 0x2, 0x2, 0x100c, 0x100e, 0x3, 0x2, 
       0x2, 0x2, 0x100d, 0x100f, 0x7, 0x2a5, 0x2, 0x2, 0x100e, 0x100d, 0x3, 
       0x2, 0x2, 0x2, 0x100e, 0x100f, 0x3, 0x2, 0x2, 0x2, 0x100f, 0x1011, 
       0x3, 0x2, 0x2, 0x2, 0x1010, 0x1012, 0x7, 0x2a5, 0x2, 0x2, 0x1011, 
       0x1010, 0x3, 0x2, 0x2, 0x2, 0x1011, 0x1012, 0x3, 0x2, 0x2, 0x2, 0x1012, 
       0x1013, 0x3, 0x2, 0x2, 0x2, 0x1013, 0x1014, 0x7, 0x17, 0x2, 0x2, 
       0x1014, 0x2d3, 0x3, 0x2, 0x2, 0x2, 0x1015, 0x101b, 0x5, 0x2d6, 0x16c, 
       0x2, 0x1016, 0x1019, 0x7, 0x1a, 0x2, 0x2, 0x1017, 0x101a, 0x5, 0x2d6, 
       0x16c, 0x2, 0x1018, 0x101a, 0x5, 0x498, 0x24d, 0x2, 0x1019, 0x1017, 
       0x3, 0x2, 0x2, 0x2, 0x1019, 0x1018, 0x3, 0x2, 0x2, 0x2, 0x101a, 0x101c, 
       0x3, 0x2, 0x2, 0x2, 0x101b, 0x1016, 0x3, 0x2, 0x2, 0x2, 0x101b, 0x101c, 
       0x3, 0x2, 0x2, 0x2, 0x101c, 0x1023, 0x3, 0x2, 0x2, 0x2, 0x101d, 0x1023, 
       0x7, 0x29f, 0x2, 0x2, 0x101e, 0x1020, 0x5, 0x498, 0x24d, 0x2, 0x101f, 
       0x1021, 0x5, 0x47e, 0x240, 0x2, 0x1020, 0x101f, 0x3, 0x2, 0x2, 0x2, 
       0x1020, 0x1021, 0x3, 0x2, 0x2, 0x2, 0x1021, 0x1023, 0x3, 0x2, 0x2, 
       0x2, 0x1022, 0x1015, 0x3, 0x2, 0x2, 0x2, 0x1022, 0x101d, 0x3, 0x2, 
       0x2, 0x2, 0x1022, 0x101e, 0x3, 0x2, 0x2, 0x2, 0x1023, 0x2d5, 0x3, 
       0x2, 0x2, 0x2, 0x1024, 0x1027, 0x7, 0x2a2, 0x2, 0x2, 0x1025, 0x1027, 
       0x5, 0x47e, 0x240, 0x2, 0x1026, 0x1024, 0x3, 0x2, 0x2, 0x2, 0x1026, 
       0x1025, 0x3, 0x2, 0x2, 0x2, 0x1027, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x1028, 
       0x102b, 0x7, 0x2a2, 0x2, 0x2, 0x1029, 0x102a, 0x7, 0x1a, 0x2, 0x2, 
       0x102a, 0x102c, 0x5, 0x498, 0x24d, 0x2, 0x102b, 0x1029, 0x3, 0x2, 
       0x2, 0x2, 0x102b, 0x102c, 0x3, 0x2, 0x2, 0x2, 0x102c, 0x102f, 0x3, 
       0x2, 0x2, 0x2, 0x102d, 0x102f, 0x7, 0x29f, 0x2, 0x2, 0x102e, 0x1028, 
       0x3, 0x2, 0x2, 0x2, 0x102e, 0x102d, 0x3, 0x2, 0x2, 0x2, 0x102f, 0x2d9, 
       0x3, 0x2, 0x2, 0x2, 0x1030, 0x1031, 0x7, 0x2aa, 0x2, 0x2, 0x1031, 
       0x2db, 0x3, 0x2, 0x2, 0x2, 0x1032, 0x1033, 0x5, 0x2de, 0x170, 0x2, 
       0x1033, 0x1034, 0x5, 0x45a, 0x22e, 0x2, 0x1034, 0x1035, 0x9, 0x8, 
       0x2, 0x2, 0x1035, 0x2dd, 0x3, 0x2, 0x2, 0x2, 0x1036, 0x103c, 0x3, 
       0x2, 0x2, 0x2, 0x1037, 0x1039, 0x7, 0x39, 0x2, 0x2, 0x1038, 0x103a, 
       0x5, 0x2d2, 0x16a, 0x2, 0x1039, 0x1038, 0x3, 0x2, 0x2, 0x2, 0x1039, 
       0x103a, 0x3, 0x2, 0x2, 0x2, 0x103a, 0x103c, 0x3, 0x2, 0x2, 0x2, 0x103b, 
       0x1036, 0x3, 0x2, 0x2, 0x2, 0x103b, 0x1037, 0x3, 0x2, 0x2, 0x2, 0x103c, 
       0x2df, 0x3, 0x2, 0x2, 0x2, 0x103d, 0x1059, 0x7, 0xd, 0x2, 0x2, 0x103e, 
       0x1041, 0x7, 0x2d6, 0x2, 0x2, 0x103f, 0x1042, 0x5, 0x2e6, 0x174, 
       0x2, 0x1040, 0x1042, 0x5, 0x2e8, 0x175, 0x2, 0x1041, 0x103f, 0x3, 
       0x2, 0x2, 0x2, 0x1041, 0x1040, 0x3, 0x2, 0x2, 0x2, 0x1042, 0x1043, 
       0x3, 0x2, 0x2, 0x2, 0x1043, 0x1044, 0x9, 0x2, 0x2, 0x2, 0x1044, 0x105a, 
       0x3, 0x2, 0x2, 0x2, 0x1045, 0x1046, 0x5, 0x2ec, 0x177, 0x2, 0x1046, 
       0x1047, 0x9, 0x2, 0x2, 0x2, 0x1047, 0x105a, 0x3, 0x2, 0x2, 0x2, 0x1048, 
       0x1049, 0x7, 0x2e7, 0x2, 0x2, 0x1049, 0x104a, 0x7, 0x2e8, 0x2, 0x2, 
       0x104a, 0x104b, 0x7, 0x2e9, 0x2, 0x2, 0x104b, 0x104c, 0x7, 0x2ea, 
       0x2, 0x2, 0x104c, 0x104d, 0x7, 0x2eb, 0x2, 0x2, 0x104d, 0x104e, 0x7, 
       0x2ec, 0x2, 0x2, 0x104e, 0x104f, 0x7, 0x2ed, 0x2, 0x2, 0x104f, 0x1050, 
       0x7, 0x2ee, 0x2, 0x2, 0x1050, 0x1051, 0x5, 0x2e2, 0x172, 0x2, 0x1051, 
       0x1052, 0x5, 0x2e4, 0x173, 0x2, 0x1052, 0x1053, 0x5, 0x2e4, 0x173, 
       0x2, 0x1053, 0x1055, 0x5, 0x2e4, 0x173, 0x2, 0x1054, 0x1056, 0x7, 
       0x2f0, 0x2, 0x2, 0x1055, 0x1054, 0x3, 0x2, 0x2, 0x2, 0x1055, 0x1056, 
       0x3, 0x2, 0x2, 0x2, 0x1056, 0x1057, 0x3, 0x2, 0x2, 0x2, 0x1057, 0x1058, 
       0x9, 0x2, 0x2, 0x2, 0x1058, 0x105a, 0x3, 0x2, 0x2, 0x2, 0x1059, 0x103e, 
       0x3, 0x2, 0x2, 0x2, 0x1059, 0x1045, 0x3, 0x2, 0x2, 0x2, 0x1059, 0x1048, 
       0x3, 0x2, 0x2, 0x2, 0x105a, 0x2e1, 0x3, 0x2, 0x2, 0x2, 0x105b, 0x105c, 
       0x9, 0x11, 0x2, 0x2, 0x105c, 0x2e3, 0x3, 0x2, 0x2, 0x2, 0x105d, 0x105e, 
       0x9, 0x12, 0x2, 0x2, 0x105e, 0x2e5, 0x3, 0x2, 0x2, 0x2, 0x105f, 0x1060, 
       0x7, 0x2da, 0x2, 0x2, 0x1060, 0x1062, 0x5, 0x182, 0xc2, 0x2, 0x1061, 
       0x1063, 0x7, 0x1d, 0x2, 0x2, 0x1062, 0x1061, 0x3, 0x2, 0x2, 0x2, 
       0x1062, 0x1063, 0x3, 0x2, 0x2, 0x2, 0x1063, 0x2e7, 0x3, 0x2, 0x2, 
       0x2, 0x1064, 0x1065, 0x7, 0x2db, 0x2, 0x2, 0x1065, 0x1066, 0x7, 0x2dc, 
       0x2, 0x2, 0x1066, 0x1067, 0x7, 0x2dd, 0x2, 0x2, 0x1067, 0x1068, 0x5, 
       0x2ea, 0x176, 0x2, 0x1068, 0x1069, 0x7, 0x2de, 0x2, 0x2, 0x1069, 
       0x2e9, 0x3, 0x2, 0x2, 0x2, 0x106a, 0x106b, 0x9, 0x13, 0x2, 0x2, 0x106b, 
       0x2eb, 0x3, 0x2, 0x2, 0x2, 0x106c, 0x106d, 0x7, 0x2e1, 0x2, 0x2, 
       0x106d, 0x106e, 0x7, 0x2e3, 0x2, 0x2, 0x106e, 0x106f, 0x5, 0x2ee, 
       0x178, 0x2, 0x106f, 0x1070, 0x5, 0x2f0, 0x179, 0x2, 0x1070, 0x1071, 
       0x5, 0x182, 0xc2, 0x2, 0x1071, 0x1072, 0x5, 0x182, 0xc2, 0x2, 0x1072, 
       0x1073, 0x5, 0x182, 0xc2, 0x2, 0x1073, 0x2ed, 0x3, 0x2, 0x2, 0x2, 
       0x1074, 0x1075, 0x9, 0x14, 0x2, 0x2, 0x1075, 0x2ef, 0x3, 0x2, 0x2, 
       0x2, 0x1076, 0x1077, 0x9, 0x15, 0x2, 0x2, 0x1077, 0x2f1, 0x3, 0x2, 
       0x2, 0x2, 0x1078, 0x1079, 0x7, 0xf, 0x2, 0x2, 0x1079, 0x107a, 0x5, 
       0x2f4, 0x17b, 0x2, 0x107a, 0x107b, 0x9, 0x2, 0x2, 0x2, 0x107b, 0x2f3, 
       0x3, 0x2, 0x2, 0x2, 0x107c, 0x1084, 0x5, 0x2f6, 0x17c, 0x2, 0x107d, 
       0x107f, 0x5, 0x2f8, 0x17d, 0x2, 0x107e, 0x107d, 0x3, 0x2, 0x2, 0x2, 
       0x107f, 0x1082, 0x3, 0x2, 0x2, 0x2, 0x1080, 0x107e, 0x3, 0x2, 0x2, 
       0x2, 0x1080, 0x1081, 0x3, 0x2, 0x2, 0x2, 0x1081, 0x1084, 0x3, 0x2, 
       0x2, 0x2, 0x1082, 0x1080, 0x3, 0x2, 0x2, 0x2, 0x1083, 0x107c, 0x3, 
       0x2, 0x2, 0x2, 0x1083, 0x1080, 0x3, 0x2, 0x2, 0x2, 0x1084, 0x2f5, 
       0x3, 0x2, 0x2, 0x2, 0x1085, 0x108a, 0x7, 0x2f1, 0x2, 0x2, 0x1086, 
       0x1087, 0x7, 0x16, 0x2, 0x2, 0x1087, 0x1088, 0x5, 0x2fa, 0x17e, 0x2, 
       0x1088, 0x1089, 0x7, 0x17, 0x2, 0x2, 0x1089, 0x108b, 0x3, 0x2, 0x2, 
       0x2, 0x108a, 0x1086, 0x3, 0x2, 0x2, 0x2, 0x108a, 0x108b, 0x3, 0x2, 
       0x2, 0x2, 0x108b, 0x2f7, 0x3, 0x2, 0x2, 0x2, 0x108c, 0x1099, 0x7, 
       0x1b, 0x2, 0x2, 0x108d, 0x1096, 0x7, 0x16, 0x2, 0x2, 0x108e, 0x1093, 
       0x5, 0x2fa, 0x17e, 0x2, 0x108f, 0x1090, 0x7, 0x1a, 0x2, 0x2, 0x1090, 
       0x1092, 0x5, 0x2fa, 0x17e, 0x2, 0x1091, 0x108f, 0x3, 0x2, 0x2, 0x2, 
       0x1092, 0x1095, 0x3, 0x2, 0x2, 0x2, 0x1093, 0x1091, 0x3, 0x2, 0x2, 
       0x2, 0x1093, 0x1094, 0x3, 0x2, 0x2, 0x2, 0x1094, 0x1097, 0x3, 0x2, 
       0x2, 0x2, 0x1095, 0x1093, 0x3, 0x2, 0x2, 0x2, 0x1096, 0x108e, 0x3, 
       0x2, 0x2, 0x2, 0x1096, 0x1097, 0x3, 0x2, 0x2, 0x2, 0x1097, 0x1098, 
       0x3, 0x2, 0x2, 0x2, 0x1098, 0x109a, 0x7, 0x17, 0x2, 0x2, 0x1099, 
       0x108d, 0x3, 0x2, 0x2, 0x2, 0x1099, 0x109a, 0x3, 0x2, 0x2, 0x2, 0x109a, 
       0x2f9, 0x3, 0x2, 0x2, 0x2, 0x109b, 0x109f, 0x7, 0x1b, 0x2, 0x2, 0x109c, 
       0x109f, 0x5, 0x2fc, 0x17f, 0x2, 0x109d, 0x109f, 0x5, 0x498, 0x24d, 
       0x2, 0x109e, 0x109b, 0x3, 0x2, 0x2, 0x2, 0x109e, 0x109c, 0x3, 0x2, 
       0x2, 0x2, 0x109e, 0x109d, 0x3, 0x2, 0x2, 0x2, 0x109f, 0x2fb, 0x3, 
       0x2, 0x2, 0x2, 0x10a0, 0x10a4, 0x7, 0x1c9, 0x2, 0x2, 0x10a1, 0x10a3, 
       0x9, 0xb, 0x2, 0x2, 0x10a2, 0x10a1, 0x3, 0x2, 0x2, 0x2, 0x10a3, 0x10a6, 
       0x3, 0x2, 0x2, 0x2, 0x10a4, 0x10a2, 0x3, 0x2, 0x2, 0x2, 0x10a4, 0x10a5, 
       0x3, 0x2, 0x2, 0x2, 0x10a5, 0x10a7, 0x3, 0x2, 0x2, 0x2, 0x10a6, 0x10a4, 
       0x3, 0x2, 0x2, 0x2, 0x10a7, 0x10a8, 0x7, 0x243, 0x2, 0x2, 0x10a8, 
       0x2fd, 0x3, 0x2, 0x2, 0x2, 0x10a9, 0x10aa, 0x7, 0x10, 0x2, 0x2, 0x10aa, 
       0x2ff, 0x3, 0x2, 0x2, 0x2, 0x10ab, 0x10bc, 0x7, 0x15, 0x2, 0x2, 0x10ac, 
       0x10bd, 0x5, 0x316, 0x18c, 0x2, 0x10ad, 0x10bd, 0x5, 0x318, 0x18d, 
       0x2, 0x10ae, 0x10bd, 0x5, 0x31e, 0x190, 0x2, 0x10af, 0x10bd, 0x7, 
       0x23, 0x2, 0x2, 0x10b0, 0x10bd, 0x5, 0x302, 0x182, 0x2, 0x10b1, 0x10bd, 
       0x7, 0x25, 0x2, 0x2, 0x10b2, 0x10bd, 0x7, 0x26, 0x2, 0x2, 0x10b3, 
       0x10bd, 0x5, 0x304, 0x183, 0x2, 0x10b4, 0x10bd, 0x5, 0x306, 0x184, 
       0x2, 0x10b5, 0x10bd, 0x5, 0x314, 0x18b, 0x2, 0x10b6, 0x10bd, 0x5, 
       0x310, 0x189, 0x2, 0x10b7, 0x10bd, 0x5, 0x312, 0x18a, 0x2, 0x10b8, 
       0x10bd, 0x5, 0x308, 0x185, 0x2, 0x10b9, 0x10bd, 0x5, 0x30a, 0x186, 
       0x2, 0x10ba, 0x10bd, 0x5, 0x30c, 0x187, 0x2, 0x10bb, 0x10bd, 0x5, 
       0x30e, 0x188, 0x2, 0x10bc, 0x10ac, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10ad, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10ae, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10af, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b0, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b1, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b2, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b3, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b4, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b5, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b6, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b7, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b8, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b9, 
       0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10ba, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10bb, 
       0x3, 0x2, 0x2, 0x2, 0x10bd, 0x10be, 0x3, 0x2, 0x2, 0x2, 0x10be, 0x10bf, 
       0x9, 0x2, 0x2, 0x2, 0x10bf, 0x301, 0x3, 0x2, 0x2, 0x2, 0x10c0, 0x10c2, 
       0x7, 0x24, 0x2, 0x2, 0x10c1, 0x10c3, 0x7, 0x18, 0x2, 0x2, 0x10c2, 
       0x10c1, 0x3, 0x2, 0x2, 0x2, 0x10c2, 0x10c3, 0x3, 0x2, 0x2, 0x2, 0x10c3, 
       0x303, 0x3, 0x2, 0x2, 0x2, 0x10c4, 0x10da, 0x7, 0x27, 0x2, 0x2, 0x10c5, 
       0x10c6, 0x5, 0x31a, 0x18e, 0x2, 0x10c6, 0x10c7, 0x7, 0x33, 0x2, 0x2, 
       0x10c7, 0x10c9, 0x3, 0x2, 0x2, 0x2, 0x10c8, 0x10c5, 0x3, 0x2, 0x2, 
       0x2, 0x10c8, 0x10c9, 0x3, 0x2, 0x2, 0x2, 0x10c9, 0x10ca, 0x3, 0x2, 
       0x2, 0x2, 0x10ca, 0x10cc, 0x5, 0x31a, 0x18e, 0x2, 0x10cb, 0x10c8, 
       0x3, 0x2, 0x2, 0x2, 0x10cb, 0x10cc, 0x3, 0x2, 0x2, 0x2, 0x10cc, 0x10cd, 
       0x3, 0x2, 0x2, 0x2, 0x10cd, 0x10db, 0x5, 0x31a, 0x18e, 0x2, 0x10ce, 
       0x10d0, 0x7, 0x33, 0x2, 0x2, 0x10cf, 0x10ce, 0x3, 0x2, 0x2, 0x2, 
       0x10cf, 0x10d0, 0x3, 0x2, 0x2, 0x2, 0x10d0, 0x10d4, 0x3, 0x2, 0x2, 
       0x2, 0x10d1, 0x10d2, 0x5, 0x31a, 0x18e, 0x2, 0x10d2, 0x10d3, 0x7, 
       0x33, 0x2, 0x2, 0x10d3, 0x10d5, 0x3, 0x2, 0x2, 0x2, 0x10d4, 0x10d1, 
       0x3, 0x2, 0x2, 0x2, 0x10d5, 0x10d6, 0x3, 0x2, 0x2, 0x2, 0x10d6, 0x10d4, 
       0x3, 0x2, 0x2, 0x2, 0x10d6, 0x10d7, 0x3, 0x2, 0x2, 0x2, 0x10d7, 0x10d8, 
       0x3, 0x2, 0x2, 0x2, 0x10d8, 0x10d9, 0x5, 0x31a, 0x18e, 0x2, 0x10d9, 
       0x10db, 0x3, 0x2, 0x2, 0x2, 0x10da, 0x10cb, 0x3, 0x2, 0x2, 0x2, 0x10da, 
       0x10cf, 0x3, 0x2, 0x2, 0x2, 0x10db, 0x305, 0x3, 0x2, 0x2, 0x2, 0x10dc, 
       0x10f2, 0x7, 0x28, 0x2, 0x2, 0x10dd, 0x10de, 0x5, 0x31a, 0x18e, 0x2, 
       0x10de, 0x10df, 0x7, 0x33, 0x2, 0x2, 0x10df, 0x10e1, 0x3, 0x2, 0x2, 
       0x2, 0x10e0, 0x10dd, 0x3, 0x2, 0x2, 0x2, 0x10e0, 0x10e1, 0x3, 0x2, 
       0x2, 0x2, 0x10e1, 0x10e2, 0x3, 0x2, 0x2, 0x2, 0x10e2, 0x10e4, 0x5, 
       0x31a, 0x18e, 0x2, 0x10e3, 0x10e0, 0x3, 0x2, 0x2, 0x2, 0x10e3, 0x10e4, 
       0x3, 0x2, 0x2, 0x2, 0x10e4, 0x10e5, 0x3, 0x2, 0x2, 0x2, 0x10e5, 0x10f3, 
       0x5, 0x31a, 0x18e, 0x2, 0x10e6, 0x10e8, 0x7, 0x33, 0x2, 0x2, 0x10e7, 
       0x10e6, 0x3, 0x2, 0x2, 0x2, 0x10e7, 0x10e8, 0x3, 0x2, 0x2, 0x2, 0x10e8, 
       0x10ec, 0x3, 0x2, 0x2, 0x2, 0x10e9, 0x10ea, 0x5, 0x31a, 0x18e, 0x2, 
       0x10ea, 0x10eb, 0x7, 0x33, 0x2, 0x2, 0x10eb, 0x10ed, 0x3, 0x2, 0x2, 
       0x2, 0x10ec, 0x10e9, 0x3, 0x2, 0x2, 0x2, 0x10ed, 0x10ee, 0x3, 0x2, 
       0x2, 0x2, 0x10ee, 0x10ec, 0x3, 0x2, 0x2, 0x2, 0x10ee, 0x10ef, 0x3, 
       0x2, 0x2, 0x2, 0x10ef, 0x10f0, 0x3, 0x2, 0x2, 0x2, 0x10f0, 0x10f1, 
       0x5, 0x31a, 0x18e, 0x2, 0x10f1, 0x10f3, 0x3, 0x2, 0x2, 0x2, 0x10f2, 
       0x10e3, 0x3, 0x2, 0x2, 0x2, 0x10f2, 0x10e7, 0x3, 0x2, 0x2, 0x2, 0x10f3, 
       0x307, 0x3, 0x2, 0x2, 0x2, 0x10f4, 0x10f6, 0x7, 0x2c, 0x2, 0x2, 0x10f5, 
       0x10f7, 0x7, 0x1e, 0x2, 0x2, 0x10f6, 0x10f5, 0x3, 0x2, 0x2, 0x2, 
       0x10f6, 0x10f7, 0x3, 0x2, 0x2, 0x2, 0x10f7, 0x10f8, 0x3, 0x2, 0x2, 
       0x2, 0x10f8, 0x10f9, 0x7, 0x1f, 0x2, 0x2, 0x10f9, 0x10fa, 0x7, 0x16, 
       0x2, 0x2, 0x10fa, 0x10fb, 0x5, 0x31a, 0x18e, 0x2, 0x10fb, 0x10fc, 
       0x7, 0x17, 0x2, 0x2, 0x10fc, 0x309, 0x3, 0x2, 0x2, 0x2, 0x10fd, 0x10ff, 
       0x7, 0x2e, 0x2, 0x2, 0x10fe, 0x1100, 0x7, 0x1e, 0x2, 0x2, 0x10ff, 
       0x10fe, 0x3, 0x2, 0x2, 0x2, 0x10ff, 0x1100, 0x3, 0x2, 0x2, 0x2, 0x1100, 
       0x1101, 0x3, 0x2, 0x2, 0x2, 0x1101, 0x1102, 0x7, 0x1f, 0x2, 0x2, 
       0x1102, 0x1103, 0x7, 0x16, 0x2, 0x2, 0x1103, 0x1104, 0x5, 0x31a, 
       0x18e, 0x2, 0x1104, 0x1105, 0x7, 0x17, 0x2, 0x2, 0x1105, 0x30b, 0x3, 
       0x2, 0x2, 0x2, 0x1106, 0x1107, 0x7, 0x2d, 0x2, 0x2, 0x1107, 0x30d, 
       0x3, 0x2, 0x2, 0x2, 0x1108, 0x1109, 0x7, 0x2f, 0x2, 0x2, 0x1109, 
       0x30f, 0x3, 0x2, 0x2, 0x2, 0x110a, 0x110b, 0x7, 0x2a, 0x2, 0x2, 0x110b, 
       0x110c, 0x7, 0x31, 0x2, 0x2, 0x110c, 0x311, 0x3, 0x2, 0x2, 0x2, 0x110d, 
       0x110e, 0x7, 0x2b, 0x2, 0x2, 0x110e, 0x110f, 0x7, 0x31, 0x2, 0x2, 
       0x110f, 0x313, 0x3, 0x2, 0x2, 0x2, 0x1110, 0x1111, 0x7, 0x29, 0x2, 
       0x2, 0x1111, 0x315, 0x3, 0x2, 0x2, 0x2, 0x1112, 0x1113, 0x7, 0x20, 
       0x2, 0x2, 0x1113, 0x317, 0x3, 0x2, 0x2, 0x2, 0x1114, 0x1115, 0x7, 
       0x21, 0x2, 0x2, 0x1115, 0x319, 0x3, 0x2, 0x2, 0x2, 0x1116, 0x111d, 
       0x7, 0x31, 0x2, 0x2, 0x1117, 0x1118, 0x7, 0x1c9, 0x2, 0x2, 0x1118, 
       0x1119, 0x7, 0x241, 0x2, 0x2, 0x1119, 0x111d, 0x7, 0x243, 0x2, 0x2, 
       0x111a, 0x111d, 0x7, 0x1e, 0x2, 0x2, 0x111b, 0x111d, 0x7, 0x2a, 0x2, 
       0x2, 0x111c, 0x1116, 0x3, 0x2, 0x2, 0x2, 0x111c, 0x1117, 0x3, 0x2, 
       0x2, 0x2, 0x111c, 0x111a, 0x3, 0x2, 0x2, 0x2, 0x111c, 0x111b, 0x3, 
       0x2, 0x2, 0x2, 0x111d, 0x31b, 0x3, 0x2, 0x2, 0x2, 0x111e, 0x111f, 
       0x7, 0x34, 0x2, 0x2, 0x111f, 0x31d, 0x3, 0x2, 0x2, 0x2, 0x1120, 0x1124, 
       0x7, 0x22, 0x2, 0x2, 0x1121, 0x1123, 0x5, 0x320, 0x191, 0x2, 0x1122, 
       0x1121, 0x3, 0x2, 0x2, 0x2, 0x1123, 0x1126, 0x3, 0x2, 0x2, 0x2, 0x1124, 
       0x1122, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x1125, 0x3, 0x2, 0x2, 0x2, 0x1125, 
       0x31f, 0x3, 0x2, 0x2, 0x2, 0x1126, 0x1124, 0x3, 0x2, 0x2, 0x2, 0x1127, 
       0x1128, 0x9, 0x16, 0x2, 0x2, 0x1128, 0x321, 0x3, 0x2, 0x2, 0x2, 0x1129, 
       0x1157, 0x5, 0x324, 0x193, 0x2, 0x112a, 0x1157, 0x5, 0x326, 0x194, 
       0x2, 0x112b, 0x1157, 0x5, 0x328, 0x195, 0x2, 0x112c, 0x1157, 0x5, 
       0x32a, 0x196, 0x2, 0x112d, 0x1157, 0x5, 0x32c, 0x197, 0x2, 0x112e, 
       0x1157, 0x5, 0x32e, 0x198, 0x2, 0x112f, 0x1157, 0x5, 0x330, 0x199, 
       0x2, 0x1130, 0x1157, 0x5, 0x332, 0x19a, 0x2, 0x1131, 0x1157, 0x5, 
       0x338, 0x19d, 0x2, 0x1132, 0x1157, 0x5, 0x33a, 0x19e, 0x2, 0x1133, 
       0x1157, 0x5, 0x34a, 0x1a6, 0x2, 0x1134, 0x1157, 0x5, 0x34c, 0x1a7, 
       0x2, 0x1135, 0x1157, 0x5, 0x34e, 0x1a8, 0x2, 0x1136, 0x1157, 0x5, 
       0x350, 0x1a9, 0x2, 0x1137, 0x1157, 0x5, 0x352, 0x1aa, 0x2, 0x1138, 
       0x1157, 0x5, 0x354, 0x1ab, 0x2, 0x1139, 0x1157, 0x5, 0x356, 0x1ac, 
       0x2, 0x113a, 0x1157, 0x5, 0x35a, 0x1ae, 0x2, 0x113b, 0x1157, 0x5, 
       0x35e, 0x1b0, 0x2, 0x113c, 0x1157, 0x5, 0x360, 0x1b1, 0x2, 0x113d, 
       0x1157, 0x5, 0x362, 0x1b2, 0x2, 0x113e, 0x1157, 0x5, 0x364, 0x1b3, 
       0x2, 0x113f, 0x1157, 0x5, 0x368, 0x1b5, 0x2, 0x1140, 0x1157, 0x5, 
       0x36c, 0x1b7, 0x2, 0x1141, 0x1157, 0x5, 0x370, 0x1b9, 0x2, 0x1142, 
       0x1157, 0x5, 0x372, 0x1ba, 0x2, 0x1143, 0x1157, 0x5, 0x374, 0x1bb, 
       0x2, 0x1144, 0x1157, 0x5, 0x376, 0x1bc, 0x2, 0x1145, 0x1157, 0x5, 
       0x378, 0x1bd, 0x2, 0x1146, 0x1157, 0x5, 0x37a, 0x1be, 0x2, 0x1147, 
       0x1157, 0x5, 0x37c, 0x1bf, 0x2, 0x1148, 0x1157, 0x5, 0x37e, 0x1c0, 
       0x2, 0x1149, 0x1157, 0x5, 0x382, 0x1c2, 0x2, 0x114a, 0x1157, 0x5, 
       0x380, 0x1c1, 0x2, 0x114b, 0x1157, 0x5, 0x384, 0x1c3, 0x2, 0x114c, 
       0x1157, 0x5, 0x386, 0x1c4, 0x2, 0x114d, 0x1157, 0x5, 0x38a, 0x1c6, 
       0x2, 0x114e, 0x1157, 0x5, 0x38c, 0x1c7, 0x2, 0x114f, 0x1157, 0x5, 
       0x38e, 0x1c8, 0x2, 0x1150, 0x1157, 0x5, 0x390, 0x1c9, 0x2, 0x1151, 
       0x1157, 0x5, 0x392, 0x1ca, 0x2, 0x1152, 0x1157, 0x5, 0x394, 0x1cb, 
       0x2, 0x1153, 0x1157, 0x5, 0x398, 0x1cd, 0x2, 0x1154, 0x1157, 0x5, 
       0x39a, 0x1ce, 0x2, 0x1155, 0x1157, 0x5, 0x39c, 0x1cf, 0x2, 0x1156, 
       0x1129, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x112a, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x112b, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x112c, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x112d, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x112e, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x112f, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1130, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1131, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1132, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1133, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1134, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1135, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1136, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1137, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1138, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1139, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x113a, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x113b, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x113c, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x113d, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x113e, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x113f, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1140, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1141, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1142, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1143, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1144, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1145, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1146, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1147, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1148, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1149, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x114a, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x114b, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x114c, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x114d, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x114e, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x114f, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1150, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1151, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1152, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1153, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1154, 0x3, 0x2, 0x2, 0x2, 0x1156, 
       0x1155, 0x3, 0x2, 0x2, 0x2, 0x1157, 0x323, 0x3, 0x2, 0x2, 0x2, 0x1158, 
       0x115a, 0x7, 0x37, 0x2, 0x2, 0x1159, 0x115b, 0x5, 0x2d2, 0x16a, 0x2, 
       0x115a, 0x1159, 0x3, 0x2, 0x2, 0x2, 0x115a, 0x115b, 0x3, 0x2, 0x2, 
       0x2, 0x115b, 0x115c, 0x3, 0x2, 0x2, 0x2, 0x115c, 0x115d, 0x5, 0x480, 
       0x241, 0x2, 0x115d, 0x115e, 0x5, 0x480, 0x241, 0x2, 0x115e, 0x325, 
       0x3, 0x2, 0x2, 0x2, 0x115f, 0x1161, 0x7, 0x39, 0x2, 0x2, 0x1160, 
       0x1162, 0x5, 0x2d2, 0x16a, 0x2, 0x1161, 0x1160, 0x3, 0x2, 0x2, 0x2, 
       0x1161, 0x1162, 0x3, 0x2, 0x2, 0x2, 0x1162, 0x1164, 0x3, 0x2, 0x2, 
       0x2, 0x1163, 0x115f, 0x3, 0x2, 0x2, 0x2, 0x1163, 0x1164, 0x3, 0x2, 
       0x2, 0x2, 0x1164, 0x1165, 0x3, 0x2, 0x2, 0x2, 0x1165, 0x1166, 0x5, 
       0x480, 0x241, 0x2, 0x1166, 0x116f, 0x7, 0x16, 0x2, 0x2, 0x1167, 0x116c, 
       0x5, 0x46e, 0x238, 0x2, 0x1168, 0x1169, 0x7, 0x1a, 0x2, 0x2, 0x1169, 
       0x116b, 0x5, 0x46e, 0x238, 0x2, 0x116a, 0x1168, 0x3, 0x2, 0x2, 0x2, 
       0x116b, 0x116e, 0x3, 0x2, 0x2, 0x2, 0x116c, 0x116a, 0x3, 0x2, 0x2, 
       0x2, 0x116c, 0x116d, 0x3, 0x2, 0x2, 0x2, 0x116d, 0x1170, 0x3, 0x2, 
       0x2, 0x2, 0x116e, 0x116c, 0x3, 0x2, 0x2, 0x2, 0x116f, 0x1167, 0x3, 
       0x2, 0x2, 0x2, 0x116f, 0x1170, 0x3, 0x2, 0x2, 0x2, 0x1170, 0x1171, 
       0x3, 0x2, 0x2, 0x2, 0x1171, 0x1172, 0x7, 0x17, 0x2, 0x2, 0x1172, 
       0x327, 0x3, 0x2, 0x2, 0x2, 0x1173, 0x1175, 0x7, 0x3a, 0x2, 0x2, 0x1174, 
       0x1176, 0x5, 0x2d2, 0x16a, 0x2, 0x1175, 0x1174, 0x3, 0x2, 0x2, 0x2, 
       0x1175, 0x1176, 0x3, 0x2, 0x2, 0x2, 0x1176, 0x1177, 0x3, 0x2, 0x2, 
       0x2, 0x1177, 0x1178, 0x5, 0x39e, 0x1d0, 0x2, 0x1178, 0x117a, 0x5, 
       0x480, 0x241, 0x2, 0x1179, 0x117b, 0x5, 0x480, 0x241, 0x2, 0x117a, 
       0x1179, 0x3, 0x2, 0x2, 0x2, 0x117a, 0x117b, 0x3, 0x2, 0x2, 0x2, 0x117b, 
       0x329, 0x3, 0x2, 0x2, 0x2, 0x117c, 0x117e, 0x7, 0x3b, 0x2, 0x2, 0x117d, 
       0x117f, 0x5, 0x480, 0x241, 0x2, 0x117e, 0x117d, 0x3, 0x2, 0x2, 0x2, 
       0x117e, 0x117f, 0x3, 0x2, 0x2, 0x2, 0x117f, 0x1181, 0x3, 0x2, 0x2, 
       0x2, 0x1180, 0x1182, 0x5, 0x480, 0x241, 0x2, 0x1181, 0x1180, 0x3, 
       0x2, 0x2, 0x2, 0x1181, 0x1182, 0x3, 0x2, 0x2, 0x2, 0x1182, 0x1183, 
       0x3, 0x2, 0x2, 0x2, 0x1183, 0x1184, 0x5, 0x46e, 0x238, 0x2, 0x1184, 
       0x32b, 0x3, 0x2, 0x2, 0x2, 0x1185, 0x1187, 0x7, 0x3c, 0x2, 0x2, 0x1186, 
       0x1188, 0x5, 0x2d2, 0x16a, 0x2, 0x1187, 0x1186, 0x3, 0x2, 0x2, 0x2, 
       0x1187, 0x1188, 0x3, 0x2, 0x2, 0x2, 0x1188, 0x1189, 0x3, 0x2, 0x2, 
       0x2, 0x1189, 0x118a, 0x5, 0x480, 0x241, 0x2, 0x118a, 0x32d, 0x3, 
       0x2, 0x2, 0x2, 0x118b, 0x118d, 0x7, 0x3d, 0x2, 0x2, 0x118c, 0x118e, 
       0x5, 0x2d2, 0x16a, 0x2, 0x118d, 0x118c, 0x3, 0x2, 0x2, 0x2, 0x118d, 
       0x118e, 0x3, 0x2, 0x2, 0x2, 0x118e, 0x1190, 0x3, 0x2, 0x2, 0x2, 0x118f, 
       0x1191, 0x5, 0x480, 0x241, 0x2, 0x1190, 0x118f, 0x3, 0x2, 0x2, 0x2, 
       0x1190, 0x1191, 0x3, 0x2, 0x2, 0x2, 0x1191, 0x32f, 0x3, 0x2, 0x2, 
       0x2, 0x1192, 0x1194, 0x7, 0x3e, 0x2, 0x2, 0x1193, 0x1195, 0x5, 0x2d2, 
       0x16a, 0x2, 0x1194, 0x1193, 0x3, 0x2, 0x2, 0x2, 0x1194, 0x1195, 0x3, 
       0x2, 0x2, 0x2, 0x1195, 0x1196, 0x3, 0x2, 0x2, 0x2, 0x1196, 0x1197, 
       0x5, 0x480, 0x241, 0x2, 0x1197, 0x331, 0x3, 0x2, 0x2, 0x2, 0x1198, 
       0x119a, 0x7, 0x3f, 0x2, 0x2, 0x1199, 0x119b, 0x5, 0x2d2, 0x16a, 0x2, 
       0x119a, 0x1199, 0x3, 0x2, 0x2, 0x2, 0x119a, 0x119b, 0x3, 0x2, 0x2, 
       0x2, 0x119b, 0x119d, 0x3, 0x2, 0x2, 0x2, 0x119c, 0x119e, 0x5, 0x39e, 
       0x1d0, 0x2, 0x119d, 0x119c, 0x3, 0x2, 0x2, 0x2, 0x119d, 0x119e, 0x3, 
       0x2, 0x2, 0x2, 0x119e, 0x119f, 0x3, 0x2, 0x2, 0x2, 0x119f, 0x11a0, 
       0x5, 0x480, 0x241, 0x2, 0x11a0, 0x333, 0x3, 0x2, 0x2, 0x2, 0x11a1, 
       0x11a3, 0x7, 0x40, 0x2, 0x2, 0x11a2, 0x11a4, 0x5, 0x2d2, 0x16a, 0x2, 
       0x11a3, 0x11a2, 0x3, 0x2, 0x2, 0x2, 0x11a3, 0x11a4, 0x3, 0x2, 0x2, 
       0x2, 0x11a4, 0x11a5, 0x3, 0x2, 0x2, 0x2, 0x11a5, 0x11a6, 0x5, 0x472, 
       0x23a, 0x2, 0x11a6, 0x335, 0x3, 0x2, 0x2, 0x2, 0x11a7, 0x11a9, 0x7, 
       0x41, 0x2, 0x2, 0x11a8, 0x11aa, 0x5, 0x2d2, 0x16a, 0x2, 0x11a9, 0x11a8, 
       0x3, 0x2, 0x2, 0x2, 0x11a9, 0x11aa, 0x3, 0x2, 0x2, 0x2, 0x11aa, 0x11ab, 
       0x3, 0x2, 0x2, 0x2, 0x11ab, 0x11ac, 0x5, 0x472, 0x23a, 0x2, 0x11ac, 
       0x337, 0x3, 0x2, 0x2, 0x2, 0x11ad, 0x11af, 0x7, 0x42, 0x2, 0x2, 0x11ae, 
       0x11b0, 0x5, 0x2d2, 0x16a, 0x2, 0x11af, 0x11ae, 0x3, 0x2, 0x2, 0x2, 
       0x11af, 0x11b0, 0x3, 0x2, 0x2, 0x2, 0x11b0, 0x11b8, 0x3, 0x2, 0x2, 
       0x2, 0x11b1, 0x11b6, 0x5, 0x46e, 0x238, 0x2, 0x11b2, 0x11b4, 0x5, 
       0x46e, 0x238, 0x2, 0x11b3, 0x11b5, 0x5, 0x46e, 0x238, 0x2, 0x11b4, 
       0x11b3, 0x3, 0x2, 0x2, 0x2, 0x11b4, 0x11b5, 0x3, 0x2, 0x2, 0x2, 0x11b5, 
       0x11b7, 0x3, 0x2, 0x2, 0x2, 0x11b6, 0x11b2, 0x3, 0x2, 0x2, 0x2, 0x11b6, 
       0x11b7, 0x3, 0x2, 0x2, 0x2, 0x11b7, 0x11b9, 0x3, 0x2, 0x2, 0x2, 0x11b8, 
       0x11b1, 0x3, 0x2, 0x2, 0x2, 0x11b8, 0x11b9, 0x3, 0x2, 0x2, 0x2, 0x11b9, 
       0x339, 0x3, 0x2, 0x2, 0x2, 0x11ba, 0x11bc, 0x7, 0x43, 0x2, 0x2, 0x11bb, 
       0x11bd, 0x5, 0x2d2, 0x16a, 0x2, 0x11bc, 0x11bb, 0x3, 0x2, 0x2, 0x2, 
       0x11bc, 0x11bd, 0x3, 0x2, 0x2, 0x2, 0x11bd, 0x11bf, 0x3, 0x2, 0x2, 
       0x2, 0x11be, 0x11c0, 0x5, 0x480, 0x241, 0x2, 0x11bf, 0x11be, 0x3, 
       0x2, 0x2, 0x2, 0x11bf, 0x11c0, 0x3, 0x2, 0x2, 0x2, 0x11c0, 0x33b, 
       0x3, 0x2, 0x2, 0x2, 0x11c1, 0x11c2, 0x7, 0x44, 0x2, 0x2, 0x11c2, 
       0x33d, 0x3, 0x2, 0x2, 0x2, 0x11c3, 0x11c5, 0x7, 0x45, 0x2, 0x2, 0x11c4, 
       0x11c6, 0x5, 0x2d2, 0x16a, 0x2, 0x11c5, 0x11c4, 0x3, 0x2, 0x2, 0x2, 
       0x11c5, 0x11c6, 0x3, 0x2, 0x2, 0x2, 0x11c6, 0x11c7, 0x3, 0x2, 0x2, 
       0x2, 0x11c7, 0x11c8, 0x5, 0x472, 0x23a, 0x2, 0x11c8, 0x33f, 0x3, 
       0x2, 0x2, 0x2, 0x11c9, 0x11ca, 0x7, 0x46, 0x2, 0x2, 0x11ca, 0x341, 
       0x3, 0x2, 0x2, 0x2, 0x11cb, 0x11cc, 0x7, 0x47, 0x2, 0x2, 0x11cc, 
       0x343, 0x3, 0x2, 0x2, 0x2, 0x11cd, 0x11ce, 0x7, 0x48, 0x2, 0x2, 0x11ce, 
       0x345, 0x3, 0x2, 0x2, 0x2, 0x11cf, 0x11d0, 0x7, 0x49, 0x2, 0x2, 0x11d0, 
       0x347, 0x3, 0x2, 0x2, 0x2, 0x11d1, 0x11d2, 0x7, 0x4a, 0x2, 0x2, 0x11d2, 
       0x349, 0x3, 0x2, 0x2, 0x2, 0x11d3, 0x11d5, 0x7, 0x4c, 0x2, 0x2, 0x11d4, 
       0x11d6, 0x5, 0x2d2, 0x16a, 0x2, 0x11d5, 0x11d4, 0x3, 0x2, 0x2, 0x2, 
       0x11d5, 0x11d6, 0x3, 0x2, 0x2, 0x2, 0x11d6, 0x11d8, 0x3, 0x2, 0x2, 
       0x2, 0x11d7, 0x11d3, 0x3, 0x2, 0x2, 0x2, 0x11d7, 0x11d8, 0x3, 0x2, 
       0x2, 0x2, 0x11d8, 0x11d9, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11da, 0x5, 
       0x468, 0x235, 0x2, 0x11da, 0x34b, 0x3, 0x2, 0x2, 0x2, 0x11db, 0x11dd, 
       0x7, 0x4d, 0x2, 0x2, 0x11dc, 0x11de, 0x5, 0x2d2, 0x16a, 0x2, 0x11dd, 
       0x11dc, 0x3, 0x2, 0x2, 0x2, 0x11dd, 0x11de, 0x3, 0x2, 0x2, 0x2, 0x11de, 
       0x11df, 0x3, 0x2, 0x2, 0x2, 0x11df, 0x11e0, 0x5, 0x464, 0x233, 0x2, 
       0x11e0, 0x34d, 0x3, 0x2, 0x2, 0x2, 0x11e1, 0x11e3, 0x7, 0x4e, 0x2, 
       0x2, 0x11e2, 0x11e4, 0x5, 0x2d2, 0x16a, 0x2, 0x11e3, 0x11e2, 0x3, 
       0x2, 0x2, 0x2, 0x11e3, 0x11e4, 0x3, 0x2, 0x2, 0x2, 0x11e4, 0x11e5, 
       0x3, 0x2, 0x2, 0x2, 0x11e5, 0x11e6, 0x5, 0x464, 0x233, 0x2, 0x11e6, 
       0x34f, 0x3, 0x2, 0x2, 0x2, 0x11e7, 0x11e9, 0x7, 0x4f, 0x2, 0x2, 0x11e8, 
       0x11ea, 0x5, 0x480, 0x241, 0x2, 0x11e9, 0x11e8, 0x3, 0x2, 0x2, 0x2, 
       0x11e9, 0x11ea, 0x3, 0x2, 0x2, 0x2, 0x11ea, 0x351, 0x3, 0x2, 0x2, 
       0x2, 0x11eb, 0x11ed, 0x7, 0x50, 0x2, 0x2, 0x11ec, 0x11ee, 0x5, 0x2d2, 
       0x16a, 0x2, 0x11ed, 0x11ec, 0x3, 0x2, 0x2, 0x2, 0x11ed, 0x11ee, 0x3, 
       0x2, 0x2, 0x2, 0x11ee, 0x11ef, 0x3, 0x2, 0x2, 0x2, 0x11ef, 0x11f1, 
       0x5, 0x480, 0x241, 0x2, 0x11f0, 0x11f2, 0x5, 0x480, 0x241, 0x2, 0x11f1, 
       0x11f0, 0x3, 0x2, 0x2, 0x2, 0x11f1, 0x11f2, 0x3, 0x2, 0x2, 0x2, 0x11f2, 
       0x353, 0x3, 0x2, 0x2, 0x2, 0x11f3, 0x11f4, 0x7, 0x51, 0x2, 0x2, 0x11f4, 
       0x11f5, 0x5, 0x480, 0x241, 0x2, 0x11f5, 0x355, 0x3, 0x2, 0x2, 0x2, 
       0x11f6, 0x11f8, 0x7, 0x52, 0x2, 0x2, 0x11f7, 0x11f9, 0x5, 0x2d2, 
       0x16a, 0x2, 0x11f8, 0x11f7, 0x3, 0x2, 0x2, 0x2, 0x11f8, 0x11f9, 0x3, 
       0x2, 0x2, 0x2, 0x11f9, 0x11fa, 0x3, 0x2, 0x2, 0x2, 0x11fa, 0x11fb, 
       0x5, 0x480, 0x241, 0x2, 0x11fb, 0x357, 0x3, 0x2, 0x2, 0x2, 0x11fc, 
       0x11fe, 0x7, 0x53, 0x2, 0x2, 0x11fd, 0x11ff, 0x5, 0x2d2, 0x16a, 0x2, 
       0x11fe, 0x11fd, 0x3, 0x2, 0x2, 0x2, 0x11fe, 0x11ff, 0x3, 0x2, 0x2, 
       0x2, 0x11ff, 0x1200, 0x3, 0x2, 0x2, 0x2, 0x1200, 0x1203, 0x5, 0x46e, 
       0x238, 0x2, 0x1201, 0x1202, 0x7, 0x1bf, 0x2, 0x2, 0x1202, 0x1204, 
       0x5, 0x46e, 0x238, 0x2, 0x1203, 0x1201, 0x3, 0x2, 0x2, 0x2, 0x1203, 
       0x1204, 0x3, 0x2, 0x2, 0x2, 0x1204, 0x1207, 0x3, 0x2, 0x2, 0x2, 0x1205, 
       0x1206, 0x7, 0x1c0, 0x2, 0x2, 0x1206, 0x1208, 0x5, 0x46e, 0x238, 
       0x2, 0x1207, 0x1205, 0x3, 0x2, 0x2, 0x2, 0x1207, 0x1208, 0x3, 0x2, 
       0x2, 0x2, 0x1208, 0x120b, 0x3, 0x2, 0x2, 0x2, 0x1209, 0x120a, 0x9, 
       0x10, 0x2, 0x2, 0x120a, 0x120c, 0x5, 0x46e, 0x238, 0x2, 0x120b, 0x1209, 
       0x3, 0x2, 0x2, 0x2, 0x120b, 0x120c, 0x3, 0x2, 0x2, 0x2, 0x120c, 0x359, 
       0x3, 0x2, 0x2, 0x2, 0x120d, 0x120e, 0x7, 0x54, 0x2, 0x2, 0x120e, 
       0x120f, 0x5, 0x480, 0x241, 0x2, 0x120f, 0x35b, 0x3, 0x2, 0x2, 0x2, 
       0x1210, 0x1212, 0x7, 0x55, 0x2, 0x2, 0x1211, 0x1213, 0x5, 0x2d2, 
       0x16a, 0x2, 0x1212, 0x1211, 0x3, 0x2, 0x2, 0x2, 0x1212, 0x1213, 0x3, 
       0x2, 0x2, 0x2, 0x1213, 0x1214, 0x3, 0x2, 0x2, 0x2, 0x1214, 0x1215, 
       0x5, 0x46e, 0x238, 0x2, 0x1215, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x1216, 
       0x1218, 0x7, 0x56, 0x2, 0x2, 0x1217, 0x1219, 0x5, 0x2d2, 0x16a, 0x2, 
       0x1218, 0x1217, 0x3, 0x2, 0x2, 0x2, 0x1218, 0x1219, 0x3, 0x2, 0x2, 
       0x2, 0x1219, 0x121b, 0x3, 0x2, 0x2, 0x2, 0x121a, 0x121c, 0x5, 0x480, 
       0x241, 0x2, 0x121b, 0x121a, 0x3, 0x2, 0x2, 0x2, 0x121b, 0x121c, 0x3, 
       0x2, 0x2, 0x2, 0x121c, 0x121d, 0x3, 0x2, 0x2, 0x2, 0x121d, 0x121e, 
       0x5, 0x480, 0x241, 0x2, 0x121e, 0x35f, 0x3, 0x2, 0x2, 0x2, 0x121f, 
       0x1220, 0x7, 0x57, 0x2, 0x2, 0x1220, 0x361, 0x3, 0x2, 0x2, 0x2, 0x1221, 
       0x1222, 0x7, 0x58, 0x2, 0x2, 0x1222, 0x363, 0x3, 0x2, 0x2, 0x2, 0x1223, 
       0x1224, 0x7, 0x59, 0x2, 0x2, 0x1224, 0x365, 0x3, 0x2, 0x2, 0x2, 0x1225, 
       0x1226, 0x7, 0x5a, 0x2, 0x2, 0x1226, 0x367, 0x3, 0x2, 0x2, 0x2, 0x1227, 
       0x1229, 0x7, 0x5b, 0x2, 0x2, 0x1228, 0x122a, 0x5, 0x2d2, 0x16a, 0x2, 
       0x1229, 0x1228, 0x3, 0x2, 0x2, 0x2, 0x1229, 0x122a, 0x3, 0x2, 0x2, 
       0x2, 0x122a, 0x122d, 0x3, 0x2, 0x2, 0x2, 0x122b, 0x122e, 0x5, 0x47e, 
       0x240, 0x2, 0x122c, 0x122e, 0x5, 0x480, 0x241, 0x2, 0x122d, 0x122b, 
       0x3, 0x2, 0x2, 0x2, 0x122d, 0x122c, 0x3, 0x2, 0x2, 0x2, 0x122e, 0x122f, 
       0x3, 0x2, 0x2, 0x2, 0x122f, 0x1230, 0x5, 0x480, 0x241, 0x2, 0x1230, 
       0x369, 0x3, 0x2, 0x2, 0x2, 0x1231, 0x123a, 0x7, 0x5c, 0x2, 0x2, 0x1232, 
       0x1237, 0x5, 0x260, 0x131, 0x2, 0x1233, 0x1234, 0x7, 0x1a, 0x2, 0x2, 
       0x1234, 0x1236, 0x5, 0x260, 0x131, 0x2, 0x1235, 0x1233, 0x3, 0x2, 
       0x2, 0x2, 0x1236, 0x1239, 0x3, 0x2, 0x2, 0x2, 0x1237, 0x1235, 0x3, 
       0x2, 0x2, 0x2, 0x1237, 0x1238, 0x3, 0x2, 0x2, 0x2, 0x1238, 0x123b, 
       0x3, 0x2, 0x2, 0x2, 0x1239, 0x1237, 0x3, 0x2, 0x2, 0x2, 0x123a, 0x1232, 
       0x3, 0x2, 0x2, 0x2, 0x123a, 0x123b, 0x3, 0x2, 0x2, 0x2, 0x123b, 0x36b, 
       0x3, 0x2, 0x2, 0x2, 0x123c, 0x123e, 0x7, 0x5d, 0x2, 0x2, 0x123d, 
       0x123f, 0x5, 0x2d2, 0x16a, 0x2, 0x123e, 0x123d, 0x3, 0x2, 0x2, 0x2, 
       0x123e, 0x123f, 0x3, 0x2, 0x2, 0x2, 0x123f, 0x1240, 0x3, 0x2, 0x2, 
       0x2, 0x1240, 0x1241, 0x5, 0x480, 0x241, 0x2, 0x1241, 0x36d, 0x3, 
       0x2, 0x2, 0x2, 0x1242, 0x1243, 0x7, 0x5e, 0x2, 0x2, 0x1243, 0x36f, 
       0x3, 0x2, 0x2, 0x2, 0x1244, 0x1246, 0x7, 0x5f, 0x2, 0x2, 0x1245, 
       0x1247, 0x5, 0x2d2, 0x16a, 0x2, 0x1246, 0x1245, 0x3, 0x2, 0x2, 0x2, 
       0x1246, 0x1247, 0x3, 0x2, 0x2, 0x2, 0x1247, 0x1249, 0x3, 0x2, 0x2, 
       0x2, 0x1248, 0x124a, 0x5, 0x480, 0x241, 0x2, 0x1249, 0x1248, 0x3, 
       0x2, 0x2, 0x2, 0x1249, 0x124a, 0x3, 0x2, 0x2, 0x2, 0x124a, 0x124b, 
       0x3, 0x2, 0x2, 0x2, 0x124b, 0x124c, 0x5, 0x480, 0x241, 0x2, 0x124c, 
       0x371, 0x3, 0x2, 0x2, 0x2, 0x124d, 0x124f, 0x7, 0x60, 0x2, 0x2, 0x124e, 
       0x1250, 0x5, 0x2d2, 0x16a, 0x2, 0x124f, 0x124e, 0x3, 0x2, 0x2, 0x2, 
       0x124f, 0x1250, 0x3, 0x2, 0x2, 0x2, 0x1250, 0x1253, 0x3, 0x2, 0x2, 
       0x2, 0x1251, 0x1254, 0x5, 0x47e, 0x240, 0x2, 0x1252, 0x1254, 0x5, 
       0x480, 0x241, 0x2, 0x1253, 0x1251, 0x3, 0x2, 0x2, 0x2, 0x1253, 0x1252, 
       0x3, 0x2, 0x2, 0x2, 0x1253, 0x1254, 0x3, 0x2, 0x2, 0x2, 0x1254, 0x1255, 
       0x3, 0x2, 0x2, 0x2, 0x1255, 0x1256, 0x5, 0x480, 0x241, 0x2, 0x1256, 
       0x373, 0x3, 0x2, 0x2, 0x2, 0x1257, 0x1259, 0x7, 0x61, 0x2, 0x2, 0x1258, 
       0x125a, 0x5, 0x2d2, 0x16a, 0x2, 0x1259, 0x1258, 0x3, 0x2, 0x2, 0x2, 
       0x1259, 0x125a, 0x3, 0x2, 0x2, 0x2, 0x125a, 0x125b, 0x3, 0x2, 0x2, 
       0x2, 0x125b, 0x125d, 0x5, 0x480, 0x241, 0x2, 0x125c, 0x125e, 0x5, 
       0x480, 0x241, 0x2, 0x125d, 0x125c, 0x3, 0x2, 0x2, 0x2, 0x125d, 0x125e, 
       0x3, 0x2, 0x2, 0x2, 0x125e, 0x375, 0x3, 0x2, 0x2, 0x2, 0x125f, 0x1261, 
       0x7, 0x62, 0x2, 0x2, 0x1260, 0x1262, 0x5, 0x2d2, 0x16a, 0x2, 0x1261, 
       0x1260, 0x3, 0x2, 0x2, 0x2, 0x1261, 0x1262, 0x3, 0x2, 0x2, 0x2, 0x1262, 
       0x1263, 0x3, 0x2, 0x2, 0x2, 0x1263, 0x1265, 0x5, 0x480, 0x241, 0x2, 
       0x1264, 0x1266, 0x5, 0x480, 0x241, 0x2, 0x1265, 0x1264, 0x3, 0x2, 
       0x2, 0x2, 0x1265, 0x1266, 0x3, 0x2, 0x2, 0x2, 0x1266, 0x377, 0x3, 
       0x2, 0x2, 0x2, 0x1267, 0x1269, 0x7, 0x63, 0x2, 0x2, 0x1268, 0x126a, 
       0x5, 0x2d2, 0x16a, 0x2, 0x1269, 0x1268, 0x3, 0x2, 0x2, 0x2, 0x1269, 
       0x126a, 0x3, 0x2, 0x2, 0x2, 0x126a, 0x126b, 0x3, 0x2, 0x2, 0x2, 0x126b, 
       0x126c, 0x5, 0x39e, 0x1d0, 0x2, 0x126c, 0x126e, 0x5, 0x480, 0x241, 
       0x2, 0x126d, 0x126f, 0x5, 0x480, 0x241, 0x2, 0x126e, 0x126d, 0x3, 
       0x2, 0x2, 0x2, 0x126e, 0x126f, 0x3, 0x2, 0x2, 0x2, 0x126f, 0x379, 
       0x3, 0x2, 0x2, 0x2, 0x1270, 0x1272, 0x7, 0x64, 0x2, 0x2, 0x1271, 
       0x1273, 0x5, 0x2d2, 0x16a, 0x2, 0x1272, 0x1271, 0x3, 0x2, 0x2, 0x2, 
       0x1272, 0x1273, 0x3, 0x2, 0x2, 0x2, 0x1273, 0x1274, 0x3, 0x2, 0x2, 
       0x2, 0x1274, 0x1276, 0x5, 0x480, 0x241, 0x2, 0x1275, 0x1277, 0x5, 
       0x480, 0x241, 0x2, 0x1276, 0x1275, 0x3, 0x2, 0x2, 0x2, 0x1276, 0x1277, 
       0x3, 0x2, 0x2, 0x2, 0x1277, 0x37b, 0x3, 0x2, 0x2, 0x2, 0x1278, 0x127a, 
       0x7, 0x65, 0x2, 0x2, 0x1279, 0x127b, 0x5, 0x2d2, 0x16a, 0x2, 0x127a, 
       0x1279, 0x3, 0x2, 0x2, 0x2, 0x127a, 0x127b, 0x3, 0x2, 0x2, 0x2, 0x127b, 
       0x127c, 0x3, 0x2, 0x2, 0x2, 0x127c, 0x127d, 0x5, 0x39e, 0x1d0, 0x2, 
       0x127d, 0x127f, 0x5, 0x480, 0x241, 0x2, 0x127e, 0x1280, 0x5, 0x480, 
       0x241, 0x2, 0x127f, 0x127e, 0x3, 0x2, 0x2, 0x2, 0x127f, 0x1280, 0x3, 
       0x2, 0x2, 0x2, 0x1280, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x1281, 0x1283, 
       0x7, 0x66, 0x2, 0x2, 0x1282, 0x1284, 0x5, 0x2d2, 0x16a, 0x2, 0x1283, 
       0x1282, 0x3, 0x2, 0x2, 0x2, 0x1283, 0x1284, 0x3, 0x2, 0x2, 0x2, 0x1284, 
       0x1287, 0x3, 0x2, 0x2, 0x2, 0x1285, 0x1288, 0x5, 0x47e, 0x240, 0x2, 
       0x1286, 0x1288, 0x5, 0x480, 0x241, 0x2, 0x1287, 0x1285, 0x3, 0x2, 
       0x2, 0x2, 0x1287, 0x1286, 0x3, 0x2, 0x2, 0x2, 0x1288, 0x1289, 0x3, 
       0x2, 0x2, 0x2, 0x1289, 0x128a, 0x5, 0x480, 0x241, 0x2, 0x128a, 0x37f, 
       0x3, 0x2, 0x2, 0x2, 0x128b, 0x128d, 0x7, 0x67, 0x2, 0x2, 0x128c, 
       0x128e, 0x5, 0x2d2, 0x16a, 0x2, 0x128d, 0x128c, 0x3, 0x2, 0x2, 0x2, 
       0x128d, 0x128e, 0x3, 0x2, 0x2, 0x2, 0x128e, 0x128f, 0x3, 0x2, 0x2, 
       0x2, 0x128f, 0x1290, 0x5, 0x480, 0x241, 0x2, 0x1290, 0x1292, 0x7, 
       0x16, 0x2, 0x2, 0x1291, 0x1293, 0x7, 0x1b1, 0x2, 0x2, 0x1292, 0x1291, 
       0x3, 0x2, 0x2, 0x2, 0x1292, 0x1293, 0x3, 0x2, 0x2, 0x2, 0x1293, 0x1294, 
       0x3, 0x2, 0x2, 0x2, 0x1294, 0x1295, 0x7, 0x17, 0x2, 0x2, 0x1295, 
       0x381, 0x3, 0x2, 0x2, 0x2, 0x1296, 0x1298, 0x7, 0x67, 0x2, 0x2, 0x1297, 
       0x1299, 0x5, 0x2d2, 0x16a, 0x2, 0x1298, 0x1297, 0x3, 0x2, 0x2, 0x2, 
       0x1298, 0x1299, 0x3, 0x2, 0x2, 0x2, 0x1299, 0x129b, 0x3, 0x2, 0x2, 
       0x2, 0x129a, 0x129c, 0x5, 0x480, 0x241, 0x2, 0x129b, 0x129a, 0x3, 
       0x2, 0x2, 0x2, 0x129b, 0x129c, 0x3, 0x2, 0x2, 0x2, 0x129c, 0x129e, 
       0x3, 0x2, 0x2, 0x2, 0x129d, 0x129f, 0x5, 0x480, 0x241, 0x2, 0x129e, 
       0x129d, 0x3, 0x2, 0x2, 0x2, 0x129e, 0x129f, 0x3, 0x2, 0x2, 0x2, 0x129f, 
       0x12a0, 0x3, 0x2, 0x2, 0x2, 0x12a0, 0x12a1, 0x5, 0x480, 0x241, 0x2, 
       0x12a1, 0x383, 0x3, 0x2, 0x2, 0x2, 0x12a2, 0x12a4, 0x7, 0x68, 0x2, 
       0x2, 0x12a3, 0x12a5, 0x5, 0x2d2, 0x16a, 0x2, 0x12a4, 0x12a3, 0x3, 
       0x2, 0x2, 0x2, 0x12a4, 0x12a5, 0x3, 0x2, 0x2, 0x2, 0x12a5, 0x12a7, 
       0x3, 0x2, 0x2, 0x2, 0x12a6, 0x12a8, 0x5, 0x46e, 0x238, 0x2, 0x12a7, 
       0x12a6, 0x3, 0x2, 0x2, 0x2, 0x12a7, 0x12a8, 0x3, 0x2, 0x2, 0x2, 0x12a8, 
       0x385, 0x3, 0x2, 0x2, 0x2, 0x12a9, 0x12ab, 0x7, 0x69, 0x2, 0x2, 0x12aa, 
       0x12ac, 0x5, 0x2d2, 0x16a, 0x2, 0x12ab, 0x12aa, 0x3, 0x2, 0x2, 0x2, 
       0x12ab, 0x12ac, 0x3, 0x2, 0x2, 0x2, 0x12ac, 0x387, 0x3, 0x2, 0x2, 
       0x2, 0x12ad, 0x12ae, 0x7, 0x6a, 0x2, 0x2, 0x12ae, 0x389, 0x3, 0x2, 
       0x2, 0x2, 0x12af, 0x12b1, 0x7, 0x6b, 0x2, 0x2, 0x12b0, 0x12b2, 0x5, 
       0x2d2, 0x16a, 0x2, 0x12b1, 0x12b0, 0x3, 0x2, 0x2, 0x2, 0x12b1, 0x12b2, 
       0x3, 0x2, 0x2, 0x2, 0x12b2, 0x12b3, 0x3, 0x2, 0x2, 0x2, 0x12b3, 0x12b4, 
       0x5, 0x39e, 0x1d0, 0x2, 0x12b4, 0x12b5, 0x5, 0x480, 0x241, 0x2, 0x12b5, 
       0x38b, 0x3, 0x2, 0x2, 0x2, 0x12b6, 0x12b8, 0x7, 0x6c, 0x2, 0x2, 0x12b7, 
       0x12b9, 0x5, 0x2d2, 0x16a, 0x2, 0x12b8, 0x12b7, 0x3, 0x2, 0x2, 0x2, 
       0x12b8, 0x12b9, 0x3, 0x2, 0x2, 0x2, 0x12b9, 0x12ba, 0x3, 0x2, 0x2, 
       0x2, 0x12ba, 0x12bb, 0x5, 0x39e, 0x1d0, 0x2, 0x12bb, 0x12bc, 0x5, 
       0x480, 0x241, 0x2, 0x12bc, 0x38d, 0x3, 0x2, 0x2, 0x2, 0x12bd, 0x12bf, 
       0x7, 0x6d, 0x2, 0x2, 0x12be, 0x12c0, 0x5, 0x2d2, 0x16a, 0x2, 0x12bf, 
       0x12be, 0x3, 0x2, 0x2, 0x2, 0x12bf, 0x12c0, 0x3, 0x2, 0x2, 0x2, 0x12c0, 
       0x12c3, 0x3, 0x2, 0x2, 0x2, 0x12c1, 0x12c4, 0x5, 0x480, 0x241, 0x2, 
       0x12c2, 0x12c4, 0x5, 0x42c, 0x217, 0x2, 0x12c3, 0x12c1, 0x3, 0x2, 
       0x2, 0x2, 0x12c3, 0x12c2, 0x3, 0x2, 0x2, 0x2, 0x12c4, 0x38f, 0x3, 
       0x2, 0x2, 0x2, 0x12c5, 0x12c7, 0x7, 0x6e, 0x2, 0x2, 0x12c6, 0x12c8, 
       0x5, 0x2d2, 0x16a, 0x2, 0x12c7, 0x12c6, 0x3, 0x2, 0x2, 0x2, 0x12c7, 
       0x12c8, 0x3, 0x2, 0x2, 0x2, 0x12c8, 0x12ca, 0x3, 0x2, 0x2, 0x2, 0x12c9, 
       0x12cb, 0x5, 0x480, 0x241, 0x2, 0x12ca, 0x12c9, 0x3, 0x2, 0x2, 0x2, 
       0x12ca, 0x12cb, 0x3, 0x2, 0x2, 0x2, 0x12cb, 0x12cc, 0x3, 0x2, 0x2, 
       0x2, 0x12cc, 0x12cd, 0x5, 0x480, 0x241, 0x2, 0x12cd, 0x391, 0x3, 
       0x2, 0x2, 0x2, 0x12ce, 0x12d0, 0x7, 0x6f, 0x2, 0x2, 0x12cf, 0x12d1, 
       0x5, 0x2d2, 0x16a, 0x2, 0x12d0, 0x12cf, 0x3, 0x2, 0x2, 0x2, 0x12d0, 
       0x12d1, 0x3, 0x2, 0x2, 0x2, 0x12d1, 0x12d2, 0x3, 0x2, 0x2, 0x2, 0x12d2, 
       0x12d3, 0x5, 0x480, 0x241, 0x2, 0x12d3, 0x393, 0x3, 0x2, 0x2, 0x2, 
       0x12d4, 0x12d6, 0x7, 0x70, 0x2, 0x2, 0x12d5, 0x12d7, 0x5, 0x2d2, 
       0x16a, 0x2, 0x12d6, 0x12d5, 0x3, 0x2, 0x2, 0x2, 0x12d6, 0x12d7, 0x3, 
       0x2, 0x2, 0x2, 0x12d7, 0x12d8, 0x3, 0x2, 0x2, 0x2, 0x12d8, 0x12db, 
       0x5, 0x480, 0x241, 0x2, 0x12d9, 0x12dc, 0x5, 0x480, 0x241, 0x2, 0x12da, 
       0x12dc, 0x5, 0x3e6, 0x1f4, 0x2, 0x12db, 0x12d9, 0x3, 0x2, 0x2, 0x2, 
       0x12db, 0x12da, 0x3, 0x2, 0x2, 0x2, 0x12db, 0x12dc, 0x3, 0x2, 0x2, 
       0x2, 0x12dc, 0x395, 0x3, 0x2, 0x2, 0x2, 0x12dd, 0x12df, 0x7, 0x71, 
       0x2, 0x2, 0x12de, 0x12e0, 0x5, 0x2d2, 0x16a, 0x2, 0x12df, 0x12de, 
       0x3, 0x2, 0x2, 0x2, 0x12df, 0x12e0, 0x3, 0x2, 0x2, 0x2, 0x12e0, 0x12e1, 
       0x3, 0x2, 0x2, 0x2, 0x12e1, 0x12e2, 0x5, 0x472, 0x23a, 0x2, 0x12e2, 
       0x397, 0x3, 0x2, 0x2, 0x2, 0x12e3, 0x12e5, 0x7, 0x72, 0x2, 0x2, 0x12e4, 
       0x12e6, 0x5, 0x2d2, 0x16a, 0x2, 0x12e5, 0x12e4, 0x3, 0x2, 0x2, 0x2, 
       0x12e5, 0x12e6, 0x3, 0x2, 0x2, 0x2, 0x12e6, 0x12e7, 0x3, 0x2, 0x2, 
       0x2, 0x12e7, 0x12e9, 0x5, 0x480, 0x241, 0x2, 0x12e8, 0x12ea, 0x5, 
       0x480, 0x241, 0x2, 0x12e9, 0x12e8, 0x3, 0x2, 0x2, 0x2, 0x12e9, 0x12ea, 
       0x3, 0x2, 0x2, 0x2, 0x12ea, 0x399, 0x3, 0x2, 0x2, 0x2, 0x12eb, 0x12ed, 
       0x7, 0x73, 0x2, 0x2, 0x12ec, 0x12ee, 0x5, 0x2d2, 0x16a, 0x2, 0x12ed, 
       0x12ec, 0x3, 0x2, 0x2, 0x2, 0x12ed, 0x12ee, 0x3, 0x2, 0x2, 0x2, 0x12ee, 
       0x12ef, 0x3, 0x2, 0x2, 0x2, 0x12ef, 0x12f0, 0x5, 0x480, 0x241, 0x2, 
       0x12f0, 0x12f1, 0x5, 0x46e, 0x238, 0x2, 0x12f1, 0x39b, 0x3, 0x2, 
       0x2, 0x2, 0x12f2, 0x12f4, 0x7, 0x74, 0x2, 0x2, 0x12f3, 0x12f5, 0x5, 
       0x2d2, 0x16a, 0x2, 0x12f4, 0x12f3, 0x3, 0x2, 0x2, 0x2, 0x12f4, 0x12f5, 
       0x3, 0x2, 0x2, 0x2, 0x12f5, 0x12f6, 0x3, 0x2, 0x2, 0x2, 0x12f6, 0x12f7, 
       0x5, 0x3ee, 0x1f8, 0x2, 0x12f7, 0x12f8, 0x5, 0x452, 0x22a, 0x2, 0x12f8, 
       0x39d, 0x3, 0x2, 0x2, 0x2, 0x12f9, 0x12fc, 0x5, 0x46e, 0x238, 0x2, 
       0x12fa, 0x12fc, 0x5, 0x47c, 0x23f, 0x2, 0x12fb, 0x12f9, 0x3, 0x2, 
       0x2, 0x2, 0x12fb, 0x12fa, 0x3, 0x2, 0x2, 0x2, 0x12fc, 0x39f, 0x3, 
       0x2, 0x2, 0x2, 0x12fd, 0x12fe, 0x9, 0x17, 0x2, 0x2, 0x12fe, 0x3a1, 
       0x3, 0x2, 0x2, 0x2, 0x12ff, 0x1350, 0x5, 0x3b6, 0x1dc, 0x2, 0x1300, 
       0x1350, 0x5, 0x3b8, 0x1dd, 0x2, 0x1301, 0x1350, 0x5, 0x3ba, 0x1de, 
       0x2, 0x1302, 0x1350, 0x5, 0x3bc, 0x1df, 0x2, 0x1303, 0x1350, 0x5, 
       0x3be, 0x1e0, 0x2, 0x1304, 0x1350, 0x5, 0x3c0, 0x1e1, 0x2, 0x1305, 
       0x1350, 0x5, 0x3c2, 0x1e2, 0x2, 0x1306, 0x1350, 0x5, 0x3c4, 0x1e3, 
       0x2, 0x1307, 0x1350, 0x5, 0x3c6, 0x1e4, 0x2, 0x1308, 0x1350, 0x5, 
       0x3c8, 0x1e5, 0x2, 0x1309, 0x1350, 0x5, 0x3ca, 0x1e6, 0x2, 0x130a, 
       0x1350, 0x5, 0x3cc, 0x1e7, 0x2, 0x130b, 0x1350, 0x5, 0x3ce, 0x1e8, 
       0x2, 0x130c, 0x1350, 0x5, 0x3d0, 0x1e9, 0x2, 0x130d, 0x1350, 0x5, 
       0x3d2, 0x1ea, 0x2, 0x130e, 0x1350, 0x5, 0x3d4, 0x1eb, 0x2, 0x130f, 
       0x1350, 0x5, 0x3d6, 0x1ec, 0x2, 0x1310, 0x1350, 0x5, 0x3d8, 0x1ed, 
       0x2, 0x1311, 0x1350, 0x5, 0x3da, 0x1ee, 0x2, 0x1312, 0x1350, 0x5, 
       0x3dc, 0x1ef, 0x2, 0x1313, 0x1350, 0x5, 0x3de, 0x1f0, 0x2, 0x1314, 
       0x1350, 0x5, 0x3e0, 0x1f1, 0x2, 0x1315, 0x1350, 0x5, 0x3e2, 0x1f2, 
       0x2, 0x1316, 0x1350, 0x5, 0x3e4, 0x1f3, 0x2, 0x1317, 0x1350, 0x5, 
       0x3e6, 0x1f4, 0x2, 0x1318, 0x1350, 0x5, 0x3e8, 0x1f5, 0x2, 0x1319, 
       0x1350, 0x5, 0x3ea, 0x1f6, 0x2, 0x131a, 0x1350, 0x5, 0x3ec, 0x1f7, 
       0x2, 0x131b, 0x1350, 0x5, 0x3ee, 0x1f8, 0x2, 0x131c, 0x1350, 0x5, 
       0x3f0, 0x1f9, 0x2, 0x131d, 0x1350, 0x5, 0x3f2, 0x1fa, 0x2, 0x131e, 
       0x1350, 0x5, 0x3f4, 0x1fb, 0x2, 0x131f, 0x1350, 0x5, 0x3f6, 0x1fc, 
       0x2, 0x1320, 0x1350, 0x5, 0x3f8, 0x1fd, 0x2, 0x1321, 0x1350, 0x5, 
       0x3fa, 0x1fe, 0x2, 0x1322, 0x1350, 0x5, 0x3fc, 0x1ff, 0x2, 0x1323, 
       0x1350, 0x5, 0x3fe, 0x200, 0x2, 0x1324, 0x1350, 0x5, 0x400, 0x201, 
       0x2, 0x1325, 0x1350, 0x5, 0x402, 
  };
  static uint16_t serializedATNSegment2[] = {
    0x202, 0x2, 0x1326, 0x1350, 0x5, 0x404, 0x203, 0x2, 0x1327, 0x1350, 
       0x5, 0x406, 0x204, 0x2, 0x1328, 0x1350, 0x5, 0x408, 0x205, 0x2, 0x1329, 
       0x1350, 0x5, 0x40a, 0x206, 0x2, 0x132a, 0x1350, 0x5, 0x40c, 0x207, 
       0x2, 0x132b, 0x1350, 0x5, 0x40e, 0x208, 0x2, 0x132c, 0x1350, 0x5, 
       0x410, 0x209, 0x2, 0x132d, 0x1350, 0x5, 0x412, 0x20a, 0x2, 0x132e, 
       0x1350, 0x5, 0x414, 0x20b, 0x2, 0x132f, 0x1350, 0x5, 0x416, 0x20c, 
       0x2, 0x1330, 0x1350, 0x5, 0x418, 0x20d, 0x2, 0x1331, 0x1350, 0x5, 
       0x41a, 0x20e, 0x2, 0x1332, 0x1350, 0x5, 0x41c, 0x20f, 0x2, 0x1333, 
       0x1350, 0x5, 0x41e, 0x210, 0x2, 0x1334, 0x1350, 0x5, 0x420, 0x211, 
       0x2, 0x1335, 0x1350, 0x5, 0x422, 0x212, 0x2, 0x1336, 0x1350, 0x5, 
       0x424, 0x213, 0x2, 0x1337, 0x1350, 0x5, 0x426, 0x214, 0x2, 0x1338, 
       0x1350, 0x5, 0x428, 0x215, 0x2, 0x1339, 0x1350, 0x5, 0x42a, 0x216, 
       0x2, 0x133a, 0x1350, 0x5, 0x42c, 0x217, 0x2, 0x133b, 0x1350, 0x5, 
       0x42e, 0x218, 0x2, 0x133c, 0x1350, 0x5, 0x430, 0x219, 0x2, 0x133d, 
       0x1350, 0x5, 0x432, 0x21a, 0x2, 0x133e, 0x1350, 0x5, 0x434, 0x21b, 
       0x2, 0x133f, 0x1350, 0x5, 0x436, 0x21c, 0x2, 0x1340, 0x1350, 0x5, 
       0x438, 0x21d, 0x2, 0x1341, 0x1350, 0x5, 0x43a, 0x21e, 0x2, 0x1342, 
       0x1350, 0x5, 0x43c, 0x21f, 0x2, 0x1343, 0x1350, 0x5, 0x43e, 0x220, 
       0x2, 0x1344, 0x1350, 0x5, 0x440, 0x221, 0x2, 0x1345, 0x1350, 0x5, 
       0x442, 0x222, 0x2, 0x1346, 0x1350, 0x5, 0x444, 0x223, 0x2, 0x1347, 
       0x1350, 0x5, 0x446, 0x224, 0x2, 0x1348, 0x1350, 0x5, 0x448, 0x225, 
       0x2, 0x1349, 0x1350, 0x5, 0x44a, 0x226, 0x2, 0x134a, 0x1350, 0x5, 
       0x44c, 0x227, 0x2, 0x134b, 0x1350, 0x5, 0x44e, 0x228, 0x2, 0x134c, 
       0x1350, 0x5, 0x450, 0x229, 0x2, 0x134d, 0x1350, 0x5, 0x452, 0x22a, 
       0x2, 0x134e, 0x1350, 0x5, 0x454, 0x22b, 0x2, 0x134f, 0x12ff, 0x3, 
       0x2, 0x2, 0x2, 0x134f, 0x1300, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1301, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1302, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1303, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1304, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1305, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1306, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1307, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1308, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1309, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x130a, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x130b, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x130c, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x130d, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x130e, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x130f, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1310, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1311, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1312, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1313, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1314, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1315, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1316, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1317, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1318, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1319, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x131a, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x131b, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x131c, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x131d, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x131e, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x131f, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1320, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1321, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1322, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1323, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1324, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1325, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1326, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1327, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1328, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1329, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x132a, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x132b, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x132c, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x132d, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x132e, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x132f, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1330, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1331, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1332, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1333, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1334, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1335, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1336, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1337, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1338, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1339, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x133a, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x133b, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x133c, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x133d, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x133e, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x133f, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1340, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1341, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1342, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1343, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1344, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1345, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1346, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1347, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x1348, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x1349, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x134a, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x134b, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x134c, 0x3, 0x2, 0x2, 0x2, 0x134f, 0x134d, 
       0x3, 0x2, 0x2, 0x2, 0x134f, 0x134e, 0x3, 0x2, 0x2, 0x2, 0x1350, 0x3a3, 
       0x3, 0x2, 0x2, 0x2, 0x1351, 0x135a, 0x7, 0x16, 0x2, 0x2, 0x1352, 
       0x1357, 0x5, 0x46e, 0x238, 0x2, 0x1353, 0x1354, 0x7, 0x1a, 0x2, 0x2, 
       0x1354, 0x1356, 0x5, 0x46e, 0x238, 0x2, 0x1355, 0x1353, 0x3, 0x2, 
       0x2, 0x2, 0x1356, 0x1359, 0x3, 0x2, 0x2, 0x2, 0x1357, 0x1355, 0x3, 
       0x2, 0x2, 0x2, 0x1357, 0x1358, 0x3, 0x2, 0x2, 0x2, 0x1358, 0x135b, 
       0x3, 0x2, 0x2, 0x2, 0x1359, 0x1357, 0x3, 0x2, 0x2, 0x2, 0x135a, 0x1352, 
       0x3, 0x2, 0x2, 0x2, 0x135a, 0x135b, 0x3, 0x2, 0x2, 0x2, 0x135b, 0x135c, 
       0x3, 0x2, 0x2, 0x2, 0x135c, 0x135e, 0x7, 0x17, 0x2, 0x2, 0x135d, 
       0x1351, 0x3, 0x2, 0x2, 0x2, 0x135d, 0x135e, 0x3, 0x2, 0x2, 0x2, 0x135e, 
       0x3a5, 0x3, 0x2, 0x2, 0x2, 0x135f, 0x1360, 0x5, 0x498, 0x24d, 0x2, 
       0x1360, 0x3a7, 0x3, 0x2, 0x2, 0x2, 0x1361, 0x1362, 0x5, 0x498, 0x24d, 
       0x2, 0x1362, 0x3a9, 0x3, 0x2, 0x2, 0x2, 0x1363, 0x1364, 0x5, 0x498, 
       0x24d, 0x2, 0x1364, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x1365, 0x1369, 0x7, 
       0x126, 0x2, 0x2, 0x1366, 0x1369, 0x7, 0x127, 0x2, 0x2, 0x1367, 0x1369, 
       0x5, 0x47e, 0x240, 0x2, 0x1368, 0x1365, 0x3, 0x2, 0x2, 0x2, 0x1368, 
       0x1366, 0x3, 0x2, 0x2, 0x2, 0x1368, 0x1367, 0x3, 0x2, 0x2, 0x2, 0x1369, 
       0x3ad, 0x3, 0x2, 0x2, 0x2, 0x136a, 0x136b, 0x7, 0x16, 0x2, 0x2, 0x136b, 
       0x136e, 0x5, 0x46e, 0x238, 0x2, 0x136c, 0x136d, 0x7, 0x1a, 0x2, 0x2, 
       0x136d, 0x136f, 0x5, 0x46e, 0x238, 0x2, 0x136e, 0x136c, 0x3, 0x2, 
       0x2, 0x2, 0x136e, 0x136f, 0x3, 0x2, 0x2, 0x2, 0x136f, 0x1372, 0x3, 
       0x2, 0x2, 0x2, 0x1370, 0x1371, 0x7, 0x1a, 0x2, 0x2, 0x1371, 0x1373, 
       0x5, 0x46e, 0x238, 0x2, 0x1372, 0x1370, 0x3, 0x2, 0x2, 0x2, 0x1372, 
       0x1373, 0x3, 0x2, 0x2, 0x2, 0x1373, 0x1376, 0x3, 0x2, 0x2, 0x2, 0x1374, 
       0x1375, 0x7, 0x1a, 0x2, 0x2, 0x1375, 0x1377, 0x5, 0x46e, 0x238, 0x2, 
       0x1376, 0x1374, 0x3, 0x2, 0x2, 0x2, 0x1376, 0x1377, 0x3, 0x2, 0x2, 
       0x2, 0x1377, 0x1378, 0x3, 0x2, 0x2, 0x2, 0x1378, 0x1379, 0x7, 0x17, 
       0x2, 0x2, 0x1379, 0x3af, 0x3, 0x2, 0x2, 0x2, 0x137a, 0x137b, 0x9, 
       0x18, 0x2, 0x2, 0x137b, 0x3b1, 0x3, 0x2, 0x2, 0x2, 0x137c, 0x137d, 
       0x7, 0xee, 0x2, 0x2, 0x137d, 0x3b3, 0x3, 0x2, 0x2, 0x2, 0x137e, 0x137f, 
       0x7, 0x16, 0x2, 0x2, 0x137f, 0x1380, 0x5, 0x46e, 0x238, 0x2, 0x1380, 
       0x1381, 0x7, 0x1a, 0x2, 0x2, 0x1381, 0x1384, 0x5, 0x46e, 0x238, 0x2, 
       0x1382, 0x1383, 0x7, 0x1a, 0x2, 0x2, 0x1383, 0x1385, 0x5, 0x46e, 
       0x238, 0x2, 0x1384, 0x1382, 0x3, 0x2, 0x2, 0x2, 0x1384, 0x1385, 0x3, 
       0x2, 0x2, 0x2, 0x1385, 0x1386, 0x3, 0x2, 0x2, 0x2, 0x1386, 0x1387, 
       0x7, 0x17, 0x2, 0x2, 0x1387, 0x3b5, 0x3, 0x2, 0x2, 0x2, 0x1388, 0x1389, 
       0x7, 0x86, 0x2, 0x2, 0x1389, 0x138a, 0x7, 0x16, 0x2, 0x2, 0x138a, 
       0x138b, 0x5, 0x46e, 0x238, 0x2, 0x138b, 0x138c, 0x7, 0x17, 0x2, 0x2, 
       0x138c, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x138d, 0x138e, 0x7, 0x87, 0x2, 
       0x2, 0x138e, 0x138f, 0x7, 0x16, 0x2, 0x2, 0x138f, 0x1392, 0x5, 0x46e, 
       0x238, 0x2, 0x1390, 0x1391, 0x7, 0x1a, 0x2, 0x2, 0x1391, 0x1393, 
       0x7, 0x125, 0x2, 0x2, 0x1392, 0x1390, 0x3, 0x2, 0x2, 0x2, 0x1392, 
       0x1393, 0x3, 0x2, 0x2, 0x2, 0x1393, 0x1394, 0x3, 0x2, 0x2, 0x2, 0x1394, 
       0x1395, 0x7, 0x17, 0x2, 0x2, 0x1395, 0x3b9, 0x3, 0x2, 0x2, 0x2, 0x1396, 
       0x1397, 0x7, 0x88, 0x2, 0x2, 0x1397, 0x1398, 0x7, 0x16, 0x2, 0x2, 
       0x1398, 0x1399, 0x5, 0x46e, 0x238, 0x2, 0x1399, 0x139a, 0x7, 0x17, 
       0x2, 0x2, 0x139a, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x139b, 0x139c, 0x7, 
       0x89, 0x2, 0x2, 0x139c, 0x139d, 0x7, 0x16, 0x2, 0x2, 0x139d, 0x139e, 
       0x5, 0x46e, 0x238, 0x2, 0x139e, 0x139f, 0x7, 0x1a, 0x2, 0x2, 0x139f, 
       0x13a4, 0x5, 0x46e, 0x238, 0x2, 0x13a0, 0x13a1, 0x7, 0x1a, 0x2, 0x2, 
       0x13a1, 0x13a3, 0x5, 0x46e, 0x238, 0x2, 0x13a2, 0x13a0, 0x3, 0x2, 
       0x2, 0x2, 0x13a3, 0x13a6, 0x3, 0x2, 0x2, 0x2, 0x13a4, 0x13a2, 0x3, 
       0x2, 0x2, 0x2, 0x13a4, 0x13a5, 0x3, 0x2, 0x2, 0x2, 0x13a5, 0x13a7, 
       0x3, 0x2, 0x2, 0x2, 0x13a6, 0x13a4, 0x3, 0x2, 0x2, 0x2, 0x13a7, 0x13a8, 
       0x7, 0x17, 0x2, 0x2, 0x13a8, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x13a9, 0x13aa, 
       0x7, 0x8a, 0x2, 0x2, 0x13aa, 0x13ab, 0x7, 0x16, 0x2, 0x2, 0x13ab, 
       0x13ac, 0x5, 0x46e, 0x238, 0x2, 0x13ac, 0x13ad, 0x7, 0x17, 0x2, 0x2, 
       0x13ad, 0x3bf, 0x3, 0x2, 0x2, 0x2, 0x13ae, 0x13af, 0x7, 0x8b, 0x2, 
       0x2, 0x13af, 0x13b0, 0x7, 0x16, 0x2, 0x2, 0x13b0, 0x13b1, 0x5, 0x46e, 
       0x238, 0x2, 0x13b1, 0x13b2, 0x7, 0x1a, 0x2, 0x2, 0x13b2, 0x13b7, 
       0x5, 0x46e, 0x238, 0x2, 0x13b3, 0x13b4, 0x7, 0x1a, 0x2, 0x2, 0x13b4, 
       0x13b6, 0x5, 0x46e, 0x238, 0x2, 0x13b5, 0x13b3, 0x3, 0x2, 0x2, 0x2, 
       0x13b6, 0x13b9, 0x3, 0x2, 0x2, 0x2, 0x13b7, 0x13b5, 0x3, 0x2, 0x2, 
       0x2, 0x13b7, 0x13b8, 0x3, 0x2, 0x2, 0x2, 0x13b8, 0x13ba, 0x3, 0x2, 
       0x2, 0x2, 0x13b9, 0x13b7, 0x3, 0x2, 0x2, 0x2, 0x13ba, 0x13bb, 0x7, 
       0x17, 0x2, 0x2, 0x13bb, 0x3c1, 0x3, 0x2, 0x2, 0x2, 0x13bc, 0x13bd, 
       0x7, 0x8c, 0x2, 0x2, 0x13bd, 0x13be, 0x7, 0x16, 0x2, 0x2, 0x13be, 
       0x13bf, 0x5, 0x46e, 0x238, 0x2, 0x13bf, 0x13c0, 0x7, 0x1a, 0x2, 0x2, 
       0x13c0, 0x13c1, 0x5, 0x46e, 0x238, 0x2, 0x13c1, 0x13c2, 0x7, 0x17, 
       0x2, 0x2, 0x13c2, 0x3c3, 0x3, 0x2, 0x2, 0x2, 0x13c3, 0x13c4, 0x7, 
       0x8d, 0x2, 0x2, 0x13c4, 0x13c5, 0x7, 0x16, 0x2, 0x2, 0x13c5, 0x13c8, 
       0x5, 0x46e, 0x238, 0x2, 0x13c6, 0x13c7, 0x7, 0x1a, 0x2, 0x2, 0x13c7, 
       0x13c9, 0x5, 0x3a6, 0x1d4, 0x2, 0x13c8, 0x13c6, 0x3, 0x2, 0x2, 0x2, 
       0x13c8, 0x13c9, 0x3, 0x2, 0x2, 0x2, 0x13c9, 0x13ca, 0x3, 0x2, 0x2, 
       0x2, 0x13ca, 0x13cb, 0x7, 0x17, 0x2, 0x2, 0x13cb, 0x3c5, 0x3, 0x2, 
       0x2, 0x2, 0x13cc, 0x13cd, 0x7, 0x8e, 0x2, 0x2, 0x13cd, 0x13ce, 0x7, 
       0x16, 0x2, 0x2, 0x13ce, 0x13cf, 0x5, 0x46e, 0x238, 0x2, 0x13cf, 0x13d0, 
       0x7, 0x1a, 0x2, 0x2, 0x13d0, 0x13d3, 0x5, 0x46e, 0x238, 0x2, 0x13d1, 
       0x13d2, 0x7, 0x1a, 0x2, 0x2, 0x13d2, 0x13d4, 0x5, 0x46e, 0x238, 0x2, 
       0x13d3, 0x13d1, 0x3, 0x2, 0x2, 0x2, 0x13d3, 0x13d4, 0x3, 0x2, 0x2, 
       0x2, 0x13d4, 0x13d5, 0x3, 0x2, 0x2, 0x2, 0x13d5, 0x13d6, 0x7, 0x17, 
       0x2, 0x2, 0x13d6, 0x3c7, 0x3, 0x2, 0x2, 0x2, 0x13d7, 0x13d8, 0x7, 
       0x8f, 0x2, 0x2, 0x13d8, 0x13d9, 0x7, 0x16, 0x2, 0x2, 0x13d9, 0x13da, 
       0x5, 0x46e, 0x238, 0x2, 0x13da, 0x13db, 0x7, 0x1a, 0x2, 0x2, 0x13db, 
       0x13de, 0x5, 0x46e, 0x238, 0x2, 0x13dc, 0x13dd, 0x7, 0x1a, 0x2, 0x2, 
       0x13dd, 0x13df, 0x5, 0x46e, 0x238, 0x2, 0x13de, 0x13dc, 0x3, 0x2, 
       0x2, 0x2, 0x13de, 0x13df, 0x3, 0x2, 0x2, 0x2, 0x13df, 0x13e0, 0x3, 
       0x2, 0x2, 0x2, 0x13e0, 0x13e1, 0x7, 0x17, 0x2, 0x2, 0x13e1, 0x3c9, 
       0x3, 0x2, 0x2, 0x2, 0x13e2, 0x13ec, 0x7, 0x90, 0x2, 0x2, 0x13e3, 
       0x13e5, 0x7, 0x16, 0x2, 0x2, 0x13e4, 0x13e6, 0x5, 0x46e, 0x238, 0x2, 
       0x13e5, 0x13e4, 0x3, 0x2, 0x2, 0x2, 0x13e5, 0x13e6, 0x3, 0x2, 0x2, 
       0x2, 0x13e6, 0x13e9, 0x3, 0x2, 0x2, 0x2, 0x13e7, 0x13e8, 0x7, 0x1a, 
       0x2, 0x2, 0x13e8, 0x13ea, 0x5, 0x3a8, 0x1d5, 0x2, 0x13e9, 0x13e7, 
       0x3, 0x2, 0x2, 0x2, 0x13e9, 0x13ea, 0x3, 0x2, 0x2, 0x2, 0x13ea, 0x13eb, 
       0x3, 0x2, 0x2, 0x2, 0x13eb, 0x13ed, 0x7, 0x17, 0x2, 0x2, 0x13ec, 
       0x13e3, 0x3, 0x2, 0x2, 0x2, 0x13ec, 0x13ed, 0x3, 0x2, 0x2, 0x2, 0x13ed, 
       0x3cb, 0x3, 0x2, 0x2, 0x2, 0x13ee, 0x13ef, 0x7, 0x91, 0x2, 0x2, 0x13ef, 
       0x13f0, 0x7, 0x16, 0x2, 0x2, 0x13f0, 0x13f1, 0x5, 0x46e, 0x238, 0x2, 
       0x13f1, 0x13f2, 0x7, 0x17, 0x2, 0x2, 0x13f2, 0x3cd, 0x3, 0x2, 0x2, 
       0x2, 0x13f3, 0x13f4, 0x7, 0x92, 0x2, 0x2, 0x13f4, 0x13f5, 0x7, 0x16, 
       0x2, 0x2, 0x13f5, 0x13f8, 0x5, 0x46e, 0x238, 0x2, 0x13f6, 0x13f7, 
       0x7, 0x1a, 0x2, 0x2, 0x13f7, 0x13f9, 0x5, 0x46e, 0x238, 0x2, 0x13f8, 
       0x13f6, 0x3, 0x2, 0x2, 0x2, 0x13f8, 0x13f9, 0x3, 0x2, 0x2, 0x2, 0x13f9, 
       0x13fc, 0x3, 0x2, 0x2, 0x2, 0x13fa, 0x13fb, 0x7, 0x1a, 0x2, 0x2, 
       0x13fb, 0x13fd, 0x5, 0x46e, 0x238, 0x2, 0x13fc, 0x13fa, 0x3, 0x2, 
       0x2, 0x2, 0x13fc, 0x13fd, 0x3, 0x2, 0x2, 0x2, 0x13fd, 0x13fe, 0x3, 
       0x2, 0x2, 0x2, 0x13fe, 0x13ff, 0x7, 0x17, 0x2, 0x2, 0x13ff, 0x3cf, 
       0x3, 0x2, 0x2, 0x2, 0x1400, 0x1401, 0x7, 0x93, 0x2, 0x2, 0x1401, 
       0x1402, 0x7, 0x16, 0x2, 0x2, 0x1402, 0x1403, 0x5, 0x46e, 0x238, 0x2, 
       0x1403, 0x1404, 0x7, 0x1a, 0x2, 0x2, 0x1404, 0x1405, 0x5, 0x46e, 
       0x238, 0x2, 0x1405, 0x1406, 0x7, 0x1a, 0x2, 0x2, 0x1406, 0x1407, 
       0x5, 0x46e, 0x238, 0x2, 0x1407, 0x1408, 0x7, 0x17, 0x2, 0x2, 0x1408, 
       0x3d1, 0x3, 0x2, 0x2, 0x2, 0x1409, 0x140a, 0x7, 0x94, 0x2, 0x2, 0x140a, 
       0x140b, 0x7, 0x16, 0x2, 0x2, 0x140b, 0x140c, 0x5, 0x46e, 0x238, 0x2, 
       0x140c, 0x140d, 0x7, 0x17, 0x2, 0x2, 0x140d, 0x3d3, 0x3, 0x2, 0x2, 
       0x2, 0x140e, 0x140f, 0x7, 0x95, 0x2, 0x2, 0x140f, 0x1410, 0x7, 0x16, 
       0x2, 0x2, 0x1410, 0x1411, 0x5, 0x46e, 0x238, 0x2, 0x1411, 0x1412, 
       0x7, 0x1a, 0x2, 0x2, 0x1412, 0x1413, 0x5, 0x46e, 0x238, 0x2, 0x1413, 
       0x1414, 0x7, 0x1a, 0x2, 0x2, 0x1414, 0x1415, 0x5, 0x3b0, 0x1d9, 0x2, 
       0x1415, 0x1416, 0x7, 0x17, 0x2, 0x2, 0x1416, 0x3d5, 0x3, 0x2, 0x2, 
       0x2, 0x1417, 0x1418, 0x7, 0x96, 0x2, 0x2, 0x1418, 0x1419, 0x7, 0x16, 
       0x2, 0x2, 0x1419, 0x141a, 0x5, 0x46e, 0x238, 0x2, 0x141a, 0x141b, 
       0x7, 0x1a, 0x2, 0x2, 0x141b, 0x141c, 0x5, 0x46e, 0x238, 0x2, 0x141c, 
       0x141d, 0x7, 0x17, 0x2, 0x2, 0x141d, 0x3d7, 0x3, 0x2, 0x2, 0x2, 0x141e, 
       0x141f, 0x7, 0x97, 0x2, 0x2, 0x141f, 0x1420, 0x7, 0x16, 0x2, 0x2, 
       0x1420, 0x1421, 0x5, 0x46e, 0x238, 0x2, 0x1421, 0x1422, 0x7, 0x1a, 
       0x2, 0x2, 0x1422, 0x1425, 0x5, 0x46e, 0x238, 0x2, 0x1423, 0x1424, 
       0x7, 0x1a, 0x2, 0x2, 0x1424, 0x1426, 0x5, 0x3ac, 0x1d7, 0x2, 0x1425, 
       0x1423, 0x3, 0x2, 0x2, 0x2, 0x1425, 0x1426, 0x3, 0x2, 0x2, 0x2, 0x1426, 
       0x1427, 0x3, 0x2, 0x2, 0x2, 0x1427, 0x1428, 0x7, 0x17, 0x2, 0x2, 
       0x1428, 0x3d9, 0x3, 0x2, 0x2, 0x2, 0x1429, 0x142a, 0x7, 0x98, 0x2, 
       0x2, 0x142a, 0x142b, 0x7, 0x16, 0x2, 0x2, 0x142b, 0x142c, 0x5, 0x46e, 
       0x238, 0x2, 0x142c, 0x142d, 0x7, 0x17, 0x2, 0x2, 0x142d, 0x3db, 0x3, 
       0x2, 0x2, 0x2, 0x142e, 0x142f, 0x7, 0x99, 0x2, 0x2, 0x142f, 0x1430, 
       0x7, 0x16, 0x2, 0x2, 0x1430, 0x1431, 0x5, 0x46e, 0x238, 0x2, 0x1431, 
       0x1432, 0x7, 0x1a, 0x2, 0x2, 0x1432, 0x1433, 0x5, 0x46e, 0x238, 0x2, 
       0x1433, 0x1434, 0x7, 0x17, 0x2, 0x2, 0x1434, 0x3dd, 0x3, 0x2, 0x2, 
       0x2, 0x1435, 0x1436, 0x7, 0x9a, 0x2, 0x2, 0x1436, 0x1437, 0x7, 0x16, 
       0x2, 0x2, 0x1437, 0x1438, 0x5, 0x46e, 0x238, 0x2, 0x1438, 0x1439, 
       0x7, 0x17, 0x2, 0x2, 0x1439, 0x3df, 0x3, 0x2, 0x2, 0x2, 0x143a, 0x1440, 
       0x7, 0x9b, 0x2, 0x2, 0x143b, 0x143d, 0x7, 0x16, 0x2, 0x2, 0x143c, 
       0x143e, 0x5, 0x480, 0x241, 0x2, 0x143d, 0x143c, 0x3, 0x2, 0x2, 0x2, 
       0x143d, 0x143e, 0x3, 0x2, 0x2, 0x2, 0x143e, 0x143f, 0x3, 0x2, 0x2, 
       0x2, 0x143f, 0x1441, 0x7, 0x17, 0x2, 0x2, 0x1440, 0x143b, 0x3, 0x2, 
       0x2, 0x2, 0x1440, 0x1441, 0x3, 0x2, 0x2, 0x2, 0x1441, 0x3e1, 0x3, 
       0x2, 0x2, 0x2, 0x1442, 0x1447, 0x7, 0x9c, 0x2, 0x2, 0x1443, 0x1444, 
       0x7, 0x16, 0x2, 0x2, 0x1444, 0x1445, 0x5, 0x480, 0x241, 0x2, 0x1445, 
       0x1446, 0x7, 0x17, 0x2, 0x2, 0x1446, 0x1448, 0x3, 0x2, 0x2, 0x2, 
       0x1447, 0x1443, 0x3, 0x2, 0x2, 0x2, 0x1447, 0x1448, 0x3, 0x2, 0x2, 
       0x2, 0x1448, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x1449, 0x144c, 0x7, 0x9d, 
       0x2, 0x2, 0x144a, 0x144b, 0x7, 0x16, 0x2, 0x2, 0x144b, 0x144d, 0x7, 
       0x17, 0x2, 0x2, 0x144c, 0x144a, 0x3, 0x2, 0x2, 0x2, 0x144c, 0x144d, 
       0x3, 0x2, 0x2, 0x2, 0x144d, 0x3e5, 0x3, 0x2, 0x2, 0x2, 0x144e, 0x144f, 
       0x7, 0x9e, 0x2, 0x2, 0x144f, 0x1450, 0x7, 0x16, 0x2, 0x2, 0x1450, 
       0x1455, 0x5, 0x480, 0x241, 0x2, 0x1451, 0x1452, 0x7, 0x1a, 0x2, 0x2, 
       0x1452, 0x1454, 0x5, 0x480, 0x241, 0x2, 0x1453, 0x1451, 0x3, 0x2, 
       0x2, 0x2, 0x1454, 0x1457, 0x3, 0x2, 0x2, 0x2, 0x1455, 0x1453, 0x3, 
       0x2, 0x2, 0x2, 0x1455, 0x1456, 0x3, 0x2, 0x2, 0x2, 0x1456, 0x1458, 
       0x3, 0x2, 0x2, 0x2, 0x1457, 0x1455, 0x3, 0x2, 0x2, 0x2, 0x1458, 0x1459, 
       0x7, 0x17, 0x2, 0x2, 0x1459, 0x3e7, 0x3, 0x2, 0x2, 0x2, 0x145a, 0x145b, 
       0x7, 0x9f, 0x2, 0x2, 0x145b, 0x145c, 0x7, 0x16, 0x2, 0x2, 0x145c, 
       0x145d, 0x5, 0x46e, 0x238, 0x2, 0x145d, 0x145e, 0x7, 0x17, 0x2, 0x2, 
       0x145e, 0x3e9, 0x3, 0x2, 0x2, 0x2, 0x145f, 0x1465, 0x7, 0xa0, 0x2, 
       0x2, 0x1460, 0x1462, 0x7, 0x16, 0x2, 0x2, 0x1461, 0x1463, 0x5, 0x480, 
       0x241, 0x2, 0x1462, 0x1461, 0x3, 0x2, 0x2, 0x2, 0x1462, 0x1463, 0x3, 
       0x2, 0x2, 0x2, 0x1463, 0x1464, 0x3, 0x2, 0x2, 0x2, 0x1464, 0x1466, 
       0x7, 0x17, 0x2, 0x2, 0x1465, 0x1460, 0x3, 0x2, 0x2, 0x2, 0x1465, 
       0x1466, 0x3, 0x2, 0x2, 0x2, 0x1466, 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x1467, 
       0x1468, 0x7, 0xa1, 0x2, 0x2, 0x1468, 0x1469, 0x7, 0x16, 0x2, 0x2, 
       0x1469, 0x146c, 0x5, 0x46e, 0x238, 0x2, 0x146a, 0x146b, 0x7, 0x1a, 
       0x2, 0x2, 0x146b, 0x146d, 0x5, 0x480, 0x241, 0x2, 0x146c, 0x146a, 
       0x3, 0x2, 0x2, 0x2, 0x146c, 0x146d, 0x3, 0x2, 0x2, 0x2, 0x146d, 0x146e, 
       0x3, 0x2, 0x2, 0x2, 0x146e, 0x146f, 0x7, 0x17, 0x2, 0x2, 0x146f, 
       0x3ed, 0x3, 0x2, 0x2, 0x2, 0x1470, 0x1471, 0x7, 0xa2, 0x2, 0x2, 0x1471, 
       0x1472, 0x7, 0x16, 0x2, 0x2, 0x1472, 0x1473, 0x5, 0x46e, 0x238, 0x2, 
       0x1473, 0x1474, 0x7, 0x1a, 0x2, 0x2, 0x1474, 0x1475, 0x5, 0x46e, 
       0x238, 0x2, 0x1475, 0x1476, 0x7, 0x17, 0x2, 0x2, 0x1476, 0x3ef, 0x3, 
       0x2, 0x2, 0x2, 0x1477, 0x1478, 0x7, 0xa3, 0x2, 0x2, 0x1478, 0x1479, 
       0x7, 0x16, 0x2, 0x2, 0x1479, 0x147a, 0x5, 0x46e, 0x238, 0x2, 0x147a, 
       0x147b, 0x7, 0x17, 0x2, 0x2, 0x147b, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x147c, 
       0x147d, 0x7, 0xa4, 0x2, 0x2, 0x147d, 0x147e, 0x7, 0x16, 0x2, 0x2, 
       0x147e, 0x147f, 0x5, 0x46e, 0x238, 0x2, 0x147f, 0x1480, 0x7, 0x17, 
       0x2, 0x2, 0x1480, 0x3f3, 0x3, 0x2, 0x2, 0x2, 0x1481, 0x1482, 0x7, 
       0xa5, 0x2, 0x2, 0x1482, 0x1483, 0x7, 0x16, 0x2, 0x2, 0x1483, 0x1484, 
       0x5, 0x46e, 0x238, 0x2, 0x1484, 0x1485, 0x7, 0x17, 0x2, 0x2, 0x1485, 
       0x3f5, 0x3, 0x2, 0x2, 0x2, 0x1486, 0x1487, 0x7, 0xa6, 0x2, 0x2, 0x1487, 
       0x1488, 0x7, 0x16, 0x2, 0x2, 0x1488, 0x148b, 0x5, 0x46e, 0x238, 0x2, 
       0x1489, 0x148a, 0x7, 0x1a, 0x2, 0x2, 0x148a, 0x148c, 0x5, 0x46e, 
       0x238, 0x2, 0x148b, 0x1489, 0x3, 0x2, 0x2, 0x2, 0x148b, 0x148c, 0x3, 
       0x2, 0x2, 0x2, 0x148c, 0x148d, 0x3, 0x2, 0x2, 0x2, 0x148d, 0x148e, 
       0x7, 0x17, 0x2, 0x2, 0x148e, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x148f, 0x1490, 
       0x7, 0xa7, 0x2, 0x2, 0x1490, 0x1491, 0x7, 0x16, 0x2, 0x2, 0x1491, 
       0x1494, 0x5, 0x46e, 0x238, 0x2, 0x1492, 0x1493, 0x7, 0x1a, 0x2, 0x2, 
       0x1493, 0x1495, 0x7, 0x128, 0x2, 0x2, 0x1494, 0x1492, 0x3, 0x2, 0x2, 
       0x2, 0x1494, 0x1495, 0x3, 0x2, 0x2, 0x2, 0x1495, 0x1496, 0x3, 0x2, 
       0x2, 0x2, 0x1496, 0x1497, 0x7, 0x17, 0x2, 0x2, 0x1497, 0x3f9, 0x3, 
       0x2, 0x2, 0x2, 0x1498, 0x1499, 0x7, 0xa8, 0x2, 0x2, 0x1499, 0x149a, 
       0x5, 0x3ae, 0x1d8, 0x2, 0x149a, 0x3fb, 0x3, 0x2, 0x2, 0x2, 0x149b, 
       0x149c, 0x7, 0xa9, 0x2, 0x2, 0x149c, 0x149d, 0x5, 0x3ae, 0x1d8, 0x2, 
       0x149d, 0x3fd, 0x3, 0x2, 0x2, 0x2, 0x149e, 0x149f, 0x7, 0xaa, 0x2, 
       0x2, 0x149f, 0x14a0, 0x5, 0x3ae, 0x1d8, 0x2, 0x14a0, 0x3ff, 0x3, 
       0x2, 0x2, 0x2, 0x14a1, 0x14a2, 0x7, 0xab, 0x2, 0x2, 0x14a2, 0x14a3, 
       0x5, 0x3ae, 0x1d8, 0x2, 0x14a3, 0x401, 0x3, 0x2, 0x2, 0x2, 0x14a4, 
       0x14a5, 0x7, 0xac, 0x2, 0x2, 0x14a5, 0x14a6, 0x5, 0x3ae, 0x1d8, 0x2, 
       0x14a6, 0x403, 0x3, 0x2, 0x2, 0x2, 0x14a7, 0x14a8, 0x7, 0xad, 0x2, 
       0x2, 0x14a8, 0x14a9, 0x7, 0x16, 0x2, 0x2, 0x14a9, 0x14aa, 0x5, 0x46e, 
       0x238, 0x2, 0x14aa, 0x14ab, 0x7, 0x17, 0x2, 0x2, 0x14ab, 0x405, 0x3, 
       0x2, 0x2, 0x2, 0x14ac, 0x14ad, 0x7, 0xae, 0x2, 0x2, 0x14ad, 0x14ae, 
       0x7, 0x16, 0x2, 0x2, 0x14ae, 0x14af, 0x5, 0x46e, 0x238, 0x2, 0x14af, 
       0x14b0, 0x7, 0x17, 0x2, 0x2, 0x14b0, 0x407, 0x3, 0x2, 0x2, 0x2, 0x14b1, 
       0x14b2, 0x7, 0xaf, 0x2, 0x2, 0x14b2, 0x14b3, 0x7, 0x16, 0x2, 0x2, 
       0x14b3, 0x14b4, 0x5, 0x46e, 0x238, 0x2, 0x14b4, 0x14b5, 0x7, 0x17, 
       0x2, 0x2, 0x14b5, 0x409, 0x3, 0x2, 0x2, 0x2, 0x14b6, 0x14b7, 0x7, 
       0xb0, 0x2, 0x2, 0x14b7, 0x14b8, 0x7, 0x16, 0x2, 0x2, 0x14b8, 0x14b9, 
       0x5, 0x480, 0x241, 0x2, 0x14b9, 0x14ba, 0x7, 0x17, 0x2, 0x2, 0x14ba, 
       0x40b, 0x3, 0x2, 0x2, 0x2, 0x14bb, 0x14bc, 0x7, 0xb1, 0x2, 0x2, 0x14bc, 
       0x14bd, 0x7, 0x16, 0x2, 0x2, 0x14bd, 0x14be, 0x5, 0x480, 0x241, 0x2, 
       0x14be, 0x14bf, 0x7, 0x17, 0x2, 0x2, 0x14bf, 0x40d, 0x3, 0x2, 0x2, 
       0x2, 0x14c0, 0x14c1, 0x7, 0xb2, 0x2, 0x2, 0x14c1, 0x14c2, 0x7, 0x16, 
       0x2, 0x2, 0x14c2, 0x14c3, 0x5, 0x480, 0x241, 0x2, 0x14c3, 0x14c4, 
       0x7, 0x17, 0x2, 0x2, 0x14c4, 0x40f, 0x3, 0x2, 0x2, 0x2, 0x14c5, 0x14c6, 
       0x7, 0xb3, 0x2, 0x2, 0x14c6, 0x14c7, 0x7, 0x16, 0x2, 0x2, 0x14c7, 
       0x14c8, 0x5, 0x480, 0x241, 0x2, 0x14c8, 0x14c9, 0x7, 0x17, 0x2, 0x2, 
       0x14c9, 0x411, 0x3, 0x2, 0x2, 0x2, 0x14ca, 0x14cd, 0x7, 0xb4, 0x2, 
       0x2, 0x14cb, 0x14cc, 0x7, 0x16, 0x2, 0x2, 0x14cc, 0x14ce, 0x7, 0x17, 
       0x2, 0x2, 0x14cd, 0x14cb, 0x3, 0x2, 0x2, 0x2, 0x14cd, 0x14ce, 0x3, 
       0x2, 0x2, 0x2, 0x14ce, 0x413, 0x3, 0x2, 0x2, 0x2, 0x14cf, 0x14d0, 
       0x7, 0xb5, 0x2, 0x2, 0x14d0, 0x14d1, 0x7, 0x16, 0x2, 0x2, 0x14d1, 
       0x14d2, 0x5, 0x480, 0x241, 0x2, 0x14d2, 0x14d3, 0x7, 0x17, 0x2, 0x2, 
       0x14d3, 0x415, 0x3, 0x2, 0x2, 0x2, 0x14d4, 0x14d5, 0x7, 0xb6, 0x2, 
       0x2, 0x14d5, 0x14d6, 0x7, 0x16, 0x2, 0x2, 0x14d6, 0x14d7, 0x5, 0x480, 
       0x241, 0x2, 0x14d7, 0x14d8, 0x7, 0x1a, 0x2, 0x2, 0x14d8, 0x14d9, 
       0x5, 0x46e, 0x238, 0x2, 0x14d9, 0x14da, 0x7, 0x17, 0x2, 0x2, 0x14da, 
       0x417, 0x3, 0x2, 0x2, 0x2, 0x14db, 0x14dc, 0x7, 0xb7, 0x2, 0x2, 0x14dc, 
       0x14dd, 0x7, 0x16, 0x2, 0x2, 0x14dd, 0x14de, 0x5, 0x46e, 0x238, 0x2, 
       0x14de, 0x14df, 0x7, 0x1a, 0x2, 0x2, 0x14df, 0x14e0, 0x5, 0x46e, 
       0x238, 0x2, 0x14e0, 0x14e1, 0x7, 0x17, 0x2, 0x2, 0x14e1, 0x419, 0x3, 
       0x2, 0x2, 0x2, 0x14e2, 0x14e3, 0x7, 0xb8, 0x2, 0x2, 0x14e3, 0x14e4, 
       0x7, 0x16, 0x2, 0x2, 0x14e4, 0x14e5, 0x5, 0x46e, 0x238, 0x2, 0x14e5, 
       0x14e6, 0x7, 0x1a, 0x2, 0x2, 0x14e6, 0x14ed, 0x5, 0x46e, 0x238, 0x2, 
       0x14e7, 0x14e8, 0x7, 0x1a, 0x2, 0x2, 0x14e8, 0x14eb, 0x5, 0x46e, 
       0x238, 0x2, 0x14e9, 0x14ea, 0x7, 0x1a, 0x2, 0x2, 0x14ea, 0x14ec, 
       0x5, 0x46e, 0x238, 0x2, 0x14eb, 0x14e9, 0x3, 0x2, 0x2, 0x2, 0x14eb, 
       0x14ec, 0x3, 0x2, 0x2, 0x2, 0x14ec, 0x14ee, 0x3, 0x2, 0x2, 0x2, 0x14ed, 
       0x14e7, 0x3, 0x2, 0x2, 0x2, 0x14ed, 0x14ee, 0x3, 0x2, 0x2, 0x2, 0x14ee, 
       0x14ef, 0x3, 0x2, 0x2, 0x2, 0x14ef, 0x14f0, 0x7, 0x17, 0x2, 0x2, 
       0x14f0, 0x41b, 0x3, 0x2, 0x2, 0x2, 0x14f1, 0x14f2, 0x7, 0xb9, 0x2, 
       0x2, 0x14f2, 0x14f3, 0x7, 0x16, 0x2, 0x2, 0x14f3, 0x14f4, 0x5, 0x46e, 
       0x238, 0x2, 0x14f4, 0x14f5, 0x7, 0x1a, 0x2, 0x2, 0x14f5, 0x14f8, 
       0x5, 0x46e, 0x238, 0x2, 0x14f6, 0x14f7, 0x7, 0x1a, 0x2, 0x2, 0x14f7, 
       0x14f9, 0x5, 0x46e, 0x238, 0x2, 0x14f8, 0x14f6, 0x3, 0x2, 0x2, 0x2, 
       0x14f8, 0x14f9, 0x3, 0x2, 0x2, 0x2, 0x14f9, 0x14fa, 0x3, 0x2, 0x2, 
       0x2, 0x14fa, 0x14fb, 0x7, 0x17, 0x2, 0x2, 0x14fb, 0x41d, 0x3, 0x2, 
       0x2, 0x2, 0x14fc, 0x14fd, 0x7, 0xba, 0x2, 0x2, 0x14fd, 0x14fe, 0x7, 
       0x16, 0x2, 0x2, 0x14fe, 0x14ff, 0x5, 0x46e, 0x238, 0x2, 0x14ff, 0x1500, 
       0x7, 0x1a, 0x2, 0x2, 0x1500, 0x1501, 0x5, 0x46e, 0x238, 0x2, 0x1501, 
       0x1502, 0x7, 0x1a, 0x2, 0x2, 0x1502, 0x1509, 0x5, 0x46e, 0x238, 0x2, 
       0x1503, 0x1504, 0x7, 0x1a, 0x2, 0x2, 0x1504, 0x1507, 0x5, 0x46e, 
       0x238, 0x2, 0x1505, 0x1506, 0x7, 0x1a, 0x2, 0x2, 0x1506, 0x1508, 
       0x5, 0x46e, 0x238, 0x2, 0x1507, 0x1505, 0x3, 0x2, 0x2, 0x2, 0x1507, 
       0x1508, 0x3, 0x2, 0x2, 0x2, 0x1508, 0x150a, 0x3, 0x2, 0x2, 0x2, 0x1509, 
       0x1503, 0x3, 0x2, 0x2, 0x2, 0x1509, 0x150a, 0x3, 0x2, 0x2, 0x2, 0x150a, 
       0x150b, 0x3, 0x2, 0x2, 0x2, 0x150b, 0x150c, 0x7, 0x17, 0x2, 0x2, 
       0x150c, 0x41f, 0x3, 0x2, 0x2, 0x2, 0x150d, 0x150e, 0x7, 0xbb, 0x2, 
       0x2, 0x150e, 0x150f, 0x7, 0x16, 0x2, 0x2, 0x150f, 0x1510, 0x5, 0x46e, 
       0x238, 0x2, 0x1510, 0x1511, 0x7, 0x17, 0x2, 0x2, 0x1511, 0x421, 0x3, 
       0x2, 0x2, 0x2, 0x1512, 0x1513, 0x7, 0xbc, 0x2, 0x2, 0x1513, 0x423, 
       0x3, 0x2, 0x2, 0x2, 0x1514, 0x1515, 0x7, 0xbd, 0x2, 0x2, 0x1515, 
       0x1516, 0x7, 0x16, 0x2, 0x2, 0x1516, 0x1519, 0x5, 0x46e, 0x238, 0x2, 
       0x1517, 0x1518, 0x7, 0x1a, 0x2, 0x2, 0x1518, 0x151a, 0x7, 0xd6, 0x2, 
       0x2, 0x1519, 0x1517, 0x3, 0x2, 0x2, 0x2, 0x1519, 0x151a, 0x3, 0x2, 
       0x2, 0x2, 0x151a, 0x151b, 0x3, 0x2, 0x2, 0x2, 0x151b, 0x151c, 0x7, 
       0x17, 0x2, 0x2, 0x151c, 0x425, 0x3, 0x2, 0x2, 0x2, 0x151d, 0x151e, 
       0x7, 0xbe, 0x2, 0x2, 0x151e, 0x151f, 0x7, 0x16, 0x2, 0x2, 0x151f, 
       0x1520, 0x5, 0x46e, 0x238, 0x2, 0x1520, 0x1521, 0x7, 0x17, 0x2, 0x2, 
       0x1521, 0x427, 0x3, 0x2, 0x2, 0x2, 0x1522, 0x1527, 0x7, 0xbf, 0x2, 
       0x2, 0x1523, 0x1524, 0x7, 0x16, 0x2, 0x2, 0x1524, 0x1525, 0x5, 0x480, 
       0x241, 0x2, 0x1525, 0x1526, 0x7, 0x17, 0x2, 0x2, 0x1526, 0x1528, 
       0x3, 0x2, 0x2, 0x2, 0x1527, 0x1523, 0x3, 0x2, 0x2, 0x2, 0x1527, 0x1528, 
       0x3, 0x2, 0x2, 0x2, 0x1528, 0x429, 0x3, 0x2, 0x2, 0x2, 0x1529, 0x152a, 
       0x7, 0xc0, 0x2, 0x2, 0x152a, 0x152b, 0x7, 0x16, 0x2, 0x2, 0x152b, 
       0x152e, 0x5, 0x46e, 0x238, 0x2, 0x152c, 0x152d, 0x7, 0x1a, 0x2, 0x2, 
       0x152d, 0x152f, 0x5, 0x46e, 0x238, 0x2, 0x152e, 0x152c, 0x3, 0x2, 
       0x2, 0x2, 0x152e, 0x152f, 0x3, 0x2, 0x2, 0x2, 0x152f, 0x1530, 0x3, 
       0x2, 0x2, 0x2, 0x1530, 0x1531, 0x7, 0x17, 0x2, 0x2, 0x1531, 0x42b, 
       0x3, 0x2, 0x2, 0x2, 0x1532, 0x1533, 0x7, 0xc1, 0x2, 0x2, 0x1533, 
       0x1534, 0x7, 0x16, 0x2, 0x2, 0x1534, 0x1535, 0x5, 0x46e, 0x238, 0x2, 
       0x1535, 0x1536, 0x7, 0x1a, 0x2, 0x2, 0x1536, 0x1539, 0x5, 0x46e, 
       0x238, 0x2, 0x1537, 0x1538, 0x7, 0x1a, 0x2, 0x2, 0x1538, 0x153a, 
       0x5, 0x46e, 0x238, 0x2, 0x1539, 0x1537, 0x3, 0x2, 0x2, 0x2, 0x1539, 
       0x153a, 0x3, 0x2, 0x2, 0x2, 0x153a, 0x153b, 0x3, 0x2, 0x2, 0x2, 0x153b, 
       0x153c, 0x7, 0x17, 0x2, 0x2, 0x153c, 0x42d, 0x3, 0x2, 0x2, 0x2, 0x153d, 
       0x153e, 0x7, 0xc2, 0x2, 0x2, 0x153e, 0x153f, 0x7, 0x16, 0x2, 0x2, 
       0x153f, 0x1540, 0x5, 0x46e, 0x238, 0x2, 0x1540, 0x1541, 0x7, 0x1a, 
       0x2, 0x2, 0x1541, 0x1542, 0x5, 0x3b0, 0x1d9, 0x2, 0x1542, 0x1543, 
       0x7, 0x17, 0x2, 0x2, 0x1543, 0x42f, 0x3, 0x2, 0x2, 0x2, 0x1544, 0x1545, 
       0x7, 0xc3, 0x2, 0x2, 0x1545, 0x1546, 0x7, 0x16, 0x2, 0x2, 0x1546, 
       0x1547, 0x5, 0x46e, 0x238, 0x2, 0x1547, 0x1548, 0x7, 0x1a, 0x2, 0x2, 
       0x1548, 0x154b, 0x5, 0x46e, 0x238, 0x2, 0x1549, 0x154a, 0x7, 0x1a, 
       0x2, 0x2, 0x154a, 0x154c, 0x5, 0x46e, 0x238, 0x2, 0x154b, 0x1549, 
       0x3, 0x2, 0x2, 0x2, 0x154b, 0x154c, 0x3, 0x2, 0x2, 0x2, 0x154c, 0x154d, 
       0x3, 0x2, 0x2, 0x2, 0x154d, 0x154e, 0x7, 0x17, 0x2, 0x2, 0x154e, 
       0x431, 0x3, 0x2, 0x2, 0x2, 0x154f, 0x1550, 0x7, 0xc4, 0x2, 0x2, 0x1550, 
       0x433, 0x3, 0x2, 0x2, 0x2, 0x1551, 0x155b, 0x7, 0xc5, 0x2, 0x2, 0x1552, 
       0x1554, 0x7, 0x16, 0x2, 0x2, 0x1553, 0x1555, 0x5, 0x46e, 0x238, 0x2, 
       0x1554, 0x1553, 0x3, 0x2, 0x2, 0x2, 0x1554, 0x1555, 0x3, 0x2, 0x2, 
       0x2, 0x1555, 0x1558, 0x3, 0x2, 0x2, 0x2, 0x1556, 0x1557, 0x7, 0x1a, 
       0x2, 0x2, 0x1557, 0x1559, 0x5, 0x3aa, 0x1d6, 0x2, 0x1558, 0x1556, 
       0x3, 0x2, 0x2, 0x2, 0x1558, 0x1559, 0x3, 0x2, 0x2, 0x2, 0x1559, 0x155a, 
       0x3, 0x2, 0x2, 0x2, 0x155a, 0x155c, 0x7, 0x17, 0x2, 0x2, 0x155b, 
       0x1552, 0x3, 0x2, 0x2, 0x2, 0x155b, 0x155c, 0x3, 0x2, 0x2, 0x2, 0x155c, 
       0x435, 0x3, 0x2, 0x2, 0x2, 0x155d, 0x1567, 0x7, 0xc6, 0x2, 0x2, 0x155e, 
       0x1560, 0x7, 0x16, 0x2, 0x2, 0x155f, 0x1561, 0x5, 0x46e, 0x238, 0x2, 
       0x1560, 0x155f, 0x3, 0x2, 0x2, 0x2, 0x1560, 0x1561, 0x3, 0x2, 0x2, 
       0x2, 0x1561, 0x1564, 0x3, 0x2, 0x2, 0x2, 0x1562, 0x1563, 0x7, 0x1a, 
       0x2, 0x2, 0x1563, 0x1565, 0x5, 0x3b2, 0x1da, 0x2, 0x1564, 0x1562, 
       0x3, 0x2, 0x2, 0x2, 0x1564, 0x1565, 0x3, 0x2, 0x2, 0x2, 0x1565, 0x1566, 
       0x3, 0x2, 0x2, 0x2, 0x1566, 0x1568, 0x7, 0x17, 0x2, 0x2, 0x1567, 
       0x155e, 0x3, 0x2, 0x2, 0x2, 0x1567, 0x1568, 0x3, 0x2, 0x2, 0x2, 0x1568, 
       0x437, 0x3, 0x2, 0x2, 0x2, 0x1569, 0x156a, 0x7, 0xc7, 0x2, 0x2, 0x156a, 
       0x156b, 0x5, 0x3b4, 0x1db, 0x2, 0x156b, 0x439, 0x3, 0x2, 0x2, 0x2, 
       0x156c, 0x156d, 0x7, 0xc8, 0x2, 0x2, 0x156d, 0x156e, 0x5, 0x3b4, 
       0x1db, 0x2, 0x156e, 0x43b, 0x3, 0x2, 0x2, 0x2, 0x156f, 0x1570, 0x7, 
       0xc9, 0x2, 0x2, 0x1570, 0x1571, 0x5, 0x3b4, 0x1db, 0x2, 0x1571, 0x43d, 
       0x3, 0x2, 0x2, 0x2, 0x1572, 0x1573, 0x7, 0xca, 0x2, 0x2, 0x1573, 
       0x1574, 0x5, 0x3b4, 0x1db, 0x2, 0x1574, 0x43f, 0x3, 0x2, 0x2, 0x2, 
       0x1575, 0x1576, 0x7, 0xcb, 0x2, 0x2, 0x1576, 0x1577, 0x5, 0x3b4, 
       0x1db, 0x2, 0x1577, 0x441, 0x3, 0x2, 0x2, 0x2, 0x1578, 0x1579, 0x7, 
       0xcc, 0x2, 0x2, 0x1579, 0x157a, 0x7, 0x16, 0x2, 0x2, 0x157a, 0x157d, 
       0x5, 0x46e, 0x238, 0x2, 0x157b, 0x157c, 0x7, 0x1a, 0x2, 0x2, 0x157c, 
       0x157e, 0x5, 0x46e, 0x238, 0x2, 0x157d, 0x157b, 0x3, 0x2, 0x2, 0x2, 
       0x157d, 0x157e, 0x3, 0x2, 0x2, 0x2, 0x157e, 0x157f, 0x3, 0x2, 0x2, 
       0x2, 0x157f, 0x1580, 0x7, 0x17, 0x2, 0x2, 0x1580, 0x443, 0x3, 0x2, 
       0x2, 0x2, 0x1581, 0x1582, 0x7, 0xcd, 0x2, 0x2, 0x1582, 0x1583, 0x7, 
       0x16, 0x2, 0x2, 0x1583, 0x1586, 0x5, 0x46e, 0x238, 0x2, 0x1584, 0x1585, 
       0x7, 0x1a, 0x2, 0x2, 0x1585, 0x1587, 0x5, 0x46e, 0x238, 0x2, 0x1586, 
       0x1584, 0x3, 0x2, 0x2, 0x2, 0x1586, 0x1587, 0x3, 0x2, 0x2, 0x2, 0x1587, 
       0x1588, 0x3, 0x2, 0x2, 0x2, 0x1588, 0x1589, 0x7, 0x17, 0x2, 0x2, 
       0x1589, 0x445, 0x3, 0x2, 0x2, 0x2, 0x158a, 0x158b, 0x7, 0xce, 0x2, 
       0x2, 0x158b, 0x158c, 0x7, 0x16, 0x2, 0x2, 0x158c, 0x158f, 0x5, 0x46e, 
       0x238, 0x2, 0x158d, 0x158e, 0x7, 0x1a, 0x2, 0x2, 0x158e, 0x1590, 
       0x5, 0x46e, 0x238, 0x2, 0x158f, 0x158d, 0x3, 0x2, 0x2, 0x2, 0x158f, 
       0x1590, 0x3, 0x2, 0x2, 0x2, 0x1590, 0x1591, 0x3, 0x2, 0x2, 0x2, 0x1591, 
       0x1592, 0x7, 0x17, 0x2, 0x2, 0x1592, 0x447, 0x3, 0x2, 0x2, 0x2, 0x1593, 
       0x1594, 0x7, 0xcf, 0x2, 0x2, 0x1594, 0x1595, 0x7, 0x16, 0x2, 0x2, 
       0x1595, 0x1596, 0x5, 0x46e, 0x238, 0x2, 0x1596, 0x1597, 0x7, 0x17, 
       0x2, 0x2, 0x1597, 0x449, 0x3, 0x2, 0x2, 0x2, 0x1598, 0x1599, 0x7, 
       0xd0, 0x2, 0x2, 0x1599, 0x159a, 0x7, 0x16, 0x2, 0x2, 0x159a, 0x159b, 
       0x5, 0x46e, 0x238, 0x2, 0x159b, 0x159c, 0x7, 0x17, 0x2, 0x2, 0x159c, 
       0x44b, 0x3, 0x2, 0x2, 0x2, 0x159d, 0x159e, 0x7, 0xd1, 0x2, 0x2, 0x159e, 
       0x159f, 0x7, 0x16, 0x2, 0x2, 0x159f, 0x15a0, 0x5, 0x46e, 0x238, 0x2, 
       0x15a0, 0x15a1, 0x7, 0x17, 0x2, 0x2, 0x15a1, 0x44d, 0x3, 0x2, 0x2, 
       0x2, 0x15a2, 0x15a3, 0x7, 0xd2, 0x2, 0x2, 0x15a3, 0x15a4, 0x7, 0x16, 
       0x2, 0x2, 0x15a4, 0x15a5, 0x5, 0x46e, 0x238, 0x2, 0x15a5, 0x15a6, 
       0x7, 0x17, 0x2, 0x2, 0x15a6, 0x44f, 0x3, 0x2, 0x2, 0x2, 0x15a7, 0x15a8, 
       0x7, 0xd3, 0x2, 0x2, 0x15a8, 0x15a9, 0x7, 0x16, 0x2, 0x2, 0x15a9, 
       0x15aa, 0x5, 0x46e, 0x238, 0x2, 0x15aa, 0x15ab, 0x7, 0x1a, 0x2, 0x2, 
       0x15ab, 0x15ac, 0x5, 0x46e, 0x238, 0x2, 0x15ac, 0x15ad, 0x7, 0x1a, 
       0x2, 0x2, 0x15ad, 0x15b0, 0x5, 0x46e, 0x238, 0x2, 0x15ae, 0x15af, 
       0x7, 0x1a, 0x2, 0x2, 0x15af, 0x15b1, 0x5, 0x46e, 0x238, 0x2, 0x15b0, 
       0x15ae, 0x3, 0x2, 0x2, 0x2, 0x15b0, 0x15b1, 0x3, 0x2, 0x2, 0x2, 0x15b1, 
       0x15b2, 0x3, 0x2, 0x2, 0x2, 0x15b2, 0x15b3, 0x7, 0x17, 0x2, 0x2, 
       0x15b3, 0x451, 0x3, 0x2, 0x2, 0x2, 0x15b4, 0x15b5, 0x7, 0xd4, 0x2, 
       0x2, 0x15b5, 0x15b6, 0x7, 0x16, 0x2, 0x2, 0x15b6, 0x15b9, 0x5, 0x46e, 
       0x238, 0x2, 0x15b7, 0x15b8, 0x7, 0x1a, 0x2, 0x2, 0x15b8, 0x15ba, 
       0x5, 0x46e, 0x238, 0x2, 0x15b9, 0x15b7, 0x3, 0x2, 0x2, 0x2, 0x15b9, 
       0x15ba, 0x3, 0x2, 0x2, 0x2, 0x15ba, 0x15bb, 0x3, 0x2, 0x2, 0x2, 0x15bb, 
       0x15bc, 0x7, 0x17, 0x2, 0x2, 0x15bc, 0x453, 0x3, 0x2, 0x2, 0x2, 0x15bd, 
       0x15be, 0x7, 0xd5, 0x2, 0x2, 0x15be, 0x15bf, 0x7, 0x16, 0x2, 0x2, 
       0x15bf, 0x15c0, 0x5, 0x46e, 0x238, 0x2, 0x15c0, 0x15c1, 0x7, 0x17, 
       0x2, 0x2, 0x15c1, 0x455, 0x3, 0x2, 0x2, 0x2, 0x15c2, 0x15c3, 0x9, 
       0x19, 0x2, 0x2, 0x15c3, 0x457, 0x3, 0x2, 0x2, 0x2, 0x15c4, 0x15c5, 
       0x5, 0x460, 0x231, 0x2, 0x15c5, 0x15c7, 0x7, 0x1d4, 0x2, 0x2, 0x15c6, 
       0x15c8, 0x5, 0x14, 0xb, 0x2, 0x15c7, 0x15c6, 0x3, 0x2, 0x2, 0x2, 
       0x15c7, 0x15c8, 0x3, 0x2, 0x2, 0x2, 0x15c8, 0x15cb, 0x3, 0x2, 0x2, 
       0x2, 0x15c9, 0x15cb, 0x5, 0x45e, 0x230, 0x2, 0x15ca, 0x15c4, 0x3, 
       0x2, 0x2, 0x2, 0x15ca, 0x15c9, 0x3, 0x2, 0x2, 0x2, 0x15cb, 0x459, 
       0x3, 0x2, 0x2, 0x2, 0x15cc, 0x15ce, 0x5, 0x46e, 0x238, 0x2, 0x15cd, 
       0x15cf, 0x5, 0x14, 0xb, 0x2, 0x15ce, 0x15cd, 0x3, 0x2, 0x2, 0x2, 
       0x15ce, 0x15cf, 0x3, 0x2, 0x2, 0x2, 0x15cf, 0x15d2, 0x3, 0x2, 0x2, 
       0x2, 0x15d0, 0x15d2, 0x5, 0x45e, 0x230, 0x2, 0x15d1, 0x15cc, 0x3, 
       0x2, 0x2, 0x2, 0x15d1, 0x15d0, 0x3, 0x2, 0x2, 0x2, 0x15d2, 0x45b, 
       0x3, 0x2, 0x2, 0x2, 0x15d3, 0x15d4, 0x5, 0x48c, 0x247, 0x2, 0x15d4, 
       0x15d5, 0x5, 0x472, 0x23a, 0x2, 0x15d5, 0x45d, 0x3, 0x2, 0x2, 0x2, 
       0x15d6, 0x15d8, 0x7, 0x85, 0x2, 0x2, 0x15d7, 0x15d9, 0x7, 0x256, 
       0x2, 0x2, 0x15d8, 0x15d7, 0x3, 0x2, 0x2, 0x2, 0x15d9, 0x15da, 0x3, 
       0x2, 0x2, 0x2, 0x15da, 0x15d8, 0x3, 0x2, 0x2, 0x2, 0x15da, 0x15db, 
       0x3, 0x2, 0x2, 0x2, 0x15db, 0x15dc, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x15dd, 
       0x7, 0x19, 0x2, 0x2, 0x15dd, 0x45f, 0x3, 0x2, 0x2, 0x2, 0x15de, 0x15e1, 
       0x5, 0x322, 0x192, 0x2, 0x15df, 0x15e1, 0x5, 0x46e, 0x238, 0x2, 0x15e0, 
       0x15de, 0x3, 0x2, 0x2, 0x2, 0x15e0, 0x15df, 0x3, 0x2, 0x2, 0x2, 0x15e1, 
       0x461, 0x3, 0x2, 0x2, 0x2, 0x15e2, 0x15e3, 0x7, 0x102, 0x2, 0x2, 
       0x15e3, 0x15e4, 0x7, 0x16, 0x2, 0x2, 0x15e4, 0x15e5, 0x5, 0x460, 
       0x231, 0x2, 0x15e5, 0x15e6, 0x7, 0x17, 0x2, 0x2, 0x15e6, 0x463, 0x3, 
       0x2, 0x2, 0x2, 0x15e7, 0x15e8, 0x5, 0x46a, 0x236, 0x2, 0x15e8, 0x15e9, 
       0x7, 0x1bf, 0x2, 0x2, 0x15e9, 0x15ea, 0x5, 0x46e, 0x238, 0x2, 0x15ea, 
       0x465, 0x3, 0x2, 0x2, 0x2, 0x15eb, 0x15ec, 0x5, 0x46a, 0x236, 0x2, 
       0x15ec, 0x15ed, 0x5, 0x478, 0x23d, 0x2, 0x15ed, 0x15ee, 0x5, 0x46e, 
       0x238, 0x2, 0x15ee, 0x467, 0x3, 0x2, 0x2, 0x2, 0x15ef, 0x15f2, 0x5, 
       0x464, 0x233, 0x2, 0x15f0, 0x15f2, 0x5, 0x466, 0x234, 0x2, 0x15f1, 
       0x15ef, 0x3, 0x2, 0x2, 0x2, 0x15f1, 0x15f0, 0x3, 0x2, 0x2, 0x2, 0x15f2, 
       0x469, 0x3, 0x2, 0x2, 0x2, 0x15f3, 0x15fd, 0x5, 0x474, 0x23b, 0x2, 
       0x15f4, 0x15fd, 0x5, 0x3a2, 0x1d2, 0x2, 0x15f5, 0x15fd, 0x5, 0x480, 
       0x241, 0x2, 0x15f6, 0x15fd, 0x5, 0x48e, 0x248, 0x2, 0x15f7, 0x15fd, 
       0x5, 0x47e, 0x240, 0x2, 0x15f8, 0x15f9, 0x7, 0x16, 0x2, 0x2, 0x15f9, 
       0x15fa, 0x5, 0x46e, 0x238, 0x2, 0x15fa, 0x15fb, 0x7, 0x17, 0x2, 0x2, 
       0x15fb, 0x15fd, 0x3, 0x2, 0x2, 0x2, 0x15fc, 0x15f3, 0x3, 0x2, 0x2, 
       0x2, 0x15fc, 0x15f4, 0x3, 0x2, 0x2, 0x2, 0x15fc, 0x15f5, 0x3, 0x2, 
       0x2, 0x2, 0x15fc, 0x15f6, 0x3, 0x2, 0x2, 0x2, 0x15fc, 0x15f7, 0x3, 
       0x2, 0x2, 0x2, 0x15fc, 0x15f8, 0x3, 0x2, 0x2, 0x2, 0x15fd, 0x46b, 
       0x3, 0x2, 0x2, 0x2, 0x15fe, 0x15ff, 0x5, 0xce, 0x68, 0x2, 0x15ff, 
       0x1600, 0x5, 0x46e, 0x238, 0x2, 0x1600, 0x46d, 0x3, 0x2, 0x2, 0x2, 
       0x1601, 0x1602, 0x8, 0x238, 0x1, 0x2, 0x1602, 0x1603, 0x7, 0x1ac, 
       0x2, 0x2, 0x1603, 0x160d, 0x5, 0x46e, 0x238, 0x14, 0x1604, 0x160d, 
       0x5, 0x48e, 0x248, 0x2, 0x1605, 0x160d, 0x5, 0x470, 0x239, 0x2, 0x1606, 
       0x160d, 0x5, 0x46c, 0x237, 0x2, 0x1607, 0x160d, 0x5, 0x462, 0x232, 
       0x2, 0x1608, 0x160d, 0x5, 0x474, 0x23b, 0x2, 0x1609, 0x160d, 0x5, 
       0x480, 0x241, 0x2, 0x160a, 0x160d, 0x5, 0x47e, 0x240, 0x2, 0x160b, 
       0x160d, 0x5, 0x3a2, 0x1d2, 0x2, 0x160c, 0x1601, 0x3, 0x2, 0x2, 0x2, 
       0x160c, 0x1604, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x1605, 0x3, 0x2, 0x2, 
       0x2, 0x160c, 0x1606, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x1607, 0x3, 0x2, 
       0x2, 0x2, 0x160c, 0x1608, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x1609, 0x3, 
       0x2, 0x2, 0x2, 0x160c, 0x160a, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x160b, 
       0x3, 0x2, 0x2, 0x2, 0x160d, 0x162f, 0x3, 0x2, 0x2, 0x2, 0x160e, 0x160f, 
       0xc, 0x11, 0x2, 0x2, 0x160f, 0x1610, 0x7, 0x1af, 0x2, 0x2, 0x1610, 
       0x162e, 0x5, 0x46e, 0x238, 0x11, 0x1611, 0x1612, 0xc, 0x10, 0x2, 
       0x2, 0x1612, 0x1613, 0x9, 0x1a, 0x2, 0x2, 0x1613, 0x162e, 0x5, 0x46e, 
       0x238, 0x11, 0x1614, 0x1615, 0xc, 0xf, 0x2, 0x2, 0x1615, 0x1616, 
       0x7, 0x1b3, 0x2, 0x2, 0x1616, 0x162e, 0x5, 0x46e, 0x238, 0x10, 0x1617, 
       0x1618, 0xc, 0xe, 0x2, 0x2, 0x1618, 0x1619, 0x7, 0x1ad, 0x2, 0x2, 
       0x1619, 0x162e, 0x5, 0x46e, 0x238, 0xf, 0x161a, 0x161b, 0xc, 0xd, 
       0x2, 0x2, 0x161b, 0x161c, 0x7, 0x1ae, 0x2, 0x2, 0x161c, 0x162e, 0x5, 
       0x46e, 0x238, 0xe, 0x161d, 0x161e, 0xc, 0xc, 0x2, 0x2, 0x161e, 0x161f, 
       0x7, 0x1bf, 0x2, 0x2, 0x161f, 0x162e, 0x5, 0x46e, 0x238, 0xd, 0x1620, 
       0x1624, 0xc, 0xb, 0x2, 0x2, 0x1621, 0x1625, 0x5, 0x478, 0x23d, 0x2, 
       0x1622, 0x1625, 0x5, 0x476, 0x23c, 0x2, 0x1623, 0x1625, 0x7, 0x1bf, 
       0x2, 0x2, 0x1624, 0x1621, 0x3, 0x2, 0x2, 0x2, 0x1624, 0x1622, 0x3, 
       0x2, 0x2, 0x2, 0x1624, 0x1623, 0x3, 0x2, 0x2, 0x2, 0x1625, 0x1626, 
       0x3, 0x2, 0x2, 0x2, 0x1626, 0x162e, 0x5, 0x46e, 0x238, 0xc, 0x1627, 
       0x1628, 0xc, 0xa, 0x2, 0x2, 0x1628, 0x1629, 0x7, 0x1aa, 0x2, 0x2, 
       0x1629, 0x162e, 0x5, 0x46e, 0x238, 0xb, 0x162a, 0x162b, 0xc, 0x9, 
       0x2, 0x2, 0x162b, 0x162c, 0x7, 0x1ab, 0x2, 0x2, 0x162c, 0x162e, 0x5, 
       0x46e, 0x238, 0xa, 0x162d, 0x160e, 0x3, 0x2, 0x2, 0x2, 0x162d, 0x1611, 
       0x3, 0x2, 0x2, 0x2, 0x162d, 0x1614, 0x3, 0x2, 0x2, 0x2, 0x162d, 0x1617, 
       0x3, 0x2, 0x2, 0x2, 0x162d, 0x161a, 0x3, 0x2, 0x2, 0x2, 0x162d, 0x161d, 
       0x3, 0x2, 0x2, 0x2, 0x162d, 0x1620, 0x3, 0x2, 0x2, 0x2, 0x162d, 0x1627, 
       0x3, 0x2, 0x2, 0x2, 0x162d, 0x162a, 0x3, 0x2, 0x2, 0x2, 0x162e, 0x1631, 
       0x3, 0x2, 0x2, 0x2, 0x162f, 0x162d, 0x3, 0x2, 0x2, 0x2, 0x162f, 0x1630, 
       0x3, 0x2, 0x2, 0x2, 0x1630, 0x46f, 0x3, 0x2, 0x2, 0x2, 0x1631, 0x162f, 
       0x3, 0x2, 0x2, 0x2, 0x1632, 0x1633, 0x7, 0x16, 0x2, 0x2, 0x1633, 
       0x1634, 0x5, 0x46e, 0x238, 0x2, 0x1634, 0x1635, 0x7, 0x17, 0x2, 0x2, 
       0x1635, 0x471, 0x3, 0x2, 0x2, 0x2, 0x1636, 0x1637, 0x5, 0x46e, 0x238, 
       0x2, 0x1637, 0x473, 0x3, 0x2, 0x2, 0x2, 0x1638, 0x1639, 0x5, 0x484, 
       0x243, 0x2, 0x1639, 0x163a, 0x5, 0x47c, 0x23f, 0x2, 0x163a, 0x475, 
       0x3, 0x2, 0x2, 0x2, 0x163b, 0x163c, 0x9, 0x1b, 0x2, 0x2, 0x163c, 
       0x477, 0x3, 0x2, 0x2, 0x2, 0x163d, 0x163e, 0x9, 0x1c, 0x2, 0x2, 0x163e, 
       0x479, 0x3, 0x2, 0x2, 0x2, 0x163f, 0x1640, 0x9, 0x1d, 0x2, 0x2, 0x1640, 
       0x47b, 0x3, 0x2, 0x2, 0x2, 0x1641, 0x164a, 0x7, 0x16, 0x2, 0x2, 0x1642, 
       0x1647, 0x5, 0x46e, 0x238, 0x2, 0x1643, 0x1644, 0x7, 0x1a, 0x2, 0x2, 
       0x1644, 0x1646, 0x5, 0x46e, 0x238, 0x2, 0x1645, 0x1643, 0x3, 0x2, 
       0x2, 0x2, 0x1646, 0x1649, 0x3, 0x2, 0x2, 0x2, 0x1647, 0x1645, 0x3, 
       0x2, 0x2, 0x2, 0x1647, 0x1648, 0x3, 0x2, 0x2, 0x2, 0x1648, 0x164b, 
       0x3, 0x2, 0x2, 0x2, 0x1649, 0x1647, 0x3, 0x2, 0x2, 0x2, 0x164a, 0x1642, 
       0x3, 0x2, 0x2, 0x2, 0x164a, 0x164b, 0x3, 0x2, 0x2, 0x2, 0x164b, 0x164c, 
       0x3, 0x2, 0x2, 0x2, 0x164c, 0x164d, 0x7, 0x17, 0x2, 0x2, 0x164d, 
       0x47d, 0x3, 0x2, 0x2, 0x2, 0x164e, 0x1652, 0x9, 0x1e, 0x2, 0x2, 0x164f, 
       0x1651, 0x9, 0x1f, 0x2, 0x2, 0x1650, 0x164f, 0x3, 0x2, 0x2, 0x2, 
       0x1651, 0x1654, 0x3, 0x2, 0x2, 0x2, 0x1652, 0x1650, 0x3, 0x2, 0x2, 
       0x2, 0x1652, 0x1653, 0x3, 0x2, 0x2, 0x2, 0x1653, 0x1655, 0x3, 0x2, 
       0x2, 0x2, 0x1654, 0x1652, 0x3, 0x2, 0x2, 0x2, 0x1655, 0x1656, 0x7, 
       0x243, 0x2, 0x2, 0x1656, 0x47f, 0x3, 0x2, 0x2, 0x2, 0x1657, 0x165b, 
       0x5, 0x490, 0x249, 0x2, 0x1658, 0x165b, 0x5, 0x486, 0x244, 0x2, 0x1659, 
       0x165b, 0x5, 0x482, 0x242, 0x2, 0x165a, 0x1657, 0x3, 0x2, 0x2, 0x2, 
       0x165a, 0x1658, 0x3, 0x2, 0x2, 0x2, 0x165a, 0x1659, 0x3, 0x2, 0x2, 
       0x2, 0x165b, 0x481, 0x3, 0x2, 0x2, 0x2, 0x165c, 0x165e, 0x5, 0x498, 
       0x24d, 0x2, 0x165d, 0x165f, 0x5, 0x47e, 0x240, 0x2, 0x165e, 0x165d, 
       0x3, 0x2, 0x2, 0x2, 0x165e, 0x165f, 0x3, 0x2, 0x2, 0x2, 0x165f, 0x483, 
       0x3, 0x2, 0x2, 0x2, 0x1660, 0x1661, 0x5, 0x490, 0x249, 0x2, 0x1661, 
       0x485, 0x3, 0x2, 0x2, 0x2, 0x1662, 0x1667, 0x5, 0x488, 0x245, 0x2, 
       0x1663, 0x1664, 0x7, 0x1be, 0x2, 0x2, 0x1664, 0x1666, 0x5, 0x488, 
       0x245, 0x2, 0x1665, 0x1663, 0x3, 0x2, 0x2, 0x2, 0x1666, 0x1669, 0x3, 
       0x2, 0x2, 0x2, 0x1667, 0x1665, 0x3, 0x2, 0x2, 0x2, 0x1667, 0x1668, 
       0x3, 0x2, 0x2, 0x2, 0x1668, 0x487, 0x3, 0x2, 0x2, 0x2, 0x1669, 0x1667, 
       0x3, 0x2, 0x2, 0x2, 0x166a, 0x166d, 0x5, 0x490, 0x249, 0x2, 0x166b, 
       0x166d, 0x5, 0x48a, 0x246, 0x2, 0x166c, 0x166a, 0x3, 0x2, 0x2, 0x2, 
       0x166c, 0x166b, 0x3, 0x2, 0x2, 0x2, 0x166d, 0x489, 0x3, 0x2, 0x2, 
       0x2, 0x166e, 0x166f, 0x5, 0x490, 0x249, 0x2, 0x166f, 0x1672, 0x7, 
       0x16, 0x2, 0x2, 0x1670, 0x1673, 0x5, 0x46e, 0x238, 0x2, 0x1671, 0x1673, 
       0x7, 0x1b0, 0x2, 0x2, 0x1672, 0x1670, 0x3, 0x2, 0x2, 0x2, 0x1672, 
       0x1671, 0x3, 0x2, 0x2, 0x2, 0x1673, 0x1674, 0x3, 0x2, 0x2, 0x2, 0x1674, 
       0x1675, 0x7, 0x17, 0x2, 0x2, 0x1675, 0x48b, 0x3, 0x2, 0x2, 0x2, 0x1676, 
       0x1677, 0x5, 0x490, 0x249, 0x2, 0x1677, 0x48d, 0x3, 0x2, 0x2, 0x2, 
       0x1678, 0x167a, 0x7, 0x1ae, 0x2, 0x2, 0x1679, 0x1678, 0x3, 0x2, 0x2, 
       0x2, 0x1679, 0x167a, 0x3, 0x2, 0x2, 0x2, 0x167a, 0x167b, 0x3, 0x2, 
       0x2, 0x2, 0x167b, 0x167f, 0x7, 0x18, 0x2, 0x2, 0x167c, 0x167e, 0x7, 
       0x1d6, 0x2, 0x2, 0x167d, 0x167c, 0x3, 0x2, 0x2, 0x2, 0x167e, 0x1681, 
       0x3, 0x2, 0x2, 0x2, 0x167f, 0x167d, 0x3, 0x2, 0x2, 0x2, 0x167f, 0x1680, 
       0x3, 0x2, 0x2, 0x2, 0x1680, 0x48f, 0x3, 0x2, 0x2, 0x2, 0x1681, 0x167f, 
       0x3, 0x2, 0x2, 0x2, 0x1682, 0x168d, 0x5, 0x492, 0x24a, 0x2, 0x1683, 
       0x1685, 0x7, 0x1b1, 0x2, 0x2, 0x1684, 0x1683, 0x3, 0x2, 0x2, 0x2, 
       0x1684, 0x1685, 0x3, 0x2, 0x2, 0x2, 0x1685, 0x1686, 0x3, 0x2, 0x2, 
       0x2, 0x1686, 0x168d, 0x5, 0x494, 0x24b, 0x2, 0x1687, 0x168d, 0x7, 
       0x1ac, 0x2, 0x2, 0x1688, 0x168d, 0x7, 0x1c0, 0x2, 0x2, 0x1689, 0x168d, 
       0x7, 0x1c1, 0x2, 0x2, 0x168a, 0x168d, 0x7, 0x1c2, 0x2, 0x2, 0x168b, 
       0x168d, 0x5, 0x3a0, 0x1d1, 0x2, 0x168c, 0x1682, 0x3, 0x2, 0x2, 0x2, 
       0x168c, 0x1684, 0x3, 0x2, 0x2, 0x2, 0x168c, 0x1687, 0x3, 0x2, 0x2, 
       0x2, 0x168c, 0x1688, 0x3, 0x2, 0x2, 0x2, 0x168c, 0x1689, 0x3, 0x2, 
       0x2, 0x2, 0x168c, 0x168a, 0x3, 0x2, 0x2, 0x2, 0x168c, 0x168b, 0x3, 
       0x2, 0x2, 0x2, 0x168d, 0x491, 0x3, 0x2, 0x2, 0x2, 0x168e, 0x168f, 
       0x5, 0x494, 0x24b, 0x2, 0x168f, 0x1690, 0x7, 0x264, 0x2, 0x2, 0x1690, 
       0x1692, 0x3, 0x2, 0x2, 0x2, 0x1691, 0x168e, 0x3, 0x2, 0x2, 0x2, 0x1692, 
       0x1693, 0x3, 0x2, 0x2, 0x2, 0x1693, 0x1691, 0x3, 0x2, 0x2, 0x2, 0x1693, 
       0x1694, 0x3, 0x2, 0x2, 0x2, 0x1694, 0x1695, 0x3, 0x2, 0x2, 0x2, 0x1695, 
       0x1696, 0x5, 0x494, 0x24b, 0x2, 0x1696, 0x493, 0x3, 0x2, 0x2, 0x2, 
       0x1697, 0x16f1, 0x7, 0x1b, 0x2, 0x2, 0x1698, 0x16f1, 0x7, 0x155, 
       0x2, 0x2, 0x1699, 0x16f1, 0x7, 0x156, 0x2, 0x2, 0x169a, 0x16f1, 0x7, 
       0x157, 0x2, 0x2, 0x169b, 0x16f1, 0x7, 0x158, 0x2, 0x2, 0x169c, 0x16f1, 
       0x7, 0x159, 0x2, 0x2, 0x169d, 0x16f1, 0x7, 0x15a, 0x2, 0x2, 0x169e, 
       0x16f1, 0x7, 0x15b, 0x2, 0x2, 0x169f, 0x16f1, 0x7, 0x15c, 0x2, 0x2, 
       0x16a0, 0x16f1, 0x7, 0x15d, 0x2, 0x2, 0x16a1, 0x16f1, 0x7, 0x15e, 
       0x2, 0x2, 0x16a2, 0x16f1, 0x7, 0x15f, 0x2, 0x2, 0x16a3, 0x16f1, 0x7, 
       0x160, 0x2, 0x2, 0x16a4, 0x16f1, 0x7, 0x161, 0x2, 0x2, 0x16a5, 0x16f1, 
       0x7, 0x162, 0x2, 0x2, 0x16a6, 0x16f1, 0x7, 0x163, 0x2, 0x2, 0x16a7, 
       0x16f1, 0x7, 0x164, 0x2, 0x2, 0x16a8, 0x16f1, 0x7, 0x165, 0x2, 0x2, 
       0x16a9, 0x16f1, 0x7, 0x166, 0x2, 0x2, 0x16aa, 0x16f1, 0x7, 0x167, 
       0x2, 0x2, 0x16ab, 0x16f1, 0x7, 0x168, 0x2, 0x2, 0x16ac, 0x16f1, 0x7, 
       0x169, 0x2, 0x2, 0x16ad, 0x16f1, 0x7, 0x16a, 0x2, 0x2, 0x16ae, 0x16f1, 
       0x7, 0x16b, 0x2, 0x2, 0x16af, 0x16f1, 0x7, 0x16c, 0x2, 0x2, 0x16b0, 
       0x16f1, 0x7, 0x16d, 0x2, 0x2, 0x16b1, 0x16f1, 0x7, 0x16e, 0x2, 0x2, 
       0x16b2, 0x16f1, 0x7, 0x16f, 0x2, 0x2, 0x16b3, 0x16f1, 0x7, 0x170, 
       0x2, 0x2, 0x16b4, 0x16f1, 0x7, 0x171, 0x2, 0x2, 0x16b5, 0x16f1, 0x7, 
       0x172, 0x2, 0x2, 0x16b6, 0x16f1, 0x7, 0x173, 0x2, 0x2, 0x16b7, 0x16f1, 
       0x7, 0x174, 0x2, 0x2, 0x16b8, 0x16f1, 0x7, 0x175, 0x2, 0x2, 0x16b9, 
       0x16f1, 0x7, 0x176, 0x2, 0x2, 0x16ba, 0x16f1, 0x7, 0x177, 0x2, 0x2, 
       0x16bb, 0x16f1, 0x7, 0x178, 0x2, 0x2, 0x16bc, 0x16f1, 0x7, 0x179, 
       0x2, 0x2, 0x16bd, 0x16f1, 0x7, 0x17a, 0x2, 0x2, 0x16be, 0x16f1, 0x7, 
       0x17b, 0x2, 0x2, 0x16bf, 0x16f1, 0x7, 0x17c, 0x2, 0x2, 0x16c0, 0x16f1, 
       0x7, 0x17d, 0x2, 0x2, 0x16c1, 0x16f1, 0x7, 0x17e, 0x2, 0x2, 0x16c2, 
       0x16f1, 0x7, 0x17f, 0x2, 0x2, 0x16c3, 0x16f1, 0x7, 0x180, 0x2, 0x2, 
       0x16c4, 0x16f1, 0x7, 0x181, 0x2, 0x2, 0x16c5, 0x16f1, 0x7, 0x182, 
       0x2, 0x2, 0x16c6, 0x16f1, 0x7, 0x183, 0x2, 0x2, 0x16c7, 0x16f1, 0x7, 
       0x184, 0x2, 0x2, 0x16c8, 0x16f1, 0x7, 0x185, 0x2, 0x2, 0x16c9, 0x16f1, 
       0x7, 0x186, 0x2, 0x2, 0x16ca, 0x16f1, 0x7, 0x187, 0x2, 0x2, 0x16cb, 
       0x16f1, 0x7, 0x188, 0x2, 0x2, 0x16cc, 0x16f1, 0x7, 0x189, 0x2, 0x2, 
       0x16cd, 0x16f1, 0x7, 0x18a, 0x2, 0x2, 0x16ce, 0x16f1, 0x7, 0x18b, 
       0x2, 0x2, 0x16cf, 0x16f1, 0x7, 0x18c, 0x2, 0x2, 0x16d0, 0x16f1, 0x7, 
       0x18d, 0x2, 0x2, 0x16d1, 0x16f1, 0x7, 0x18e, 0x2, 0x2, 0x16d2, 0x16f1, 
       0x7, 0x18f, 0x2, 0x2, 0x16d3, 0x16f1, 0x7, 0x190, 0x2, 0x2, 0x16d4, 
       0x16f1, 0x7, 0x191, 0x2, 0x2, 0x16d5, 0x16f1, 0x7, 0x192, 0x2, 0x2, 
       0x16d6, 0x16f1, 0x7, 0x193, 0x2, 0x2, 0x16d7, 0x16f1, 0x7, 0x194, 
       0x2, 0x2, 0x16d8, 0x16f1, 0x7, 0x195, 0x2, 0x2, 0x16d9, 0x16f1, 0x7, 
       0x196, 0x2, 0x2, 0x16da, 0x16f1, 0x7, 0x197, 0x2, 0x2, 0x16db, 0x16f1, 
       0x7, 0x198, 0x2, 0x2, 0x16dc, 0x16f1, 0x7, 0x199, 0x2, 0x2, 0x16dd, 
       0x16f1, 0x7, 0x19a, 0x2, 0x2, 0x16de, 0x16f1, 0x7, 0x19b, 0x2, 0x2, 
       0x16df, 0x16f1, 0x7, 0x19c, 0x2, 0x2, 0x16e0, 0x16f1, 0x7, 0x19d, 
       0x2, 0x2, 0x16e1, 0x16f1, 0x7, 0x19e, 0x2, 0x2, 0x16e2, 0x16f1, 0x7, 
       0x19f, 0x2, 0x2, 0x16e3, 0x16f1, 0x7, 0x1a1, 0x2, 0x2, 0x16e4, 0x16f1, 
       0x7, 0x1a2, 0x2, 0x2, 0x16e5, 0x16f1, 0x7, 0x1a3, 0x2, 0x2, 0x16e6, 
       0x16f1, 0x7, 0x1a4, 0x2, 0x2, 0x16e7, 0x16f1, 0x7, 0x1a5, 0x2, 0x2, 
       0x16e8, 0x16f1, 0x7, 0x1a6, 0x2, 0x2, 0x16e9, 0x16f1, 0x7, 0x1a7, 
       0x2, 0x2, 0x16ea, 0x16f1, 0x7, 0x1a8, 0x2, 0x2, 0x16eb, 0x16f1, 0x7, 
       0x13a, 0x2, 0x2, 0x16ec, 0x16f1, 0x7, 0x13c, 0x2, 0x2, 0x16ed, 0x16f1, 
       0x7, 0x13e, 0x2, 0x2, 0x16ee, 0x16f1, 0x7, 0x140, 0x2, 0x2, 0x16ef, 
       0x16f1, 0x5, 0xe6, 0x74, 0x2, 0x16f0, 0x1697, 0x3, 0x2, 0x2, 0x2, 
       0x16f0, 0x1698, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x1699, 0x3, 0x2, 0x2, 
       0x2, 0x16f0, 0x169a, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x169b, 0x3, 0x2, 
       0x2, 0x2, 0x16f0, 0x169c, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x169d, 0x3, 
       0x2, 0x2, 0x2, 0x16f0, 0x169e, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x169f, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a0, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a1, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a2, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a3, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a4, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a5, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a6, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a7, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a8, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16a9, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16aa, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ab, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ac, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ad, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ae, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16af, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b0, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b1, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b2, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b3, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b4, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b5, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b6, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b7, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b8, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16b9, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ba, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16bb, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16bc, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16bd, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16be, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16bf, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c0, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c1, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c2, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c3, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c4, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c5, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c6, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c7, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c8, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16c9, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ca, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16cb, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16cc, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16cd, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ce, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16cf, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d0, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d1, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d2, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d3, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d4, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d5, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d6, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d7, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d8, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16d9, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16da, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16db, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16dc, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16dd, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16de, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16df, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e0, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e1, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e2, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e3, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e4, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e5, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e6, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e7, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e8, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e9, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ea, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16eb, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ec, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ed, 
       0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ee, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16ef, 
       0x3, 0x2, 0x2, 0x2, 0x16f1, 0x495, 0x3, 0x2, 0x2, 0x2, 0x16f2, 0x16f3, 
       0x7, 0x1b, 0x2, 0x2, 0x16f3, 0x497, 0x3, 0x2, 0x2, 0x2, 0x16f4, 0x16f5, 
       0x9, 0x20, 0x2, 0x2, 0x16f5, 0x499, 0x3, 0x2, 0x2, 0x2, 0x16f6, 0x16f7, 
       0x8, 0x24e, 0x1, 0x2, 0x16f7, 0x1704, 0x5, 0x494, 0x24b, 0x2, 0x16f8, 
       0x16f9, 0x5, 0x494, 0x24b, 0x2, 0x16f9, 0x16fa, 0x7, 0x1be, 0x2, 
       0x2, 0x16fa, 0x16fb, 0x5, 0x494, 0x24b, 0x2, 0x16fb, 0x1704, 0x3, 
       0x2, 0x2, 0x2, 0x16fc, 0x1704, 0x5, 0x430, 0x219, 0x2, 0x16fd, 0x16fe, 
       0x5, 0x494, 0x24b, 0x2, 0x16fe, 0x16ff, 0x7, 0x2f4, 0x2, 0x2, 0x16ff, 
       0x1700, 0x5, 0x494, 0x24b, 0x2, 0x1700, 0x1704, 0x3, 0x2, 0x2, 0x2, 
       0x1701, 0x1704, 0x7, 0x100, 0x2, 0x2, 0x1702, 0x1704, 0x7, 0x102, 
       0x2, 0x2, 0x1703, 0x16f6, 0x3, 0x2, 0x2, 0x2, 0x1703, 0x16f8, 0x3, 
       0x2, 0x2, 0x2, 0x1703, 0x16fc, 0x3, 0x2, 0x2, 0x2, 0x1703, 0x16fd, 
       0x3, 0x2, 0x2, 0x2, 0x1703, 0x1701, 0x3, 0x2, 0x2, 0x2, 0x1703, 0x1702, 
       0x3, 0x2, 0x2, 0x2, 0x1704, 0x170c, 0x3, 0x2, 0x2, 0x2, 0x1705, 0x1706, 
       0xc, 0x7, 0x2, 0x2, 0x1706, 0x1707, 0x7, 0x16, 0x2, 0x2, 0x1707, 
       0x1708, 0x5, 0x46e, 0x238, 0x2, 0x1708, 0x1709, 0x7, 0x17, 0x2, 0x2, 
       0x1709, 0x170b, 0x3, 0x2, 0x2, 0x2, 0x170a, 0x1705, 0x3, 0x2, 0x2, 
       0x2, 0x170b, 0x170e, 0x3, 0x2, 0x2, 0x2, 0x170c, 0x170a, 0x3, 0x2, 
       0x2, 0x2, 0x170c, 0x170d, 0x3, 0x2, 0x2, 0x2, 0x170d, 0x49b, 0x3, 
       0x2, 0x2, 0x2, 0x170e, 0x170c, 0x3, 0x2, 0x2, 0x2, 0x207, 0x4a2, 
       0x4a4, 0x4a8, 0x4bc, 0x4c1, 0x4c7, 0x4ce, 0x4d4, 0x4e2, 0x4e7, 0x4e9, 
       0x4ed, 0x4fd, 0x502, 0x513, 0x547, 0x564, 0x574, 0x57c, 0x57f, 0x590, 
       0x594, 0x598, 0x59f, 0x5b2, 0x5b6, 0x5bf, 0x5cb, 0x5da, 0x5e1, 0x5ed, 
       0x600, 0x60b, 0x618, 0x623, 0x625, 0x635, 0x648, 0x64f, 0x653, 0x65b, 
       0x663, 0x66e, 0x67c, 0x68c, 0x6ab, 0x6b7, 0x6ee, 0x71f, 0x730, 0x735, 
       0x739, 0x748, 0x74f, 0x751, 0x754, 0x759, 0x76a, 0x771, 0x773, 0x777, 
       0x779, 0x77c, 0x781, 0x786, 0x78d, 0x792, 0x797, 0x79b, 0x7a0, 0x7a4, 
       0x7ad, 0x7b0, 0x7b3, 0x7b8, 0x7bd, 0x7c7, 0x7cc, 0x7d0, 0x7d5, 0x7df, 
       0x7e2, 0x7e5, 0x7ea, 0x7ef, 0x7fe, 0x813, 0x817, 0x81c, 0x81e, 0x82a, 
       0x82f, 0x839, 0x83f, 0x845, 0x849, 0x851, 0x858, 0x85f, 0x86e, 0x872, 
       0x87a, 0x883, 0x889, 0x88f, 0x89b, 0x8a4, 0x8ad, 0x8b6, 0x8bf, 0x8c8, 
       0x8cd, 0x8d4, 0x8d8, 0x8e0, 0x8ec, 0x8ee, 0x8f4, 0x900, 0x902, 0x906, 
       0x90b, 0x912, 0x91e, 0x923, 0x926, 0x92c, 0x939, 0x93e, 0x944, 0x94b, 
       0x954, 0x959, 0x95b, 0x962, 0x96b, 0x973, 0x975, 0x97b, 0x987, 0x989, 
       0x98f, 0x99b, 0x99d, 0x9a3, 0x9af, 0x9b1, 0x9b7, 0x9c0, 0x9c8, 0x9ca, 
       0x9d0, 0x9dd, 0x9df, 0x9e5, 0x9f2, 0x9f7, 0x9fd, 0xa04, 0xa11, 0xa16, 
       0xa1c, 0xa23, 0xa30, 0xa35, 0xa3b, 0xa40, 0xa46, 0xa53, 0xa59, 0xa66, 
       0xa6b, 0xa72, 0xa7b, 0xa87, 0xa89, 0xa8f, 0xa98, 0xa9d, 0xa9f, 0xaa5, 
       0xaae, 0xab3, 0xab5, 0xabb, 0xac4, 0xac9, 0xacb, 0xada, 0xae2, 0xaec, 
       0xaef, 0xaf2, 0xaf5, 0xb25, 0xb2a, 0xb34, 0xb3d, 0xb43, 0xb78, 0xb89, 
       0xb8e, 0xb97, 0xba0, 0xbbb, 0xbca, 0xbdc, 0xbe3, 0xbf0, 0xbfa, 0xbfd, 
       0xc01, 0xc06, 0xc0d, 0xc11, 0xc23, 0xc34, 0xc3d, 0xc45, 0xc49, 0xc4d, 
       0xc53, 0xc61, 0xc67, 0xc74, 0xc78, 0xc86, 0xced, 0xcf0, 0xcfa, 0xd00, 
       0xd06, 0xd0c, 0xd12, 0xd45, 0xd4b, 0xd50, 0xd56, 0xd5b, 0xd77, 0xd7d, 
       0xd83, 0xd89, 0xd92, 0xd98, 0xda1, 0xdaa, 0xdb0, 0xdb4, 0xdbb, 0xdd4, 
       0xded, 0xdf3, 0xdfc, 0xe17, 0xe24, 0xe2e, 0xe37, 0xe3d, 0xe43, 0xe48, 
       0xe4c, 0xe50, 0xe54, 0xe58, 0xe5a, 0xe6a, 0xe83, 0xe8f, 0xeb4, 0xeba, 
       0xec0, 0xec6, 0xed4, 0xeda, 0xee4, 0xee7, 0xeed, 0xef1, 0xf0c, 0xf1d, 
       0xf22, 0xf28, 0xf2e, 0xf34, 0xf3a, 0xf40, 0xf46, 0xf4c, 0xf52, 0xf58, 
       0xf5b, 0xf61, 0xf67, 0xf70, 0xf76, 0xf85, 0xf8c, 0xf92, 0xf98, 0xf9e, 
       0xfa7, 0xfb9, 0xfbf, 0xfc5, 0xfde, 0xfe4, 0xfea, 0xff0, 0xff7, 0xffe, 
       0x1004, 0x100b, 0x100e, 0x1011, 0x1019, 0x101b, 0x1020, 0x1022, 0x1026, 
       0x102b, 0x102e, 0x1039, 0x103b, 0x1041, 0x1055, 0x1059, 0x1062, 0x1080, 
       0x1083, 0x108a, 0x1093, 0x1096, 0x1099, 0x109e, 0x10a4, 0x10bc, 0x10c2, 
       0x10c8, 0x10cb, 0x10cf, 0x10d6, 0x10da, 0x10e0, 0x10e3, 0x10e7, 0x10ee, 
       0x10f2, 0x10f6, 0x10ff, 0x111c, 0x1124, 0x1156, 0x115a, 0x1161, 0x1163, 
       0x116c, 0x116f, 0x1175, 0x117a, 0x117e, 0x1181, 0x1187, 0x118d, 0x1190, 
       0x1194, 0x119a, 0x119d, 0x11a3, 0x11a9, 0x11af, 0x11b4, 0x11b6, 0x11b8, 
       0x11bc, 0x11bf, 0x11c5, 0x11d5, 0x11d7, 0x11dd, 0x11e3, 0x11e9, 0x11ed, 
       0x11f1, 0x11f8, 0x11fe, 0x1203, 0x1207, 0x120b, 0x1212, 0x1218, 0x121b, 
       0x1229, 0x122d, 0x1237, 0x123a, 0x123e, 0x1246, 0x1249, 0x124f, 0x1253, 
       0x1259, 0x125d, 0x1261, 0x1265, 0x1269, 0x126e, 0x1272, 0x1276, 0x127a, 
       0x127f, 0x1283, 0x1287, 0x128d, 0x1292, 0x1298, 0x129b, 0x129e, 0x12a4, 
       0x12a7, 0x12ab, 0x12b1, 0x12b8, 0x12bf, 0x12c3, 0x12c7, 0x12ca, 0x12d0, 
       0x12d6, 0x12db, 0x12df, 0x12e5, 0x12e9, 0x12ed, 0x12f4, 0x12fb, 0x134f, 
       0x1357, 0x135a, 0x135d, 0x1368, 0x136e, 0x1372, 0x1376, 0x1384, 0x1392, 
       0x13a4, 0x13b7, 0x13c8, 0x13d3, 0x13de, 0x13e5, 0x13e9, 0x13ec, 0x13f8, 
       0x13fc, 0x1425, 0x143d, 0x1440, 0x1447, 0x144c, 0x1455, 0x1462, 0x1465, 
       0x146c, 0x148b, 0x1494, 0x14cd, 0x14eb, 0x14ed, 0x14f8, 0x1507, 0x1509, 
       0x1519, 0x1527, 0x152e, 0x1539, 0x154b, 0x1554, 0x1558, 0x155b, 0x1560, 
       0x1564, 0x1567, 0x157d, 0x1586, 0x158f, 0x15b0, 0x15b9, 0x15c7, 0x15ca, 
       0x15ce, 0x15d1, 0x15da, 0x15e0, 0x15f1, 0x15fc, 0x160c, 0x1624, 0x162d, 
       0x162f, 0x1647, 0x164a, 0x1652, 0x165a, 0x165e, 0x1667, 0x166c, 0x1672, 
       0x1679, 0x167f, 0x1684, 0x168c, 0x1693, 0x16f0, 0x1703, 0x170c, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment2,
    serializedATNSegment2 + sizeof(serializedATNSegment2) / sizeof(serializedATNSegment2[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

RpgParser::Initializer RpgParser::_init;
